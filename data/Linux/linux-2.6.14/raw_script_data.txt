.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the next set bit in a memory region
.SH SYNOPSIS
.B "unsigned long" find_next_bit
.BI "(const unsigned long *"  ","
.BI "unsigned " long ","
.BI "unsigned " long ");"
.SH ARGUMENTS
.IP "" 12
-- undescribed --
.IP "long" 12
-- undescribed --
.IP "long" 12
-- undescribed --
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "ioremap" 9 "ioremap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioremap \-    map bus memory into CPU space
.SH SYNOPSIS
.B "void __iomem *" ioremap
.BI "(unsigned long " address ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "address" 12
   bus address of the memory
.IP "size" 12
      size of the resource to map
.SH "DESCRIPTION"
ioremap performs a platform specific sequence of operations to
make bus memory CPU accessible via the readb/readw/readl/writeb/
writew/writel functions and the other mmio helpers. The returned
address is not guaranteed to be usable directly as a virtual
address.
.TH "virt_to_phys" 9 "virt_to_phys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
virt_to_phys \- 	map virtual addresses to physical
.SH SYNOPSIS
.B "unsigned long" virt_to_phys
.BI "(volatile void *" address ");"
.SH ARGUMENTS
.IP "address" 12
 address to remap
.SH "DESCRIPTION"
The returned physical address is the physical (CPU) mapping for
the memory address given. It is only valid to use this function on
addresses directly mapped or allocated via kmalloc.

This function does not give bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
.TH "phys_to_virt" 9 "phys_to_virt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
phys_to_virt \- 	map physical address to virtual
.SH SYNOPSIS
.B "void *" phys_to_virt
.BI "(unsigned long " address ");"
.SH ARGUMENTS
.IP "address" 12
 address to remap
.SH "DESCRIPTION"
The returned virtual address is a current CPU mapping for
the memory address given. It is only valid to use this function on
addresses that have a kernel mapping

This function does not handle bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
.TH "check_signature" 9 "check_signature" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_signature \- 	find BIOS signatures
.SH SYNOPSIS
.B "int" check_signature
.BI "(const volatile void __iomem *" io_addr ","
.BI "const unsigned char *" signature ","
.BI "int " length ");"
.SH ARGUMENTS
.IP "io_addr" 12
 mmio address to check
.IP "signature" 12
  signature block
.IP "length" 12
 length of signature
.SH "DESCRIPTION"
Perform a signature comparison with the mmio address io_addr. This
address should have been obtained by ioremap.
Returns 1 on a match.
.TH "llc_pdu_header_init" 9 "llc_pdu_header_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_header_init \-  initializes pdu header
.SH SYNOPSIS
.B "void" llc_pdu_header_init
.BI "(struct sk_buff *" skb ","
.BI "u8 " type ","
.BI "u8 " ssap ","
.BI "u8 " dsap ","
.BI "u8 " cr ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that header must be set into it.
.IP "type" 12
 type of PDU (U, I or S).
.IP "ssap" 12
 source sap.
.IP "dsap" 12
 destination sap.
.IP "cr" 12
 command/response bit (0 or 1).
.SH "DESCRIPTION"
This function sets DSAP, SSAP and command/Response bit in LLC header.
.TH "llc_pdu_decode_sa" 9 "llc_pdu_decode_sa" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_decode_sa \-  extracs source address (MAC) of input frame
.SH SYNOPSIS
.B "void" llc_pdu_decode_sa
.BI "(struct sk_buff *" skb ","
.BI "u8 *" sa ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that source address must be extracted from it.
.IP "sa" 12
 pointer to source address (6 byte array).
.SH "DESCRIPTION"
This function extracts source address(MAC) of input frame.
.TH "llc_pdu_decode_da" 9 "llc_pdu_decode_da" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_decode_da \-  extracts dest address of input frame
.SH SYNOPSIS
.B "void" llc_pdu_decode_da
.BI "(struct sk_buff *" skb ","
.BI "u8 *" da ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that destination address must be extracted from it
.IP "da" 12
-- undescribed --
.SH "DESCRIPTION"
This function extracts destination address(MAC) of input frame.
.TH "llc_pdu_decode_ssap" 9 "llc_pdu_decode_ssap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_decode_ssap \-  extracts source SAP of input frame
.SH SYNOPSIS
.B "void" llc_pdu_decode_ssap
.BI "(struct sk_buff *" skb ","
.BI "u8 *" ssap ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that source SAP must be extracted from it.
.IP "ssap" 12
 source SAP (output argument).
.SH "DESCRIPTION"
This function extracts source SAP of input frame. Right bit of SSAP is
command/response bit.
.TH "llc_pdu_decode_dsap" 9 "llc_pdu_decode_dsap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_decode_dsap \-  extracts dest SAP of input frame
.SH SYNOPSIS
.B "void" llc_pdu_decode_dsap
.BI "(struct sk_buff *" skb ","
.BI "u8 *" dsap ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that destination SAP must be extracted from it.
.IP "dsap" 12
 destination SAP (output argument).
.SH "DESCRIPTION"
This function extracts destination SAP of input frame. right bit of
DSAP designates individual/group SAP.
.TH "llc_pdu_init_as_ui_cmd" 9 "llc_pdu_init_as_ui_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_ui_cmd \-  sets LLC header as UI PDU
.SH SYNOPSIS
.B "void" llc_pdu_init_as_ui_cmd
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that header must be set into it.
.SH "DESCRIPTION"
This function sets third byte of LLC header as a UI PDU.
.TH "llc_pdu_init_as_test_cmd" 9 "llc_pdu_init_as_test_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_test_cmd \-  sets PDU as TEST
.SH SYNOPSIS
.B "void" llc_pdu_init_as_test_cmd
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
-- undescribed --
.SH "DESCRIPTION"
\fIskb\fP - Address of the skb to build

Sets a PDU as TEST
.TH "llc_pdu_init_as_test_rsp" 9 "llc_pdu_init_as_test_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_test_rsp \-  build TEST response PDU
.SH SYNOPSIS
.B "void" llc_pdu_init_as_test_rsp
.BI "(struct sk_buff *" skb ","
.BI "struct sk_buff *" ev_skb ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "ev_skb" 12
 The received TEST command PDU frame
.SH "DESCRIPTION"
Builds a pdu frame as a TEST response.
.TH "llc_pdu_init_as_xid_cmd" 9 "llc_pdu_init_as_xid_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_xid_cmd \-  sets bytes 3, 4 \\\amp; 5 of LLC header as XID
.SH SYNOPSIS
.B "void" llc_pdu_init_as_xid_cmd
.BI "(struct sk_buff *" skb ","
.BI "u8 " svcs_supported ","
.BI "u8 " rx_window ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that header must be set into it.
.IP "svcs_supported" 12
-- undescribed --
.IP "rx_window" 12
-- undescribed --
.SH "DESCRIPTION"
This function sets third,fourth,fifth and sixth bytes of LLC header as
a XID PDU.
.TH "llc_pdu_init_as_xid_rsp" 9 "llc_pdu_init_as_xid_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_xid_rsp \-  builds XID response PDU
.SH SYNOPSIS
.B "void" llc_pdu_init_as_xid_rsp
.BI "(struct sk_buff *" skb ","
.BI "u8 " svcs_supported ","
.BI "u8 " rx_window ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "svcs_supported" 12
 The class of the LLC (I or II)
.IP "rx_window" 12
 The size of the receive window of the LLC
.SH "DESCRIPTION"
Builds a pdu frame as an XID response.
.TH "Kernel API" 9 "struct sock_common" "January 2021" "API Manual" LINUX
.SH NAME
struct sock_common \-  minimal network layer representation of sockets
.SH SYNOPSIS
struct sock_common {
.br
.BI "    unsigned short " skc_family ""
;

.br
.BI "    volatile unsigned char " skc_state ""
;

.br
.BI "    unsigned char " skc_reuse ""
;

.br
.BI "    int " skc_bound_dev_if ""
;

.br
.BI "    struct hlist_node " skc_node ""
;

.br
.BI "    struct hlist_node " skc_bind_node ""
;

.br
.BI "    atomic_t " skc_refcnt ""
;

.br
.BI "    unsigned int " skc_hash ""
;

.br
.BI "    struct proto *" skc_prot ""
;

.br
};
.br
.SH Arguments
.IP "skc_family" 12
 network address family
.IP "skc_state" 12
 Connection state
.IP "skc_reuse" 12
 SO_REUSEADDR setting
.IP "skc_bound_dev_if" 12
 bound device index if != 0
.IP "skc_node" 12
 main hash linkage for various protocol lookup tables
.IP "skc_bind_node" 12
 bind hash linkage for various protocol lookup tables
.IP "skc_refcnt" 12
 reference count
.IP "skc_hash" 12
 hash value used with various protocol lookup tables
.IP "skc_prot" 12
 protocol handlers inside a network family
.SH "Description"
This is the minimal network layer representation of sockets, the header
for struct sock and struct inet_timewait_sock.
.TH "Kernel API" 9 "struct sock" "January 2021" "API Manual" LINUX
.SH NAME
struct sock \-  network layer representation of sockets
.SH SYNOPSIS
struct sock {
.br
.BI "    struct sock_common " __sk_common ""
;

.br
.BI "#define sk_family		__sk_common.skc_family"
.br
.BI "#define sk_state		__sk_common.skc_state"
.br
.BI "#define sk_reuse		__sk_common.skc_reuse"
.br
.BI "#define sk_bound_dev_if		__sk_common.skc_bound_dev_if"
.br
.BI "#define sk_node			__sk_common.skc_node"
.br
.BI "#define sk_bind_node		__sk_common.skc_bind_node"
.br
.BI "#define sk_refcnt		__sk_common.skc_refcnt"
.br
.BI "#define sk_hash			__sk_common.skc_hash"
.br
.BI "#define sk_prot			__sk_common.skc_prot"
.br
.BI "    unsigned char" sk_shutdown:2 ""
;

.br
.BI "    unsigned char" sk_no_check:2 ""
;

.br
.BI "    unsigned char" sk_userlocks:4 ""
;

.br
.BI "    unsigned char " sk_protocol ""
;

.br
.BI "    unsigned short " sk_type ""
;

.br
.BI "    int " sk_rcvbuf ""
;

.br
.BI "    socket_lock_t " sk_lock ""
;

.br
.BI "    wait_queue_head_t *" sk_sleep ""
;

.br
.BI "    struct dst_entry *" sk_dst_cache ""
;

.br
.BI "    struct xfrm_policy *" sk_policy[2] ""
;

.br
.BI "    rwlock_t " sk_dst_lock ""
;

.br
.BI "    atomic_t " sk_rmem_alloc ""
;

.br
.BI "    atomic_t " sk_wmem_alloc ""
;

.br
.BI "    atomic_t " sk_omem_alloc ""
;

.br
.BI "    struct sk_buff_head " sk_receive_queue ""
;

.br
.BI "    struct sk_buff_head " sk_write_queue ""
;

.br
.BI "    int " sk_wmem_queued ""
;

.br
.BI "    int " sk_forward_alloc ""
;

.br
.BI "    unsigned int " sk_allocation ""
;

.br
.BI "    int " sk_sndbuf ""
;

.br
.BI "    int " sk_route_caps ""
;

.br
.BI "    unsigned long " sk_flags ""
;

.br
.BI "    unsigned long " sk_lingertime ""
;

.br
.BI "    struct " sk_backlog ""
;

.br
.BI "    struct sk_buff_head " sk_error_queue ""
;

.br
.BI "    struct proto *" sk_prot_creator ""
;

.br
.BI "    rwlock_t " sk_callback_lock ""
;

.br
.BI "    int " sk_err ""
;

.br
.BI "    int " sk_err_soft ""
;

.br
.BI "    unsigned short " sk_ack_backlog ""
;

.br
.BI "    unsigned short " sk_max_ack_backlog ""
;

.br
.BI "    __u32 " sk_priority ""
;

.br
.BI "    struct ucred " sk_peercred ""
;

.br
.BI "    int " sk_rcvlowat ""
;

.br
.BI "    long " sk_rcvtimeo ""
;

.br
.BI "    long " sk_sndtimeo ""
;

.br
.BI "    struct sk_filter *" sk_filter ""
;

.br
.BI "    void *" sk_protinfo ""
;

.br
.BI "    struct timer_list " sk_timer ""
;

.br
.BI "    struct timeval " sk_stamp ""
;

.br
.BI "    struct socket *" sk_socket ""
;

.br
.BI "    void *" sk_user_data ""
;

.br
.BI "    struct page *" sk_sndmsg_page ""
;

.br
.BI "    struct sk_buff *" sk_send_head ""
;

.br
.BI "    __u32 " sk_sndmsg_off ""
;

.br
.BI "    int " sk_write_pending ""
;

.br
.BI "    void *" sk_security ""
;

.br
.BI "    void (*" sk_state_change ") (struct sock *sk)"
;

.br
.BI "    void (*" sk_data_ready ") (struct sock *sk, int bytes)"
;

.br
.BI "    void (*" sk_write_space ") (struct sock *sk)"
;

.br
.BI "    void (*" sk_error_report ") (struct sock *sk)"
;

.br
.BI "    int (*" sk_backlog_rcv ") (struct sock *sk,struct sk_buff *skb)"
;

.br
.BI "    void (*" sk_destruct ") (struct sock *sk)"
;

.br
};
.br
.SH Arguments
.IP "__sk_common" 12
 shared layout with inet_timewait_sock
.IP "sk_shutdown" 12
 mask of SEND_SHUTDOWN and/or RCV_SHUTDOWN
.IP "sk_no_check" 12
 SO_NO_CHECK setting, wether or not checkup packets
.IP "sk_userlocks" 12
 SO_SNDBUF and SO_RCVBUF settings
.IP "sk_protocol" 12
 which protocol this socket belongs in this network family
.IP "sk_type" 12
 socket type (SOCK_STREAM, etc)
.IP "sk_rcvbuf" 12
 size of receive buffer in bytes
.IP "sk_lock" 12
	synchronizer
.IP "sk_sleep" 12
 sock wait queue
.IP "sk_dst_cache" 12
 destination cache
.IP "sk_policy[2]" 12
 flow policy
.IP "sk_dst_lock" 12
 destination cache lock
.IP "sk_rmem_alloc" 12
 receive queue bytes committed
.IP "sk_wmem_alloc" 12
 transmit queue bytes committed
.IP "sk_omem_alloc" 12
 "o" is "option" or "other"
.IP "sk_receive_queue" 12
 incoming packets
.IP "sk_write_queue" 12
 Packet sending queue
.IP "sk_wmem_queued" 12
 persistent queue size
.IP "sk_forward_alloc" 12
 space allocated forward
.IP "sk_allocation" 12
 allocation mode
.IP "sk_sndbuf" 12
 size of send buffer in bytes
.IP "sk_route_caps" 12
 route capabilities (e.g. NETIF_F_TSO)
.IP "sk_flags" 12
 SO_LINGER (l_onoff), SO_BROADCAST, SO_KEEPALIVE, SO_OOBINLINE settings
.IP "sk_lingertime" 12
 SO_LINGER l_linger setting
.IP "sk_backlog" 12
 always used with the per-socket spinlock held
.IP "sk_error_queue" 12
 rarely used
.IP "sk_prot_creator" 12
 sk_prot of original sock creator (see ipv6_setsockopt, IPV6_ADDRFORM for instance)
.IP "sk_callback_lock" 12
 used with the callbacks in the end of this struct
.IP "sk_err" 12
 last error
.IP "sk_err_soft" 12
 errors that don't cause failure but are the cause of a persistent failure not just 'timed out'
.IP "sk_ack_backlog" 12
 current listen backlog
.IP "sk_max_ack_backlog" 12
 listen backlog set in \fBlisten\fP
.IP "sk_priority" 12
 SO_PRIORITY setting
.IP "sk_peercred" 12
 SO_PEERCRED setting
.IP "sk_rcvlowat" 12
 SO_RCVLOWAT setting
.IP "sk_rcvtimeo" 12
 SO_RCVTIMEO setting
.IP "sk_sndtimeo" 12
 SO_SNDTIMEO setting
.IP "sk_filter" 12
 socket filtering instructions
.IP "sk_protinfo" 12
 private area, net family specific, when not using slab
.IP "sk_timer" 12
 sock cleanup timer
.IP "sk_stamp" 12
 time stamp of last packet received
.IP "sk_socket" 12
 Identd and reporting IO signals
.IP "sk_user_data" 12
 RPC layer private data
.IP "sk_sndmsg_page" 12
 cached page for sendmsg
.IP "sk_send_head" 12
 front of stuff to transmit
.IP "sk_sndmsg_off" 12
 cached offset for sendmsg
.IP "sk_write_pending" 12
 a write to stream socket waits to start
.IP "sk_security" 12
 used by security modules
.IP "sk_state_change" 12
 callback to indicate change in the state of the sock
.IP "sk_data_ready" 12
 callback to indicate there is data to be processed
.IP "sk_write_space" 12
 callback to indicate there is bf sending space available
.IP "sk_error_report" 12
 callback to indicate errors (e.g. MSG_ERRQUEUE)
.IP "sk_backlog_rcv" 12
 callback to process the backlog
.IP "sk_destruct" 12
 called at sock freeing time, i.e. when all refcnt == 0
.TH "sk_filter" 9 "sk_filter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_filter \-  run a packet through a socket filter
.SH SYNOPSIS
.B "int" sk_filter
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ","
.BI "int " needlock ");"
.SH ARGUMENTS
.IP "sk" 12
 sock associated with &amp;sk_buff
.IP "skb" 12
 buffer to filter
.IP "needlock" 12
 set to 1 if the sock is not locked by caller.
.SH "DESCRIPTION"
Run the filter code and then cut skb-&gt;data to correct size returned by
sk_run_filter. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
than pkt_len we keep whole skb-&gt;data. This is the socket level
wrapper to sk_run_filter. It returns 0 if the packet should
be accepted or -EPERM if the packet should be tossed.
.TH "sk_filter_release" 9 "sk_filter_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_filter_release \- 
.SH SYNOPSIS
.B "void" sk_filter_release
.BI "(struct sock *" sk ","
.BI "struct sk_filter *" fp ");"
.SH ARGUMENTS
.IP "sk" 12
 socket
.IP "fp" 12
 filter to remove
.SH "DESCRIPTION"
Remove a filter from a socket and release its resources.
.TH "sk_eat_skb" 9 "sk_eat_skb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_eat_skb \-  Release a skb if it is no longer needed
.SH SYNOPSIS
.B "void" sk_eat_skb
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 socket to eat this skb from
.IP "skb" 12
 socket buffer to eat
.SH "DESCRIPTION"
This routine must be called with interrupts disabled or with the socket
locked so that the sk_buff queue operation is ok.
.TH "Kernel API" 9 "struct llc_sap" "January 2021" "API Manual" LINUX
.SH NAME
struct llc_sap \-  Defines the SAP component
.SH SYNOPSIS
struct llc_sap {
.br
};
.br
.SH Arguments
.SH "Description"

\fIstation\fP - station this sap belongs to
\fIstate\fP - sap state
\fIp_bit\fP - only lowest-order bit used
\fIf_bit\fP - only lowest-order bit used
\fIladdr\fP - SAP value in this 'lsap'
\fInode\fP - entry in station sap_list
\fIsk_list\fP - LLC sockets this one manages
.TH "Kernel API" 9 "struct x25_route" "January 2021" "API Manual" LINUX
.SH NAME
struct x25_route \-  x25 routing entry
.SH SYNOPSIS
struct x25_route {
.br
};
.br
.SH Arguments
.SH "Description"
\fInode\fP - entry in x25_list_lock
\fIaddress\fP - Start of address range
\fIsigdigits\fP - Number of sig digits
\fIdev\fP - More than one for MLP
\fIrefcnt\fP - reference counter
.TH "llc_mac_null" 9 "llc_mac_null" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_mac_null \-  determines if a address is a null mac address
.SH SYNOPSIS
.B "int" llc_mac_null
.BI "(u8 *" mac ");"
.SH ARGUMENTS
.IP "mac" 12
 Mac address to test if null.
.SH "DESCRIPTION"
Determines if a given address is a null mac address.  Returns 0 if the
address is not a null mac, 1 if the address is a null mac.
.TH "llc_mac_match" 9 "llc_mac_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_mac_match \-  determines if two mac addresses are the same
.SH SYNOPSIS
.B "int" llc_mac_match
.BI "(u8 *" mac1 ","
.BI "u8 *" mac2 ");"
.SH ARGUMENTS
.IP "mac1" 12
 First mac address to compare.
.IP "mac2" 12
 Second mac address to compare.
.SH "DESCRIPTION"
Determines if two given mac address are the same.  Returns 0 if there
is not a complete match up to len, 1 if a complete match up to len is
found.
.TH "tcf_exts_is_predicative" 9 "tcf_exts_is_predicative" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_exts_is_predicative \-  check if a predicative extension is present
.SH SYNOPSIS
.B "int" tcf_exts_is_predicative
.BI "(struct tcf_exts *" exts ");"
.SH ARGUMENTS
.IP "exts" 12
 tc filter extensions handle
.SH "DESCRIPTION"
Returns 1 if a predicative extension is present, i.e. an extension which
might cause further actions and thus overrule the regular tcf_result.
.TH "tcf_exts_is_available" 9 "tcf_exts_is_available" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_exts_is_available \-  check if at least one extension is present
.SH SYNOPSIS
.B "int" tcf_exts_is_available
.BI "(struct tcf_exts *" exts ");"
.SH ARGUMENTS
.IP "exts" 12
 tc filter extensions handle
.SH "DESCRIPTION"
Returns 1 if at least one extension is present.
.TH "tcf_exts_exec" 9 "tcf_exts_exec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_exts_exec \-  execute tc filter extensions
.SH SYNOPSIS
.B "int" tcf_exts_exec
.BI "(struct sk_buff *" skb ","
.BI "struct tcf_exts *" exts ","
.BI "struct tcf_result *" res ");"
.SH ARGUMENTS
.IP "skb" 12
 socket buffer
.IP "exts" 12
 tc filter extensions handle
.IP "res" 12
 desired result
.SH "DESCRIPTION"
Executes all configured extensions. Returns 0 on a normal execution,
a negative number if the filter must be considered unmatched or
a positive action code (TC_ACT_*) which must be returned to the
underlying layer.
.TH "Kernel API" 9 "struct tcf_pkt_info" "January 2021" "API Manual" LINUX
.SH NAME
struct tcf_pkt_info \-  packet information
.SH SYNOPSIS
struct tcf_pkt_info {
.br
};
.br
.SH Arguments
.TH "Kernel API" 9 "struct tcf_ematch" "January 2021" "API Manual" LINUX
.SH NAME
struct tcf_ematch \-  extended match (ematch)
.SH SYNOPSIS
struct tcf_ematch {
.br
.BI "    struct tcf_ematch_ops *" ops ""
;

.br
.BI "    unsigned long " data ""
;

.br
.BI "    unsigned int " datalen ""
;

.br
.BI "    u16 " matchid ""
;

.br
.BI "    u16 " flags ""
;

.br
};
.br
.SH Arguments
.IP "ops" 12
 the operations lookup table of the corresponding ematch module
.IP "data" 12
 ematch specific data
.IP "datalen" 12
 length of the ematch specific configuration data
.IP "matchid" 12
 identifier to allow userspace to reidentify a match
.IP "flags" 12
 flags specifying attributes and the relation to other matches
.SH "Description"
.TH "Kernel API" 9 "struct tcf_ematch_tree" "January 2021" "API Manual" LINUX
.SH NAME
struct tcf_ematch_tree \-  ematch tree handle
.SH SYNOPSIS
struct tcf_ematch_tree {
.br
.BI "    struct tcf_ematch_tree_hdr " hdr ""
;

.br
.BI "    struct tcf_ematch *" matches ""
;

.br
};
.br
.SH Arguments
.IP "hdr" 12
 ematch tree header supplied by userspace
.IP "matches" 12
 array of ematches
.SH "Description"
.TH "Kernel API" 9 "struct tcf_ematch_ops" "January 2021" "API Manual" LINUX
.SH NAME
struct tcf_ematch_ops \-  ematch module operations
.SH SYNOPSIS
struct tcf_ematch_ops {
.br
.BI "    int " kind ""
;

.br
.BI "    int " datalen ""
;

.br
.BI "    int (*" change ") (struct tcf_proto *, void *,int, struct tcf_ematch *)"
;

.br
.BI "    int (*" match ") (struct sk_buff *, struct tcf_ematch *,struct tcf_pkt_info *)"
;

.br
.BI "    void (*" destroy ") (struct tcf_proto *,struct tcf_ematch *)"
;

.br
.BI "    int (*" dump ") (struct sk_buff *, struct tcf_ematch *)"
;

.br
.BI "    struct module *" owner ""
;

.br
.BI "    struct list_head " link ""
;

.br
};
.br
.SH Arguments
.IP "kind" 12
 identifier (kind) of this ematch module
.IP "datalen" 12
 length of expected configuration data (optional)
.IP "change" 12
 called during validation (optional)
.IP "match" 12
 called during ematch tree evaluation, must return 1/0
.IP "destroy" 12
 called during destroyage (optional)
.IP "dump" 12
 called during dumping process (optional)
.IP "owner" 12
 owner, must be set to THIS_MODULE
.IP "link" 12
 link to previous/next ematch module (internal use)
.SH "Description"
.TH "tcf_em_tree_change" 9 "tcf_em_tree_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_em_tree_change \-  replace ematch tree of a running classifier
.SH SYNOPSIS
.B "void" tcf_em_tree_change
.BI "(struct tcf_proto *" tp ","
.BI "struct tcf_ematch_tree *" dst ","
.BI "struct tcf_ematch_tree *" src ");"
.SH ARGUMENTS
.IP "tp" 12
 classifier kind handle
.IP "dst" 12
 destination ematch tree variable
.IP "src" 12
 source ematch tree (temporary tree from tcf_em_tree_validate)
.SH "DESCRIPTION"
This functions replaces the ematch tree in \fIdst\fP with the ematch
tree in \fIsrc\fP. The classifier in charge of the ematch tree may be
running.
.SH "DESCRIPTION"
This functions replaces the ematch tree in \fIdst\fP with the ematch
tree in \fIsrc\fP. The classifier in charge of the ematch tree may be
running.
.TH "tcf_em_tree_match" 9 "tcf_em_tree_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_em_tree_match \-  evaulate an ematch tree
.SH SYNOPSIS
.B "int" tcf_em_tree_match
.BI "(struct sk_buff *" skb ","
.BI "struct tcf_ematch_tree *" tree ","
.BI "struct tcf_pkt_info *" info ");"
.SH ARGUMENTS
.IP "skb" 12
 socket buffer of the packet in question
.IP "tree" 12
 ematch tree to be used for evaluation
.IP "info" 12
 packet information examined by classifier
.SH "DESCRIPTION"
This function matches \fIskb\fP against the ematch tree in \fItree\fP by going
through all ematches respecting their logic relations returning
as soon as the result is obvious.

Returns 1 if the ematch tree as-one matches, no ematches are configured
or ematch is not enabled in the kernel, otherwise 0 is returned.
.SH "DESCRIPTION"
This function matches \fIskb\fP against the ematch tree in \fItree\fP by going
through all ematches respecting their logic relations returning
as soon as the result is obvious.

Returns 1 if the ematch tree as-one matches, no ematches are configured
or ematch is not enabled in the kernel, otherwise 0 is returned.
.TH "sctp_list_dequeue" 9 "sctp_list_dequeue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sctp_list_dequeue \-  remove from the head of the queue
.SH SYNOPSIS
.B "struct list_head *" sctp_list_dequeue
.BI "(struct list_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list to dequeue from
.SH "DESCRIPTION"
Remove the head of the list. The head item is
returned or NULL if the list is empty.
.TH "pcibios_resource_to_bus" 9 "pcibios_resource_to_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcibios_resource_to_bus \-  convert resource to PCI bus address
.SH SYNOPSIS
.B "void" pcibios_resource_to_bus
.BI "(struct pci_dev *" dev ","
.BI "struct pci_bus_region *" region ","
.BI "struct resource *" res ");"
.SH ARGUMENTS
.IP "dev" 12
 device which owns this resource
.IP "region" 12
 converted bus-centric region (start,end)
.IP "res" 12
 resource to convert
.SH "DESCRIPTION"
Convert a resource to a PCI device bus address or bus window.
.TH "tlb_remove_tlb_entry" 9 "tlb_remove_tlb_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tlb_remove_tlb_entry \-  remember a pte unmapping for later tlb invalidation.
.SH SYNOPSIS
.B "" tlb_remove_tlb_entry
.BI "(" tlb ","
.BI "" ptep ","
.BI "" address ");"
.SH ARGUMENTS
.IP "tlb" 12
.IP "ptep" 12
.IP "address" 12
.SH "DESCRIPTION"

Record the fact that pte's were really umapped in -&gt;need_flush, so we can
later optimise away the tlb invalidate.   This helps when userspace is
unmapping already-unmapped pages, which happens quite a lot.
.TH "hweight32" 9 "hweight32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hweight32 \-  returns the hamming weight of a N-bit word
.SH SYNOPSIS
.B "" hweight32
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
 the word to weigh
.SH "DESCRIPTION"
The Hamming Weight of a number is the total number of bits set in it.
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "atomic_read" 9 "atomic_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_read \-  read atomic variable
.SH SYNOPSIS
.B "" atomic_read
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically reads the value of \fIv\fP.
.TH "atomic_set" 9 "atomic_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_set \-  set atomic variable
.SH SYNOPSIS
.B "" atomic_set
.BI "(" v ","
.BI "" i ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.IP "i" 12
 required value
.SH "DESCRIPTION"
Atomically sets the value of \fIv\fP to \fIi\fP.
.TH "atomic_add" 9 "atomic_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add \-  add integer to atomic variable
.SH SYNOPSIS
.B "void" atomic_add
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP.
.TH "atomic_sub" 9 "atomic_sub" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub \-  subtract the atomic variable
.SH SYNOPSIS
.B "void" atomic_sub
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP.
.TH "atomic_sub_and_test" 9 "atomic_sub_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub_and_test \-  subtract value from variable and test result
.SH SYNOPSIS
.B "" atomic_sub_and_test
.BI "(" i ","
.BI "" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP and returns
true if the result is zero, or false for all
other cases.
.TH "atomic_inc" 9 "atomic_inc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc \-  increment atomic variable
.SH SYNOPSIS
.B "" atomic_inc
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1.
.TH "atomic_inc_return" 9 "atomic_inc_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc_return \-  increment atomic variable
.SH SYNOPSIS
.B "" atomic_inc_return
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1.
.TH "atomic_dec" 9 "atomic_dec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec \-  decrement atomic variable
.SH SYNOPSIS
.B "" atomic_dec
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1.
.TH "atomic_dec_return" 9 "atomic_dec_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec_return \-  decrement atomic variable
.SH SYNOPSIS
.B "" atomic_dec_return
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1.
.TH "atomic_dec_and_test" 9 "atomic_dec_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec_and_test \-  decrement and test
.SH SYNOPSIS
.B "" atomic_dec_and_test
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1 and
returns true if the result is 0, or false for all other
cases.
.TH "atomic_inc_and_test" 9 "atomic_inc_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc_and_test \-  increment and test
.SH SYNOPSIS
.B "" atomic_inc_and_test
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1
and returns true if the result is zero, or false for all
other cases.
.TH "atomic_add_negative" 9 "atomic_add_negative" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add_negative \-  add and test if negative
.SH SYNOPSIS
.B "" atomic_add_negative
.BI "(" i ","
.BI "" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and returns true
if the result is negative, or false when
result is greater than or equal to zero.
.TH "for_each_dtlb_entry" 9 "for_each_dtlb_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
for_each_dtlb_entry \- 
.SH SYNOPSIS
.B "" for_each_dtlb_entry
.BI "(" tlb ");"
.SH ARGUMENTS
.IP "tlb" 12
	TLB entry
.SH "DESCRIPTION"
Iterate over free (non-wired) DTLB entries
.SH "DESCRIPTION"
Iterate over free (non-wired) DTLB entries
.TH "for_each_itlb_entry" 9 "for_each_itlb_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
for_each_itlb_entry \- 
.SH SYNOPSIS
.B "" for_each_itlb_entry
.BI "(" tlb ");"
.SH ARGUMENTS
.IP "tlb" 12
	TLB entry
.SH "DESCRIPTION"
Iterate over free (non-wired) ITLB entries
.SH "DESCRIPTION"
Iterate over free (non-wired) ITLB entries
.TH "__flush_tlb_slot" 9 "__flush_tlb_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__flush_tlb_slot \- 
.SH SYNOPSIS
.B "void" __flush_tlb_slot
.BI "(unsigned long long " slot ");"
.SH ARGUMENTS
.IP "slot" 12
	Address of TLB slot.
.SH "DESCRIPTION"
Flushes TLB slot \fIslot\fP.
.SH "DESCRIPTION"
Flushes TLB slot \fIslot\fP.
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the next set bit in a memory region
.SH SYNOPSIS
.B "unsigned long" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned long " size ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "snd_pcm_playback_ready" 9 "snd_pcm_playback_ready" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_playback_ready \-  check whether the playback buffer is available
.SH SYNOPSIS
.B "int" snd_pcm_playback_ready
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.SH "DESCRIPTION"
Checks whether enough free space is available on the playback buffer.

Returns non-zero if available, or zero if not.
.TH "snd_pcm_capture_ready" 9 "snd_pcm_capture_ready" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_capture_ready \-  check whether the capture buffer is available
.SH SYNOPSIS
.B "int" snd_pcm_capture_ready
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.SH "DESCRIPTION"
Checks whether enough capture data is available on the capture buffer.

Returns non-zero if available, or zero if not.
.TH "snd_pcm_playback_data" 9 "snd_pcm_playback_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_playback_data \-  check whether any data exists on the playback buffer
.SH SYNOPSIS
.B "int" snd_pcm_playback_data
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.SH "DESCRIPTION"
Checks whether any data exists on the playback buffer. If stop_threshold
is bigger or equal to boundary, then this function returns always non-zero.

Returns non-zero if exists, or zero if not.
.TH "snd_pcm_playback_empty" 9 "snd_pcm_playback_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_playback_empty \-  check whether the playback buffer is empty
.SH SYNOPSIS
.B "int" snd_pcm_playback_empty
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.SH "DESCRIPTION"
Checks whether the playback buffer is empty.

Returns non-zero if empty, or zero if not.
.TH "snd_pcm_capture_empty" 9 "snd_pcm_capture_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_capture_empty \-  check whether the capture buffer is empty
.SH SYNOPSIS
.B "int" snd_pcm_capture_empty
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.SH "DESCRIPTION"
Checks whether the capture buffer is empty.

Returns non-zero if empty, or zero if not.
.TH "snd_pcm_format_cpu_endian" 9 "snd_pcm_format_cpu_endian" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_cpu_endian \-  Check the PCM format is CPU-endian
.SH SYNOPSIS
.B "int" snd_pcm_format_cpu_endian
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns 1 if the given PCM format is CPU-endian, 0 if
opposite, or a negative error code if endian not specified.
.TH "snd_printk" 9 "snd_printk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_printk \-  printk wrapper
.SH SYNOPSIS
.B "" snd_printk
.BI "(" fmt ","
.BI "" args... ");"
.SH ARGUMENTS
.IP "fmt" 12
 format string
.IP "args..." 12
.SH "DESCRIPTION"
Works like \fBprint\fP but prints the file and the line of the caller
when configured with CONFIG_SND_VERBOSE_PRINTK.
.TH "snd_printd" 9 "snd_printd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_printd \-  debug printk
.SH SYNOPSIS
.B "" snd_printd
.BI "(" fmt ","
.BI "" args... ");"
.SH ARGUMENTS
.IP "fmt" 12
.IP "args..." 12
.SH "DESCRIPTION"
Compiled only when Works like \fBsnd_printk\fP for debugging purpose.
Ignored when CONFIG_SND_DEBUG is not set.
.TH "snd_assert" 9 "snd_assert" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_assert \-  run-time assertion macro
.SH SYNOPSIS
.B "" snd_assert
.BI "(" expr ","
.BI "" args... ");"
.SH ARGUMENTS
.IP "expr" 12
 expression
\fIargs\fP...: the action
.IP "args..." 12
.SH "DESCRIPTION"
This macro checks the expression in run-time and invokes the commands
given in the rest arguments if the assertion is failed.
When CONFIG_SND_DEBUG is not set, the expression is executed but
not checked.
.TH "snd_runtime_check" 9 "snd_runtime_check" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_runtime_check \-  run-time assertion macro
.SH SYNOPSIS
.B "" snd_runtime_check
.BI "(" expr ","
.BI "" args... ");"
.SH ARGUMENTS
.IP "expr" 12
 expression
\fIargs\fP...: the action
.IP "args..." 12
.SH "DESCRIPTION"
This macro checks the expression in run-time and invokes the commands
given in the rest arguments if the assertion is failed.
Unlike \fBsnd_assert\fP, the action commands are executed even if
CONFIG_SND_DEBUG is not set but without any error messages.
.TH "snd_printdd" 9 "snd_printdd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_printdd \-  debug printk
.SH SYNOPSIS
.B "" snd_printdd
.BI "(" format ","
.BI "" args... ");"
.SH ARGUMENTS
.IP "format" 12
 format string
.IP "args..." 12
.SH "DESCRIPTION"
Compiled only when Works like \fBsnd_printk\fP for debugging purpose.
Ignored when CONFIG_SND_DEBUG_DETECT is not set.
.TH "Kernel API" 9 "struct gnet_stats_basic" "January 2021" "API Manual" LINUX
.SH NAME
struct gnet_stats_basic \-  byte/packet throughput statistics
.SH SYNOPSIS
struct gnet_stats_basic {
.br
.BI "    __u64 " bytes ""
;

.br
.BI "    __u32 " packets ""
;

.br
};
.br
.SH Arguments
.IP "bytes" 12
 number of seen bytes
.IP "packets" 12
 number of seen packets
.TH "Kernel API" 9 "struct gnet_stats_rate_est" "January 2021" "API Manual" LINUX
.SH NAME
struct gnet_stats_rate_est \-  rate estimator
.SH SYNOPSIS
struct gnet_stats_rate_est {
.br
.BI "    __u32 " bps ""
;

.br
.BI "    __u32 " pps ""
;

.br
};
.br
.SH Arguments
.IP "bps" 12
 current byte rate
.IP "pps" 12
 current packet rate
.TH "Kernel API" 9 "struct gnet_stats_queue" "January 2021" "API Manual" LINUX
.SH NAME
struct gnet_stats_queue \-  queuing statistics
.SH SYNOPSIS
struct gnet_stats_queue {
.br
.BI "    __u32 " qlen ""
;

.br
.BI "    __u32 " backlog ""
;

.br
.BI "    __u32 " drops ""
;

.br
.BI "    __u32 " requeues ""
;

.br
.BI "    __u32 " overlimits ""
;

.br
};
.br
.SH Arguments
.IP "qlen" 12
 queue length
.IP "backlog" 12
 backlog size of queue
.IP "drops" 12
 number of dropped packets
.IP "requeues" 12
 number of requeues
.IP "overlimits" 12
 number of enqueues over the limit
.TH "Kernel API" 9 "struct gnet_estimator" "January 2021" "API Manual" LINUX
.SH NAME
struct gnet_estimator \-  rate estimator configuration
.SH SYNOPSIS
struct gnet_estimator {
.br
.BI "    signed char " interval ""
;

.br
.BI "    unsigned char " ewma_log ""
;

.br
};
.br
.SH Arguments
.IP "interval" 12
 sampling period
.IP "ewma_log" 12
 the log of measurement window weight
.TH "page_dup_rmap" 9 "page_dup_rmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
page_dup_rmap \-  duplicate pte mapping to a page
.SH SYNOPSIS
.B "void" page_dup_rmap
.BI "(struct page *" page ");"
.SH ARGUMENTS
.IP "page" 12
	the page to add the mapping to
.SH "FOR COPY_PAGE_RANGE ONLY"
 minimal extract from page_add_rmap,
avoiding unnecessary tests (already checked) so it's quicker.
.TH "dcookie_register" 9 "dcookie_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dcookie_register \-  register a user of dcookies
.SH SYNOPSIS
.B "struct dcookie_user *" dcookie_register
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Register as a dcookie user. Returns NULL on failure.
.TH "dcookie_unregister" 9 "dcookie_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dcookie_unregister \-  unregister a user of dcookies
.SH SYNOPSIS
.B "void" dcookie_unregister
.BI "(struct dcookie_user *" user ");"
.SH ARGUMENTS
.IP "user" 12
-- undescribed --
.SH "DESCRIPTION"

Unregister as a dcookie user. This may invalidate
any dcookie values returned from \fBget_dcookie\fP.
.TH "get_dcookie" 9 "get_dcookie" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_dcookie \-  acquire a dcookie
.SH SYNOPSIS
.B "int" get_dcookie
.BI "(struct dentry *" dentry ","
.BI "struct vfsmount *" vfsmnt ","
.BI "unsigned long *" cookie ");"
.SH ARGUMENTS
.IP "dentry" 12
-- undescribed --
.IP "vfsmnt" 12
-- undescribed --
.IP "cookie" 12
-- undescribed --
.SH "DESCRIPTION"

Convert the given dentry/vfsmount pair into
a cookie value.

Returns -EINVAL if no living task has registered as a
dcookie user.

Returns 0 on success, with *cookie filled in
.TH "Kernel API" 9 "struct rcu_head" "January 2021" "API Manual" LINUX
.SH NAME
struct rcu_head \-  callback structure for use with RCU
.SH SYNOPSIS
struct rcu_head {
.br
.BI "    struct rcu_head *" next ""
;

.br
.BI "    void (*" func ") (struct rcu_head *head)"
;

.br
};
.br
.SH Arguments
.IP "next" 12
 next update requests in a list
.IP "func" 12
 actual update function to call after the grace period.
.TH "rcu_read_lock" 9 "rcu_read_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcu_read_lock \-  mark the beginning of an RCU read-side critical section.
.SH SYNOPSIS
.B "" rcu_read_lock
.SH ARGUMENTS
.SH "DESCRIPTION"

When \fBsynchronize_rcu\fP is invoked on one CPU while other CPUs
are within RCU read-side critical sections, then the
\fBsynchronize_rcu\fP is guaranteed to block until after all the other
CPUs exit their critical sections.  Similarly, if \fBcall_rcu\fP is invoked
on one CPU while other CPUs are within RCU read-side critical
sections, invocation of the corresponding RCU callback is deferred
until after the all the other CPUs exit their critical sections.

Note, however, that RCU callbacks are permitted to run concurrently
with RCU read-side critical sections.  One way that this can happen
.SH "IS VIA THE FOLLOWING SEQUENCE OF EVENTS"
 (1) CPU 0 enters an RCU
read-side critical section, (2) CPU 1 invokes \fBcall_rcu\fP to register
an RCU callback, (3) CPU 0 exits the RCU read-side critical section,
(4) CPU 2 enters a RCU read-side critical section, (5) the RCU
callback is invoked.  This is legal, because the RCU read-side critical
section that was running concurrently with the \fBcall_rcu\fP (and which
therefore might be referencing something that the corresponding RCU
callback would free up) has completed before the corresponding
RCU callback is invoked.

RCU read-side critical sections may be nested.  Any deferred actions
will be deferred until the outermost RCU read-side critical section
completes.

It is illegal to block while in an RCU read-side critical section.
.TH "rcu_read_unlock" 9 "rcu_read_unlock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcu_read_unlock \-  marks the end of an RCU read-side critical section.
.SH SYNOPSIS
.B "" rcu_read_unlock
.SH ARGUMENTS
.SH "DESCRIPTION"

See \fBrcu_read_lock\fP for more information.
.TH "rcu_read_lock_bh" 9 "rcu_read_lock_bh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcu_read_lock_bh \-  mark the beginning of a softirq-only RCU critical section
.SH SYNOPSIS
.B "" rcu_read_lock_bh
.SH ARGUMENTS
.SH "DESCRIPTION"

This is equivalent of \fBrcu_read_lock\fP, but to be used when updates
are being done using \fBcall_rcu_bh\fP. Since \fBcall_rcu_bh\fP callbacks
consider completion of a softirq handler to be a quiescent state,
a process in RCU read-side critical section must be protected by
disabling softirqs. Read-side critical sections in interrupt context
can use just \fBrcu_read_lock\fP.
.TH "rcu_dereference" 9 "rcu_dereference" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcu_dereference \-  fetch an RCU-protected pointer in an
.SH SYNOPSIS
.B "" rcu_dereference
.BI "(" p ");"
.SH ARGUMENTS
.IP "p" 12
.SH "DESCRIPTION"
RCU read-side critical section.  This pointer may later
be safely dereferenced.

Inserts memory barriers on architectures that require them
(currently only the Alpha), and, more importantly, documents
exactly which pointers are protected by RCU.
.TH "rcu_assign_pointer" 9 "rcu_assign_pointer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcu_assign_pointer \-  assign (publicize) a pointer to a newly
.SH SYNOPSIS
.B "" rcu_assign_pointer
.BI "(" p ","
.BI "" v ");"
.SH ARGUMENTS
.IP "p" 12
.IP "v" 12
.SH "DESCRIPTION"
initialized structure that will be dereferenced by RCU read-side
critical sections.  Returns the value assigned.

Inserts memory barriers on architectures that require them
(pretty much all of them other than x86), and also prevents
the compiler from reordering the code that initializes the
structure after the pointer assignment.  More importantly, this
call documents which pointers will be dereferenced by RCU read-side
code.
.TH "synchronize_sched" 9 "synchronize_sched" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
synchronize_sched \-  block until all CPUs have exited any non-preemptive
.SH SYNOPSIS
.B "" synchronize_sched
.SH ARGUMENTS
.SH "DESCRIPTION"
kernel code sequences.

This means that all preempt_disable code sequences, including NMI and
hardware-interrupt handlers, in progress on entry will have completed
before this primitive returns.  However, this does not guarantee that
softirq handlers will have completed, since in some kernels

This primitive provides the guarantees made by the (deprecated)
\fBsynchronize_kernel\fP API.  In contrast, \fBsynchronize_rcu\fP only
guarantees that \fBrcu_read_lock\fP sections will have completed.
.TH "Kernel API" 9 "struct cycx_x25_config" "January 2021" "API Manual" LINUX
.SH NAME
struct cycx_x25_config \-  cyclom2x x25 firmware configuration
.SH SYNOPSIS
struct cycx_x25_config {
.br
};
.br
.SH Arguments
.SH "Description"
\fIlink\fP - link number
\fIspeed\fP - line speed
\fIclock\fP - internal/external
\fIn2\fP - # of level 2 retransm.(values: 1 thru FF)
\fIn2win\fP - level 2 window (values: 1 thru 7)
\fIn3win\fP - level 3 window (values: 1 thru 7)
\fInvc\fP - # of logical channels (values: 1 thru 64)
\fIpktlen\fP - level 3 packet lenght - log base 2 of size
\fIlocaddr\fP - my address
\fIremaddr\fP - remote address
\fIt1\fP - time, in seconds
\fIt2\fP - time, in seconds
\fIt21\fP - time, in seconds
\fInpvc\fP - # of permanent virt. circuits (1 thru nvc)
\fIt23\fP - time, in seconds
\fIflags\fP - see dosx25.doc, in portuguese, for details
.TH "module_init" 9 "module_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
module_init \-  driver initialization entry point
.SH SYNOPSIS
.B "" module_init
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
 function to be run at kernel boot time or module insertion
.SH "DESCRIPTION"
\fBmodule_init\fP will either be called during do_initcalls (if
builtin) or at module insertion time (if a module).  There can only
be one per module.
.TH "module_exit" 9 "module_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
module_exit \-  driver exit entry point
.SH SYNOPSIS
.B "" module_exit
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
 function to be run when driver is removed
.SH "DESCRIPTION"
\fBmodule_exit\fP will wrap the driver clean-up code
with \fBcleanup_module\fP when used with rmmod when
the driver is a module.  If the driver is statically
compiled into the kernel, \fBmodule_exit\fP has no effect.
There can only be one per module.
.TH "uart_handle_dcd_change" 9 "uart_handle_dcd_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_handle_dcd_change \-  handle a change of carrier detect state
.SH SYNOPSIS
.B "void" uart_handle_dcd_change
.BI "(struct uart_port *" port ","
.BI "unsigned int " status ");"
.SH ARGUMENTS
.IP "port" 12
 uart_port structure for the open port
.IP "status" 12
 new carrier detect status, nonzero if active
.TH "uart_handle_cts_change" 9 "uart_handle_cts_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_handle_cts_change \-  handle a change of clear-to-send state
.SH SYNOPSIS
.B "void" uart_handle_cts_change
.BI "(struct uart_port *" port ","
.BI "unsigned int " status ");"
.SH ARGUMENTS
.IP "port" 12
 uart_port structure for the open port
.IP "status" 12
 new clear to send status, nonzero if active
.TH "oprofile_arch_init" 9 "oprofile_arch_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofile_arch_init \- time initialisation. *ops must be set to a filled-in
.SH SYNOPSIS
.B "int" oprofile_arch_init
.BI "(struct oprofile_operations *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
-- undescribed --
.SH "DESCRIPTION"
operations structure. This is called even in timer interrupt
mode so an arch can set a backtrace callback.

If an error occurs, the fields should be left untouched.
.TH "oprofile_arch_exit" 9 "oprofile_arch_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofile_arch_exit \- time exit/cleanup for the arch.
.SH SYNOPSIS
.B "void" oprofile_arch_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "oprofile_add_sample" 9 "oprofile_add_sample" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofile_add_sample \- 
.SH SYNOPSIS
.B "void" oprofile_add_sample
.BI "(struct pt_regs *const " regs ","
.BI "unsigned long " event ");"
.SH ARGUMENTS
.IP "regs" 12
-- undescribed --
.IP "event" 12
-- undescribed --
.SH "DESCRIPTION"
\fBsmp_processor_id\fP as cpu.
.TH "oprofilefs_create_file" 9 "oprofilefs_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofilefs_create_file \- 
.SH SYNOPSIS
.B "int" oprofilefs_create_file
.BI "(struct super_block *" sb ","
.BI "struct dentry *" root ","
.BI "char const *" name ","
.BI "struct file_operations *" fops ");"
.SH ARGUMENTS
.IP "sb" 12
-- undescribed --
.IP "root" 12
-- undescribed --
.IP "name" 12
-- undescribed --
.IP "fops" 12
-- undescribed --
.SH "DESCRIPTION"
the specified file operations.
.TH "oprofilefs_str_to_user" 9 "oprofilefs_str_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofilefs_str_to_user \- 
.SH SYNOPSIS
.B "ssize_t" oprofilefs_str_to_user
.BI "(char const *" str ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" offset ");"
.SH ARGUMENTS
.IP "str" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.SH "DESCRIPTION"
appropriately. Returns bytes written or -EFAULT.
.TH "oprofilefs_ulong_to_user" 9 "oprofilefs_ulong_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofilefs_ulong_to_user \- 
.SH SYNOPSIS
.B "ssize_t" oprofilefs_ulong_to_user
.BI "(unsigned long " val ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" offset ");"
.SH ARGUMENTS
.IP "val" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.SH "DESCRIPTION"
updating *offset appropriately. Returns bytes written or -EFAULT.
.TH "oprofilefs_ulong_from_user" 9 "oprofilefs_ulong_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofilefs_ulong_from_user \- 
.SH SYNOPSIS
.B "int" oprofilefs_ulong_from_user
.BI "(unsigned long *" val ","
.BI "char const __user *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "val" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
Returns 0 on success, &lt; 0 on error.
.TH "__vlan_put_tag" 9 "__vlan_put_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__vlan_put_tag \-  regular VLAN tag inserting
.SH SYNOPSIS
.B "struct sk_buff *" __vlan_put_tag
.BI "(struct sk_buff *" skb ","
.BI "unsigned short " tag ");"
.SH ARGUMENTS
.IP "skb" 12
 skbuff to tag
.IP "tag" 12
 VLAN tag to insert
.SH "DESCRIPTION"
Inserts the VLAN tag into \fIskb\fP as part of the payload
Returns a VLAN tagged skb. If a new skb is created, \fIskb\fP is freed.

Following the \fBskb_unshare\fP example, in case of error, the calling function
doesn't have to worry about freeing the original skb.
.TH "__vlan_hwaccel_put_tag" 9 "__vlan_hwaccel_put_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__vlan_hwaccel_put_tag \-  hardware accelerated VLAN inserting
.SH SYNOPSIS
.B "struct sk_buff *" __vlan_hwaccel_put_tag
.BI "(struct sk_buff *" skb ","
.BI "unsigned short " tag ");"
.SH ARGUMENTS
.IP "skb" 12
 skbuff to tag
.IP "tag" 12
 VLAN tag to insert
.SH "DESCRIPTION"
Puts the VLAN tag in \fIskb\fP-&gt;cb[] and lets the device do the rest
.TH "vlan_put_tag" 9 "vlan_put_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vlan_put_tag \-  inserts VLAN tag according to device features
.SH SYNOPSIS
.B "struct sk_buff *" vlan_put_tag
.BI "(struct sk_buff *" skb ","
.BI "unsigned short " tag ");"
.SH ARGUMENTS
.IP "skb" 12
 skbuff to tag
.IP "tag" 12
 VLAN tag to insert
.SH "DESCRIPTION"
Assumes skb-&gt;dev is the target that will xmit this frame.
Returns a VLAN tagged skb.
.TH "__vlan_get_tag" 9 "__vlan_get_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__vlan_get_tag \-  get the VLAN ID that is part of the payload
.SH SYNOPSIS
.B "int" __vlan_get_tag
.BI "(struct sk_buff *" skb ","
.BI "unsigned short *" tag ");"
.SH ARGUMENTS
.IP "skb" 12
 skbuff to query
.IP "tag" 12
 buffer to store vlaue
.SH "DESCRIPTION"
Returns error if the skb is not of VLAN type
.TH "__vlan_hwaccel_get_tag" 9 "__vlan_hwaccel_get_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__vlan_hwaccel_get_tag \-  get the VLAN ID that is in @skb-\\\gt;cb[]
.SH SYNOPSIS
.B "int" __vlan_hwaccel_get_tag
.BI "(struct sk_buff *" skb ","
.BI "unsigned short *" tag ");"
.SH ARGUMENTS
.IP "skb" 12
 skbuff to query
.IP "tag" 12
 buffer to store vlaue
.SH "DESCRIPTION"
Returns error if \fIskb\fP-&gt;cb[] is not set correctly
.TH "vlan_get_tag" 9 "vlan_get_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vlan_get_tag \-  get the VLAN ID from the skb
.SH SYNOPSIS
.B "int" vlan_get_tag
.BI "(struct sk_buff *" skb ","
.BI "unsigned short *" tag ");"
.SH ARGUMENTS
.IP "skb" 12
 skbuff to query
.IP "tag" 12
 buffer to store vlaue
.SH "DESCRIPTION"
Returns error if the skb is not VLAN tagged
.TH "efi_range_is_wc" 9 "efi_range_is_wc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
efi_range_is_wc \-  check the WC bit on an address range
.SH SYNOPSIS
.B "int" efi_range_is_wc
.BI "(unsigned long " start ","
.BI "unsigned long " len ");"
.SH ARGUMENTS
.IP "start" 12
 starting kvirt address
.IP "len" 12
 length of range
.SH "DESCRIPTION"
Consult the EFI memory map and make sure it's ok to set this range WC.
Returns true or false.
.TH "register_atm_ioctl" 9 "register_atm_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_atm_ioctl \-  register handler for ioctl operations
.SH SYNOPSIS
.B "void" register_atm_ioctl
.BI "(struct atm_ioctl *"  ");"
.SH ARGUMENTS
.IP "" 12
-- undescribed --
.SH "DESCRIPTION"

Special (non-device) handlers of ioctl's should
register here. If you're a normal device, you should
set .ioctl in your atmdev_ops instead.
.TH "deregister_atm_ioctl" 9 "deregister_atm_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
deregister_atm_ioctl \-  remove the ioctl handler
.SH SYNOPSIS
.B "void" deregister_atm_ioctl
.BI "(struct atm_ioctl *"  ");"
.SH ARGUMENTS
.IP "" 12
-- undescribed --
.TH "nfs_list_add_request" 9 "nfs_list_add_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_list_add_request \-  Insert a request into a list
.SH SYNOPSIS
.B "void" nfs_list_add_request
.BI "(struct nfs_page *" req ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "req" 12
 request
.IP "head" 12
 head of list into which to insert the request.
.TH "nfs_list_remove_request" 9 "nfs_list_remove_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_list_remove_request \-  Remove a request from its wb_list
.SH SYNOPSIS
.B "void" nfs_list_remove_request
.BI "(struct nfs_page *" req ");"
.SH ARGUMENTS
.IP "req" 12
 request
.TH "touch_nmi_watchdog" 9 "touch_nmi_watchdog" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
touch_nmi_watchdog \-  restart NMI watchdog timeout.
.SH SYNOPSIS
.B "void" touch_nmi_watchdog
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

If the architecture supports the NMI watchdog, \fBtouch_nmi_watchdog\fP
may be used to reset the timeout - for code which intentionally
disables interrupts for a long time. This call is stateless.
.TH "Kernel API" 9 "struct usb_ctrlrequest" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_ctrlrequest \-  SETUP data for a USB device control request
.SH SYNOPSIS
struct usb_ctrlrequest {
.br
.BI "    __u8 " bRequestType ""
;

.br
.BI "    __u8 " bRequest ""
;

.br
.BI "    __le16 " wValue ""
;

.br
.BI "    __le16 " wIndex ""
;

.br
.BI "    __le16 " wLength ""
;

.br
};
.br
.SH Arguments
.IP "bRequestType" 12
 matches the USB bmRequestType field
.IP "bRequest" 12
 matches the USB bRequest field
.IP "wValue" 12
 matches the USB wValue field (le16 byte order)
.IP "wIndex" 12
 matches the USB wIndex field (le16 byte order)
.IP "wLength" 12
 matches the USB wLength field (le16 byte order)
.SH "Description"
This structure is used to send control requests to a USB device.  It matches
the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
USB spec for a fuller description of the different fields, and what they are
used for.

Note that the driver for any interface can issue control requests.
For most devices, interfaces don't coordinate with each other, so
such requests may be made at any time.
.TH "rcuref_inc" 9 "rcuref_inc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_inc \-  increment refcount for object.
.SH SYNOPSIS
.B "void" rcuref_inc
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object in question.
.SH "DESCRIPTION"
This should be used only for objects where we use RCU and
use the \fBrcuref_inc_lf\fP api to acquire a reference
in a lock-free reader-side critical section.
.TH "rcuref_dec" 9 "rcuref_dec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_dec \-  decrement refcount for object.
.SH SYNOPSIS
.B "void" rcuref_dec
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object in question.
.SH "DESCRIPTION"
This should be used only for objects where we use RCU and
use the \fBrcuref_inc_lf\fP api to acquire a reference
in a lock-free reader-side critical section.
.TH "rcuref_dec_and_test" 9 "rcuref_dec_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_dec_and_test \-  decrement refcount for object and test
.SH SYNOPSIS
.B "int" rcuref_dec_and_test
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object.
.SH "DESCRIPTION"
Decrement the refcount, and if 0, return 1. Else return 0.

This should be used only for objects where we use RCU and
use the \fBrcuref_inc_lf\fP api to acquire a reference
in a lock-free reader-side critical section.
.TH "rcuref_inc_lf" 9 "rcuref_inc_lf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_inc_lf \-  Take reference to an object in a read-side
.SH SYNOPSIS
.B "int" rcuref_inc_lf
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object in question.
.SH "DESCRIPTION"
Try and increment the refcount by 1.  The increment might fail if
the reference counter has been through a 1 to 0 transition and
is no longer part of the lock-free list.
Returns non-zero on successful increment and zero otherwise.
.SH "DESCRIPTION"
Try and increment the refcount by 1.  The increment might fail if
the reference counter has been through a 1 to 0 transition and
is no longer part of the lock-free list.
Returns non-zero on successful increment and zero otherwise.
.TH "rcuref_inc" 9 "rcuref_inc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_inc \-  increment refcount for object.
.SH SYNOPSIS
.B "void" rcuref_inc
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object in question.
.SH "DESCRIPTION"
This should be used only for objects where we use RCU and
use the \fBrcuref_inc_lf\fP api to acquire a reference in a lock-free
reader-side critical section.
.TH "rcuref_dec" 9 "rcuref_dec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_dec \-  decrement refcount for object.
.SH SYNOPSIS
.B "void" rcuref_dec
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object in question.
.SH "DESCRIPTION"
This should be used only for objects where we use RCU and
use the \fBrcuref_inc_lf\fP api to acquire a reference in a lock-free
reader-side critical section.
.TH "rcuref_dec_and_test" 9 "rcuref_dec_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_dec_and_test \-  decrement refcount for object and test
.SH SYNOPSIS
.B "int" rcuref_dec_and_test
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object.
.SH "DESCRIPTION"
Decrement the refcount, and if 0, return 1. Else return 0.

This should be used only for objects where we use RCU and
use the \fBrcuref_inc_lf\fP api to acquire a reference in a lock-free
reader-side critical section.
.TH "rcuref_inc_lf" 9 "rcuref_inc_lf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rcuref_inc_lf \-  Take reference to an object of a lock-free collection
.SH SYNOPSIS
.B "int" rcuref_inc_lf
.BI "(atomic_t *" rcuref ");"
.SH ARGUMENTS
.IP "rcuref" 12
 reference counter in the object in question.
.SH "DESCRIPTION"
Try and increment the refcount by 1.  The increment might fail if
the reference counter has been through a 1 to 0 transition and
object is no longer part of the lock-free list.
Returns non-zero on successful increment and zero otherwise.
.SH "DESCRIPTION"
Try and increment the refcount by 1.  The increment might fail if
the reference counter has been through a 1 to 0 transition and
object is no longer part of the lock-free list.
Returns non-zero on successful increment and zero otherwise.
.TH "Kernel API" 9 "struct ts_fsm_token" "January 2021" "API Manual" LINUX
.SH NAME
struct ts_fsm_token \-  state machine token (state)
.SH SYNOPSIS
struct ts_fsm_token {
.br
.BI "    __u16 " type ""
;

.br
.BI "    __u8 " recur ""
;

.br
.BI "    __u8 " value ""
;

.br
};
.br
.SH Arguments
.IP "type" 12
 type of token
.IP "recur" 12
 number of recurrences
.IP "value" 12
 character value for TS_FSM_SPECIFIC
.TH "PCI_DEVICE" 9 "PCI_DEVICE" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
PCI_DEVICE \-  macro used to describe a specific pci device
.SH SYNOPSIS
.B "" PCI_DEVICE
.BI "(" vend ","
.BI "" dev ");"
.SH ARGUMENTS
.IP "vend" 12
 the 16 bit PCI Vendor ID
.IP "dev" 12
 the 16 bit PCI Device ID
.SH "DESCRIPTION"
This macro is used to create a struct pci_device_id that matches a
specific device.  The subvendor and subdevice fields will be set to
PCI_ANY_ID.
.TH "PCI_DEVICE_CLASS" 9 "PCI_DEVICE_CLASS" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
PCI_DEVICE_CLASS \-  macro used to describe a specific pci device class
.SH SYNOPSIS
.B "" PCI_DEVICE_CLASS
.BI "(" dev_class ","
.BI "" dev_class_mask ");"
.SH ARGUMENTS
.IP "dev_class" 12
 the class, subclass, prog-if triple for this device
.IP "dev_class_mask" 12
 the class mask for this device
.SH "DESCRIPTION"
This macro is used to create a struct pci_device_id that matches a
specific PCI class.  The vendor, device, subvendor, and subdevice
fields will be set to PCI_ANY_ID.
.TH "pid_alive" 9 "pid_alive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pid_alive \-  check that a task structure is not stale
.SH SYNOPSIS
.B "int" pid_alive
.BI "(struct task_struct *" p ");"
.SH ARGUMENTS
.IP "p" 12
 Task structure to be checked.
.SH "DESCRIPTION"
Test if a process is not yet dead (at most zombie state)
If pid_alive fails, then pointers within the task structure
can be stale and must not be dereferenced.
.TH "Kernel API" 9 "struct atalk_iface" "January 2021" "API Manual" LINUX
.SH NAME
struct atalk_iface \-  AppleTalk Interface
.SH SYNOPSIS
struct atalk_iface {
.br
.BI "#define ATIF_PROBE	1"
.br
.BI "#define ATIF_PROBE_FAIL	2"
.br
};
.br
.SH Arguments
.SH "Description"
\fIdev\fP - Network device associated with this interface
\fIaddress\fP - Our address
\fIstatus\fP - What are we doing?
\fInets\fP - Associated direct netrange
\fInext\fP - next element in the list of interfaces
.TH "nfs_save_change_attribute" 9 "nfs_save_change_attribute" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_save_change_attribute \-  Returns the inode attribute change cookie
.SH SYNOPSIS
.B "long" nfs_save_change_attribute
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to inode
The "change attribute" is updated every time we finish an operation
that will result in a metadata change on the server.
.TH "nfs_verify_change_attribute" 9 "nfs_verify_change_attribute" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_verify_change_attribute \-  Detects NFS inode cache updates
.SH SYNOPSIS
.B "int" nfs_verify_change_attribute
.BI "(struct inode *" inode ","
.BI "unsigned long " chattr ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "chattr" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to inode
\fIchattr\fP - previously saved change attribute
Return "false" if metadata has been updated (or is in the process of
being updated) since the change attribute was saved.
.TH "Kernel API" 9 "struct cycx_fw_info" "January 2021" "API Manual" LINUX
.SH NAME
struct cycx_fw_info \-  firmware module information.
.SH SYNOPSIS
struct cycx_fw_info {
.br
};
.br
.SH Arguments
.SH "Description"
\fIcodeid\fP - firmware ID
\fIversion\fP - firmware version number
\fIadapter\fP - compatible adapter types
\fImemsize\fP - minimum memory size
\fIreserved\fP - reserved
\fIstartoffs\fP - entry point offset
\fIwinoffs\fP - dual-port memory window offset
\fIcodeoffs\fP - code load offset
\fIcodesize\fP - code size
\fIdataoffs\fP - configuration data load offset
\fIdatasize\fP - configuration data size
.TH "Kernel API" 9 "struct cycx_firmware" "January 2021" "API Manual" LINUX
.SH NAME
struct cycx_firmware \-  CYCX firmware file structure
.SH SYNOPSIS
struct cycx_firmware {
.br
};
.br
.SH Arguments
.SH "Description"
\fIsignature\fP - CFM file signature
\fIversion\fP - file format version
\fIchecksum\fP - info + image
\fIreserved\fP - reserved
\fIdescr\fP - description string
\fIinfo\fP - firmware module info
\fIimage\fP - code image (variable size)
.TH "relay_write" 9 "relay_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_write \-  write data into the channel
.SH SYNOPSIS
.B "void" relay_write
.BI "(struct rchan *" chan ","
.BI "const void *" data ","
.BI "size_t " length ");"
.SH ARGUMENTS
.IP "chan" 12
 relay channel
.IP "data" 12
 data to be written
.IP "length" 12
 number of bytes to write
.SH "DESCRIPTION"
Writes data into the current cpu's channel buffer.

Protects the buffer by disabling interrupts.  Use this
if you might be logging from interrupt context.  Try
\fB__relay_write\fP if you know you	won't be logging from
interrupt context.
.TH "__relay_write" 9 "__relay_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__relay_write \-  write data into the channel
.SH SYNOPSIS
.B "void" __relay_write
.BI "(struct rchan *" chan ","
.BI "const void *" data ","
.BI "size_t " length ");"
.SH ARGUMENTS
.IP "chan" 12
 relay channel
.IP "data" 12
 data to be written
.IP "length" 12
 number of bytes to write
.SH "DESCRIPTION"
Writes data into the current cpu's channel buffer.

Protects the buffer by disabling preemption.  Use
\fBrelay_write\fP if you might be logging from interrupt
context.
.TH "relay_reserve" 9 "relay_reserve" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_reserve \-  reserve slot in channel buffer
.SH SYNOPSIS
.B "void *" relay_reserve
.BI "(struct rchan *" chan ","
.BI "size_t " length ");"
.SH ARGUMENTS
.IP "chan" 12
 relay channel
.IP "length" 12
 number of bytes to reserve
.SH "DESCRIPTION"
Returns pointer to reserved slot, NULL if full.

Reserves a slot in the current cpu's channel buffer.
Does not protect the buffer at all - caller must provide
appropriate synchronization.
.TH "subbuf_start_reserve" 9 "subbuf_start_reserve" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
subbuf_start_reserve \-  reserve bytes at the start of a sub-buffer
.SH SYNOPSIS
.B "void" subbuf_start_reserve
.BI "(struct rchan_buf *" buf ","
.BI "size_t " length ");"
.SH ARGUMENTS
.IP "buf" 12
 relay channel buffer
.IP "length" 12
 number of bytes to reserve
.SH "DESCRIPTION"
Helper function used to reserve bytes at the beginning of
a sub-buffer in the \fBsubbuf_start\fP callback.
.TH "is_zero_ether_addr" 9 "is_zero_ether_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_zero_ether_addr \-  Determine if give Ethernet address is all
.SH SYNOPSIS
.B "int" is_zero_ether_addr
.BI "(const u8 *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
-- undescribed --
.SH "DESCRIPTION"
zeros.
.TH "is_multicast_ether_addr" 9 "is_multicast_ether_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_multicast_ether_addr \-  Determine if the given Ethernet address is a
.SH SYNOPSIS
.B "int" is_multicast_ether_addr
.BI "(const u8 *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
 Pointer to a six-byte array containing the Ethernet address
.SH "DESCRIPTION"
Return true if the address is a multicast address.
.SH "DESCRIPTION"
Return true if the address is a multicast address.
.TH "is_valid_ether_addr" 9 "is_valid_ether_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_valid_ether_addr \-  Determine if the given Ethernet address is valid
.SH SYNOPSIS
.B "int" is_valid_ether_addr
.BI "(const u8 *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
 Pointer to a six-byte array containing the Ethernet address
.SH "DESCRIPTION"
Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
a multicast address, and is not FF:FF:FF:FF:FF:FF.

Return true if the address is valid.
.TH "random_ether_addr" 9 "random_ether_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
random_ether_addr \-  Generate software assigned random Ethernet address
.SH SYNOPSIS
.B "void" random_ether_addr
.BI "(u8 *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
 Pointer to a six-byte array containing the Ethernet address
.SH "DESCRIPTION"
Generate a random Ethernet address (MAC) that is not multicast
and has the local assigned bit set.
.TH "Kernel API" 9 "struct security_operations" "January 2021" "API Manual" LINUX
.SH NAME
struct security_operations \-  main security structure
.SH SYNOPSIS
struct security_operations {
.br
.BI "    int (*" ptrace ") (struct task_struct * parent, struct task_struct * child)"
;

.br
.BI "    int (*" capget ") (struct task_struct * target,kernel_cap_t * effective,kernel_cap_t * inheritable, kernel_cap_t * permitted)"
;

.br
.BI "    int (*" capset_check ") (struct task_struct * target,kernel_cap_t * effective,kernel_cap_t * inheritable,kernel_cap_t * permitted)"
;

.br
.BI "    void (*" capset_set ") (struct task_struct * target,kernel_cap_t * effective,kernel_cap_t * inheritable,kernel_cap_t * permitted)"
;

.br
.BI "    int (*" acct ") (struct file * file)"
;

.br
.BI "    int (*" sysctl ") (struct ctl_table * table, int op)"
;

.br
.BI "    int (*" capable ") (struct task_struct * tsk, int cap)"
;

.br
.BI "    int (*" syslog ") (int type)"
;

.br
.BI "    int (*" settime ") (struct timespec *ts, struct timezone *tz)"
;

.br
.BI "    int (*" vm_enough_memory ") (long pages)"
;

.br
.BI "    int (*" bprm_alloc_security ") (struct linux_binprm * bprm)"
;

.br
.BI "    void (*" bprm_free_security ") (struct linux_binprm * bprm)"
;

.br
.BI "    void (*" bprm_apply_creds ") (struct linux_binprm * bprm, int unsafe)"
;

.br
.BI "    void (*" bprm_post_apply_creds ") (struct linux_binprm * bprm)"
;

.br
.BI "    int (*" bprm_set_security ") (struct linux_binprm * bprm)"
;

.br
.BI "    int (*" bprm_check_security ") (struct linux_binprm * bprm)"
;

.br
.BI "    int (*" bprm_secureexec ") (struct linux_binprm * bprm)"
;

.br
.BI "    int (*" sb_alloc_security ") (struct super_block * sb)"
;

.br
.BI "    void (*" sb_free_security ") (struct super_block * sb)"
;

.br
.BI "    int (*" sb_copy_data ") (struct file_system_type *type,void *orig, void *copy)"
;

.br
.BI "    int (*" sb_statfs ") (struct super_block * sb)"
;

.br
.BI "    int (*" sb_mount ") (char *dev_name, struct nameidata * nd,char *type, unsigned long flags, void *data)"
;

.br
.BI "    int (*" sb_check_sb ") (struct vfsmount * mnt, struct nameidata * nd)"
;

.br
.BI "    int (*" sb_umount ") (struct vfsmount * mnt, int flags)"
;

.br
.BI "    void (*" sb_umount_close ") (struct vfsmount * mnt)"
;

.br
.BI "    void (*" sb_umount_busy ") (struct vfsmount * mnt)"
;

.br
.BI "    void (*" sb_post_remount ") (struct vfsmount * mnt,unsigned long flags, void *data)"
;

.br
.BI "    void (*" sb_post_mountroot ") (void)"
;

.br
.BI "    void (*" sb_post_addmount ") (struct vfsmount * mnt,struct nameidata * mountpoint_nd)"
;

.br
.BI "    int (*" sb_pivotroot ") (struct nameidata * old_nd,struct nameidata * new_nd)"
;

.br
.BI "    void (*" sb_post_pivotroot ") (struct nameidata * old_nd,struct nameidata * new_nd)"
;

.br
.BI "    int (*" inode_alloc_security ") (struct inode *inode)"
;

.br
.BI "    void (*" inode_free_security ") (struct inode *inode)"
;

.br
.BI "    int (*" inode_init_security ") (struct inode *inode, struct inode *dir,char **name, void **value, size_t *len)"
;

.br
.BI "    int (*" inode_create ") (struct inode *dir,struct dentry *dentry, int mode)"
;

.br
.BI "    int (*" inode_link ") (struct dentry *old_dentry,struct inode *dir, struct dentry *new_dentry)"
;

.br
.BI "    int (*" inode_unlink ") (struct inode *dir, struct dentry *dentry)"
;

.br
.BI "    int (*" inode_symlink ") (struct inode *dir,struct dentry *dentry, const char *old_name)"
;

.br
.BI "    int (*" inode_mkdir ") (struct inode *dir, struct dentry *dentry, int mode)"
;

.br
.BI "    int (*" inode_rmdir ") (struct inode *dir, struct dentry *dentry)"
;

.br
.BI "    int (*" inode_mknod ") (struct inode *dir, struct dentry *dentry,int mode, dev_t dev)"
;

.br
.BI "    int (*" inode_rename ") (struct inode *old_dir, struct dentry *old_dentry,struct inode *new_dir, struct dentry *new_dentry)"
;

.br
.BI "    int (*" inode_readlink ") (struct dentry *dentry)"
;

.br
.BI "    int (*" inode_follow_link ") (struct dentry *dentry, struct nameidata *nd)"
;

.br
.BI "    int (*" inode_permission ") (struct inode *inode, int mask, struct nameidata *nd)"
;

.br
.BI "    int (*" inode_setattr ") (struct dentry *dentry, struct iattr *attr)"
;

.br
.BI "    int (*" inode_getattr ") (struct vfsmount *mnt, struct dentry *dentry)"
;

.br
.BI "    void (*" inode_delete ") (struct inode *inode)"
;

.br
.BI "    int (*" inode_setxattr ") (struct dentry *dentry, char *name, void *value,size_t size, int flags)"
;

.br
.BI "    void (*" inode_post_setxattr ") (struct dentry *dentry, char *name, void *value,size_t size, int flags)"
;

.br
.BI "    int (*" inode_getxattr ") (struct dentry *dentry, char *name)"
;

.br
.BI "    int (*" inode_listxattr ") (struct dentry *dentry)"
;

.br
.BI "    int (*" inode_removexattr ") (struct dentry *dentry, char *name)"
;

.br
.BI "    int (*" inode_getsecurity ") (struct inode *inode, const char *name, void *buffer, size_t size)"
;

.br
.BI "    int (*" inode_setsecurity ") (struct inode *inode, const char *name, const void *value, size_t size, int flags)"
;

.br
.BI "    int (*" inode_listsecurity ") (struct inode *inode, char *buffer, size_t buffer_size)"
;

.br
.BI "    int (*" file_permission ") (struct file * file, int mask)"
;

.br
.BI "    int (*" file_alloc_security ") (struct file * file)"
;

.br
.BI "    void (*" file_free_security ") (struct file * file)"
;

.br
.BI "    int (*" file_ioctl ") (struct file * file, unsigned int cmd,unsigned long arg)"
;

.br
.BI "    int (*" file_mmap ") (struct file * file,unsigned long reqprot,unsigned long prot, unsigned long flags)"
;

.br
.BI "    int (*" file_mprotect ") (struct vm_area_struct * vma,unsigned long reqprot,unsigned long prot)"
;

.br
.BI "    int (*" file_lock ") (struct file * file, unsigned int cmd)"
;

.br
.BI "    int (*" file_fcntl ") (struct file * file, unsigned int cmd,unsigned long arg)"
;

.br
.BI "    int (*" file_set_fowner ") (struct file * file)"
;

.br
.BI "    int (*" file_send_sigiotask ") (struct task_struct * tsk,struct fown_struct * fown, int sig)"
;

.br
.BI "    int (*" file_receive ") (struct file * file)"
;

.br
.BI "    int (*" task_create ") (unsigned long clone_flags)"
;

.br
.BI "    int (*" task_alloc_security ") (struct task_struct * p)"
;

.br
.BI "    void (*" task_free_security ") (struct task_struct * p)"
;

.br
.BI "    int (*" task_setuid ") (uid_t id0, uid_t id1, uid_t id2, int flags)"
;

.br
.BI "    int (*" task_post_setuid ") (uid_t old_ruid  ,uid_t old_euid, uid_t old_suid, int flags)"
;

.br
.BI "    int (*" task_setgid ") (gid_t id0, gid_t id1, gid_t id2, int flags)"
;

.br
.BI "    int (*" task_setpgid ") (struct task_struct * p, pid_t pgid)"
;

.br
.BI "    int (*" task_getpgid ") (struct task_struct * p)"
;

.br
.BI "    int (*" task_getsid ") (struct task_struct * p)"
;

.br
.BI "    int (*" task_setgroups ") (struct group_info *group_info)"
;

.br
.BI "    int (*" task_setnice ") (struct task_struct * p, int nice)"
;

.br
.BI "    int (*" task_setrlimit ") (unsigned int resource, struct rlimit * new_rlim)"
;

.br
.BI "    int (*" task_setscheduler ") (struct task_struct * p, int policy,struct sched_param * lp)"
;

.br
.BI "    int (*" task_getscheduler ") (struct task_struct * p)"
;

.br
.BI "    int (*" task_kill ") (struct task_struct * p,struct siginfo * info, int sig)"
;

.br
.BI "    int (*" task_wait ") (struct task_struct * p)"
;

.br
.BI "    int (*" task_prctl ") (int option, unsigned long arg2,unsigned long arg3, unsigned long arg4,unsigned long arg5)"
;

.br
.BI "    void (*" task_reparent_to_init ") (struct task_struct * p)"
;

.br
.BI "    void (*" task_to_inode ") (struct task_struct *p, struct inode *inode)"
;

.br
.BI "    int (*" ipc_permission ") (struct kern_ipc_perm * ipcp, short flag)"
;

.br
.BI "    int (*" msg_msg_alloc_security ") (struct msg_msg * msg)"
;

.br
.BI "    void (*" msg_msg_free_security ") (struct msg_msg * msg)"
;

.br
.BI "    int (*" msg_queue_alloc_security ") (struct msg_queue * msq)"
;

.br
.BI "    void (*" msg_queue_free_security ") (struct msg_queue * msq)"
;

.br
.BI "    int (*" msg_queue_associate ") (struct msg_queue * msq, int msqflg)"
;

.br
.BI "    int (*" msg_queue_msgctl ") (struct msg_queue * msq, int cmd)"
;

.br
.BI "    int (*" msg_queue_msgsnd ") (struct msg_queue * msq,struct msg_msg * msg, int msqflg)"
;

.br
.BI "    int (*" msg_queue_msgrcv ") (struct msg_queue * msq,struct msg_msg * msg,struct task_struct * target,long type, int mode)"
;

.br
.BI "    int (*" shm_alloc_security ") (struct shmid_kernel * shp)"
;

.br
.BI "    void (*" shm_free_security ") (struct shmid_kernel * shp)"
;

.br
.BI "    int (*" shm_associate ") (struct shmid_kernel * shp, int shmflg)"
;

.br
.BI "    int (*" shm_shmctl ") (struct shmid_kernel * shp, int cmd)"
;

.br
.BI "    int (*" shm_shmat ") (struct shmid_kernel * shp,char __user *shmaddr, int shmflg)"
;

.br
.BI "    int (*" sem_alloc_security ") (struct sem_array * sma)"
;

.br
.BI "    void (*" sem_free_security ") (struct sem_array * sma)"
;

.br
.BI "    int (*" sem_associate ") (struct sem_array * sma, int semflg)"
;

.br
.BI "    int (*" sem_semctl ") (struct sem_array * sma, int cmd)"
;

.br
.BI "    int (*" netlink_send ") (struct sock * sk, struct sk_buff * skb)"
;

.br
.BI "    int (*" netlink_recv ") (struct sk_buff * skb)"
;

.br
.BI "    int (*" register_security ") (const char *name,struct security_operations *ops)"
;

.br
.BI "    int (*" unregister_security ") (const char *name,struct security_operations *ops)"
;

.br
.BI "#ifdef CONFIG_SECURITY_NETWORK"
.br
.BI "    int (*" unix_stream_connect ") (struct socket * sock,struct socket * other, struct sock * newsk)"
;

.br
.BI "    int (*" unix_may_send ") (struct socket * sock, struct socket * other)"
;

.br
.BI "    int (*" socket_create ") (int family, int type, int protocol, int kern)"
;

.br
.BI "    void (*" socket_post_create ") (struct socket * sock, int family,int type, int protocol, int kern)"
;

.br
.BI "    int (*" socket_bind ") (struct socket * sock,struct sockaddr * address, int addrlen)"
;

.br
.BI "    int (*" socket_connect ") (struct socket * sock,struct sockaddr * address, int addrlen)"
;

.br
.BI "    int (*" socket_listen ") (struct socket * sock, int backlog)"
;

.br
.BI "    int (*" socket_accept ") (struct socket * sock, struct socket * newsock)"
;

.br
.BI "    void (*" socket_post_accept ") (struct socket * sock,struct socket * newsock)"
;

.br
.BI "    int (*" socket_sendmsg ") (struct socket * sock,struct msghdr * msg, int size)"
;

.br
.BI "    int (*" socket_recvmsg ") (struct socket * sock,struct msghdr * msg, int size, int flags)"
;

.br
.BI "    int (*" socket_getsockname ") (struct socket * sock)"
;

.br
.BI "    int (*" socket_getpeername ") (struct socket * sock)"
;

.br
.BI "    int (*" socket_getsockopt ") (struct socket * sock, int level, int optname)"
;

.br
.BI "    int (*" socket_setsockopt ") (struct socket * sock, int level, int optname)"
;

.br
.BI "    int (*" socket_shutdown ") (struct socket * sock, int how)"
;

.br
.BI "    int (*" socket_sock_rcv_skb ") (struct sock * sk, struct sk_buff * skb)"
;

.br
.BI "    int (*" socket_getpeersec ") (struct socket *sock, char __user *optval, int __user *optlen, unsigned len)"
;

.br
.BI "    int (*" sk_alloc_security ") (struct sock *sk, int family, int priority)"
;

.br
.BI "    void (*" sk_free_security ") (struct sock *sk)"
;

.br
.BI "#endif"
.br
};
.br
.SH Arguments
.IP "ptrace" 12
Check permission before allowing the \fIparent\fP process to trace the
\fIchild\fP process.
Security modules may also want to perform a process tracing check
during an execve in the set_security or apply_creds hooks of
binprm_security_ops if the process is being traced and its security
attributes would be changed by the execve.
\fIparent\fP contains the task_struct structure for parent process.
\fIchild\fP contains the task_struct structure for child process.
Return 0 if permission is granted.
.IP "capget" 12
Get the \fIeffective\fP, \fIinheritable\fP, and \fIpermitted\fP capability sets for
the \fItarget\fP process.  The hook may also perform permission checking to
determine if the current process is allowed to see the capability sets
of the \fItarget\fP process.
\fItarget\fP contains the task_struct structure for target process.
\fIeffective\fP contains the effective capability set.
\fIinheritable\fP contains the inheritable capability set.
\fIpermitted\fP contains the permitted capability set.
Return 0 if the capability sets were successfully obtained.
.IP "capset_check" 12
Check permission before setting the \fIeffective\fP, \fIinheritable\fP, and
\fIpermitted\fP capability sets for the \fItarget\fP process.
.IP "capset_set" 12
Set the \fIeffective\fP, \fIinheritable\fP, and \fIpermitted\fP capability sets for
the \fItarget\fP process.  Since capset_check cannot always check permission
to the real \fItarget\fP process, this hook may also perform permission
checking to determine if the current process is allowed to set the
capability sets of the \fItarget\fP process.  However, this hook has no way
of returning an error due to the structure of the sys_capset code.
\fItarget\fP contains the task_struct structure for target process.
\fIeffective\fP contains the effective capability set.
\fIinheritable\fP contains the inheritable capability set.
\fIpermitted\fP contains the permitted capability set.
.IP "acct" 12
Check permission before enabling or disabling process accounting.  If
accounting is being enabled, then \fIfile\fP refers to the open file used to
store accounting records.  If accounting is being disabled, then \fIfile\fP
is NULL.
\fIfile\fP contains the file structure for the accounting file (may be NULL).
Return 0 if permission is granted.
.IP "sysctl" 12
Check permission before accessing the \fItable\fP sysctl variable in the
manner specified by \fIop\fP.
\fItable\fP contains the ctl_table structure for the sysctl variable.
\fIop\fP contains the operation (001 = search, 002 = write, 004 = read).
Return 0 if permission is granted.
.IP "capable" 12
Check whether the \fItsk\fP process has the \fIcap\fP capability.
\fItsk\fP contains the task_struct for the process.
\fIcap\fP contains the capability &lt;include/linux/capability.h&gt;.
Return 0 if the capability is granted for \fItsk\fP.
.IP "syslog" 12
Check permission before accessing the kernel message ring or changing
logging to the console.
See the syslog(2) manual page for an explanation of the \fItype\fP values.  
\fItype\fP contains the type of action.
Return 0 if permission is granted.
.IP "settime" 12
Check permission to change the system time.
struct timespec and timezone are defined in include/linux/time.h
\fIts\fP contains new time
\fItz\fP contains new timezone
Return 0 if permission is granted.
.IP "vm_enough_memory" 12
Check permissions for allocating a new virtual mapping.
\fIpages\fP contains the number of pages.
Return 0 if permission is granted.
.IP "bprm_alloc_security" 12
Allocate and attach a security structure to the \fIbprm\fP-&gt;security field.
The security field is initialized to NULL when the bprm structure is
allocated.
\fIbprm\fP contains the linux_binprm structure to be modified.
Return 0 if operation was successful.
.IP "bprm_free_security" 12
\fIbprm\fP contains the linux_binprm structure to be modified.
Deallocate and clear the \fIbprm\fP-&gt;security field.
.IP "bprm_apply_creds" 12
Compute and set the security attributes of a process being transformed
by an execve operation based on the old attributes (current-&gt;security)
and the information saved in \fIbprm\fP-&gt;security by the set_security hook.
Since this hook function (and its caller) are void, this hook can not
return an error.  However, it can leave the security attributes of the
process unchanged if an access failure occurs at this point.
bprm_apply_creds is called under task_lock.  \fIunsafe\fP indicates various
reasons why it may be unsafe to change security state.
\fIbprm\fP contains the linux_binprm structure.
.IP "bprm_post_apply_creds" 12
Runs after bprm_apply_creds with the task_lock dropped, so that
functions which cannot be called safely under the task_lock can
be used.  This hook is a good place to perform state changes on
the process such as closing open file descriptors to which access
is no longer granted if the attributes were changed.
Note that a security module might need to save state between
bprm_apply_creds and bprm_post_apply_creds to store the decision
on whether the process may proceed.
\fIbprm\fP contains the linux_binprm structure.
.IP "bprm_set_security" 12
Save security information in the bprm-&gt;security field, typically based
on information about the bprm-&gt;file, for later use by the apply_creds
hook.  This hook may also optionally check permissions (e.g. for
transitions between security domains).
This hook may be called multiple times during a single execve, e.g. for
interpreters.  The hook can tell whether it has already been called by
checking to see if \fIbprm\fP-&gt;security is non-NULL.  If so, then the hook
may decide either to retain the security information saved earlier or
to replace it.
\fIbprm\fP contains the linux_binprm structure.
Return 0 if the hook is successful and permission is granted.
.IP "bprm_check_security" 12
This hook mediates the point when a search for a binary handler	will
begin.  It allows a check the \fIbprm\fP-&gt;security value which is set in
the preceding set_security call.  The primary difference from
set_security is that the argv list and envp list are reliably
available in \fIbprm\fP.  This hook may be called multiple times
during a single execve; and in each pass set_security is called
first.
\fIbprm\fP contains the linux_binprm structure.
Return 0 if the hook is successful and permission is granted.
.IP "bprm_secureexec" 12
Return a boolean value (0 or 1) indicating whether a "secure exec" 
is required.  The flag is passed in the auxiliary table
on the initial stack to the ELF interpreter to indicate whether libc 
should enable secure mode.
\fIbprm\fP contains the linux_binprm structure.
.IP "sb_alloc_security" 12
Allocate and attach a security structure to the sb-&gt;s_security field.
The s_security field is initialized to NULL when the structure is
allocated.
\fIsb\fP contains the super_block structure to be modified.
Return 0 if operation was successful.
.IP "sb_free_security" 12
Deallocate and clear the sb-&gt;s_security field.
\fIsb\fP contains the super_block structure to be modified.
.IP "sb_copy_data" 12
Allow mount option data to be copied prior to parsing by the filesystem,
so that the security module can extract security-specific mount
options cleanly (a filesystem may modify the data e.g. with \fBstrsep\fP).
This also allows the original mount data to be stripped of security-
specific options to avoid having to make filesystems aware of them.
\fItype\fP the type of filesystem being mounted.
\fIorig\fP the original mount data copied from userspace.
\fIcopy\fP copied data which will be passed to the security module.
Returns 0 if the copy was successful.
.IP "sb_statfs" 12
Check permission before obtaining filesystem statistics for the \fIsb\fP
filesystem.
\fIsb\fP contains the super_block structure for the filesystem.
Return 0 if permission is granted.  
.IP "sb_mount" 12
Check permission before an object specified by \fIdev_name\fP is mounted on
the mount point named by \fInd\fP.  For an ordinary mount, \fIdev_name\fP
identifies a device if the file system type requires a device.  For a
remount (\fIflags\fP &amp; MS_REMOUNT), \fIdev_name\fP is irrelevant.  For a
loopback/bind mount (\fIflags\fP &amp; MS_BIND), \fIdev_name\fP identifies the
pathname of the object being mounted.
\fIdev_name\fP contains the name for object being mounted.
\fInd\fP contains the nameidata structure for mount point object.
\fItype\fP contains the filesystem type.
\fIflags\fP contains the mount flags.
\fIdata\fP contains the filesystem-specific data.
Return 0 if permission is granted.
.IP "sb_check_sb" 12
Check permission before the device with superblock \fImnt\fP-&gt;sb is mounted
on the mount point named by \fInd\fP.
\fImnt\fP contains the vfsmount for device being mounted.
\fInd\fP contains the nameidata object for the mount point.
Return 0 if permission is granted.
.IP "sb_umount" 12
Check permission before the \fImnt\fP file system is unmounted.
\fImnt\fP contains the mounted file system.
\fIflags\fP contains the unmount flags, e.g. MNT_FORCE.
Return 0 if permission is granted.
.IP "sb_umount_close" 12
Close any files in the \fImnt\fP mounted filesystem that are held open by
the security module.  This hook is called during an umount operation
prior to checking whether the filesystem is still busy.
\fImnt\fP contains the mounted filesystem.
.IP "sb_umount_busy" 12
Handle a failed umount of the \fImnt\fP mounted filesystem, e.g.  re-opening
any files that were closed by umount_close.  This hook is called during
an umount operation if the umount fails after a call to the
umount_close hook.
\fImnt\fP contains the mounted filesystem.
.IP "sb_post_remount" 12
Update the security module's state when a filesystem is remounted.
This hook is only called if the remount was successful.
\fImnt\fP contains the mounted file system.
\fIflags\fP contains the new filesystem flags.
\fIdata\fP contains the filesystem-specific data.
.IP "sb_post_mountroot" 12
Update the security module's state when the root filesystem is mounted.
This hook is only called if the mount was successful.
.IP "sb_post_addmount" 12
Update the security module's state when a filesystem is mounted.
This hook is called any time a mount is successfully grafetd to
the tree.
\fImnt\fP contains the mounted filesystem.
\fImountpoint_nd\fP contains the nameidata structure for the mount point.
.IP "sb_pivotroot" 12
Check permission before pivoting the root filesystem.
\fIold_nd\fP contains the nameidata structure for the new location of the current root (put_old).
\fInew_nd\fP contains the nameidata structure for the new root (new_root).
Return 0 if permission is granted.
.IP "sb_post_pivotroot" 12
Update module state after a successful pivot.
\fIold_nd\fP contains the nameidata structure for the old root.
\fInew_nd\fP contains the nameidata structure for the new root.
.IP "inode_alloc_security" 12
Allocate and attach a security structure to \fIinode\fP-&gt;i_security.  The
i_security field is initialized to NULL when the inode structure is
allocated.
\fIinode\fP contains the inode structure.
Return 0 if operation was successful.
.IP "inode_free_security" 12
\fIinode\fP contains the inode structure.
Deallocate the inode security structure and set \fIinode\fP-&gt;i_security to
NULL. 
.IP "inode_init_security" 12
Obtain the security attribute name suffix and value to set on a newly
created inode and set up the incore security field for the new inode.
This hook is called by the fs code as part of the inode creation
transaction and provides for atomic labeling of the inode, unlike
the post_create/mkdir/... hooks called by the VFS.  The hook function
is expected to allocate the name and value via kmalloc, with the caller
being responsible for calling kfree after using them.
If the security module does not use security attributes or does
not wish to put a security attribute on this particular inode,
then it should return -EOPNOTSUPP to skip this processing.
\fIinode\fP contains the inode structure of the newly created inode.
\fIdir\fP contains the inode structure of the parent directory.
\fIname\fP will be set to the allocated name suffix (e.g. selinux).
\fIvalue\fP will be set to the allocated attribute value.
\fIlen\fP will be set to the length of the value.
Returns 0 if \fIname\fP and \fIvalue\fP have been successfully set,
-EOPNOTSUPP if no security attribute is needed, or
-ENOMEM on memory allocation failure.
.IP "inode_create" 12
Check permission to create a regular file.
\fIdir\fP contains inode structure of the parent of the new file.
\fIdentry\fP contains the dentry structure for the file to be created.
\fImode\fP contains the file mode of the file to be created.
Return 0 if permission is granted.
.IP "inode_link" 12
Check permission before creating a new hard link to a file.
\fIold_dentry\fP contains the dentry structure for an existing link to the file.
\fIdir\fP contains the inode structure of the parent directory of the new link.
\fInew_dentry\fP contains the dentry structure for the new link.
Return 0 if permission is granted.
.IP "inode_unlink" 12
Check the permission to remove a hard link to a file. 
\fIdir\fP contains the inode structure of parent directory of the file.
\fIdentry\fP contains the dentry structure for file to be unlinked.
Return 0 if permission is granted.
.IP "inode_symlink" 12
Check the permission to create a symbolic link to a file.
\fIdir\fP contains the inode structure of parent directory of the symbolic link.
\fIdentry\fP contains the dentry structure of the symbolic link.
\fIold_name\fP contains the pathname of file.
Return 0 if permission is granted.
.IP "inode_mkdir" 12
Check permissions to create a new directory in the existing directory
associated with inode strcture \fIdir\fP. 
\fIdir\fP containst the inode structure of parent of the directory to be created.
\fIdentry\fP contains the dentry structure of new directory.
\fImode\fP contains the mode of new directory.
Return 0 if permission is granted.
.IP "inode_rmdir" 12
Check the permission to remove a directory.
\fIdir\fP contains the inode structure of parent of the directory to be removed.
\fIdentry\fP contains the dentry structure of directory to be removed.
Return 0 if permission is granted.
.IP "inode_mknod" 12
Check permissions when creating a special file (or a socket or a fifo
file created via the mknod system call).  Note that if mknod operation
is being done for a regular file, then the create hook will be called
and not this hook.
\fIdir\fP contains the inode structure of parent of the new file.
\fIdentry\fP contains the dentry structure of the new file.
\fImode\fP contains the mode of the new file.
\fIdev\fP contains the the device number.
Return 0 if permission is granted.
.IP "inode_rename" 12
Check for permission to rename a file or directory.
\fIold_dir\fP contains the inode structure for parent of the old link.
\fIold_dentry\fP contains the dentry structure of the old link.
\fInew_dir\fP contains the inode structure for parent of the new link.
\fInew_dentry\fP contains the dentry structure of the new link.
Return 0 if permission is granted.
.IP "inode_readlink" 12
Check the permission to read the symbolic link.
\fIdentry\fP contains the dentry structure for the file link.
Return 0 if permission is granted.
.IP "inode_follow_link" 12
Check permission to follow a symbolic link when looking up a pathname.
\fIdentry\fP contains the dentry structure for the link.
\fInd\fP contains the nameidata structure for the parent directory.
Return 0 if permission is granted.
.IP "inode_permission" 12
Check permission before accessing an inode.  This hook is called by the
existing Linux permission function, so a security module can use it to
provide additional checking for existing Linux permission checks.
Notice that this hook is called when a file is opened (as well as many
other operations), whereas the file_security_ops permission hook is
called when the actual read/write operations are performed.
\fIinode\fP contains the inode structure to check.
\fImask\fP contains the permission mask.
\fInd\fP contains the nameidata (may be NULL).
Return 0 if permission is granted.
.IP "inode_setattr" 12
Check permission before setting file attributes.  Note that the kernel
call to notify_change is performed from several locations, whenever
file attributes change (such as when a file is truncated, chown/chmod
operations, transferring disk quotas, etc).
\fIdentry\fP contains the dentry structure for the file.
\fIattr\fP is the iattr structure containing the new file attributes.
Return 0 if permission is granted.
.IP "inode_getattr" 12
Check permission before obtaining file attributes.
\fImnt\fP is the vfsmount where the dentry was looked up
\fIdentry\fP contains the dentry structure for the file.
Return 0 if permission is granted.
.IP "inode_delete" 12
\fIinode\fP contains the inode structure for deleted inode.
This hook is called when a deleted inode is released (i.e. an inode
with no hard links has its use count drop to zero).  A security module
can use this hook to release any persistent label associated with the
inode.
.IP "inode_setxattr" 12
Check permission before setting the extended attributes
\fIvalue\fP identified by \fIname\fP for \fIdentry\fP.
Return 0 if permission is granted.
.IP "inode_post_setxattr" 12
Update inode security field after successful setxattr operation.
\fIvalue\fP identified by \fIname\fP for \fIdentry\fP.
.IP "inode_getxattr" 12
Check permission before obtaining the extended attributes
identified by \fIname\fP for \fIdentry\fP.
Return 0 if permission is granted.
.IP "inode_listxattr" 12
Check permission before obtaining the list of extended attribute 
names for \fIdentry\fP.
Return 0 if permission is granted.
.IP "inode_removexattr" 12
Check permission before removing the extended attribute
identified by \fIname\fP for \fIdentry\fP.
Return 0 if permission is granted.
.IP "inode_getsecurity" 12
Copy the extended attribute representation of the security label 
associated with \fIname\fP for \fIinode\fP into \fIbuffer\fP.  \fIbuffer\fP may be
NULL to request the size of the buffer required.  \fIsize\fP indicates
the size of \fIbuffer\fP in bytes.  Note that \fIname\fP is the remainder
of the attribute name after the security. prefix has been removed.
Return number of bytes used/required on success.
.IP "inode_setsecurity" 12
Set the security label associated with \fIname\fP for \fIinode\fP from the
extended attribute value \fIvalue\fP.  \fIsize\fP indicates the size of the
\fIvalue\fP in bytes.  \fIflags\fP may be XATTR_CREATE, XATTR_REPLACE, or 0.
Note that \fIname\fP is the remainder of the attribute name after the 
security. prefix has been removed.
Return 0 on success.
.IP "inode_listsecurity" 12
Copy the extended attribute names for the security labels
associated with \fIinode\fP into \fIbuffer\fP.  The maximum size of \fIbuffer\fP
is specified by \fIbuffer_size\fP.  \fIbuffer\fP may be NULL to request
the size of the buffer required.
Returns number of bytes used/required on success.
.IP "file_permission" 12
Check file permissions before accessing an open file.  This hook is
called by various operations that read or write files.  A security
module can use this hook to perform additional checking on these
operations, e.g.  to revalidate permissions on use to support privilege
bracketing or policy changes.  Notice that this hook is used when the
actual read/write operations are performed, whereas the
inode_security_ops hook is called when a file is opened (as well as
many other operations).
.IP "file_alloc_security" 12
Allocate and attach a security structure to the file-&gt;f_security field.
The security field is initialized to NULL when the structure is first
created.
\fIfile\fP contains the file structure to secure.
Return 0 if the hook is successful and permission is granted.
.IP "file_free_security" 12
Deallocate and free any security structures stored in file-&gt;f_security.
\fIfile\fP contains the file structure being modified.
.IP "file_ioctl" 12
\fIfile\fP contains the file structure.
\fIcmd\fP contains the operation to perform.
\fIarg\fP contains the operational arguments.
Check permission for an ioctl operation on \fIfile\fP.  Note that \fIarg\fP can
sometimes represents a user space pointer; in other cases, it may be a
simple integer value.  When \fIarg\fP represents a user space pointer, it
should never be used by the security module.
Return 0 if permission is granted.
.IP "file_mmap" 12
Check permissions for a mmap operation.  The \fIfile\fP may be NULL, e.g.
if mapping anonymous memory.
\fIfile\fP contains the file structure for file to map (may be NULL).
\fIreqprot\fP contains the protection requested by the application.
\fIprot\fP contains the protection that will be applied by the kernel.
\fIflags\fP contains the operational flags.
Return 0 if permission is granted.
.IP "file_mprotect" 12
Check permissions before changing memory access permissions.
\fIvma\fP contains the memory region to modify.
\fIreqprot\fP contains the protection requested by the application.
\fIprot\fP contains the protection that will be applied by the kernel.
Return 0 if permission is granted.
.IP "file_lock" 12
Check permission before performing file locking operations.
.IP "file_fcntl" 12
Check permission before allowing the file operation specified by \fIcmd\fP
from being performed on the file \fIfile\fP.  Note that \fIarg\fP can sometimes
represents a user space pointer; in other cases, it may be a simple
integer value.  When \fIarg\fP represents a user space pointer, it should
never be used by the security module.
\fIfile\fP contains the file structure.
\fIcmd\fP contains the operation to be performed.
\fIarg\fP contains the operational arguments.
Return 0 if permission is granted.
.IP "file_set_fowner" 12
Save owner security information (typically from current-&gt;security) in
file-&gt;f_security for later use by the send_sigiotask hook.
\fIfile\fP contains the file structure to update.
Return 0 on success.
.IP "file_send_sigiotask" 12
Check permission for the file owner \fIfown\fP to send SIGIO or SIGURG to the
process \fItsk\fP.  Note that this hook is sometimes called from interrupt.
Note that the fown_struct, \fIfown\fP, is never outside the context of a
struct file, so the file structure (and associated security information)
.IP "file_receive" 12
This hook allows security modules to control the ability of a process
to receive an open file descriptor via socket IPC.
\fIfile\fP contains the file structure being received.
Return 0 if permission is granted.
.IP "task_create" 12
Check permission before creating a child process.  See the clone(2)
manual page for definitions of the \fIclone_flags\fP.
\fIclone_flags\fP contains the flags indicating what should be shared.
Return 0 if permission is granted.
.IP "task_alloc_security" 12
\fIp\fP contains the task_struct for child process.
Allocate and attach a security structure to the p-&gt;security field. The
security field is initialized to NULL when the task structure is
allocated.
Return 0 if operation was successful.
.IP "task_free_security" 12
\fIp\fP contains the task_struct for process.
Deallocate and clear the p-&gt;security field.
.IP "task_setuid" 12
Check permission before setting one or more of the user identity
attributes of the current process.  The \fIflags\fP parameter indicates
which of the set*uid system calls invoked this hook and how to
interpret the \fIid0\fP, \fIid1\fP, and \fIid2\fP parameters.  See the LSM_SETID
definitions at the beginning of this file for the \fIflags\fP values and
their meanings.
\fIid0\fP contains a uid.
\fIid1\fP contains a uid.
\fIid2\fP contains a uid.
\fIflags\fP contains one of the LSM_SETID_* values.
Return 0 if permission is granted.
.IP "task_post_setuid" 12
Update the module's state after setting one or more of the user
identity attributes of the current process.  The \fIflags\fP parameter
indicates which of the set*uid system calls invoked this hook.  If
\fIflags\fP is LSM_SETID_FS, then \fIold_ruid\fP is the old fs uid and the other
parameters are not used.
\fIold_ruid\fP contains the old real uid (or fs uid if LSM_SETID_FS).
\fIold_euid\fP contains the old effective uid (or -1 if LSM_SETID_FS).
\fIold_suid\fP contains the old saved uid (or -1 if LSM_SETID_FS).
\fIflags\fP contains one of the LSM_SETID_* values.
Return 0 on success.
.IP "task_setgid" 12
Check permission before setting one or more of the group identity
attributes of the current process.  The \fIflags\fP parameter indicates
which of the set*gid system calls invoked this hook and how to
interpret the \fIid0\fP, \fIid1\fP, and \fIid2\fP parameters.  See the LSM_SETID
definitions at the beginning of this file for the \fIflags\fP values and
their meanings.
\fIid0\fP contains a gid.
\fIid1\fP contains a gid.
\fIid2\fP contains a gid.
\fIflags\fP contains one of the LSM_SETID_* values.
Return 0 if permission is granted.
.IP "task_setpgid" 12
Check permission before setting the process group identifier of the
process \fIp\fP to \fIpgid\fP.
\fIp\fP contains the task_struct for process being modified.
\fIpgid\fP contains the new pgid.
Return 0 if permission is granted.
.IP "task_getpgid" 12
Check permission before getting the process group identifier of the
process \fIp\fP.
\fIp\fP contains the task_struct for the process.
Return 0 if permission is granted.
.IP "task_getsid" 12
Check permission before getting the session identifier of the process
\fIp\fP.
\fIp\fP contains the task_struct for the process.
Return 0 if permission is granted.
.IP "task_setgroups" 12
Check permission before setting the supplementary group set of the
current process.
\fIgroup_info\fP contains the new group information.
Return 0 if permission is granted.
.IP "task_setnice" 12
Check permission before setting the nice value of \fIp\fP to \fInice\fP.
\fIp\fP contains the task_struct of process.
\fInice\fP contains the new nice value.
Return 0 if permission is granted.
.IP "task_setrlimit" 12
Check permission before setting the resource limits of the current
process for \fIresource\fP to \fInew_rlim\fP.  The old resource limit values can
be examined by dereferencing (current-&gt;signal-&gt;rlim + resource).
\fIresource\fP contains the resource whose limit is being set.
\fInew_rlim\fP contains the new limits for \fIresource\fP.
Return 0 if permission is granted.
.IP "task_setscheduler" 12
Check permission before setting scheduling policy and/or parameters of
process \fIp\fP based on \fIpolicy\fP and \fIlp\fP.
\fIp\fP contains the task_struct for process.
\fIpolicy\fP contains the scheduling policy.
\fIlp\fP contains the scheduling parameters.
Return 0 if permission is granted.
.IP "task_getscheduler" 12
Check permission before obtaining scheduling information for process
\fIp\fP.
\fIp\fP contains the task_struct for process.
Return 0 if permission is granted.
.IP "task_kill" 12
Check permission before sending signal \fIsig\fP to \fIp\fP.  \fIinfo\fP can be NULL,
the constant 1, or a pointer to a siginfo structure.  If \fIinfo\fP is 1 or
SI_FROMKERNEL(info) is true, then the signal should be viewed as coming
from the kernel and should typically be permitted.
SIGIO signals are handled separately by the send_sigiotask hook in
file_security_ops.
\fIp\fP contains the task_struct for process.
\fIinfo\fP contains the signal information.
\fIsig\fP contains the signal value.
Return 0 if permission is granted.
.IP "task_wait" 12
Check permission before allowing a process to reap a child process \fIp\fP
and collect its status information.
\fIp\fP contains the task_struct for process.
Return 0 if permission is granted.
.IP "task_prctl" 12
Check permission before performing a process control operation on the
current process.
\fIoption\fP contains the operation.
\fIarg2\fP contains a argument.
\fIarg3\fP contains a argument.
\fIarg4\fP contains a argument.
\fIarg5\fP contains a argument.
Return 0 if permission is granted.
.IP "task_reparent_to_init" 12
Set the security attributes in \fIp\fP-&gt;security for a kernel thread that
is being reparented to the init task.
\fIp\fP contains the task_struct for the kernel thread.
.IP "task_to_inode" 12
Set the security attributes for an inode based on an associated task's
security attributes, e.g. for /proc/pid inodes.
\fIp\fP contains the task_struct for the task.
\fIinode\fP contains the inode structure for the inode.
.IP "ipc_permission" 12
Check permissions for access to IPC
\fIipcp\fP contains the kernel IPC permission structure
\fIflag\fP contains the desired (requested) permission set
Return 0 if permission is granted.
.IP "msg_msg_alloc_security" 12
Allocate and attach a security structure to the msg-&gt;security field.
The security field is initialized to NULL when the structure is first
created.
\fImsg\fP contains the message structure to be modified.
Return 0 if operation was successful and permission is granted.
.IP "msg_msg_free_security" 12
Deallocate the security structure for this message.
\fImsg\fP contains the message structure to be modified.
.IP "msg_queue_alloc_security" 12
Allocate and attach a security structure to the
msq-&gt;q_perm.security field. The security field is initialized to
NULL when the structure is first created.
\fImsq\fP contains the message queue structure to be modified.
Return 0 if operation was successful and permission is granted.
.IP "msg_queue_free_security" 12
Deallocate security structure for this message queue.
\fImsq\fP contains the message queue structure to be modified.
.IP "msg_queue_associate" 12
Check permission when a message queue is requested through the
msgget system call.  This hook is only called when returning the
message queue identifier for an existing message queue, not when a
new message queue is created.
\fImsq\fP contains the message queue to act upon.
\fImsqflg\fP contains the operation control flags.
Return 0 if permission is granted.
.IP "msg_queue_msgctl" 12
Check permission when a message control operation specified by \fIcmd\fP
is to be performed on the message queue \fImsq\fP.
The \fImsq\fP may be NULL, e.g. for IPC_INFO or MSG_INFO.
\fImsq\fP contains the message queue to act upon.  May be NULL.
\fIcmd\fP contains the operation to be performed.
Return 0 if permission is granted.  
.IP "msg_queue_msgsnd" 12
Check permission before a message, \fImsg\fP, is enqueued on the message
queue, \fImsq\fP.
\fImsq\fP contains the message queue to send message to.
\fImsg\fP contains the message to be enqueued.
\fImsqflg\fP contains operational flags.
Return 0 if permission is granted.
.IP "msg_queue_msgrcv" 12
Check permission before a message, \fImsg\fP, is removed from the message
queue, \fImsq\fP.  The \fItarget\fP task structure contains a pointer to the 
process that will be receiving the message (not equal to the current 
process when inline receives are being performed).
\fImsq\fP contains the message queue to retrieve message from.
\fImsg\fP contains the message destination.
\fItarget\fP contains the task structure for recipient process.
\fItype\fP contains the type of message requested.
\fImode\fP contains the operational flags.
Return 0 if permission is granted.
.IP "shm_alloc_security" 12
Allocate and attach a security structure to the shp-&gt;shm_perm.security
field.  The security field is initialized to NULL when the structure is
first created.
\fIshp\fP contains the shared memory structure to be modified.
Return 0 if operation was successful and permission is granted.
.IP "shm_free_security" 12
Deallocate the security struct for this memory segment.
\fIshp\fP contains the shared memory structure to be modified.
.IP "shm_associate" 12
Check permission when a shared memory region is requested through the
shmget system call.  This hook is only called when returning the shared
memory region identifier for an existing region, not when a new shared
memory region is created.
\fIshp\fP contains the shared memory structure to be modified.
\fIshmflg\fP contains the operation control flags.
Return 0 if permission is granted.
.IP "shm_shmctl" 12
Check permission when a shared memory control operation specified by
\fIcmd\fP is to be performed on the shared memory region \fIshp\fP.
The \fIshp\fP may be NULL, e.g. for IPC_INFO or SHM_INFO.
\fIshp\fP contains shared memory structure to be modified.
\fIcmd\fP contains the operation to be performed.
Return 0 if permission is granted.
.IP "shm_shmat" 12
Check permissions prior to allowing the shmat system call to attach the
shared memory segment \fIshp\fP to the data segment of the calling process.
The attaching address is specified by \fIshmaddr\fP.
\fIshp\fP contains the shared memory structure to be modified.
\fIshmaddr\fP contains the address to attach memory region to.
\fIshmflg\fP contains the operational flags.
Return 0 if permission is granted.
.IP "sem_alloc_security" 12
Allocate and attach a security structure to the sma-&gt;sem_perm.security
field.  The security field is initialized to NULL when the structure is
first created.
\fIsma\fP contains the semaphore structure
Return 0 if operation was successful and permission is granted.
.IP "sem_free_security" 12
deallocate security struct for this semaphore
\fIsma\fP contains the semaphore structure.
.IP "sem_associate" 12
Check permission when a semaphore is requested through the semget
system call.  This hook is only called when returning the semaphore
identifier for an existing semaphore, not when a new one must be
created.
\fIsma\fP contains the semaphore structure.
\fIsemflg\fP contains the operation control flags.
Return 0 if permission is granted.
.IP "sem_semctl" 12
Check permission when a semaphore operation specified by \fIcmd\fP is to be
performed on the semaphore \fIsma\fP.  The \fIsma\fP may be NULL, e.g. for 
IPC_INFO or SEM_INFO.
\fIsma\fP contains the semaphore structure.  May be NULL.
\fIcmd\fP contains the operation to be performed.
Return 0 if permission is granted.
\fIsem_semop\fP
Check permissions before performing operations on members of the
semaphore set \fIsma\fP.  If the \fIalter\fP flag is nonzero, the semaphore set 
may be modified.
\fIsma\fP contains the semaphore structure.
\fIsops\fP contains the operations to perform.
\fInsops\fP contains the number of operations to perform.
\fIalter\fP contains the flag indicating whether changes are to be made.
Return 0 if permission is granted.
.IP "netlink_send" 12
Save security information for a netlink message so that permission
checking can be performed when the message is processed.  The security
information can be saved using the eff_cap field of the
netlink_skb_parms structure.  Also may be used to provide fine
grained control over message transmission.
\fIsk\fP associated sock of task sending the message.,
\fIskb\fP contains the sk_buff structure for the netlink message.
Return 0 if the information was successfully saved and message
is allowed to be transmitted.
.IP "netlink_recv" 12
Check permission before processing the received netlink message in
\fIskb\fP.
\fIskb\fP contains the sk_buff structure for the netlink message.
Return 0 if permission is granted.
.IP "register_security" 12
allow module stacking.
\fIname\fP contains the name of the security module being stacked.
\fIops\fP contains a pointer to the struct security_operations of the module to stack.
.IP "unregister_security" 12
remove a stacked module.
\fIname\fP contains the name of the security module being unstacked.
\fIops\fP contains a pointer to the struct security_operations of the module to unstack.
.IP "unix_stream_connect" 12
Check permissions before establishing a Unix domain stream connection
between \fIsock\fP and \fIother\fP.
\fIsock\fP contains the socket structure.
\fIother\fP contains the peer socket structure.
Return 0 if permission is granted.
.IP "unix_may_send" 12
Check permissions before connecting or sending datagrams from \fIsock\fP to
\fIother\fP.
\fIsock\fP contains the socket structure.
\fIsock\fP contains the peer socket structure.
Return 0 if permission is granted.
.IP "socket_create" 12
Check permissions prior to creating a new socket.
\fIfamily\fP contains the requested protocol family.
\fItype\fP contains the requested communications type.
\fIprotocol\fP contains the requested protocol.
\fIkern\fP set to 1 if a kernel socket.
Return 0 if permission is granted.
.IP "socket_post_create" 12
This hook allows a module to update or allocate a per-socket security
structure. Note that the security field was not added directly to the
socket structure, but rather, the socket security information is stored
in the associated inode.  Typically, the inode alloc_security hook will
allocate and and attach security information to
sock-&gt;inode-&gt;i_security.  This hook may be used to update the
sock-&gt;inode-&gt;i_security field with additional information that wasn't
available when the inode was allocated.
\fIsock\fP contains the newly created socket structure.
\fIfamily\fP contains the requested protocol family.
\fItype\fP contains the requested communications type.
\fIprotocol\fP contains the requested protocol.
\fIkern\fP set to 1 if a kernel socket.
.IP "socket_bind" 12
Check permission before socket protocol layer bind operation is
performed and the socket \fIsock\fP is bound to the address specified in the
\fIaddress\fP parameter.
\fIsock\fP contains the socket structure.
\fIaddress\fP contains the address to bind to.
\fIaddrlen\fP contains the length of address.
Return 0 if permission is granted.  
.IP "socket_connect" 12
Check permission before socket protocol layer connect operation
attempts to connect socket \fIsock\fP to a remote address, \fIaddress\fP.
\fIsock\fP contains the socket structure.
\fIaddress\fP contains the address of remote endpoint.
\fIaddrlen\fP contains the length of address.
Return 0 if permission is granted.  
.IP "socket_listen" 12
Check permission before socket protocol layer listen operation.
\fIsock\fP contains the socket structure.
\fIbacklog\fP contains the maximum length for the pending connection queue.
Return 0 if permission is granted.
.IP "socket_accept" 12
Check permission before accepting a new connection.  Note that the new
socket, \fInewsock\fP, has been created and some information copied to it,
but the accept operation has not actually been performed.
\fIsock\fP contains the listening socket structure.
\fInewsock\fP contains the newly created server socket for connection.
Return 0 if permission is granted.
.IP "socket_post_accept" 12
This hook allows a security module to copy security
information into the newly created socket's inode.
\fIsock\fP contains the listening socket structure.
\fInewsock\fP contains the newly created server socket for connection.
.IP "socket_sendmsg" 12
Check permission before transmitting a message to another socket.
\fIsock\fP contains the socket structure.
\fImsg\fP contains the message to be transmitted.
\fIsize\fP contains the size of message.
Return 0 if permission is granted.
.IP "socket_recvmsg" 12
Check permission before receiving a message from a socket.
\fIsock\fP contains the socket structure.
\fImsg\fP contains the message structure.
\fIsize\fP contains the size of message structure.
\fIflags\fP contains the operational flags.
Return 0 if permission is granted.  
.IP "socket_getsockname" 12
Check permission before the local address (name) of the socket object
\fIsock\fP is retrieved.
\fIsock\fP contains the socket structure.
Return 0 if permission is granted.
.IP "socket_getpeername" 12
Check permission before the remote address (name) of a socket object
\fIsock\fP is retrieved.
\fIsock\fP contains the socket structure.
Return 0 if permission is granted.
.IP "socket_getsockopt" 12
Check permissions before retrieving the options associated with socket
\fIsock\fP.
\fIsock\fP contains the socket structure.
\fIlevel\fP contains the protocol level to retrieve option from.
\fIoptname\fP contains the name of option to retrieve.
Return 0 if permission is granted.
.IP "socket_setsockopt" 12
Check permissions before setting the options associated with socket
\fIsock\fP.
\fIsock\fP contains the socket structure.
\fIlevel\fP contains the protocol level to set options for.
\fIoptname\fP contains the name of the option to set.
Return 0 if permission is granted.  
.IP "socket_shutdown" 12
Checks permission before all or part of a connection on the socket
\fIsock\fP is shut down.
\fIsock\fP contains the socket structure.
\fIhow\fP contains the flag indicating how future sends and receives are handled.
Return 0 if permission is granted.
.IP "socket_sock_rcv_skb" 12
Check permissions on incoming network packets.  This hook is distinct
from Netfilter's IP input hooks since it is the first time that the
incoming sk_buff \fIskb\fP has been associated with a particular socket, \fIsk\fP.
\fIsk\fP contains the sock (not socket) associated with the incoming sk_buff.
\fIskb\fP contains the incoming network data.
.IP "socket_getpeersec" 12
This hook allows the security module to provide peer socket security
state to userspace via getsockopt SO_GETPEERSEC.
\fIsock\fP is the local socket.
\fIoptval\fP userspace memory where the security state is to be copied.
\fIoptlen\fP userspace int where the module should copy the actual length
of the security state.
\fIlen\fP as input is the maximum length to copy to userspace provided
by the caller.
Return 0 if all is well, otherwise, typical getsockopt return
values.
.IP "sk_alloc_security" 12
Allocate and attach a security structure to the sk-&gt;sk_security field,
which is used to copy security attributes between local stream sockets.
.IP "sk_free_security" 12
Deallocate security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Caveat"
  \fItarget\fP is also set to current if a set of processes is
specified (i.e. all processes other than current and init or a
particular process group).  Hence, the capset_set hook may need to
revalidate permission to the actual target process.
\fItarget\fP contains the task_struct structure for target process.
\fIeffective\fP contains the effective capability set.
\fIinheritable\fP contains the inheritable capability set.
\fIpermitted\fP contains the permitted capability set.
Return 0 if permission is granted.
.SH "Note"
 this hook mediates both flock and fcntl style locks.
\fIfile\fP contains the file structure.
\fIcmd\fP contains the posix-translated lock operation to perform
(e.g. F_RDLCK, F_WRLCK).
Return 0 if permission is granted.
.SH "can always be obtained"
(struct file *)((long)fown - offsetof(struct file,f_owner));
\fItsk\fP contains the structure of task receiving signal.
\fIfown\fP contains the file owner information.
\fIsig\fP is the signal that will be sent.  When 0, kernel sends SIGIO.
Return 0 if permission is granted.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Description"
This is the main security structure.
.SH "Caveat"
  \fItarget\fP is also set to current if a set of processes is
specified (i.e. all processes other than current and init or a
particular process group).  Hence, the capset_set hook may need to
revalidate permission to the actual target process.
\fItarget\fP contains the task_struct structure for target process.
\fIeffective\fP contains the effective capability set.
\fIinheritable\fP contains the inheritable capability set.
\fIpermitted\fP contains the permitted capability set.
Return 0 if permission is granted.
.SH "Description"
This is the main security structure.
.TH "Kernel API" 9 "struct ipv6_pinfo" "January 2021" "API Manual" LINUX
.SH NAME
struct ipv6_pinfo \-  ipv6 private area
.SH SYNOPSIS
struct ipv6_pinfo {
.br
};
.br
.SH Arguments
.SH "Description"

In the struct sock hierarchy (tcp6_sock, upd6_sock, etc)
this _must_ be the last member, so that inet6_sk_generic
is able to calculate its offset from the base struct sock
by using the struct proto-&gt;slab_obj_size member. -acme
.TH "Kernel API" 9 "struct export_operations" "January 2021" "API Manual" LINUX
.SH NAME
struct export_operations \-  for nfsd to communicate with file systems
.SH SYNOPSIS
struct export_operations {
.br
.BI "    struct dentry *(*" decode_fh ") (struct super_block *sb, __u32 *fh, int fh_len, int fh_type,int (*acceptable)"
;

.br
.BI "    int (*" encode_fh ") (struct dentry *de, __u32 *fh, int *max_len,int connectable)"
;

.br
.BI "    int (*" get_name ") (struct dentry *parent, char *name,struct dentry *child)"
;

.br
.BI "    struct dentry * (*" get_parent ") (struct dentry *child)"
;

.br
.BI "    struct dentry * (*" get_dentry ") (struct super_block *sb, void *inump)"
;

.br
};
.br
.SH Arguments
.IP "decode_fh" 12
      decode a file handle fragment and return a &amp;struct dentry
.IP "encode_fh" 12
      encode a file handle fragment from a dentry
.IP "get_name" 12
       find the name for a given inode in a given directory
.IP "get_parent" 12
     find the parent of a given directory
.IP "get_dentry" 12
     find a dentry for the inode given a file handle sub-fragment
.SH "Description"
The export_operations structure provides a means for nfsd to communicate
with a particular exported file system  - particularly enabling nfsd and
the filesystem to co-operate when dealing with file handles.

export_operations contains two basic operation for dealing with file
handles, \fBdecode_fh\fP and \fBencode_fh\fP, and allows for some other
operations to be defined which standard helper routines use to get
specific information from the filesystem.

nfsd encodes information use to determine which filesystem a filehandle
applies to in the initial part of the file handle.  The remainder, termed
a file handle fragment, is controlled completely by the filesystem.  The
standard helper routines assume that this fragment will contain one or
two sub-fragments, one which identifies the file, and one which may be
used to identify the (a) directory containing the file.

In some situations, nfsd needs to get a dentry which is connected into a
specific part of the file tree.  To allow for this, it passes the
function \fBacceptable\fP together with a \fIcontext\fP which can be used to see
if the dentry is acceptable.  As there can be multiple dentrys for a
given file, the filesystem should check each one for acceptability before
looking for the next.  As soon as an acceptable one is found, it should
be returned.
.SH "decode_fh"
\fIdecode_fh\fP is given a &amp;struct super_block (\fIsb\fP), a file handle fragment
(\fIfh\fP, \fIfh_len\fP) and an acceptability testing function (\fIacceptable\fP,
\fIcontext\fP).  It should return a &amp;struct dentry which refers to the same
file that the file handle fragment refers to,  and which passes the
acceptability test.  If it cannot, it should return a NULL pointer if
the file was found but no acceptable &amp;dentries were available, or a
ERR_PTR error code indicating why it couldn't be found (e.g. ENOENT or
ENOMEM).
.SH "encode_fh"
\fIencode_fh\fP should store in the file handle fragment \fIfh\fP (using at most
\fImax_len\fP bytes) information that can be used by \fIdecode_fh\fP to recover the
file refered to by the &amp;struct dentry \fIde\fP.  If the \fIconnectable\fP flag is
set, the \fBencode_fh\fP should store sufficient information so that a good
attempt can be made to find not only the file but also it's place in the
filesystem.   This typically means storing a reference to de-&gt;d_parent in
the filehandle fragment.  \fBencode_fh\fP should return the number of bytes
stored or a negative error code such as -ENOSPC
.SH "get_name"
\fIget_name\fP should find a name for the given \fIchild\fP in the given \fIparent\fP
directory.  The name should be stored in the \fIname\fP (with the
understanding that it is already pointing to a a NAME_MAX+1 sized
buffer.   \fBget_name\fP should return 0 on success, a negative error code
or error.  \fIget_name\fP will be called without \fIparent\fP-&gt;i_sem held.
.SH "get_parent"
\fIget_parent\fP should find the parent directory for the given \fIchild\fP which
is also a directory.  In the event that it cannot be found, or storage
space cannot be allocated, a ERR_PTR should be returned.
.SH "get_dentry"
Given a &amp;super_block (\fIsb\fP) and a pointer to a file-system specific inode
identifier, possibly an inode number, (\fIinump\fP) \fBget_dentry\fP should find
the identified inode and return a dentry for that inode.  Any suitable
dentry can be returned including, if necessary, a new dentry created with
d_alloc_root.  The caller can then find any other extant dentrys by
following the d_alias links.  If a new dentry was created using
d_alloc_root, DCACHE_NFSD_DISCONNECTED should be set, and the dentry
should be \fBd_rehash\fPed.

If the inode cannot be found, either a NULL pointer or an ERR_PTR code
can be returned.  The \fIinump\fP will be whatever was passed to
\fBnfsd_find_fh_dentry\fP in either the \fIobj\fP or \fIparent\fP parameters.
.SH "Locking rules"
get_parent is called with child-&gt;d_inode-&gt;i_sem down
get_name is not (which is possibly inconsistent)
.TH "__kfifo_reset" 9 "__kfifo_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__kfifo_reset \-  removes the entire FIFO contents, no locking version
.SH SYNOPSIS
.B "void" __kfifo_reset
.BI "(struct kfifo *" fifo ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be emptied.
.TH "kfifo_reset" 9 "kfifo_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfifo_reset \-  removes the entire FIFO contents
.SH SYNOPSIS
.B "void" kfifo_reset
.BI "(struct kfifo *" fifo ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be emptied.
.TH "kfifo_put" 9 "kfifo_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfifo_put \-  puts some data into the FIFO
.SH SYNOPSIS
.B "unsigned int" kfifo_put
.BI "(struct kfifo *" fifo ","
.BI "unsigned char *" buffer ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be used.
.IP "buffer" 12
 the data to be added.
.IP "len" 12
 the length of the data to be added.
.SH "DESCRIPTION"
This function copies at most 'len' bytes from the 'buffer' into
the FIFO depending on the free space, and returns the number of
bytes copied.
.TH "kfifo_get" 9 "kfifo_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfifo_get \-  gets some data from the FIFO
.SH SYNOPSIS
.B "unsigned int" kfifo_get
.BI "(struct kfifo *" fifo ","
.BI "unsigned char *" buffer ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be used.
.IP "buffer" 12
 where the data must be copied.
.IP "len" 12
 the size of the destination buffer.
.SH "DESCRIPTION"
This function copies at most 'len' bytes from the FIFO into the
'buffer' and returns the number of copied bytes.
.TH "__kfifo_len" 9 "__kfifo_len" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__kfifo_len \-  returns the number of bytes available in the FIFO, no locking version
.SH SYNOPSIS
.B "unsigned int" __kfifo_len
.BI "(struct kfifo *" fifo ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be used.
.TH "kfifo_len" 9 "kfifo_len" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfifo_len \-  returns the number of bytes available in the FIFO
.SH SYNOPSIS
.B "unsigned int" kfifo_len
.BI "(struct kfifo *" fifo ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be used.
.TH "spin_unlock_wait" 9 "spin_unlock_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spin_unlock_wait \-  wait until the spinlock gets unlocked
.SH SYNOPSIS
.B "" spin_unlock_wait
.BI "(" lock ");"
.SH ARGUMENTS
.IP "lock" 12
 the spinlock in question.
.TH "_atomic_dec_and_lock" 9 "_atomic_dec_and_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_atomic_dec_and_lock \-  lock on reaching reference count zero
.SH SYNOPSIS
.B "int" _atomic_dec_and_lock
.BI "(atomic_t *" atomic ","
.BI "spinlock_t *" lock ");"
.SH ARGUMENTS
.IP "atomic" 12
 the atomic counter
.IP "lock" 12
 the spinlock in question
.TH "spin_can_lock" 9 "spin_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spin_can_lock \-  would spin_trylock() succeed?
.SH SYNOPSIS
.B "" spin_can_lock
.BI "(" lock ");"
.SH ARGUMENTS
.IP "lock" 12
 the spinlock in question.
.TH "kcalloc" 9 "kcalloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kcalloc \-  allocate memory for an array. The memory is set to zero.
.SH SYNOPSIS
.B "void *" kcalloc
.BI "(size_t " n ","
.BI "size_t " size ","
.BI "gfp_t " flags ");"
.SH ARGUMENTS
.IP "n" 12
 number of elements.
.IP "size" 12
 element size.
.IP "flags" 12
 the type of memory to allocate.
.TH "i2o_sg_tablesize" 9 "i2o_sg_tablesize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_sg_tablesize \-  Calculate the maximum number of elements in a SGL
.SH SYNOPSIS
.B "u16" i2o_sg_tablesize
.BI "(struct i2o_controller *" c ","
.BI "u16 " body_size ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller for which the calculation should be done
.IP "body_size" 12
 maximum body size used for message in 32-bit words.
.SH "DESCRIPTION"
Return the maximum number of SG elements in a SG list.
.TH "i2o_dma_map_single" 9 "i2o_dma_map_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_dma_map_single \-  Map pointer to controller and fill in I2O message.
.SH SYNOPSIS
.B "dma_addr_t" i2o_dma_map_single
.BI "(struct i2o_controller *" c ","
.BI "void *" ptr ","
.BI "size_t " size ","
.BI "enum dma_data_direction " direction ","
.BI "u32 __iomem **" sg_ptr ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.IP "ptr" 12
 pointer to the data which should be mapped
.IP "size" 12
 size of data in bytes
.IP "direction" 12
 DMA_TO_DEVICE / DMA_FROM_DEVICE
.IP "sg_ptr" 12
 pointer to the SG list inside the I2O message
.SH "DESCRIPTION"
This function does all necessary DMA handling and also writes the I2O
SGL elements into the I2O message. For details on DMA handling see also
\fBdma_map_single\fP. The pointer sg_ptr will only be set to the end of the
SG list if the allocation was successful.

Returns DMA address which must be checked for failures using
\fBdma_mapping_error\fP.
.TH "i2o_dma_map_sg" 9 "i2o_dma_map_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_dma_map_sg \-  Map a SG List to controller and fill in I2O message.
.SH SYNOPSIS
.B "int" i2o_dma_map_sg
.BI "(struct i2o_controller *" c ","
.BI "struct scatterlist *" sg ","
.BI "int " sg_count ","
.BI "enum dma_data_direction " direction ","
.BI "u32 __iomem **" sg_ptr ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.IP "sg" 12
 SG list to be mapped
.IP "sg_count" 12
 number of elements in the SG list
.IP "direction" 12
 DMA_TO_DEVICE / DMA_FROM_DEVICE
.IP "sg_ptr" 12
 pointer to the SG list inside the I2O message
.SH "DESCRIPTION"
This function does all necessary DMA handling and also writes the I2O
SGL elements into the I2O message. For details on DMA handling see also
\fBdma_map_sg\fP. The pointer sg_ptr will only be set to the end of the SG
list if the allocation was successful.

Returns 0 on failure or 1 on success.
.TH "i2o_dma_alloc" 9 "i2o_dma_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_dma_alloc \-  Allocate DMA memory
.SH SYNOPSIS
.B "int" i2o_dma_alloc
.BI "(struct device *" dev ","
.BI "struct i2o_dma *" addr ","
.BI "size_t " len ","
.BI "unsigned int " gfp_mask ");"
.SH ARGUMENTS
.IP "dev" 12
 struct device pointer to the PCI device of the I2O controller
.IP "addr" 12
 i2o_dma struct which should get the DMA buffer
.IP "len" 12
 length of the new DMA memory
.IP "gfp_mask" 12
 GFP mask
.SH "DESCRIPTION"
Allocate a coherent DMA memory and write the pointers into addr.

Returns 0 on success or -ENOMEM on failure.
.TH "i2o_dma_free" 9 "i2o_dma_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_dma_free \-  Free DMA memory
.SH SYNOPSIS
.B "void" i2o_dma_free
.BI "(struct device *" dev ","
.BI "struct i2o_dma *" addr ");"
.SH ARGUMENTS
.IP "dev" 12
 struct device pointer to the PCI device of the I2O controller
.IP "addr" 12
 i2o_dma struct which contains the DMA buffer
.SH "DESCRIPTION"
Free a coherent DMA memory and set virtual address of addr to NULL.
.TH "i2o_dma_realloc" 9 "i2o_dma_realloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_dma_realloc \-  Realloc DMA memory
.SH SYNOPSIS
.B "int" i2o_dma_realloc
.BI "(struct device *" dev ","
.BI "struct i2o_dma *" addr ","
.BI "size_t " len ","
.BI "unsigned int " gfp_mask ");"
.SH ARGUMENTS
.IP "dev" 12
 struct device pointer to the PCI device of the I2O controller
.IP "addr" 12
 pointer to a i2o_dma struct DMA buffer
.IP "len" 12
 new length of memory
.IP "gfp_mask" 12
 GFP mask
.SH "DESCRIPTION"
If there was something allocated in the addr, free it first. If len &gt; 0
than try to allocate it and write the addresses back to the addr
structure. If len == 0 set the virtual address to NULL.

Returns the 0 on success or negative error code on failure.
.TH "i2o_driver_notify_controller_add" 9 "i2o_driver_notify_controller_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_controller_add \-  Send notification of added controller
.SH SYNOPSIS
.B "void" i2o_driver_notify_controller_add
.BI "(struct i2o_driver *" drv ","
.BI "struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.IP "c" 12
-- undescribed --
.SH "DESCRIPTION"
to a single I2O driver

Send notification of added controller to a single registered driver.
.TH "i2o_driver_notify_controller_remove" 9 "i2o_driver_notify_controller_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_controller_remove \-  Send notification of removed
.SH SYNOPSIS
.B "void" i2o_driver_notify_controller_remove
.BI "(struct i2o_driver *" drv ","
.BI "struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.IP "c" 12
-- undescribed --
.SH "DESCRIPTION"
controller to a single I2O driver

Send notification of removed controller to a single registered driver.
.TH "i2o_driver_notify_device_add" 9 "i2o_driver_notify_device_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_device_add \-  Send notification of added device to a
.SH SYNOPSIS
.B "void" i2o_driver_notify_device_add
.BI "(struct i2o_driver *" drv ","
.BI "struct i2o_device *" i2o_dev ");"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.IP "i2o_dev" 12
-- undescribed --
.SH "DESCRIPTION"
single I2O driver

Send notification of added device to a single registered driver.
.TH "i2o_driver_notify_device_remove" 9 "i2o_driver_notify_device_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_device_remove \-  Send notification of removed device
.SH SYNOPSIS
.B "void" i2o_driver_notify_device_remove
.BI "(struct i2o_driver *" drv ","
.BI "struct i2o_device *" i2o_dev ");"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.IP "i2o_dev" 12
-- undescribed --
.SH "DESCRIPTION"
to a single I2O driver

Send notification of removed device to a single registered driver.
.TH "i2o_msg_get" 9 "i2o_msg_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_get \-  obtain an I2O message from the IOP
.SH SYNOPSIS
.B "u32" i2o_msg_get
.BI "(struct i2o_controller *" c ","
.BI "struct i2o_message __iomem **" msg ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.IP "msg" 12
 pointer to a I2O message pointer
.SH "DESCRIPTION"
This function tries to get a message slot. If no message slot is
available do not wait until one is availabe (see also i2o_msg_get_wait).

On a success the message is returned and the pointer to the message is
set in msg. The returned message is the physical page frame offset
address from the read port (see the i2o spec). If no message is
available returns I2O_QUEUE_EMPTY and msg is leaved untouched.
.TH "i2o_msg_post" 9 "i2o_msg_post" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_post \-  Post I2O message to I2O controller
.SH SYNOPSIS
.B "void" i2o_msg_post
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller to which the message should be send
.IP "m" 12
 the message identifier
.SH "DESCRIPTION"
Post the message to the I2O controller.
.TH "i2o_msg_post_wait" 9 "i2o_msg_post_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_post_wait \-  Post and wait a message and wait until return
.SH SYNOPSIS
.B "int" i2o_msg_post_wait
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ","
.BI "unsigned long " timeout ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.IP "m" 12
 message to post
.IP "timeout" 12
 time in seconds to wait
.SH "DESCRIPTION"
This API allows an OSM to post a message and then be told whether or
not the system received a successful reply. If the message times out
then the value '-ETIMEDOUT' is returned.

Returns 0 on success or negative error code on failure.
.TH "i2o_flush_reply" 9 "i2o_flush_reply" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_flush_reply \-  Flush reply from I2O controller
.SH SYNOPSIS
.B "void" i2o_flush_reply
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.IP "m" 12
 the message identifier
.SH "DESCRIPTION"
The I2O controller must be informed that the reply message is not needed
anymore. If you forget to flush the reply, the message frame can't be
used by the controller anymore and is therefore lost.
.TH "i2o_msg_out_to_virt" 9 "i2o_msg_out_to_virt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_out_to_virt \-  Turn an I2O message to a virtual address
.SH SYNOPSIS
.B "struct i2o_message *" i2o_msg_out_to_virt
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.IP "m" 12
 message engine value
.SH "DESCRIPTION"
Turn a receive message from an I2O controller bus address into
a Linux virtual address. The shared page frame is a linear block
so we simply have to shift the offset. This function does not
work for sender side messages as they are ioremap objects
provided by the I2O controller.
.TH "i2o_msg_in_to_virt" 9 "i2o_msg_in_to_virt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_in_to_virt \-  Turn an I2O message to a virtual address
.SH SYNOPSIS
.B "struct i2o_message __iomem *" i2o_msg_in_to_virt
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.IP "m" 12
 message engine value
.SH "DESCRIPTION"
Turn a send message from an I2O controller bus address into
a Linux virtual address. The shared page frame is a linear block
so we simply have to shift the offset. This function does not
work for receive side messages as they are kmalloc objects
in a different pool.
.TH "Kernel API" 9 "struct cycx_hw" "January 2021" "API Manual" LINUX
.SH NAME
struct cycx_hw \-  Adapter hardware configuration
.SH SYNOPSIS
struct cycx_hw {
.br
};
.br
.SH Arguments
.SH "Description"
\fIfwid\fP - firmware ID
\fIirq\fP - interrupt request level
\fIdpmbase\fP - dual-port memory base
\fIdpmsize\fP - dual-port memory size
\fIreserved\fP - reserved for future use
.TH "Kernel API" 9 "struct usb_host_endpoint" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_host_endpoint \-  host-side endpoint descriptor and queue
.SH SYNOPSIS
struct usb_host_endpoint {
.br
.BI "    struct usb_endpoint_descriptor " desc ""
;

.br
.BI "    struct list_head " urb_list ""
;

.br
.BI "    void *" hcpriv ""
;

.br
.BI "    unsigned char *" extra ""
;

.br
.BI "    int " extralen ""
;

.br
};
.br
.SH Arguments
.IP "desc" 12
 descriptor for this endpoint, wMaxPacketSize in native byteorder
.IP "urb_list" 12
 urbs queued to this endpoint; maintained by usbcore
.IP "hcpriv" 12
 for use by HCD; typically holds hardware dma queue head (QH)
with one or more transfer descriptors (TDs) per urb
.IP "extra" 12
 descriptors following this endpoint in the configuration
.IP "extralen" 12
 how many bytes of "extra" are valid
.SH "Description"
USB requests are always queued to a given endpoint, identified by a
descriptor within an active interface in a given USB configuration.
.TH "Kernel API" 9 "struct usb_interface" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_interface \-  what usb device drivers talk to
.SH SYNOPSIS
struct usb_interface {
.br
.BI "    struct usb_host_interface *" altsetting ""
;

.br
.BI "    struct usb_host_interface *" cur_altsetting ""
;

.br
.BI "    unsigned " num_altsetting ""
;

.br
.BI "    int " minor ""
;

.br
.BI "    enum usb_interface_condition " condition ""
;

.br
.BI "    struct device " dev ""
;

.br
.BI "    struct class_device *" class_dev ""
;

.br
};
.br
.SH Arguments
.IP "altsetting" 12
 array of interface structures, one for each alternate
setting that may be selected.  Each one includes a set of
endpoint configurations.  They will be in no particular order.
.IP "cur_altsetting" 12
 the current altsetting.
.IP "num_altsetting" 12
 number of altsettings defined.
.IP "minor" 12
 the minor number assigned to this interface, if this
interface is bound to a driver that uses the USB major number.
If this interface does not use the USB major, this field should
be unused.  The driver should set this value in the \fBprobe\fP
function of the driver, after it has been assigned a minor
number from the USB core by calling \fBusb_register_dev\fP.
.IP "condition" 12
 binding state of the interface: not bound, binding
(in \fBprobe\fP), bound to a driver, or unbinding (in \fBdisconnect\fP)
.IP "dev" 12
 driver model's view of this device
.IP "class_dev" 12
 driver model's class view of this device.
.SH "Description"
USB device drivers attach to interfaces on a physical device.  Each
interface encapsulates a single high level function, such as feeding
an audio stream to a speaker or reporting a change in a volume control.
Many USB devices only have one interface.  The protocol used to talk to
an interface's endpoints can be defined in a usb "class" specification,
or by a product's vendor.  The (default) control endpoint is part of
every interface, but is never listed among the interface's descriptors.

The driver that is bound to the interface can use standard driver model
calls such as \fBdev_get_drvdata\fP on the dev member of this structure.

Each interface may have alternate settings.  The initial configuration
of a device sets altsetting 0, but the device driver can change
that setting using \fBusb_set_interface\fP.  Alternate settings are often
used to control the the use of periodic endpoints, such as by having
different endpoints use different amounts of reserved USB bandwidth.
All standards-conformant USB devices that use isochronous endpoints
will use them in non-default settings.

The USB specification says that alternate setting numbers must run from
0 to one less than the total number of alternate settings.  But some
devices manage to mess this up, and the structures aren't necessarily
stored in numerical order anyhow.  Use \fBusb_altnum_to_altsetting\fP to
look up an alternate setting in the altsetting array based on its number.
.TH "Kernel API" 9 "struct usb_interface_cache" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_interface_cache \-  long-term representation of a device interface
.SH SYNOPSIS
struct usb_interface_cache {
.br
.BI "    unsigned " num_altsetting ""
;

.br
.BI "    struct kref " ref ""
;

.br
.BI "    struct usb_host_interface " altsetting[0] ""
;

.br
};
.br
.SH Arguments
.IP "num_altsetting" 12
 number of altsettings defined.
.IP "ref" 12
 reference counter.
.IP "altsetting[0]" 12
 variable-length array of interface structures, one for
each alternate setting that may be selected.  Each one includes a
set of endpoint configurations.  They will be in no particular order.
.SH "Description"
These structures persist for the lifetime of a usb_device, unlike
struct usb_interface (which persists only as long as its configuration
is installed).  The altsetting arrays can be accessed through these
structures at any time, permitting comparison of configurations and
providing support for the /proc/bus/usb/devices pseudo-file.
.TH "Kernel API" 9 "struct usb_host_config" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_host_config \-  representation of a device's configuration
.SH SYNOPSIS
struct usb_host_config {
.br
.BI "    struct usb_config_descriptor " desc ""
;

.br
.BI "    char *" string ""
;

.br
.BI "    struct usb_interface *" interface[USB_MAXINTERFACES] ""
;

.br
.BI "    struct usb_interface_cache *" intf_cache[USB_MAXINTERFACES] ""
;

.br
.BI "    unsigned char *" extra ""
;

.br
.BI "    int " extralen ""
;

.br
};
.br
.SH Arguments
.IP "desc" 12
 the device's configuration descriptor.
.IP "string" 12
 pointer to the cached version of the iConfiguration string, if
present for this configuration.
.IP "interface[USB_MAXINTERFACES]" 12
 array of pointers to usb_interface structures, one for each
interface in the configuration.  The number of interfaces is stored
in desc.bNumInterfaces.  These pointers are valid only while the
the configuration is active.
.IP "intf_cache[USB_MAXINTERFACES]" 12
 array of pointers to usb_interface_cache structures, one
for each interface in the configuration.  These structures exist
for the entire life of the device.
.IP "extra" 12
 pointer to buffer containing all extra descriptors associated
with this configuration (those preceding the first interface
descriptor).
.IP "extralen" 12
 length of the extra descriptors buffer.
.SH "Description"
USB devices may have multiple configurations, but only one can be active
at any time.  Each encapsulates a different operational environment;
for example, a dual-speed device would have separate configurations for
full-speed and high-speed operation.  The number of configurations
available is stored in the device descriptor as bNumConfigurations.

A configuration can contain multiple interfaces.  Each corresponds to
a different function of the USB device, and all are available whenever
the configuration is active.  The USB standard says that interfaces
are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot
of devices get this wrong.  In addition, the interface array is not
guaranteed to be sorted in numerical order.  Use \fBusb_ifnum_to_if\fP to
look up an interface entry based on its number.

Device drivers should not attempt to activate configurations.  The choice
of which configuration to install is a policy decision based on such
considerations as available power, functionality provided, and the user's
desires (expressed through hotplug scripts).  However, drivers can call
\fBusb_reset_configuration\fP to reinitialize the current configuration and
all its interfaces.
.TH "usb_interface_claimed" 9 "usb_interface_claimed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_interface_claimed \-  returns true iff an interface is claimed
.SH SYNOPSIS
.B "int" usb_interface_claimed
.BI "(struct usb_interface *" iface ");"
.SH ARGUMENTS
.IP "iface" 12
 the interface being checked
.SH "DESCRIPTION"
Returns true (nonzero) iff the interface is claimed, else false (zero).
Callers must own the driver model's usb bus readlock.  So driver
\fBprobe\fP entries don't need extra locking, but other call contexts
may need to explicitly claim that lock.
.TH "usb_make_path" 9 "usb_make_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_make_path \-  returns stable device path in the usb tree
.SH SYNOPSIS
.B "int" usb_make_path
.BI "(struct usb_device *" dev ","
.BI "char *" buf ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose path is being constructed
.IP "buf" 12
 where to put the string
.IP "size" 12
 how big is "buf"?
.SH "DESCRIPTION"
Returns length of the string (&gt; 0) or negative if size was too small.

This identifier is intended to be "stable", reflecting physical paths in
hardware such as physical bus addresses for host controllers or ports on
USB hubs.  That makes it stay the same until systems are physically
reconfigured, by re-cabling a tree of USB devices or by moving USB host
controllers.  Adding and removing devices, including virtual root hubs
in host controller driver modules, does not change these path identifers;
neither does rebooting or re-enumerating.  These are more useful identifiers
than changeable ("unstable") ones like bus numbers or device addresses.

With a partial exception for devices connected to USB 2.0 root hubs, these
identifiers are also predictable.  So long as the device tree isn't changed,
plugging any USB device into a given hub port always gives it the same path.
Because of the use of "companion" controllers, devices connected to ports on
USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
high speed, and a different one if they are full or low speed.
.TH "USB_DEVICE" 9 "USB_DEVICE" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
USB_DEVICE \-  macro used to describe a specific usb device
.SH SYNOPSIS
.B "" USB_DEVICE
.BI "(" vend ","
.BI "" prod ");"
.SH ARGUMENTS
.IP "vend" 12
 the 16 bit USB Vendor ID
.IP "prod" 12
 the 16 bit USB Product ID
.SH "DESCRIPTION"
This macro is used to create a struct usb_device_id that matches a
specific device.
.TH "USB_DEVICE_VER" 9 "USB_DEVICE_VER" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
USB_DEVICE_VER \-  macro used to describe a specific usb device with a version range
.SH SYNOPSIS
.B "" USB_DEVICE_VER
.BI "(" vend ","
.BI "" prod ","
.BI "" lo ","
.BI "" hi ");"
.SH ARGUMENTS
.IP "vend" 12
 the 16 bit USB Vendor ID
.IP "prod" 12
 the 16 bit USB Product ID
.IP "lo" 12
 the bcdDevice_lo value
.IP "hi" 12
 the bcdDevice_hi value
.SH "DESCRIPTION"
This macro is used to create a struct usb_device_id that matches a
specific device, with a version range.
.TH "USB_DEVICE_INFO" 9 "USB_DEVICE_INFO" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
USB_DEVICE_INFO \-  macro used to describe a class of usb devices
.SH SYNOPSIS
.B "" USB_DEVICE_INFO
.BI "(" cl ","
.BI "" sc ","
.BI "" pr ");"
.SH ARGUMENTS
.IP "cl" 12
 bDeviceClass value
.IP "sc" 12
 bDeviceSubClass value
.IP "pr" 12
 bDeviceProtocol value
.SH "DESCRIPTION"
This macro is used to create a struct usb_device_id that matches a
specific class of devices.
.TH "USB_INTERFACE_INFO" 9 "USB_INTERFACE_INFO" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
USB_INTERFACE_INFO \-  macro used to describe a class of usb interfaces 
.SH SYNOPSIS
.B "" USB_INTERFACE_INFO
.BI "(" cl ","
.BI "" sc ","
.BI "" pr ");"
.SH ARGUMENTS
.IP "cl" 12
 bInterfaceClass value
.IP "sc" 12
 bInterfaceSubClass value
.IP "pr" 12
 bInterfaceProtocol value
.SH "DESCRIPTION"
This macro is used to create a struct usb_device_id that matches a
specific class of interfaces.
.TH "Kernel API" 9 "struct usb_driver" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_driver \-  identifies USB driver to usbcore
.SH SYNOPSIS
struct usb_driver {
.br
.BI "    struct module *" owner ""
;

.br
.BI "    const char *" name ""
;

.br
.BI "    int (*" probe ") (struct usb_interface *intf,const struct usb_device_id *id)"
;

.br
.BI "    void (*" disconnect ") (struct usb_interface *intf)"
;

.br
.BI "    int (*" ioctl ") (struct usb_interface *intf, unsigned int code, void *buf)"
;

.br
.BI "    int (*" suspend ") (struct usb_interface *intf, pm_message_t message)"
;

.br
.BI "    int (*" resume ") (struct usb_interface *intf)"
;

.br
.BI "    const struct usb_device_id *" id_table ""
;

.br
.BI "    struct device_driver " driver ""
;

.br
};
.br
.SH Arguments
.IP "owner" 12
 Pointer to the module owner of this driver; initialize
it using THIS_MODULE.
.IP "name" 12
 The driver name should be unique among USB drivers,
and should normally be the same as the module name.
.IP "probe" 12
 Called to see if the driver is willing to manage a particular
interface on a device.  If it is, probe returns zero and uses
\fBdev_set_drvdata\fP to associate driver-specific data with the
interface.  It may also use \fBusb_set_interface\fP to specify the
appropriate altsetting.  If unwilling to manage the interface,
return a negative errno value.
.IP "disconnect" 12
 Called when the interface is no longer accessible, usually
because its device has been (or is being) disconnected or the
driver module is being unloaded.
.IP "ioctl" 12
 Used for drivers that want to talk to userspace through
the "usbfs" filesystem.  This lets devices provide ways to
expose information to user space regardless of where they
do (or don't) show up otherwise in the filesystem.
.IP "suspend" 12
 Called when the device is going to be suspended by the system.
.IP "resume" 12
 Called when the device is being resumed by the system.
.IP "id_table" 12
 USB drivers use ID table to support hotplugging.
Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
or your driver's probe function will never get called.
.IP "driver" 12
 the driver model core driver structure.
.SH "Description"
USB drivers must provide a name, \fBprobe\fP and \fBdisconnect\fP methods,
and an id_table.  Other driver fields are optional.

The id_table is used in hotplugging.  It holds a set of descriptors,
and specialized data may be associated with each entry.  That table
is used by both user and kernel mode hotplugging support.

The \fBprobe\fP and \fBdisconnect\fP methods are called in a context where
they can sleep, but they should avoid abusing the privilege.  Most
work to connect to a device should be done when the device is opened,
and undone at the last close.  The disconnect code needs to address
concurrency issues with respect to \fBopen\fP and \fBclose\fP methods, as
well as forcing all pending I/O requests to complete (by unlinking
them as necessary, and blocking until the unlinks complete).
.TH "Kernel API" 9 "struct usb_class_driver" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_class_driver \-  identifies a USB driver that wants to use the USB major number
.SH SYNOPSIS
struct usb_class_driver {
.br
.BI "    char *" name ""
;

.br
.BI "    struct file_operations *" fops ""
;

.br
.BI "    mode_t " mode ""
;

.br
.BI "    int " minor_base ""
;

.br
};
.br
.SH Arguments
.IP "name" 12
 devfs name for this driver.  Will also be used by the driver
class code to create a usb class device.
.IP "fops" 12
 pointer to the struct file_operations of this driver.
.IP "mode" 12
 the mode for the devfs file to be created for this driver.
.IP "minor_base" 12
 the start of the minor range for this driver.
.SH "Description"
This structure is used for the \fBusb_register_dev\fP and
\fBusb_unregister_dev\fP functions, to consolidate a number of the
parameters used for them.
.TH "Kernel API" 9 "struct urb" "January 2021" "API Manual" LINUX
.SH NAME
struct urb \-  USB Request Block
.SH SYNOPSIS
struct urb {
.br
.BI "    struct list_head " urb_list ""
;

.br
.BI "    struct usb_device *" dev ""
;

.br
.BI "    unsigned int " pipe ""
;

.br
.BI "    int " status ""
;

.br
.BI "    unsigned int " transfer_flags ""
;

.br
.BI "    void *" transfer_buffer ""
;

.br
.BI "    dma_addr_t " transfer_dma ""
;

.br
.BI "    int " transfer_buffer_length ""
;

.br
.BI "    int " actual_length ""
;

.br
.BI "    unsigned char *" setup_packet ""
;

.br
.BI "    dma_addr_t " setup_dma ""
;

.br
.BI "    int " start_frame ""
;

.br
.BI "    int " number_of_packets ""
;

.br
.BI "    int " interval ""
;

.br
.BI "    int " error_count ""
;

.br
.BI "    void *" context ""
;

.br
.BI "    usb_complete_t " complete ""
;

.br
.BI "    struct usb_iso_packet_descriptor " iso_frame_desc[0] ""
;

.br
};
.br
.SH Arguments
.IP "urb_list" 12
 For use by current owner of the URB.
.IP "dev" 12
 Identifies the USB device to perform the request.
.IP "pipe" 12
 Holds endpoint number, direction, type, and more.
Create these values with the eight macros available;
usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is "ctrl"
(control), "bulk", "int" (interrupt), or "iso" (isochronous).
For example \fBusb_sndbulkpipe\fP or \fBusb_rcvintpipe\fP.  Endpoint
numbers range from zero to fifteen.  Note that "in" endpoint two
is a different endpoint (and pipe) from "out" endpoint two.
The current configuration controls the existence, type, and
maximum packet size of any given endpoint.
.IP "status" 12
 This is read in non-iso completion functions to get the
status of the particular request.  ISO requests only use it
to tell whether the URB was unlinked; detailed status for
each frame is in the fields of the iso_frame-desc.
.IP "transfer_flags" 12
 A variety of flags may be used to affect how URB
submission, unlinking, or operation are handled.  Different
kinds of URB can use different flags.
.IP "transfer_buffer" 12
  This identifies the buffer to (or from) which
the I/O request will be performed (unless URB_NO_TRANSFER_DMA_MAP
is set).  This buffer must be suitable for DMA; allocate it with
\fBkmalloc\fP or equivalent.  For transfers to "in" endpoints, contents
of this buffer will be modified.  This buffer is used for the data
stage of control transfers.
.IP "transfer_dma" 12
 When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,
the device driver is saying that it provided this DMA address,
which the host controller driver should use in preference to the
transfer_buffer.
.IP "transfer_buffer_length" 12
 How big is transfer_buffer.  The transfer may
be broken up into chunks according to the current maximum packet
size for the endpoint, which is a function of the configuration
and is encoded in the pipe.  When the length is zero, neither
transfer_buffer nor transfer_dma is used.
.IP "actual_length" 12
 This is read in non-iso completion functions, and
it tells how many bytes (out of transfer_buffer_length) were
transferred.  It will normally be the same as requested, unless
either an error was reported or a short read was performed.
The URB_SHORT_NOT_OK transfer flag may be used to make such
short reads be reported as errors. 
.IP "setup_packet" 12
 Only used for control transfers, this points to eight bytes
of setup data.  Control transfers always start by sending this data
to the device.  Then transfer_buffer is read or written, if needed.
.IP "setup_dma" 12
 For control transfers with URB_NO_SETUP_DMA_MAP set, the
device driver has provided this DMA address for the setup packet.
The host controller driver should use this in preference to
setup_packet.
.IP "start_frame" 12
 Returns the initial frame for isochronous transfers.
.IP "number_of_packets" 12
 Lists the number of ISO transfer buffers.
.IP "interval" 12
 Specifies the polling interval for interrupt or isochronous
transfers.  The units are frames (milliseconds) for for full and low
speed devices, and microframes (1/8 millisecond) for highspeed ones.
.IP "error_count" 12
 Returns the number of ISO transfers that reported errors.
.IP "context" 12
 For use in completion functions.  This normally points to
request-specific driver context.
.IP "complete" 12
 Completion handler. This URB is passed as the parameter to the
completion function.  The completion function may then do what
it likes with the URB, including resubmitting or freeing it.
.IP "iso_frame_desc[0]" 12
 Used to provide arrays of ISO transfer buffers and to 
collect the transfer status for each buffer.
.SH "Description"
This structure identifies USB transfer requests.  URBs must be allocated by
calling \fBusb_alloc_urb\fP and freed with a call to \fBusb_free_urb\fP.
Initialization may be done using various usb_fill_*\fB_urb\fP functions.  URBs
are submitted using \fBusb_submit_urb\fP, and pending requests may be canceled
using \fBusb_unlink_urb\fP or \fBusb_kill_urb\fP.
.SH "Data Transfer Buffers"

Normally drivers provide I/O buffers allocated with \fBkmalloc\fP or otherwise
taken from the general page pool.  That is provided by transfer_buffer
(control requests also use setup_packet), and host controller drivers
perform a dma mapping (and unmapping) for each buffer transferred.  Those
mapping operations can be expensive on some platforms (perhaps using a dma
bounce buffer or talking to an IOMMU),
although they're cheap on commodity x86 and ppc hardware.

Alternatively, drivers may pass the URB_NO_xxx_DMA_MAP transfer flags,
which tell the host controller driver that no such mapping is needed since
the device driver is DMA-aware.  For example, a device driver might
allocate a DMA buffer with \fBusb_buffer_alloc\fP or call \fBusb_buffer_map\fP.
When these transfer flags are provided, host controller drivers will
attempt to use the dma addresses found in the transfer_dma and/or
setup_dma fields rather than determining a dma address themselves.  (Note
that transfer_buffer and setup_packet must still be set because not all
host controllers use DMA, nor do virtual root hubs).
.SH "Initialization"

All URBs submitted must initialize the dev, pipe, transfer_flags (may be
zero), and complete fields.  All URBs must also initialize
transfer_buffer and transfer_buffer_length.  They may provide the
URB_SHORT_NOT_OK transfer flag, indicating that short reads are
to be treated as errors; that flag is invalid for write requests.

Bulk URBs may
use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers
should always terminate with a short packet, even if it means adding an
extra zero length packet.

Control URBs must provide a setup_packet.  The setup_packet and
transfer_buffer may each be mapped for DMA or not, independently of
the other.  The transfer_flags bits URB_NO_TRANSFER_DMA_MAP and
URB_NO_SETUP_DMA_MAP indicate which buffers have already been mapped.
URB_NO_SETUP_DMA_MAP is ignored for non-control URBs.

Interrupt URBs must provide an interval, saying how often (in milliseconds
or, for highspeed devices, 125 microsecond units)
to poll for transfers.  After the URB has been submitted, the interval
field reflects how the transfer was actually scheduled.
The polling interval may be more frequent than requested.
For example, some controllers have a maximum interval of 32 milliseconds,
while others support intervals of up to 1024 milliseconds.
Isochronous URBs also have transfer intervals.  (Note that for isochronous
endpoints, as well as high speed interrupt endpoints, the encoding of
the transfer interval in the endpoint descriptor is logarithmic.
Device drivers must convert that value to linear units themselves.)

Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling
the host controller to schedule the transfer as soon as bandwidth
utilization allows, and then set start_frame to reflect the actual frame
selected during submission.  Otherwise drivers must specify the start_frame
and handle the case where the transfer can't begin then.  However, drivers
won't know how bandwidth is currently allocated, and while they can
find the current frame using usb_get_current_frame_number () they can't
know the range for that frame number.  (Ranges for frame counter values
are HC-specific, and can go from 256 to 65536 frames from "now".)

Isochronous URBs have a different data transfer model, in part because
the quality of service is only "best effort".  Callers provide specially
allocated URBs, with number_of_packets worth of iso_frame_desc structures
at the end.  Each such packet is an individual ISO transfer.  Isochronous
URBs are normally queued, submitted by drivers to arrange that
transfers are at least double buffered, and then explicitly resubmitted
in completion handlers, so
that data (such as audio or video) streams at as constant a rate as the
host controller scheduler can support.
.SH "Completion Callbacks"

The completion callback is made \fBin_interrupt\fP, and one of the first
things that a completion handler should do is check the status field.
The status field is provided for all URBs.  It is used to report
unlinked URBs, and status for all non-ISO transfers.  It should not
be examined before the URB is returned to the completion handler.

The context field is normally used to link URBs back to the relevant
driver or request state.

When the completion callback is invoked for non-isochronous URBs, the
actual_length field tells how many bytes were transferred.  This field
is updated even when the URB terminated with an error or was unlinked.

ISO transfer status is reported in the status and actual_length fields
of the iso_frame_desc array, and the number of errors is reported in
error_count.  Completion callbacks for ISO transfers will normally
(re)submit URBs to ensure a constant transfer rate.

Note that even fields marked "public" should not be touched by the driver
when the urb is owned by the hcd, that is, since the call to
\fBusb_submit_urb\fP till the entry into the completion routine.
.TH "usb_fill_control_urb" 9 "usb_fill_control_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_fill_control_urb \-  initializes a control urb
.SH SYNOPSIS
.B "void" usb_fill_control_urb
.BI "(struct urb *" urb ","
.BI "struct usb_device *" dev ","
.BI "unsigned int " pipe ","
.BI "unsigned char *" setup_packet ","
.BI "void *" transfer_buffer ","
.BI "int " buffer_length ","
.BI "usb_complete_t " complete ","
.BI "void *" context ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to the urb to initialize.
.IP "dev" 12
 pointer to the struct usb_device for this urb.
.IP "pipe" 12
 the endpoint pipe
.IP "setup_packet" 12
 pointer to the setup_packet buffer
.IP "transfer_buffer" 12
 pointer to the transfer buffer
.IP "buffer_length" 12
 length of the transfer buffer
.IP "complete" 12
 pointer to the usb_complete_t function
.IP "context" 12
 what to set the urb context to.
.SH "DESCRIPTION"
Initializes a control urb with the proper information needed to submit
it to a device.
.TH "usb_fill_bulk_urb" 9 "usb_fill_bulk_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_fill_bulk_urb \-  macro to help initialize a bulk urb
.SH SYNOPSIS
.B "void" usb_fill_bulk_urb
.BI "(struct urb *" urb ","
.BI "struct usb_device *" dev ","
.BI "unsigned int " pipe ","
.BI "void *" transfer_buffer ","
.BI "int " buffer_length ","
.BI "usb_complete_t " complete ","
.BI "void *" context ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to the urb to initialize.
.IP "dev" 12
 pointer to the struct usb_device for this urb.
.IP "pipe" 12
 the endpoint pipe
.IP "transfer_buffer" 12
 pointer to the transfer buffer
.IP "buffer_length" 12
 length of the transfer buffer
.IP "complete" 12
 pointer to the usb_complete_t function
.IP "context" 12
 what to set the urb context to.
.SH "DESCRIPTION"
Initializes a bulk urb with the proper information needed to submit it
to a device.
.TH "usb_fill_int_urb" 9 "usb_fill_int_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_fill_int_urb \-  macro to help initialize a interrupt urb
.SH SYNOPSIS
.B "void" usb_fill_int_urb
.BI "(struct urb *" urb ","
.BI "struct usb_device *" dev ","
.BI "unsigned int " pipe ","
.BI "void *" transfer_buffer ","
.BI "int " buffer_length ","
.BI "usb_complete_t " complete ","
.BI "void *" context ","
.BI "int " interval ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to the urb to initialize.
.IP "dev" 12
 pointer to the struct usb_device for this urb.
.IP "pipe" 12
 the endpoint pipe
.IP "transfer_buffer" 12
 pointer to the transfer buffer
.IP "buffer_length" 12
 length of the transfer buffer
.IP "complete" 12
 pointer to the usb_complete_t function
.IP "context" 12
 what to set the urb context to.
.IP "interval" 12
 what to set the urb interval to, encoded like
the endpoint descriptor's bInterval value.
.SH "DESCRIPTION"
Initializes a interrupt urb with the proper information needed to submit
it to a device.
Note that high speed interrupt endpoints use a logarithmic encoding of
the endpoint interval, and express polling intervals in microframes
(eight per millisecond) rather than in frames (one per millisecond).
.TH "Kernel API" 9 "struct usb_sg_request" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_sg_request \-  support for scatter/gather I/O
.SH SYNOPSIS
struct usb_sg_request {
.br
.BI "    int " status ""
;

.br
.BI "    size_t " bytes ""
;

.br
};
.br
.SH Arguments
.IP "status" 12
 zero indicates success, else negative errno
.IP "bytes" 12
 counts bytes transferred.
.SH "Description"
These requests are initialized using \fBusb_sg_init\fP, and then are used
as request handles passed to \fBusb_sg_wait\fP or \fBusb_sg_cancel\fP.  Most
members of the request object aren't for driver access.

The status and bytecount values are valid only after \fBusb_sg_wait\fP
returns.  If the status is zero, then the bytecount matches the total
from the request.

After an error completion, drivers may need to clear a halt condition
on the endpoint.
.TH "ata_pause" 9 "ata_pause" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pause \-  Flush writes and pause 400 nanoseconds.
.SH SYNOPSIS
.B "void" ata_pause
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to wait for.
.SH "LOCKING"
Inherited from caller.
.TH "ata_busy_wait" 9 "ata_busy_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_busy_wait \-  Wait for a port status register
.SH SYNOPSIS
.B "u8" ata_busy_wait
.BI "(struct ata_port *" ap ","
.BI "unsigned int " bits ","
.BI "unsigned int " max ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to wait for.
.IP "bits" 12
-- undescribed --
.IP "max" 12
-- undescribed --
.SH "DESCRIPTION"
Waits up to max*10 microseconds for the selected bits in the port's
status register to be cleared.
Returns final value of status register.
.SH "LOCKING"
Inherited from caller.
.TH "ata_wait_idle" 9 "ata_wait_idle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_wait_idle \-  Wait for a port to be idle.
.SH SYNOPSIS
.B "u8" ata_wait_idle
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to wait for.
.SH "DESCRIPTION"
Waits up to 10ms for port's BUSY and DRQ signals to clear.
Returns final value of status register.
.SH "LOCKING"
Inherited from caller.
.TH "ata_irq_on" 9 "ata_irq_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_irq_on \-  Enable interrupts on a port.
.SH SYNOPSIS
.B "u8" ata_irq_on
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port on which interrupts are enabled.
.SH "DESCRIPTION"
Enable interrupts on a legacy IDE device using MMIO or PIO,
wait for idle, clear any pending interrupts.
.SH "LOCKING"
Inherited from caller.
.TH "ata_irq_ack" 9 "ata_irq_ack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_irq_ack \-  Acknowledge a device interrupt.
.SH SYNOPSIS
.B "u8" ata_irq_ack
.BI "(struct ata_port *" ap ","
.BI "unsigned int " chk_drq ");"
.SH ARGUMENTS
.IP "ap" 12
 Port on which interrupts are enabled.
.IP "chk_drq" 12
-- undescribed --
.SH "DESCRIPTION"
Wait up to 10 ms for legacy IDE device to become idle (BUSY
or BUSY+DRQ clear).  Obtain dma status and port status from
device.  Clear the interrupt.  Return port status.
.TH "stop_machine_run" 9 "stop_machine_run" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
stop_machine_run \- 
.SH SYNOPSIS
.B "int" stop_machine_run
.BI "(int (*" fn ") (void *),"
.BI "void *" data ","
.BI "unsigned int " cpu ");"
.SH ARGUMENTS
.IP "fn" 12
 the function to run
.IP "data" 12
 the data ptr for the @\fBfn\fP
.IP "cpu" 12
 the cpu to run @\fBfn\fP on (or any, if \fIcpu\fP == NR_CPUS.
.SH "DESCRIPTION"
 This causes a thread to be scheduled on every other cpu,
each of which disables interrupts, and finally interrupts are disabled
on the current CPU.  The result is that noone is holding a spinlock
or inside any other preempt-disabled region when @\fBfn\fP runs.

This can be thought of as a very heavy write lock, equivalent to
.TH "__stop_machine_run" 9 "__stop_machine_run" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__stop_machine_run \- 
.SH SYNOPSIS
.B "struct task_struct *" __stop_machine_run
.BI "(int (*" fn ") (void *),"
.BI "void *" data ","
.BI "unsigned int " cpu ");"
.SH ARGUMENTS
.IP "fn" 12
 the function to run
.IP "data" 12
 the data ptr for the \fIfn\fP
.IP "cpu" 12
 the cpu to run \fIfn\fP on (or any, if \fIcpu\fP == NR_CPUS.
.SH "DESCRIPTION"
 This is a special version of the above, which returns the
thread which has run @\fBfn\fP: kthread_stop will return the return value
of @\fBfn\fP.  Used by hotplug cpu.
.TH "Kernel API" 9 "struct usb_device_id" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_device_id \-  identifies USB devices for probing and hotplugging
.SH SYNOPSIS
struct usb_device_id {
.br
.BI "    __u16 " match_flags ""
;

.br
.BI "    __u16 " idVendor ""
;

.br
.BI "    __u16 " idProduct ""
;

.br
.BI "    __u16 " bcdDevice_lo ""
;

.br
.BI "    __u16 " bcdDevice_hi ""
;

.br
.BI "    __u8 " bDeviceClass ""
;

.br
.BI "    __u8 " bDeviceSubClass ""
;

.br
.BI "    __u8 " bDeviceProtocol ""
;

.br
.BI "    __u8 " bInterfaceClass ""
;

.br
.BI "    __u8 " bInterfaceSubClass ""
;

.br
.BI "    __u8 " bInterfaceProtocol ""
;

.br
.BI "    kernel_ulong_t " driver_info ""
;

.br
};
.br
.SH Arguments
.IP "match_flags" 12
 Bit mask controlling of the other fields are used to match
against new devices.  Any field except for driver_info may be used,
although some only make sense in conjunction with other fields.
This is usually set by a USB_DEVICE_*() macro, which sets all
other fields in this structure except for driver_info.
.IP "idVendor" 12
 USB vendor ID for a device; numbers are assigned
by the USB forum to its members.
.IP "idProduct" 12
 Vendor-assigned product ID.
.IP "bcdDevice_lo" 12
 Low end of range of vendor-assigned product version numbers.
This is also used to identify individual product versions, for
a range consisting of a single device.
.IP "bcdDevice_hi" 12
 High end of version number range.  The range of product
versions is inclusive.
.IP "bDeviceClass" 12
 Class of device; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Device classes specify behavior of all
the interfaces on a devices.
.IP "bDeviceSubClass" 12
 Subclass of device; associated with bDeviceClass.
.IP "bDeviceProtocol" 12
 Protocol of device; associated with bDeviceClass.
.IP "bInterfaceClass" 12
 Class of interface; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Interface classes specify behavior only
of a given interface; other interfaces may support other classes.
.IP "bInterfaceSubClass" 12
 Subclass of interface; associated with bInterfaceClass.
.IP "bInterfaceProtocol" 12
 Protocol of interface; associated with bInterfaceClass.
.IP "driver_info" 12
 Holds information used by the driver.  Usually it holds
a pointer to a descriptor understood by the driver, or perhaps
device flags.
.SH "Description"
In most cases, drivers will create a table of device IDs by using
\fBUSB_DEVICE\fP, or similar macros designed for that purpose.
They will then export it to userspace using \fBMODULE_DEVICE_TABLE\fP,
and provide it to the USB core through their usb_driver structure.

See the \fBusb_match_id\fP function for information about how matches are
performed.  Briefly, you will normally use one of several macros to help
construct these entries.  Each entry you provide will either identify
one or more specific products, or will identify a class of products
which have agreed to behave the same.  You should put the more specific
matches towards the beginning of your table, so that driver_info can
record quirks of specific products.
.TH "kthread_create" 9 "kthread_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kthread_create \- 
.SH SYNOPSIS
.B "struct task_struct *" kthread_create
.BI "(int (*" threadfn ") (void *data),"
.BI "void *" data ","
.BI "const char " namefmt[] ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "threadfn" 12
 the function to run until signal_pending(current).
.IP "data" 12
 data ptr for \fIthreadfn\fP.
.IP "namefmt[]" 12
 printf-style name for the thread.
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
 This helper function creates and names a kernel
thread.  The thread will be stopped: use \fBwake_up_process\fP to start
it.  See also \fBkthread_run\fP, \fBkthread_create_on_cpu\fP.

When woken, the thread will run \fIthreadfn\\fBfP\fP with \fIdata\fP as its
argument. \fIthreadfn\fP can either call \fBdo_exit\fP directly if it is a
standalone thread for which noone will call \fBkthread_stop\fP, or
return when '\fBkthread_should_stop\fP' is true (which means
\fBkthread_stop\fP has been called).  The return value should be zero
.SH "OR A NEGATIVE ERROR NUMBER"
 it will be passed to \fBkthread_stop\fP.

Returns a task_struct or ERR_PTR(-ENOMEM).
.TH "kthread_run" 9 "kthread_run" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kthread_run \- 
.SH SYNOPSIS
.B "" kthread_run
.BI "(" threadfn ","
.BI "" data ","
.BI "" namefmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "threadfn" 12
 the function to run until signal_pending(current).
.IP "data" 12
 data ptr for \fIthreadfn\fP.
.IP "namefmt" 12
 printf-style name for the thread.
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
 Convenient wrapper for \fBkthread_create\fP followed by
.TH "kthread_bind" 9 "kthread_bind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kthread_bind \- created kthread to a cpu.
.SH SYNOPSIS
.B "void" kthread_bind
.BI "(struct task_struct *" k ","
.BI "unsigned int " cpu ");"
.SH ARGUMENTS
.IP "k" 12
 thread created by \fBkthread_create\fP.
.IP "cpu" 12
 cpu (might not be online, must be possible) for \fIk\fP to run on.
.SH "DESCRIPTION"
 This function is equivalent to \fBset_cpus_allowed\fP,
except that \fIcpu\fP doesn't need to be online, and the thread must be
stopped (ie. just returned from \fBkthread_create\fP.
.TH "kthread_stop" 9 "kthread_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kthread_stop \- 
.SH SYNOPSIS
.B "int" kthread_stop
.BI "(struct task_struct *" k ");"
.SH ARGUMENTS
.IP "k" 12
 thread created by \fBkthread_create\fP.
.SH "DESCRIPTION"
Sets \fBkthread_should_stop\fP for \fIk\fP to return true, wakes it, and
waits for it to exit.  Your \fBthreadfn\fP must not call \fBdo_exit\fP
itself if you use this function!  This can also be called after
\fBkthread_create\fP instead of calling \fBwake_up_process\fP: the thread
will exit without calling \fBthreadfn\fP.

Returns the result of \fBthreadfn\fP, or -EINTR if \fBwake_up_process\fP
.TH "kthread_should_stop" 9 "kthread_should_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kthread_should_stop \- 
.SH SYNOPSIS
.B "int" kthread_should_stop
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

When someone calls kthread_stop on your kthread, it will be woken
and this will return true.  You should then return, and your return
value will be passed through to \fBkthread_stop\fP.
.TH "__ATTR" 9 "__ATTR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ATTR \- 
.SH SYNOPSIS
.B "" __ATTR
.BI "(" _name ","
.BI "" _mode ","
.BI "" _show ","
.BI "" _store ");"
.SH ARGUMENTS
.IP "_name" 12
.IP "_mode" 12
.IP "_show" 12
.IP "_store" 12
.SH "DESCRIPTION"
for examples..
.TH "Kernel API" 9 "struct dccp_hdr" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_hdr \-  generic part of DCCP packet header
.SH SYNOPSIS
struct dccp_hdr {
.br
.BI "#if defined(__LITTLE_ENDIAN_BITFIELD)"
.br
.BI "#elif defined(__BIG_ENDIAN_BITFIELD)"
.br
.BI "#else"
.br
.BI "#error "Adjust your <asm/byteorder.h> defines""
.br
.BI "#endif"
.br
.BI "#if defined(__LITTLE_ENDIAN_BITFIELD)"
.br
.BI "#elif defined(__BIG_ENDIAN_BITFIELD)"
.br
.BI "#else"
.br
.BI "#error "Adjust your <asm/byteorder.h> defines""
.br
.BI "#endif"
.br
};
.br
.SH Arguments
.SH "Description"

\fIdccph_sport\fP - Relevant port on the endpoint that sent this packet
\fIdccph_dport\fP - Relevant port on the other endpoint
\fIdccph_doff\fP - Data Offset from the start of the DCCP header, in 32-bit words
\fIdccph_ccval\fP - Used by the HC-Sender CCID
\fIdccph_cscov\fP - Parts of the packet that are covered by the Checksum field
\fIdccph_checksum\fP - Internet checksum, depends on dccph_cscov
\fIdccph_x\fP - 0 = 24 bit sequence number, 1 = 48
\fIdccph_type\fP - packet type, see DCCP_PKT_ prefixed macros
\fIdccph_seq\fP - sequence number high or low order 24 bits, depends on dccph_x
.TH "Kernel API" 9 "struct dccp_hdr_ext" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_hdr_ext \-  the low bits of a 48 bit seq packet
.SH SYNOPSIS
struct dccp_hdr_ext {
.br
};
.br
.SH Arguments
.SH "Description"

\fIdccph_seq_low\fP - low 24 bits of a 48 bit seq packet
.TH "Kernel API" 9 "struct dccp_hdr_request" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_hdr_request \-  Conection initiation request header
.SH SYNOPSIS
struct dccp_hdr_request {
.br
};
.br
.SH Arguments
.SH "Description"

\fIdccph_req_service\fP - Service to which the client app wants to connect
\fIdccph_req_options\fP - list of options (must be a multiple of 32 bits
.TH "Kernel API" 9 "struct dccp_hdr_ack_bits" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_hdr_ack_bits \-  acknowledgment bits common to most packets
.SH SYNOPSIS
struct dccp_hdr_ack_bits {
.br
};
.br
.SH Arguments
.SH "Description"

\fIdccph_resp_ack_nr_high\fP - 48 bit ack number high order bits, contains GSR
\fIdccph_resp_ack_nr_low\fP - 48 bit ack number low order bits, contains GSR
.TH "Kernel API" 9 "struct dccp_hdr_response" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_hdr_response \-  Conection initiation response header
.SH SYNOPSIS
struct dccp_hdr_response {
.br
};
.br
.SH Arguments
.SH "Description"

\fIdccph_resp_ack_nr_high\fP - 48 bit ack number high order bits, contains GSR
\fIdccph_resp_ack_nr_low\fP - 48 bit ack number low order bits, contains GSR
\fIdccph_resp_service\fP - Echoes the Service Code on a received DCCP-Request
\fIdccph_resp_options\fP - list of options (must be a multiple of 32 bits
.TH "Kernel API" 9 "struct dccp_hdr_reset" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_hdr_reset \-  Unconditionally shut down a connection
.SH SYNOPSIS
struct dccp_hdr_reset {
.br
};
.br
.SH Arguments
.SH "Description"

\fIdccph_reset_service\fP - Echoes the Service Code on a received DCCP-Request
\fIdccph_reset_options\fP - list of options (must be a multiple of 32 bits
.TH "Kernel API" 9 "struct dccp_options" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_options \-  option values for a DCCP connection
.SH SYNOPSIS
struct dccp_options {
.br
};
.br
.SH Arguments
.SH "Description"
\fIdccpo_sequence_window\fP - Sequence Window Feature (section 7.5.2)
\fIdccpo_ccid\fP - Congestion Control Id (CCID) (section 10)
\fIdccpo_send_ack_vector\fP - Send Ack Vector Feature (section 11.5)
\fIdccpo_send_ndp_count\fP - Send NDP Count Feature (7.7.2)
.TH "Kernel API" 9 "struct dccp_sock" "January 2021" "API Manual" LINUX
.SH NAME
struct dccp_sock \-  DCCP socket state
.SH SYNOPSIS
struct dccp_sock {
.br
};
.br
.SH Arguments
.SH "Description"

\fIdccps_swl\fP - sequence number window low
\fIdccps_swh\fP - sequence number window high
\fIdccps_awl\fP - acknowledgement number window low
\fIdccps_awh\fP - acknowledgement number window high
\fIdccps_iss\fP - initial sequence number sent
\fIdccps_isr\fP - initial sequence number received
\fIdccps_osr\fP - first OPEN sequence number received
\fIdccps_gss\fP - greatest sequence number sent
\fIdccps_gsr\fP - greatest valid sequence number received
\fIdccps_gar\fP - greatest valid ack number received on a non-Sync; initialized to dccps_iss
\fIdccps_timestamp_time\fP - time of latest TIMESTAMP option
\fIdccps_timestamp_echo\fP - latest timestamp received on a TIMESTAMP option
\fIdccps_ext_header_len\fP - network protocol overhead (IP/IPv6 options)
\fIdccps_pmtu_cookie\fP - Last pmtu seen by socket
\fIdccps_packet_size\fP - Set thru setsockopt
\fIdccps_role\fP - Role of this sock, one of dccp_role
\fIdccps_ndp_count\fP - number of Non Data Packets since last data packet
\fIdccps_hc_rx_ackvec\fP - rx half connection ack vector
.TH "Kernel API" 9 "handle_t" "January 2021" "API Manual" LINUX
.SH NAME
typedef handle_t \-  The handle_t type represents a single atomic update being performed by some process.
.SH "Description"

All filesystem modifications made by the process go
through this handle.  Recursive operations (such as quota operations)
are gathered into a single update.

The buffer credits field is used to account for journaled buffers
being modified by the running process.  To ensure that there is
enough log space for all outstanding operations, we need to limit the
number of outstanding buffers possible at any time.  When the
operation completes, any buffer credits not used are credited back to
the transaction, so that at all times we know how many buffers the
outstanding updates on a transaction might possibly touch. 

This is an opaque datatype.
.TH "Kernel API" 9 "journal_t" "January 2021" "API Manual" LINUX
.SH NAME
typedef journal_t \-  The journal_t maintains all of the journaling state information for a single filesystem.
.SH "Description"

journal_t is linked to from the fs superblock structure.

We use the journal_t to keep track of all outstanding transaction
activity on the filesystem, and to manage the state of the log
writing process.

This is an opaque datatype.
.TH "Kernel API" 9 "struct handle_s" "January 2021" "API Manual" LINUX
.SH NAME
struct handle_s \-  The handle_s type is the concrete type associated with
.SH SYNOPSIS
struct handle_s {
.br
.BI "    transaction_t *" h_transaction ""
;

.br
.BI "    int " h_buffer_credits ""
;

.br
.BI "    int " h_ref ""
;

.br
.BI "    int " h_err ""
;

.br
.BI "    unsigned int" h_sync:1 ""
;

.br
.BI "    unsigned int" h_jdata:1 ""
;

.br
.BI "    unsigned int" h_aborted:1 ""
;

.br
};
.br
.SH Arguments
.IP "h_transaction" 12
 Which compound transaction is this update a part of?
.IP "h_buffer_credits" 12
 Number of remaining buffers we are allowed to dirty.
.IP "h_ref" 12
 Reference count on this handle
.IP "h_err" 12
 Field for caller's use to track errors through large fs operations
.IP "h_sync" 12
 flag for sync-on-close
.IP "h_jdata" 12
 flag to force data journaling
.IP "h_aborted" 12
 flag indicating fatal error on handle
.SH "Description"
handle_t.
.TH "Kernel API" 9 "struct journal_s" "January 2021" "API Manual" LINUX
.SH NAME
struct journal_s \-  The journal_s type is the concrete type associated with
.SH SYNOPSIS
struct journal_s {
.br
.BI "    unsigned long " j_flags ""
;

.br
.BI "    int " j_errno ""
;

.br
.BI "    struct buffer_head *" j_sb_buffer ""
;

.br
.BI "    journal_superblock_t *" j_superblock ""
;

.br
.BI "    int " j_format_version ""
;

.br
.BI "    spinlock_t " j_state_lock ""
;

.br
.BI "    int " j_barrier_count ""
;

.br
.BI "    struct semaphore " j_barrier ""
;

.br
.BI "    transaction_t *" j_running_transaction ""
;

.br
.BI "    transaction_t *" j_committing_transaction ""
;

.br
.BI "    transaction_t *" j_checkpoint_transactions ""
;

.br
.BI "    wait_queue_head_t " j_wait_transaction_locked ""
;

.br
.BI "    wait_queue_head_t " j_wait_logspace ""
;

.br
.BI "    wait_queue_head_t " j_wait_done_commit ""
;

.br
.BI "    wait_queue_head_t " j_wait_checkpoint ""
;

.br
.BI "    wait_queue_head_t " j_wait_commit ""
;

.br
.BI "    wait_queue_head_t " j_wait_updates ""
;

.br
.BI "    struct semaphore " j_checkpoint_sem ""
;

.br
.BI "    unsigned long " j_head ""
;

.br
.BI "    unsigned long " j_tail ""
;

.br
.BI "    unsigned long " j_free ""
;

.br
.BI "    unsigned long " j_first ""
;

.br
.BI "    unsigned long " j_last ""
;

.br
.BI "    struct block_device *" j_dev ""
;

.br
.BI "    int " j_blocksize ""
;

.br
.BI "    unsigned int " j_blk_offset ""
;

.br
.BI "    struct block_device *" j_fs_dev ""
;

.br
.BI "    unsigned int " j_maxlen ""
;

.br
.BI "    spinlock_t " j_list_lock ""
;

.br
.BI "    struct inode *" j_inode ""
;

.br
.BI "    tid_t " j_tail_sequence ""
;

.br
.BI "    tid_t " j_transaction_sequence ""
;

.br
.BI "    tid_t " j_commit_sequence ""
;

.br
.BI "    tid_t " j_commit_request ""
;

.br
.BI "    __u8 " j_uuid[16] ""
;

.br
.BI "    struct task_struct *" j_task ""
;

.br
.BI "    int " j_max_transaction_buffers ""
;

.br
.BI "    unsigned long " j_commit_interval ""
;

.br
.BI "    struct timer_list *" j_commit_timer ""
;

.br
.BI "    spinlock_t " j_revoke_lock ""
;

.br
.BI "    struct jbd_revoke_table_s *" j_revoke ""
;

.br
.BI "    struct jbd_revoke_table_s *" j_revoke_table[2] ""
;

.br
.BI "    void *" j_private ""
;

.br
};
.br
.SH Arguments
.IP "j_flags" 12
  General journaling state flags
.IP "j_errno" 12
  Is there an outstanding uncleared error on the journal (from a
prior abort)? 
.IP "j_sb_buffer" 12
 First part of superblock buffer
.IP "j_superblock" 12
 Second part of superblock buffer
.IP "j_format_version" 12
 Version of the superblock format
.IP "j_state_lock" 12
 Protect the various scalars in the journal
.IP "j_barrier_count" 12
  Number of processes waiting to create a barrier lock
.IP "j_barrier" 12
 The barrier lock itself
.IP "j_running_transaction" 12
 The current running transaction..
.IP "j_committing_transaction" 12
 the transaction we are pushing to disk
.IP "j_checkpoint_transactions" 12
 a linked circular list of all transactions
waiting for checkpointing
.IP "j_wait_transaction_locked" 12
 Wait queue for waiting for a locked transaction
to start committing, or for a barrier lock to be released
.IP "j_wait_logspace" 12
 Wait queue for waiting for checkpointing to complete
.IP "j_wait_done_commit" 12
 Wait queue for waiting for commit to complete 
.IP "j_wait_checkpoint" 12
  Wait queue to trigger checkpointing
.IP "j_wait_commit" 12
 Wait queue to trigger commit
.IP "j_wait_updates" 12
 Wait queue to wait for updates to complete
.IP "j_checkpoint_sem" 12
 Semaphore for locking against concurrent checkpoints
.IP "j_head" 12
 Journal head - identifies the first unused block in the journal
.IP "j_tail" 12
 Journal tail - identifies the oldest still-used block in the
journal.
.IP "j_free" 12
 Journal free - how many free blocks are there in the journal?
.IP "j_first" 12
 The block number of the first usable block 
.IP "j_last" 12
 The block number one beyond the last usable block
.IP "j_dev" 12
 Device where we store the journal
.IP "j_blocksize" 12
 blocksize for the location where we store the journal.
.IP "j_blk_offset" 12
 starting block offset for into the device where we store the
journal
.IP "j_fs_dev" 12
 Device which holds the client fs.  For internal journal this will
be equal to j_dev
.IP "j_maxlen" 12
 Total maximum capacity of the journal region on disk.
.IP "j_list_lock" 12
 Protects the buffer lists and internal buffer state.
.IP "j_inode" 12
 Optional inode where we store the journal.  If present, all journal
block numbers are mapped into this inode via \fBbmap\fP.
.IP "j_tail_sequence" 12
  Sequence number of the oldest transaction in the log 
.IP "j_transaction_sequence" 12
 Sequence number of the next transaction to grant
.IP "j_commit_sequence" 12
 Sequence number of the most recently committed
transaction
.IP "j_commit_request" 12
 Sequence number of the most recent transaction wanting
commit 
.IP "j_uuid[16]" 12
 Uuid of client object.
.IP "j_task" 12
 Pointer to the current commit thread for this journal
.IP "j_max_transaction_buffers" 12
  Maximum number of metadata buffers to allow in a
single compound commit transaction
.IP "j_commit_interval" 12
 What is the maximum transaction lifetime before we begin
a commit?
.IP "j_commit_timer" 12
  The timer used to wakeup the commit thread
.IP "j_revoke_lock" 12
 Protect the revoke table
.IP "j_revoke" 12
 The revoke table - maintains the list of revoked blocks in the
current transaction.
.IP "j_revoke_table[2]" 12
 alternate revoke tables for j_revoke
.IP "j_private" 12
 An opaque pointer to fs-private information.
.SH "Description"
journal_t.
.TH "Kernel API" 9 "struct usb_request" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_request \-  describes one i/o request
.SH SYNOPSIS
struct usb_request {
.br
.BI "    void *" buf ""
;

.br
.BI "    unsigned " length ""
;

.br
.BI "    dma_addr_t " dma ""
;

.br
.BI "    unsigned" no_interrupt:1 ""
;

.br
.BI "    unsigned" zero:1 ""
;

.br
.BI "    unsigned" short_not_ok:1 ""
;

.br
.BI "    void (*" complete ") (struct usb_ep *ep,struct usb_request *req)"
;

.br
.BI "    void *" context ""
;

.br
.BI "    struct list_head " list ""
;

.br
.BI "    int " status ""
;

.br
.BI "    unsigned " actual ""
;

.br
};
.br
.SH Arguments
.IP "buf" 12
 Buffer used for data.  Always provide this; some controllers
only use PIO, or don't use DMA for some endpoints.
.IP "length" 12
 Length of that data
.IP "dma" 12
 DMA address corresponding to 'buf'.  If you don't set this
field, and the usb controller needs one, it is responsible
for mapping and unmapping the buffer.
.IP "no_interrupt" 12
 If true, hints that no completion irq is needed.
Helpful sometimes with deep request queues that are handled
directly by DMA controllers.
.IP "zero" 12
 If true, when writing data, makes the last packet be "short"
by adding a zero length packet as needed;
.IP "short_not_ok" 12
 When reading data, makes short packets be
treated as errors (queue stops advancing till cleanup).
.IP "complete" 12
 Function called when request completes, so this request and
its buffer may be re-used.
Reads terminate with a short packet, or when the buffer fills,
whichever comes first.  When writes terminate, some data bytes
will usually still be in flight (often in a hardware fifo).
Errors (for reads or writes) stop the queue from advancing
until the completion function returns, so that any transfers
invalidated by the error may first be dequeued.
.IP "context" 12
 For use by the completion callback
.IP "list" 12
 For use by the gadget driver.
.IP "status" 12
 Reports completion code, zero or a negative errno.
Normally, faults block the transfer queue from advancing until
the completion callback returns.
Code "-ESHUTDOWN" indicates completion caused by device disconnect,
or when the driver disabled the endpoint.
.IP "actual" 12
 Reports bytes transferred to/from the buffer.  For reads (OUT
transfers) this may be less than the requested length.  If the
short_not_ok flag is set, short reads are treated as errors
even when status otherwise indicates successful completion.
Note that for writes (IN transfers) some data bytes may still
reside in a device-side FIFO when the request is reported as
complete.
.SH "Description"
These are allocated/freed through the endpoint they're used with.  The
hardware's driver can add extra per-request data to the memory it returns,
which often avoids separate memory allocations (potential failures),
later when the request is queued.

Request flags affect request handling, such as whether a zero length
packet is written (the "zero" flag), whether a short read should be
treated as an error (blocking request queue advance, the "short_not_ok"
flag), or hinting that an interrupt is not required (the "no_interrupt"
flag, for use with deep request queues).

Bulk endpoints can use any size buffers, and can also be used for interrupt
transfers. interrupt-only endpoints can be much less functional.
.TH "Kernel API" 9 "struct usb_ep" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_ep \-  device side representation of USB endpoint
.SH SYNOPSIS
struct usb_ep {
.br
.BI "    void *" driver_data ""
;

.br
.BI "    const char *" name ""
;

.br
.BI "    const struct usb_ep_ops *" ops ""
;

.br
.BI "    struct list_head " ep_list ""
;

.br
.BI "    unsigned" maxpacket:16 ""
;

.br
};
.br
.SH Arguments
.IP "driver_data" 12
for use by the gadget driver.  all other fields are
read-only to gadget drivers.
.IP "name" 12
identifier for the endpoint, such as "ep-a" or "ep9in-bulk"
.IP "ops" 12
 Function pointers used to access hardware-specific operations.
.IP "ep_list" 12
the gadget's ep_list holds all of its endpoints
.IP "maxpacket" 12
The maximum packet size used on this endpoint.  The initial
value can sometimes be reduced (hardware allowing), according to
the endpoint descriptor used to configure the endpoint.
.SH "Description"
the bus controller driver lists all the general purpose endpoints in
gadget-&gt;ep_list.  the control endpoint (gadget-&gt;ep0) is not in that list,
and is accessed only in response to a driver \fBsetup\fP callback.
.TH "usb_ep_enable" 9 "usb_ep_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_enable \-  configure endpoint, making it usable
.SH SYNOPSIS
.B "int" usb_ep_enable
.BI "(struct usb_ep *" ep ","
.BI "const struct usb_endpoint_descriptor *" desc ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint being configured.  may not be the endpoint named "ep0".
drivers discover endpoints through the ep_list of a usb_gadget.
.IP "desc" 12
descriptor for desired behavior.  caller guarantees this pointer
remains valid until the endpoint is disabled; the data byte order
is little-endian (usb-standard).
.SH "DESCRIPTION"
when configurations are set, or when interface settings change, the driver
will enable or disable the relevant endpoints.  while it is enabled, an
endpoint may be used for i/o until the driver receives a \fBdisconnect\fP from
the host or until the endpoint is disabled.

the ep0 implementation (which calls this routine) must ensure that the
hardware capabilities of each endpoint match the descriptor provided
for it.  for example, an endpoint named "ep2in-bulk" would be usable
for interrupt transfers as well as bulk, but it likely couldn't be used
for iso transfers or for endpoint 14.  some endpoints are fully
configurable, with more generic names like "ep-a".  (remember that for
USB, "in" means "towards the USB master".)

returns zero, or a negative error code.
.TH "usb_ep_disable" 9 "usb_ep_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_disable \-  endpoint is no longer usable
.SH SYNOPSIS
.B "int" usb_ep_disable
.BI "(struct usb_ep *" ep ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint being unconfigured.  may not be the endpoint named "ep0".
.SH "DESCRIPTION"
no other task may be using this endpoint when this is called.
any pending and uncompleted requests will complete with status
indicating disconnect (-ESHUTDOWN) before this call returns.
gadget drivers must call \fBusb_ep_enable\fP again before queueing
requests to the endpoint.

returns zero, or a negative error code.
.TH "usb_ep_alloc_request" 9 "usb_ep_alloc_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_alloc_request \-  allocate a request object to use with this endpoint
.SH SYNOPSIS
.B "struct usb_request *" usb_ep_alloc_request
.BI "(struct usb_ep *" ep ","
.BI "unsigned " gfp_flags ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint to be used with with the request
.IP "gfp_flags" 12
GFP_* flags to use
.SH "DESCRIPTION"
Request objects must be allocated with this call, since they normally
need controller-specific setup and may even need endpoint-specific
resources such as allocation of DMA descriptors.
Requests may be submitted with \fBusb_ep_queue\fP, and receive a single
completion callback.  Free requests with \fBusb_ep_free_request\fP, when
they are no longer needed.

Returns the request, or null if one could not be allocated.
.TH "usb_ep_free_request" 9 "usb_ep_free_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_free_request \-  frees a request object
.SH SYNOPSIS
.B "void" usb_ep_free_request
.BI "(struct usb_ep *" ep ","
.BI "struct usb_request *" req ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint associated with the request
.IP "req" 12
the request being freed
.SH "DESCRIPTION"
Reverses the effect of \fBusb_ep_alloc_request\fP.
Caller guarantees the request is not queued, and that it will
no longer be requeued (or otherwise used).
.TH "usb_ep_alloc_buffer" 9 "usb_ep_alloc_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_alloc_buffer \-  allocate an I/O buffer
.SH SYNOPSIS
.B "void *" usb_ep_alloc_buffer
.BI "(struct usb_ep *" ep ","
.BI "unsigned " len ","
.BI "dma_addr_t *" dma ","
.BI "unsigned " gfp_flags ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint associated with the buffer
.IP "len" 12
length of the desired buffer
.IP "dma" 12
pointer to the buffer's DMA address; must be valid
.IP "gfp_flags" 12
GFP_* flags to use
.SH "DESCRIPTION"
Returns a new buffer, or null if one could not be allocated.
The buffer is suitably aligned for dma, if that endpoint uses DMA,
and the caller won't have to care about dma-inconsistency
or any hidden "bounce buffer" mechanism.  No additional per-request
DMA mapping will be required for such buffers.
Free it later with \fBusb_ep_free_buffer\fP.

You don't need to use this call to allocate I/O buffers unless you
want to make sure drivers don't incur costs for such "bounce buffer"
copies or per-request DMA mappings.
.TH "usb_ep_free_buffer" 9 "usb_ep_free_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_free_buffer \-  frees an i/o buffer
.SH SYNOPSIS
.B "void" usb_ep_free_buffer
.BI "(struct usb_ep *" ep ","
.BI "void *" buf ","
.BI "dma_addr_t " dma ","
.BI "unsigned " len ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint associated with the buffer
.IP "buf" 12
CPU view address of the buffer
.IP "dma" 12
the buffer's DMA address
.IP "len" 12
length of the buffer
.SH "DESCRIPTION"
reverses the effect of \fBusb_ep_alloc_buffer\fP.
caller guarantees the buffer will no longer be accessed
.TH "usb_ep_queue" 9 "usb_ep_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_queue \-  queues (submits) an I/O request to an endpoint.
.SH SYNOPSIS
.B "int" usb_ep_queue
.BI "(struct usb_ep *" ep ","
.BI "struct usb_request *" req ","
.BI "unsigned " gfp_flags ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint associated with the request
.IP "req" 12
the request being submitted
.IP "gfp_flags" 12
 GFP_* flags to use in case the lower level driver couldn't
pre-allocate all necessary memory with the request.
.SH "DESCRIPTION"
This tells the device controller to perform the specified request through
that endpoint (reading or writing a buffer).  When the request completes,
including being canceled by \fBusb_ep_dequeue\fP, the request's completion
routine is called to return the request to the driver.  Any endpoint
(except control endpoints like ep0) may have more than one transfer
request queued; they complete in FIFO order.  Once a gadget driver
submits a request, that request may not be examined or modified until it
is given back to that driver through the completion callback.

Each request is turned into one or more packets.  The controller driver
never merges adjacent requests into the same packet.  OUT transfers
will sometimes use data that's already buffered in the hardware.
Drivers can rely on the fact that the first byte of the request's buffer
always corresponds to the first byte of some USB packet, for both
IN and OUT transfers.

Bulk endpoints can queue any amount of data; the transfer is packetized
automatically.  The last packet will be short if the request doesn't fill it
out completely.  Zero length packets (ZLPs) should be avoided in portable
protocols since not all usb hardware can successfully handle zero length
packets.  (ZLPs may be explicitly written, and may be implicitly written if
the request 'zero' flag is set.)  Bulk endpoints may also be used
for interrupt transfers; but the reverse is not true, and some endpoints
won't support every interrupt transfer.  (Such as 768 byte packets.)

Interrupt-only endpoints are less functional than bulk endpoints, for
example by not supporting queueing or not handling buffers that are
larger than the endpoint's maxpacket size.  They may also treat data
toggle differently.

Control endpoints ... after getting a \fBsetup\fP callback, the driver queues
one response (even if it would be zero length).  That enables the
status ack, after transfering data as specified in the response.  Setup
functions may return negative error codes to generate protocol stalls.
(Note that some USB device controllers disallow protocol stall responses
in some cases.)  When control responses are deferred (the response is
written after the setup callback returns), then \fBusb_ep_set_halt\fP may be
used on ep0 to trigger protocol stalls.

For periodic endpoints, like interrupt or isochronous ones, the usb host
arranges to poll once per interval, and the gadget driver usually will
have queued some data to transfer at that time.

Returns zero, or a negative error code.  Endpoints that are not enabled
report errors; errors will also be
reported when the usb peripheral is disconnected.
.TH "usb_ep_dequeue" 9 "usb_ep_dequeue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_dequeue \-  dequeues (cancels, unlinks) an I/O request from an endpoint
.SH SYNOPSIS
.B "int" usb_ep_dequeue
.BI "(struct usb_ep *" ep ","
.BI "struct usb_request *" req ");"
.SH ARGUMENTS
.IP "ep" 12
the endpoint associated with the request
.IP "req" 12
the request being canceled
.SH "DESCRIPTION"
if the request is still active on the endpoint, it is dequeued and its
completion routine is called (with status -ECONNRESET); else a negative
error code is returned.

note that some hardware can't clear out write fifos (to unlink the request
at the head of the queue) except as part of disconnecting from usb.  such
restrictions prevent drivers from supporting configuration changes,
even to configuration zero (a "chapter 9" requirement).
.TH "usb_ep_set_halt" 9 "usb_ep_set_halt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_set_halt \-  sets the endpoint halt feature.
.SH SYNOPSIS
.B "int" usb_ep_set_halt
.BI "(struct usb_ep *" ep ");"
.SH ARGUMENTS
.IP "ep" 12
 the non-isochronous endpoint being stalled
.SH "DESCRIPTION"
Use this to stall an endpoint, perhaps as an error report.
Except for control endpoints,
the endpoint stays halted (will not stream any data) until the host
clears this feature; drivers may need to empty the endpoint's request
queue first, to make sure no inappropriate transfers happen.

Note that while an endpoint CLEAR_FEATURE will be invisible to the
gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the
current altsetting, see \fBusb_ep_clear_halt\fP.  When switching altsettings,
it's simplest to use \fBusb_ep_enable\fP or \fBusb_ep_disable\fP for the endpoints.

Returns zero, or a negative error code.  On success, this call sets
underlying hardware state that blocks data transfers.
Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
transfer requests are still queued, or if the controller hardware
(usually a FIFO) still holds bytes that the host hasn't collected.
.TH "usb_ep_clear_halt" 9 "usb_ep_clear_halt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_clear_halt \-  clears endpoint halt, and resets toggle
.SH SYNOPSIS
.B "int" usb_ep_clear_halt
.BI "(struct usb_ep *" ep ");"
.SH ARGUMENTS
.IP "ep" 12
the bulk or interrupt endpoint being reset
.SH "DESCRIPTION"
Use this when responding to the standard usb "set interface" request,
for endpoints that aren't reconfigured, after clearing any other state
in the endpoint's i/o queue.

Returns zero, or a negative error code.  On success, this call clears
the underlying hardware state reflecting endpoint halt and data toggle.
Note that some hardware can't support this request (like pxa2xx_udc),
and accordingly can't correctly implement interface altsettings.
.TH "usb_ep_fifo_status" 9 "usb_ep_fifo_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_fifo_status \-  returns number of bytes in fifo, or error
.SH SYNOPSIS
.B "int" usb_ep_fifo_status
.BI "(struct usb_ep *" ep ");"
.SH ARGUMENTS
.IP "ep" 12
 the endpoint whose fifo status is being checked.
.SH "DESCRIPTION"
FIFO endpoints may have "unclaimed data" in them in certain cases,
such as after aborted transfers.  Hosts may not have collected all
the IN data written by the gadget driver (and reported by a request
completion).  The gadget driver may not have collected all the data
written OUT to it by the host.  Drivers that need precise handling for
fault reporting or recovery may need to use this call.

This returns the number of such bytes in the fifo, or a negative
errno if the endpoint doesn't use a FIFO or doesn't support such
precise handling.
.TH "usb_ep_fifo_flush" 9 "usb_ep_fifo_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ep_fifo_flush \-  flushes contents of a fifo
.SH SYNOPSIS
.B "void" usb_ep_fifo_flush
.BI "(struct usb_ep *" ep ");"
.SH ARGUMENTS
.IP "ep" 12
 the endpoint whose fifo is being flushed.
.SH "DESCRIPTION"
This call may be used to flush the "unclaimed data" that may exist in
an endpoint fifo after abnormal transaction terminations.  The call
must never be used except when endpoint is not being used for any
protocol translation.
.TH "Kernel API" 9 "struct usb_gadget" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_gadget \-  represents a usb slave device
.SH SYNOPSIS
struct usb_gadget {
.br
.BI "    const struct usb_gadget_ops *" ops ""
;

.br
.BI "    struct usb_ep *" ep0 ""
;

.br
.BI "    struct list_head " ep_list ""
;

.br
.BI "    enum usb_device_speed " speed ""
;

.br
.BI "    unsigned" is_dualspeed:1 ""
;

.br
.BI "    unsigned" is_otg:1 ""
;

.br
.BI "    unsigned" is_a_peripheral:1 ""
;

.br
.BI "    unsigned" b_hnp_enable:1 ""
;

.br
.BI "    unsigned" a_hnp_support:1 ""
;

.br
.BI "    unsigned" a_alt_hnp_support:1 ""
;

.br
.BI "    const char *" name ""
;

.br
.BI "    struct device " dev ""
;

.br
};
.br
.SH Arguments
.IP "ops" 12
 Function pointers used to access hardware-specific operations.
.IP "ep0" 12
 Endpoint zero, used when reading or writing responses to
driver \fBsetup\fP requests
.IP "ep_list" 12
 List of other endpoints supported by the device.
.IP "speed" 12
 Speed of current connection to USB host.
.IP "is_dualspeed" 12
 True if the controller supports both high and full speed
operation.  If it does, the gadget driver must also support both.
.IP "is_otg" 12
 True if the USB device port uses a Mini-AB jack, so that the
gadget driver must provide a USB OTG descriptor.
.IP "is_a_peripheral" 12
 False unless is_otg, the "A" end of a USB cable
is in the Mini-AB jack, and HNP has been used to switch roles
so that the "A" device currently acts as A-Peripheral, not A-Host.
.IP "b_hnp_enable" 12
 OTG device feature flag, indicating that the A-Host
enabled HNP support.
.IP "a_hnp_support" 12
 OTG device feature flag, indicating that the A-Host
supports HNP at this port.
.IP "a_alt_hnp_support" 12
 OTG device feature flag, indicating that the A-Host
only supports HNP on a different root port.
.IP "name" 12
 Identifies the controller hardware type.  Used in diagnostics
and sometimes configuration.
.IP "dev" 12
 Driver model state for this abstract device.
.SH "Description"
Gadgets have a mostly-portable "gadget driver" implementing device
functions, handling all usb configurations and interfaces.  Gadget
drivers talk to hardware-specific code indirectly, through ops vectors.
That insulates the gadget driver from hardware details, and packages
the hardware endpoints through generic i/o queues.  The "usb_gadget"
and "usb_ep" interfaces provide that insulation from the hardware.

Except for the driver data, all fields in this structure are
read-only to the gadget driver.  That driver data is part of the
"driver model" infrastructure in 2.6 (and later) kernels, and for
earlier systems is grouped in a similar structure that's not known
to the rest of the kernel.

Values of the three OTG device feature flags are updated before the
\fBsetup\fP call corresponding to USB_REQ_SET_CONFIGURATION, and before
driver \fBsuspend\fP calls.  They are valid only when is_otg, and when the
device is acting as a B-Peripheral (so is_a_peripheral is false).
.TH "usb_gadget_frame_number" 9 "usb_gadget_frame_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_frame_number \-  returns the current frame number
.SH SYNOPSIS
.B "int" usb_gadget_frame_number
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
 controller that reports the frame number
.SH "DESCRIPTION"
Returns the usb frame number, normally eleven bits from a SOF packet,
or negative errno if this device doesn't support this capability.
.TH "usb_gadget_wakeup" 9 "usb_gadget_wakeup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_wakeup \-  tries to wake up the host connected to this gadget
.SH SYNOPSIS
.B "int" usb_gadget_wakeup
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
 controller used to wake up the host
.SH "DESCRIPTION"
Returns zero on success, else negative error code if the hardware
doesn't support such attempts, or its support has not been enabled
by the usb host.  Drivers must return device descriptors that report
their ability to support this, or hosts won't enable it.

This may also try to use SRP to wake the host and start enumeration,
even if OTG isn't otherwise in use.  OTG devices may also start
remote wakeup even when hosts don't explicitly enable it.
.TH "usb_gadget_set_selfpowered" 9 "usb_gadget_set_selfpowered" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_set_selfpowered \-  sets the device selfpowered feature.
.SH SYNOPSIS
.B "int" usb_gadget_set_selfpowered
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
the device being declared as self-powered
.SH "DESCRIPTION"
this affects the device status reported by the hardware driver
to reflect that it now has a local power supply.

returns zero on success, else negative errno.
.TH "usb_gadget_clear_selfpowered" 9 "usb_gadget_clear_selfpowered" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_clear_selfpowered \-  clear the device selfpowered feature.
.SH SYNOPSIS
.B "int" usb_gadget_clear_selfpowered
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
the device being declared as bus-powered
.SH "DESCRIPTION"
this affects the device status reported by the hardware driver.
some hardware may not support bus-powered operation, in which
case this feature's value can never change.

returns zero on success, else negative errno.
.TH "usb_gadget_vbus_connect" 9 "usb_gadget_vbus_connect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_vbus_connect \-  Notify controller that VBUS is powered
.SH SYNOPSIS
.B "int" usb_gadget_vbus_connect
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
The device which now has VBUS power.
.SH "DESCRIPTION"
This call is used by a driver for an external transceiver (or GPIO)
that detects a VBUS power session starting.  Common responses include
resuming the controller, activating the D+ (or D-) pullup to let the
host detect that a USB device is attached, and starting to draw power
(8mA or possibly more, especially after SET_CONFIGURATION).

Returns zero on success, else negative errno.
.TH "usb_gadget_vbus_draw" 9 "usb_gadget_vbus_draw" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_vbus_draw \-  constrain controller's VBUS power usage
.SH SYNOPSIS
.B "int" usb_gadget_vbus_draw
.BI "(struct usb_gadget *" gadget ","
.BI "unsigned " mA ");"
.SH ARGUMENTS
.IP "gadget" 12
The device whose VBUS usage is being described
.IP "mA" 12
How much current to draw, in milliAmperes.  This should be twice
the value listed in the configuration descriptor bMaxPower field.
.SH "DESCRIPTION"
This call is used by gadget drivers during SET_CONFIGURATION calls,
reporting how much power the device may consume.  For example, this
could affect how quickly batteries are recharged.

Returns zero on success, else negative errno.
.TH "usb_gadget_vbus_disconnect" 9 "usb_gadget_vbus_disconnect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_vbus_disconnect \-  notify controller about VBUS session end
.SH SYNOPSIS
.B "int" usb_gadget_vbus_disconnect
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
the device whose VBUS supply is being described
.SH "DESCRIPTION"
This call is used by a driver for an external transceiver (or GPIO)
that detects a VBUS power session ending.  Common responses include
reversing everything done in \fBusb_gadget_vbus_connect\fP.

Returns zero on success, else negative errno.
.TH "usb_gadget_connect" 9 "usb_gadget_connect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_connect \-  software-controlled connect to USB host
.SH SYNOPSIS
.B "int" usb_gadget_connect
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
the peripheral being connected
.SH "DESCRIPTION"
Enables the D+ (or potentially D-) pullup.  The host will start
enumerating this gadget when the pullup is active and a VBUS session
is active (the link is powered).  This pullup is always enabled unless
\fBusb_gadget_disconnect\fP has been used to disable it.

Returns zero on success, else negative errno.
.TH "usb_gadget_disconnect" 9 "usb_gadget_disconnect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_disconnect \-  software-controlled disconnect from USB host
.SH SYNOPSIS
.B "int" usb_gadget_disconnect
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
the peripheral being disconnected
.SH "DESCRIPTION"
Disables the D+ (or potentially D-) pullup, which the host may see
as a disconnect (when a VBUS session is active).  Not all systems
support software pullup controls.

This routine may be used during the gadget driver \fBbind\fP call to prevent
the peripheral from ever being visible to the USB host, unless later
\fBusb_gadget_connect\fP is called.  For example, user mode components may
need to be activated before the system can talk to hosts.

Returns zero on success, else negative errno.
.TH "Kernel API" 9 "struct usb_gadget_driver" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_gadget_driver \-  driver for usb 'slave' devices
.SH SYNOPSIS
struct usb_gadget_driver {
.br
.BI "    char *" function ""
;

.br
.BI "    enum usb_device_speed " speed ""
;

.br
.BI "    int (*" bind ") (struct usb_gadget *)"
;

.br
.BI "    void (*" unbind ") (struct usb_gadget *)"
;

.br
.BI "    int (*" setup ") (struct usb_gadget *,const struct usb_ctrlrequest *)"
;

.br
.BI "    void (*" disconnect ") (struct usb_gadget *)"
;

.br
.BI "    void (*" suspend ") (struct usb_gadget *)"
;

.br
.BI "    void (*" resume ") (struct usb_gadget *)"
;

.br
.BI "    // FIXME support safe rmmodstruct device_driver " driver ""
;

.br
};
.br
.SH Arguments
.IP "function" 12
 String describing the gadget's function
.IP "speed" 12
 Highest speed the driver handles.
.IP "bind" 12
 Invoked when the driver is bound to a gadget, usually
after registering the driver.
At that point, ep0 is fully initialized, and ep_list holds
the currently-available endpoints.
Called in a context that permits sleeping.
.IP "unbind" 12
 Invoked when the driver is unbound from a gadget,
usually from rmmod (after a disconnect is reported).
Called in a context that permits sleeping.
.IP "setup" 12
 Invoked for ep0 control requests that aren't handled by
the hardware level driver. Most calls must be handled by
the gadget driver, including descriptor and configuration
management.  The 16 bit members of the setup data are in
USB byte order. Called in_interrupt; this may not sleep.  Driver
queues a response to ep0, or returns negative to stall.
.IP "disconnect" 12
 Invoked after all transfers have been stopped,
when the host is disconnected.  May be called in_interrupt; this
may not sleep.  Some devices can't detect disconnect, so this might
not be called except as part of controller shutdown.
.IP "suspend" 12
 Invoked on USB suspend.  May be called in_interrupt.
.IP "resume" 12
 Invoked on USB resume.  May be called in_interrupt.
.IP "driver" 12
 Driver model state for this driver.
.SH "Description"
Devices are disabled till a gadget driver successfully \fBbind\fPs, which
means the driver will handle \fBsetup\fP requests needed to enumerate (and
meet "chapter 9" requirements) then do some useful work.

If gadget-&gt;is_otg is true, the gadget driver must provide an OTG
descriptor during enumeration, or else fail the \fBbind\fP call.  In such
cases, no USB traffic may flow until both \fBbind\fP returns without
having called \fBusb_gadget_disconnect\fP, and the USB host stack has
initialized.

Drivers use hardware-specific knowledge to configure the usb hardware.
endpoint addressing is only one of several hardware characteristics that
are in descriptors the ep0 implementation returns from \fBsetup\fP calls.

Except for ep0 implementation, most driver code shouldn't need change to
run on top of different usb controllers.  It'll use endpoints set up by
that ep0 implementation.

The usb controller driver handles a few standard usb requests.  Those
include set_address, and feature flags for devices, interfaces, and
endpoints (the get_status, set_feature, and clear_feature requests).

Accordingly, the driver's \fBsetup\fP callback must always implement all
get_descriptor requests, returning at least a device descriptor and
a configuration descriptor.  Drivers must make sure the endpoint
descriptors match any hardware constraints. Some hardware also constrains
other descriptors. (The pxa250 allows only configurations 1, 2, or 3).

The driver's \fBsetup\fP callback must also implement set_configuration,
and should also implement set_interface, get_configuration, and
get_interface.  Setting a configuration (or interface) is where
endpoints should be activated or (config 0) shut down.

(Note that only the default control endpoint is supported.  Neither
hosts nor devices generally support control traffic except to ep0.)

Most devices will ignore USB suspend/resume operations, and so will
not provide those callbacks.  However, some may need to change modes
when the host is not longer directing those activities.  For example,
local controls (buttons, dials, etc) may need to be re-enabled since
the (remote) host can't do that any longer; or an error state might
be cleared, to make the device behave identically whether or not
power is maintained.
.TH "usb_gadget_register_driver" 9 "usb_gadget_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_register_driver \-  register a gadget driver
.SH SYNOPSIS
.B "int" usb_gadget_register_driver
.BI "(struct usb_gadget_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
the driver being registered
.SH "DESCRIPTION"
Call this in your gadget driver's module initialization function,
to tell the underlying usb controller driver about your driver.
The driver's \fBbind\fP function will be called to bind it to a
gadget.  This function must be called in a context that can sleep.
.TH "usb_gadget_unregister_driver" 9 "usb_gadget_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_unregister_driver \-  unregister a gadget driver
.SH SYNOPSIS
.B "int" usb_gadget_unregister_driver
.BI "(struct usb_gadget_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
the driver being unregistered
.SH "DESCRIPTION"
Call this in your gadget driver's module cleanup function,
to tell the underlying usb controller that your driver is
going away.  If the controller is connected to a USB host,
it will first \fBdisconnect\fP.  The driver is also requested
to \fBunbind\fP and clean up any device state, before this procedure
finally returns.
This function must be called in a context that can sleep.
.TH "Kernel API" 9 "struct usb_string" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_string \-  wraps a C string and its USB id
.SH SYNOPSIS
struct usb_string {
.br
.BI "    u8 " id ""
;

.br
.BI "    const char *" s ""
;

.br
};
.br
.SH Arguments
.IP "id" 12
the (nonzero) ID for this string
.IP "s" 12
the string, in UTF-8 encoding
.SH "Description"
If you're using \fBusb_gadget_get_string\fP, use this to wrap a string
together with its ID.
.TH "Kernel API" 9 "struct usb_gadget_strings" "January 2021" "API Manual" LINUX
.SH NAME
struct usb_gadget_strings \-  a set of USB strings in a given language
.SH SYNOPSIS
struct usb_gadget_strings {
.br
.BI "    u16 " language ""
;

.br
.BI "    struct usb_string *" strings ""
;

.br
};
.br
.SH Arguments
.IP "language" 12
identifies the strings' language (0x0409 for en-us)
.IP "strings" 12
array of strings with their ids
.SH "Description"
If you're using \fBusb_gadget_get_string\fP, use this to wrap all the
strings for a given language.
.TH "ntp_clear" 9 "ntp_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntp_clear \-  Clears the NTP state variables
.SH SYNOPSIS
.B "void" ntp_clear
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Must be called while holding a write on the xtime_lock
.TH "ntp_synced" 9 "ntp_synced" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntp_synced \-  Returns 1 if the NTP status is not UNSYNC
.SH SYNOPSIS
.B "int" ntp_synced
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "list_add" 9 "list_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_add \-  add a new entry
.SH SYNOPSIS
.B "void" list_add
.BI "(struct list_head *" new ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "new" 12
 new entry to be added
.IP "head" 12
 list head to add it after
.SH "DESCRIPTION"
Insert a new entry after the specified head.
This is good for implementing stacks.
.TH "list_add_tail" 9 "list_add_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_add_tail \-  add a new entry
.SH SYNOPSIS
.B "void" list_add_tail
.BI "(struct list_head *" new ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "new" 12
 new entry to be added
.IP "head" 12
 list head to add it before
.SH "DESCRIPTION"
Insert a new entry before the specified head.
This is useful for implementing queues.
.TH "list_add_rcu" 9 "list_add_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_add_rcu \-  add a new entry to rcu-protected list
.SH SYNOPSIS
.B "void" list_add_rcu
.BI "(struct list_head *" new ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "new" 12
 new entry to be added
.IP "head" 12
 list head to add it after
.SH "DESCRIPTION"
Insert a new entry after the specified head.
This is good for implementing stacks.

The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBlist_add_rcu\fP
or \fBlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBlist_for_each_entry_rcu\fP.
.TH "list_add_tail_rcu" 9 "list_add_tail_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_add_tail_rcu \-  add a new entry to rcu-protected list
.SH SYNOPSIS
.B "void" list_add_tail_rcu
.BI "(struct list_head *" new ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "new" 12
 new entry to be added
.IP "head" 12
 list head to add it before
.SH "DESCRIPTION"
Insert a new entry before the specified head.
This is useful for implementing queues.

The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBlist_add_tail_rcu\fP
or \fBlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBlist_for_each_entry_rcu\fP.
.TH "list_del" 9 "list_del" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_del \-  deletes entry from list.
.SH SYNOPSIS
.B "void" list_del
.BI "(struct list_head *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 the element to delete from the list.
.SH "NOTE"
 list_empty on entry does not return true after this, the entry is
in an undefined state.
.TH "list_del_rcu" 9 "list_del_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_del_rcu \-  deletes entry from list without re-initialization
.SH SYNOPSIS
.B "void" list_del_rcu
.BI "(struct list_head *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 the element to delete from the list.
.SH "NOTE"
 list_empty on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.

In particular, it means that we can not poison the forward
pointers that may still be used for walking the list.

The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBlist_del_rcu\fP
or \fBlist_add_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBlist_for_each_entry_rcu\fP.

Note that the caller is not permitted to immediately free
the newly deleted entry.  Instead, either \fBsynchronize_rcu\fP
or \fBcall_rcu\fP must be used to defer freeing until an RCU
grace period has elapsed.
.TH "list_del_init" 9 "list_del_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_del_init \-  deletes entry from list and reinitialize it.
.SH SYNOPSIS
.B "void" list_del_init
.BI "(struct list_head *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 the element to delete from the list.
.TH "list_move" 9 "list_move" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_move \-  delete from one list and add as another's head
.SH SYNOPSIS
.B "void" list_move
.BI "(struct list_head *" list ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "list" 12
 the entry to move
.IP "head" 12
 the head that will precede our entry
.TH "list_move_tail" 9 "list_move_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_move_tail \-  delete from one list and add as another's tail
.SH SYNOPSIS
.B "void" list_move_tail
.BI "(struct list_head *" list ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "list" 12
 the entry to move
.IP "head" 12
 the head that will follow our entry
.TH "list_empty" 9 "list_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_empty \-  tests whether a list is empty
.SH SYNOPSIS
.B "int" list_empty
.BI "(const struct list_head *" head ");"
.SH ARGUMENTS
.IP "head" 12
 the list to test.
.TH "list_empty_careful" 9 "list_empty_careful" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_empty_careful \-  tests whether a list is
.SH SYNOPSIS
.B "int" list_empty_careful
.BI "(const struct list_head *" head ");"
.SH ARGUMENTS
.IP "head" 12
 the list to test.
.SH "DESCRIPTION"
empty _and_ checks that no other CPU might be
in the process of still modifying either member
.SH "NOTE"
 using \fBlist_empty_careful\fP without synchronization
can only be safe if the only activity that can happen
to the list entry is \fBlist_del_init\fP. Eg. it cannot be used
if another CPU could re-\fBlist_add\fP it.
.TH "list_splice" 9 "list_splice" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_splice \-  join two lists
.SH SYNOPSIS
.B "void" list_splice
.BI "(struct list_head *" list ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "list" 12
 the new list to add.
.IP "head" 12
 the place to add it in the first list.
.TH "list_splice_init" 9 "list_splice_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_splice_init \-  join two lists and reinitialise the emptied list.
.SH SYNOPSIS
.B "void" list_splice_init
.BI "(struct list_head *" list ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "list" 12
 the new list to add.
.IP "head" 12
 the place to add it in the first list.
.SH "DESCRIPTION"
The list at \fIlist\fP is reinitialised
.TH "list_entry" 9 "list_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_entry \-  get the struct for this entry
.SH SYNOPSIS
.B "" list_entry
.BI "(" ptr ","
.BI "" type ","
.BI "" member ");"
.SH ARGUMENTS
.IP "ptr" 12
	the &amp;struct list_head pointer.
.IP "type" 12
	the type of the struct this is embedded in.
.IP "member" 12
	the name of the list_struct within the struct.
.TH "list_for_each" 9 "list_for_each" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each \- 	iterate over a list
.SH SYNOPSIS
.B "" list_for_each
.BI "(" pos ","
.BI "" head ");"
.SH ARGUMENTS
.IP "pos" 12
	the &amp;struct list_head to use as a loop counter.
.IP "head" 12
	the head for your list.
.TH "__list_for_each" 9 "__list_for_each" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__list_for_each \- 	iterate over a list
.SH SYNOPSIS
.B "" __list_for_each
.BI "(" pos ","
.BI "" head ");"
.SH ARGUMENTS
.IP "pos" 12
	the &amp;struct list_head to use as a loop counter.
.IP "head" 12
	the head for your list.
.SH "DESCRIPTION"
This variant differs from \fBlist_for_each\fP in that it's the
simplest possible list iteration code, no prefetching is done.
Use this for code that knows the list to be very short (empty
or 1 entry) most of the time.
.TH "list_for_each_prev" 9 "list_for_each_prev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_prev \- 	iterate over a list backwards
.SH SYNOPSIS
.B "" list_for_each_prev
.BI "(" pos ","
.BI "" head ");"
.SH ARGUMENTS
.IP "pos" 12
	the &amp;struct list_head to use as a loop counter.
.IP "head" 12
	the head for your list.
.TH "list_for_each_safe" 9 "list_for_each_safe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_safe \- 	iterate over a list safe against removal of list entry
.SH SYNOPSIS
.B "" list_for_each_safe
.BI "(" pos ","
.BI "" n ","
.BI "" head ");"
.SH ARGUMENTS
.IP "pos" 12
	the &amp;struct list_head to use as a loop counter.
.IP "n" 12
		another &amp;struct list_head to use as temporary storage
.IP "head" 12
	the head for your list.
.TH "list_for_each_entry" 9 "list_for_each_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_entry \- 	iterate over list of given type
.SH SYNOPSIS
.B "" list_for_each_entry
.BI "(" pos ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "pos" 12
	the type * to use as a loop counter.
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the list_struct within the struct.
.TH "list_for_each_entry_reverse" 9 "list_for_each_entry_reverse" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_entry_reverse \-  iterate backwards over list of given type.
.SH SYNOPSIS
.B "" list_for_each_entry_reverse
.BI "(" pos ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "pos" 12
	the type * to use as a loop counter.
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the list_struct within the struct.
.TH "list_prepare_entry" 9 "list_prepare_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_prepare_entry \-  prepare a pos entry for use as a start point in
.SH SYNOPSIS
.B "" list_prepare_entry
.BI "(" pos ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "pos" 12
	the type * to use as a start point
.IP "head" 12
	the head of the list
.IP "member" 12
	the name of the list_struct within the struct.
.SH "DESCRIPTION"
list_for_each_entry_continue
.TH "list_for_each_entry_continue" 9 "list_for_each_entry_continue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_entry_continue \- 	iterate over list of given type
.SH SYNOPSIS
.B "" list_for_each_entry_continue
.BI "(" pos ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "pos" 12
	the type * to use as a loop counter.
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the list_struct within the struct.
.SH "DESCRIPTION"
continuing after existing point
.TH "list_for_each_entry_safe" 9 "list_for_each_entry_safe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_entry_safe \-  iterate over list of given type safe against removal of list entry
.SH SYNOPSIS
.B "" list_for_each_entry_safe
.BI "(" pos ","
.BI "" n ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "pos" 12
	the type * to use as a loop counter.
.IP "n" 12
		another type * to use as temporary storage
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the list_struct within the struct.
.TH "list_for_each_entry_safe_continue" 9 "list_for_each_entry_safe_continue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_entry_safe_continue \- 	iterate over list of given type
.SH SYNOPSIS
.B "" list_for_each_entry_safe_continue
.BI "(" pos ","
.BI "" n ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "pos" 12
	the type * to use as a loop counter.
.IP "n" 12
		another type * to use as temporary storage
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the list_struct within the struct.
.SH "DESCRIPTION"
continuing after existing point safe against removal of list entry
.TH "list_for_each_rcu" 9 "list_for_each_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_rcu \- 	iterate over an rcu-protected list
.SH SYNOPSIS
.B "" list_for_each_rcu
.BI "(" pos ","
.BI "" head ");"
.SH ARGUMENTS
.IP "pos" 12
	the &amp;struct list_head to use as a loop counter.
.IP "head" 12
	the head for your list.
.SH "DESCRIPTION"
This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as \fBlist_add_rcu\fP
as long as the traversal is guarded by \fBrcu_read_lock\fP.
.TH "list_for_each_safe_rcu" 9 "list_for_each_safe_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_safe_rcu \- 	iterate over an rcu-protected list safe
.SH SYNOPSIS
.B "" list_for_each_safe_rcu
.BI "(" pos ","
.BI "" n ","
.BI "" head ");"
.SH ARGUMENTS
.IP "pos" 12
	the &amp;struct list_head to use as a loop counter.
.IP "n" 12
		another &amp;struct list_head to use as temporary storage
.IP "head" 12
	the head for your list.
.SH "DESCRIPTION"
This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as \fBlist_add_rcu\fP
as long as the traversal is guarded by \fBrcu_read_lock\fP.
.SH "DESCRIPTION"
This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as \fBlist_add_rcu\fP
as long as the traversal is guarded by \fBrcu_read_lock\fP.
.TH "list_for_each_entry_rcu" 9 "list_for_each_entry_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_entry_rcu \- 	iterate over rcu list of given type
.SH SYNOPSIS
.B "" list_for_each_entry_rcu
.BI "(" pos ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "pos" 12
	the type * to use as a loop counter.
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the list_struct within the struct.
.SH "DESCRIPTION"
This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as \fBlist_add_rcu\fP
as long as the traversal is guarded by \fBrcu_read_lock\fP.
.TH "list_for_each_continue_rcu" 9 "list_for_each_continue_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
list_for_each_continue_rcu \- 	iterate over an rcu-protected list
.SH SYNOPSIS
.B "" list_for_each_continue_rcu
.BI "(" pos ","
.BI "" head ");"
.SH ARGUMENTS
.IP "pos" 12
	the &amp;struct list_head to use as a loop counter.
.IP "head" 12
	the head for your list.
.SH "DESCRIPTION"
This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as \fBlist_add_rcu\fP
as long as the traversal is guarded by \fBrcu_read_lock\fP.
.SH "DESCRIPTION"
This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as \fBlist_add_rcu\fP
as long as the traversal is guarded by \fBrcu_read_lock\fP.
.TH "hlist_del_rcu" 9 "hlist_del_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_del_rcu \-  deletes entry from hash list without re-initialization
.SH SYNOPSIS
.B "void" hlist_del_rcu
.BI "(struct hlist_node *" n ");"
.SH ARGUMENTS
.IP "n" 12
 the element to delete from the hash list.
.SH "NOTE"
 \fBlist_unhashed\fP on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.

In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.

The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBhlist_add_head_rcu\fP
or \fBhlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBhlist_for_each_entry\fP.
.TH "hlist_add_head_rcu" 9 "hlist_add_head_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_add_head_rcu \-  adds the specified element to the specified hlist,
.SH SYNOPSIS
.B "void" hlist_add_head_rcu
.BI "(struct hlist_node *" n ","
.BI "struct hlist_head *" h ");"
.SH ARGUMENTS
.IP "n" 12
 the element to add to the hash list.
.IP "h" 12
 the list to add to.
.SH "DESCRIPTION"
The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBhlist_add_head_rcu\fP
or \fBhlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBhlist_for_each_rcu\fP, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by \fBrcu_read_lock\fP.
.SH "DESCRIPTION"
The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBhlist_add_head_rcu\fP
or \fBhlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBhlist_for_each_rcu\fP, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by \fBrcu_read_lock\fP.
.TH "hlist_add_before_rcu" 9 "hlist_add_before_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_add_before_rcu \-  adds the specified element to the specified hlist
.SH SYNOPSIS
.B "void" hlist_add_before_rcu
.BI "(struct hlist_node *" n ","
.BI "struct hlist_node *" next ");"
.SH ARGUMENTS
.IP "n" 12
 the new element to add to the hash list.
.IP "next" 12
 the existing element to add the new element before.
.SH "DESCRIPTION"
The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBhlist_add_head_rcu\fP
or \fBhlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBhlist_for_each_rcu\fP, used to prevent memory-consistency
problems on Alpha CPUs.
.SH "DESCRIPTION"
The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBhlist_add_head_rcu\fP
or \fBhlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBhlist_for_each_rcu\fP, used to prevent memory-consistency
problems on Alpha CPUs.
.TH "hlist_add_after_rcu" 9 "hlist_add_after_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_add_after_rcu \-  adds the specified element to the specified hlist
.SH SYNOPSIS
.B "void" hlist_add_after_rcu
.BI "(struct hlist_node *" prev ","
.BI "struct hlist_node *" n ");"
.SH ARGUMENTS
.IP "prev" 12
 the existing element to add the new element after.
.IP "n" 12
 the new element to add to the hash list.
.SH "DESCRIPTION"
The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBhlist_add_head_rcu\fP
or \fBhlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBhlist_for_each_rcu\fP, used to prevent memory-consistency
problems on Alpha CPUs.
.SH "DESCRIPTION"
The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as \fBhlist_add_head_rcu\fP
or \fBhlist_del_rcu\fP, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
\fBhlist_for_each_rcu\fP, used to prevent memory-consistency
problems on Alpha CPUs.
.TH "hlist_for_each_entry" 9 "hlist_for_each_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_for_each_entry \-  iterate over list of given type
.SH SYNOPSIS
.B "" hlist_for_each_entry
.BI "(" tpos ","
.BI "" pos ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "tpos" 12
	the type * to use as a loop counter.
.IP "pos" 12
	the &amp;struct hlist_node to use as a loop counter.
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the hlist_node within the struct.
.TH "hlist_for_each_entry_continue" 9 "hlist_for_each_entry_continue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_for_each_entry_continue \-  iterate over a hlist continuing after existing point
.SH SYNOPSIS
.B "" hlist_for_each_entry_continue
.BI "(" tpos ","
.BI "" pos ","
.BI "" member ");"
.SH ARGUMENTS
.IP "tpos" 12
	the type * to use as a loop counter.
.IP "pos" 12
	the &amp;struct hlist_node to use as a loop counter.
.IP "member" 12
	the name of the hlist_node within the struct.
.TH "hlist_for_each_entry_from" 9 "hlist_for_each_entry_from" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_for_each_entry_from \-  iterate over a hlist continuing from existing point
.SH SYNOPSIS
.B "" hlist_for_each_entry_from
.BI "(" tpos ","
.BI "" pos ","
.BI "" member ");"
.SH ARGUMENTS
.IP "tpos" 12
	the type * to use as a loop counter.
.IP "pos" 12
	the &amp;struct hlist_node to use as a loop counter.
.IP "member" 12
	the name of the hlist_node within the struct.
.TH "hlist_for_each_entry_safe" 9 "hlist_for_each_entry_safe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_for_each_entry_safe \-  iterate over list of given type safe against removal of list entry
.SH SYNOPSIS
.B "" hlist_for_each_entry_safe
.BI "(" tpos ","
.BI "" pos ","
.BI "" n ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "tpos" 12
	the type * to use as a loop counter.
.IP "pos" 12
	the &amp;struct hlist_node to use as a loop counter.
.IP "n" 12
		another &amp;struct hlist_node to use as temporary storage
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the hlist_node within the struct.
.TH "hlist_for_each_entry_rcu" 9 "hlist_for_each_entry_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hlist_for_each_entry_rcu \-  iterate over rcu list of given type
.SH SYNOPSIS
.B "" hlist_for_each_entry_rcu
.BI "(" tpos ","
.BI "" pos ","
.BI "" head ","
.BI "" member ");"
.SH ARGUMENTS
.IP "tpos" 12
.IP "pos" 12
	the &amp;struct hlist_node to use as a loop counter.
.IP "head" 12
	the head for your list.
.IP "member" 12
	the name of the hlist_node within the struct.
.SH "DESCRIPTION"
This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as \fBhlist_add_head_rcu\fP
as long as the traversal is guarded by \fBrcu_read_lock\fP.
.TH "Kernel API" 9 "struct rs_control" "January 2021" "API Manual" LINUX
.SH NAME
struct rs_control \-  rs control structure
.SH SYNOPSIS
struct rs_control {
.br
.BI "    int " mm ""
;

.br
.BI "    int " nn ""
;

.br
.BI "    uint16_t *" alpha_to ""
;

.br
.BI "    uint16_t *" index_of ""
;

.br
.BI "    uint16_t *" genpoly ""
;

.br
.BI "    int " nroots ""
;

.br
.BI "    int " fcr ""
;

.br
.BI "    int " prim ""
;

.br
.BI "    int " iprim ""
;

.br
.BI "    int " gfpoly ""
;

.br
.BI "    int " users ""
;

.br
.BI "    struct list_head " list ""
;

.br
};
.br
.SH Arguments
.IP "mm" 12
		Bits per symbol
.IP "nn" 12
		Symbols per block (= (1&lt;&lt;mm)-1)
.IP "alpha_to" 12
	log lookup table
.IP "index_of" 12
	Antilog lookup table
.IP "genpoly" 12
	Generator polynomial 
.IP "nroots" 12
	Number of generator roots = number of parity symbols
.IP "fcr" 12
	First consecutive root, index form
.IP "prim" 12
	Primitive element, index form 
.IP "iprim" 12
	prim-th root of 1, index form 
.IP "gfpoly" 12
	The primitive generator polynominal 
.IP "users" 12
	Users of this structure 
.IP "list" 12
	List entry for the rs control list
.SH "Description"
.TH "mii_nway_result" 9 "mii_nway_result" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mii_nway_result \- 
.SH SYNOPSIS
.B "unsigned int" mii_nway_result
.BI "(unsigned int " negotiated ");"
.SH ARGUMENTS
.IP "negotiated" 12
 value of MII ANAR and'd with ANLPAR
.SH "DESCRIPTION"
Given a set of MII abilities, check each bit and returns the
currently supported media, in the priority order defined by
IEEE 802.3u.  We use LPA_xxx constants but note this is not the
value of LPA solely, as described above.

The one exception to IEEE 802.3u is that 100baseT4 is placed
between 100T-full and 100T-half.  If your phy does not support
100T4 this is fine.  If your phy places 100T4 elsewhere in the
priority order, you will need to roll your own function.
.TH "mii_duplex" 9 "mii_duplex" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mii_duplex \- 
.SH SYNOPSIS
.B "unsigned int" mii_duplex
.BI "(unsigned int " duplex_lock ","
.BI "unsigned int " negotiated ");"
.SH ARGUMENTS
.IP "duplex_lock" 12
 Non-zero if duplex is locked at full
.IP "negotiated" 12
 value of MII ANAR and'd with ANLPAR
.SH "DESCRIPTION"
A small helper function for a common case.  Returns one
if the media is operating or locked at full duplex, and
returns zero otherwise.
.TH "Kernel API" 9 "enum sock_type" "January 2021" "API Manual" LINUX
.SH NAME
enum sock_type \-  Socket types
.SH SYNOPSIS
enum sock_type {
.br
.BI "    SOCK_STREAM"
, 
.br
.br
.BI "    SOCK_DGRAM"
, 
.br
.br
.BI "    SOCK_RAW"
, 
.br
.br
.BI "    SOCK_RDM"
, 
.br
.br
.BI "    SOCK_SEQPACKET"
, 
.br
.br
.BI "    SOCK_DCCP"
, 
.br
.br
.BI "    SOCK_PACKET"

};
.SH Constants
.IP "SOCK_STREAM" 12
 stream (connection) socket
.IP "SOCK_DGRAM" 12
 datagram (conn.less) socket
.IP "SOCK_RAW" 12
 raw socket
.IP "SOCK_RDM" 12
 reliably-delivered message
.IP "SOCK_SEQPACKET" 12
 sequential packet socket
.IP "SOCK_DCCP" 12
-- undescribed --
.IP "SOCK_PACKET" 12
 linux specific way of getting packets at the dev level.
For writing rarp and other similar things on the user level.
.SH "Description"
When adding some new socket type please
grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS
overrides this enum for binary compat reasons.
.TH "Kernel API" 9 "struct socket" "January 2021" "API Manual" LINUX
.SH NAME
struct socket \-  general BSD socket
.SH SYNOPSIS
struct socket {
.br
.BI "    socket_state " state ""
;

.br
.BI "    unsigned long " flags ""
;

.br
.BI "    struct proto_ops *" ops ""
;

.br
.BI "    struct fasync_struct *" fasync_list ""
;

.br
.BI "    struct file *" file ""
;

.br
.BI "    struct sock *" sk ""
;

.br
.BI "    wait_queue_head_t " wait ""
;

.br
.BI "    short " type ""
;

.br
};
.br
.SH Arguments
.IP "state" 12
 socket state (SS_CONNECTED, etc)
.IP "flags" 12
 socket flags (SOCK_ASYNC_NOSPACE, etc)
.IP "ops" 12
 protocol specific socket operations
.IP "fasync_list" 12
 Asynchronous wake up list
.IP "file" 12
 File back pointer for gc
.IP "sk" 12
 internal networking protocol agnostic socket representation
.IP "wait" 12
 wait queue for several uses
.IP "type" 12
 socket type (SOCK_STREAM, etc)
.TH "wait_event" 9 "wait_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_event \-  sleep until a condition gets true
.SH SYNOPSIS
.B "" wait_event
.BI "(" wq ","
.BI "" condition ");"
.SH ARGUMENTS
.IP "wq" 12
 the waitqueue to wait on
.IP "condition" 12
 a C expression for the event to wait for
.SH "DESCRIPTION"
The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
\fIcondition\fP evaluates to true. The \fIcondition\fP is checked each time
the waitqueue \fIwq\fP is woken up.

\fBwake_up\fP has to be called after changing any variable that could
change the result of the wait condition.
.TH "wait_event_timeout" 9 "wait_event_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_event_timeout \-  sleep until a condition gets true or a timeout elapses
.SH SYNOPSIS
.B "" wait_event_timeout
.BI "(" wq ","
.BI "" condition ","
.BI "" timeout ");"
.SH ARGUMENTS
.IP "wq" 12
 the waitqueue to wait on
.IP "condition" 12
 a C expression for the event to wait for
.IP "timeout" 12
 timeout, in jiffies
.SH "DESCRIPTION"
The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
\fIcondition\fP evaluates to true. The \fIcondition\fP is checked each time
the waitqueue \fIwq\fP is woken up.

\fBwake_up\fP has to be called after changing any variable that could
change the result of the wait condition.

The function returns 0 if the \fItimeout\fP elapsed, and the remaining
jiffies if the condition evaluated to true before the timeout elapsed.
.TH "wait_event_interruptible" 9 "wait_event_interruptible" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_event_interruptible \-  sleep until a condition gets true
.SH SYNOPSIS
.B "" wait_event_interruptible
.BI "(" wq ","
.BI "" condition ");"
.SH ARGUMENTS
.IP "wq" 12
 the waitqueue to wait on
.IP "condition" 12
 a C expression for the event to wait for
.SH "DESCRIPTION"
The process is put to sleep (TASK_INTERRUPTIBLE) until the
\fIcondition\fP evaluates to true or a signal is received.
The \fIcondition\fP is checked each time the waitqueue \fIwq\fP is woken up.

\fBwake_up\fP has to be called after changing any variable that could
change the result of the wait condition.

The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if \fIcondition\fP evaluated to true.
.TH "wait_event_interruptible_timeout" 9 "wait_event_interruptible_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_event_interruptible_timeout \-  sleep until a condition gets true or a timeout elapses
.SH SYNOPSIS
.B "" wait_event_interruptible_timeout
.BI "(" wq ","
.BI "" condition ","
.BI "" timeout ");"
.SH ARGUMENTS
.IP "wq" 12
 the waitqueue to wait on
.IP "condition" 12
 a C expression for the event to wait for
.IP "timeout" 12
 timeout, in jiffies
.SH "DESCRIPTION"
The process is put to sleep (TASK_INTERRUPTIBLE) until the
\fIcondition\fP evaluates to true or a signal is received.
The \fIcondition\fP is checked each time the waitqueue \fIwq\fP is woken up.

\fBwake_up\fP has to be called after changing any variable that could
change the result of the wait condition.

The function returns 0 if the \fItimeout\fP elapsed, -ERESTARTSYS if it
was interrupted by a signal, and the remaining jiffies otherwise
if the condition evaluated to true before the timeout elapsed.
.TH "wait_on_bit" 9 "wait_on_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_on_bit \-  wait for a bit to be cleared
.SH SYNOPSIS
.B "int" wait_on_bit
.BI "(void *" word ","
.BI "int " bit ","
.BI "int (*" action ") (void *),"
.BI "unsigned " mode ");"
.SH ARGUMENTS
.IP "word" 12
 the word being waited on, a kernel virtual address
.IP "bit" 12
 the bit of the word being waited on
.IP "action" 12
 the function used to sleep, which may take special actions
.IP "mode" 12
 the task state to sleep in
.SH "DESCRIPTION"
There is a standard hashed waitqueue table for generic use. This
is the part of the hashtable's accessor API that waits on a bit.
For instance, if one were to have waiters on a bitflag, one would
call \fBwait_on_bit\fP in threads waiting for the bit to clear.
One uses \fBwait_on_bit\fP where one is waiting for the bit to clear,
but has no intention of setting it.
.TH "wait_on_bit_lock" 9 "wait_on_bit_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_on_bit_lock \-  wait for a bit to be cleared, when wanting to set it
.SH SYNOPSIS
.B "int" wait_on_bit_lock
.BI "(void *" word ","
.BI "int " bit ","
.BI "int (*" action ") (void *),"
.BI "unsigned " mode ");"
.SH ARGUMENTS
.IP "word" 12
 the word being waited on, a kernel virtual address
.IP "bit" 12
 the bit of the word being waited on
.IP "action" 12
 the function used to sleep, which may take special actions
.IP "mode" 12
 the task state to sleep in
.SH "DESCRIPTION"
There is a standard hashed waitqueue table for generic use. This
is the part of the hashtable's accessor API that waits on a bit
when one intends to set it, for instance, trying to lock bitflags.
For instance, if one were to have waiters trying to set bitflag
and waiting for it to clear before setting it, one would call
\fBwait_on_bit\fP in threads waiting to be able to set the bit.
One uses \fBwait_on_bit_lock\fP where one is waiting for the bit to
clear with the intention of setting it, and when done, clearing it.
.TH "Kernel API" 9 "struct sk_buff" "January 2021" "API Manual" LINUX
.SH NAME
struct sk_buff \-  socket buffer
.SH SYNOPSIS
struct sk_buff {
.br
.BI "    struct sk_buff *" next ""
;

.br
.BI "    struct sk_buff *" prev ""
;

.br
.BI "    struct sock *" sk ""
;

.br
.BI "    struct skb_timeval " tstamp ""
;

.br
.BI "    struct net_device *" dev ""
;

.br
.BI "    struct net_device *" input_dev ""
;

.br
.BI "    union " h ""
;

.br
.BI "    union " nh ""
;

.br
.BI "    union " mac ""
;

.br
.BI "    struct dst_entry *" dst ""
;

.br
.BI "    struct sec_path *" sp ""
;

.br
.BI "    char " cb[40] ""
;

.br
.BI "    unsigned int " len ""
;

.br
.BI "    unsigned int " data_len ""
;

.br
.BI "    unsigned int " mac_len ""
;

.br
.BI "    unsigned int " csum ""
;

.br
.BI "    __u32 " priority ""
;

.br
.BI "    __u8" local_df:1 ""
;

.br
.BI "    __u8" cloned:1 ""
;

.br
.BI "    __u8" ip_summed:2 ""
;

.br
.BI "    __u8" nohdr:1 ""
;

.br
.BI "    __u8" nfctinfo:3 ""
;

.br
.BI "    __u8" pkt_type:3 ""
;

.br
.BI "    __be16 " protocol ""
;

.br
.BI "    void (*" destructor ") (struct sk_buff *skb)"
;

.br
.BI "#ifdef CONFIG_NETFILTER"
.br
.BI "    __u32 " nfmark ""
;

.br
.BI "    struct nf_conntrack *" nfct ""
;

.br
.BI "#if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)"
.br
.BI "#endif"
.br
.BI "#ifdef CONFIG_BRIDGE_NETFILTER"
.br
.BI "    struct nf_bridge_info *" nf_bridge ""
;

.br
.BI "#endif"
.br
.BI "#endif"
.br
.BI "#ifdef CONFIG_NET_SCHED"
.br
.BI "    __u16 " tc_index ""
;

.br
.BI "#ifdef CONFIG_NET_CLS_ACT"
.br
.BI "    __u16 " tc_verd ""
;

.br
.BI "#endif"
.br
.BI "#endif"
.br
.BI "    unsigned int " truesize ""
;

.br
.BI "    atomic_t " users ""
;

.br
.BI "    unsigned char *" head ""
;

.br
.BI "    unsigned char *" data ""
;

.br
.BI "    unsigned char *" tail ""
;

.br
.BI "    unsigned char *" end ""
;

.br
};
.br
.SH Arguments
.IP "next" 12
 Next buffer in list
.IP "prev" 12
 Previous buffer in list
.IP "sk" 12
 Socket we are owned by
.IP "tstamp" 12
 Time we arrived
.IP "dev" 12
 Device we arrived on/are leaving by
.IP "input_dev" 12
 Device we arrived on
.IP "h" 12
 Transport layer header
.IP "nh" 12
 Network layer header
.IP "mac" 12
 Link layer header
.IP "dst" 12
 destination entry
.IP "sp" 12
 the security path, used for xfrm
.IP "cb[40]" 12
 Control buffer. Free for use by every layer. Put private vars here
.IP "len" 12
 Length of actual data
.IP "data_len" 12
 Data length
.IP "mac_len" 12
 Length of link layer header
.IP "csum" 12
 Checksum
.IP "priority" 12
 Packet queueing priority
.IP "local_df" 12
 allow local fragmentation
.IP "cloned" 12
 Head may be cloned (check refcnt to be sure)
.IP "ip_summed" 12
 Driver fed us an IP checksum
.IP "nohdr" 12
 Payload reference only, must not modify header
.IP "nfctinfo" 12
 Relationship of this skb to the connection
.IP "pkt_type" 12
 Packet class
.IP "protocol" 12
 Packet protocol from driver
.IP "destructor" 12
 Destruct function
.IP "nfmark" 12
 Can be used for communication between hooks
.IP "nfct" 12
 Associated connection, if any
.IP "nf_bridge" 12
 Saved data about a bridged frame - see br_netfilter.c
.IP "tc_index" 12
 Traffic control index
.IP "tc_verd" 12
 traffic control verdict
.IP "truesize" 12
 Buffer size 
.IP "users" 12
 User count - see {datagram,tcp}.c
.IP "head" 12
 Head of buffer
.IP "data" 12
 Data head pointer
.IP "tail" 12
 Tail pointer
.IP "end" 12
 End pointer
.TH "skb_queue_empty" 9 "skb_queue_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_empty \-  check if a queue is empty
.SH SYNOPSIS
.B "int" skb_queue_empty
.BI "(const struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 queue head
.SH "DESCRIPTION"
Returns true if the queue is empty, false otherwise.
.TH "skb_get" 9 "skb_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_get \-  reference buffer
.SH SYNOPSIS
.B "struct sk_buff *" skb_get
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to reference
.SH "DESCRIPTION"
Makes another reference to a socket buffer and returns a pointer
to the buffer.
.TH "kfree_skb" 9 "kfree_skb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfree_skb \-  free an sk_buff
.SH SYNOPSIS
.B "void" kfree_skb
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to free
.SH "DESCRIPTION"
Drop a reference to the buffer and free it if the usage count has
hit zero.
.TH "skb_cloned" 9 "skb_cloned" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_cloned \-  is the buffer a clone
.SH SYNOPSIS
.B "int" skb_cloned
.BI "(const struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to check
.SH "DESCRIPTION"
Returns true if the buffer was generated with \fBskb_clone\fP and is
one of multiple shared copies of the buffer. Cloned buffers are
shared data so must not be written to under normal circumstances.
.TH "skb_header_cloned" 9 "skb_header_cloned" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_header_cloned \-  is the header a clone
.SH SYNOPSIS
.B "int" skb_header_cloned
.BI "(const struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to check
.SH "DESCRIPTION"
Returns true if modifying the header part of the buffer requires
the data to be copied.
.TH "skb_header_release" 9 "skb_header_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_header_release \-  release reference to header
.SH SYNOPSIS
.B "void" skb_header_release
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to operate on
.SH "DESCRIPTION"
Drop a reference to the header part of the buffer.  This is done
by acquiring a payload reference.  You must not read from the header
part of skb-&gt;data after this.
.TH "skb_shared" 9 "skb_shared" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_shared \-  is the buffer shared
.SH SYNOPSIS
.B "int" skb_shared
.BI "(const struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to check
.SH "DESCRIPTION"
Returns true if more than one person has a reference to this
buffer.
.TH "skb_share_check" 9 "skb_share_check" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_share_check \-  check if buffer is shared and if so clone it
.SH SYNOPSIS
.B "struct sk_buff *" skb_share_check
.BI "(struct sk_buff *" skb ","
.BI "gfp_t " pri ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to check
.IP "pri" 12
 priority for memory allocation
.SH "DESCRIPTION"
If the buffer is shared the buffer is cloned and the old copy
drops a reference. A new clone with a single reference is returned.
If the buffer is not shared the original buffer is returned. When
being called from interrupt status or with spinlocks held pri must
be GFP_ATOMIC.

NULL is returned on a memory allocation failure.
.TH "skb_unshare" 9 "skb_unshare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_unshare \-  make a copy of a shared buffer
.SH SYNOPSIS
.B "struct sk_buff *" skb_unshare
.BI "(struct sk_buff *" skb ","
.BI "gfp_t " pri ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to check
.IP "pri" 12
 priority for memory allocation
.SH "DESCRIPTION"
If the socket buffer is a clone then this function creates a new
copy of the data, drops a reference count on the old copy and returns
the new copy with the reference count at 1. If the buffer is not a clone
the original buffer is returned. When called with a spinlock held or
from interrupt state \fIpri\fP must be GFP_ATOMIC

NULL is returned on a memory allocation failure.
.TH "skb_peek" 9 "skb_peek" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_peek \- 
.SH SYNOPSIS
.B "struct sk_buff *" skb_peek
.BI "(struct sk_buff_head *" list_ ");"
.SH ARGUMENTS
.IP "list_" 12
 list to peek at
.SH "DESCRIPTION"
Peek an &amp;sk_buff. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.

Returns NULL for an empty list or a pointer to the head element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.
.TH "skb_peek_tail" 9 "skb_peek_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_peek_tail \- 
.SH SYNOPSIS
.B "struct sk_buff *" skb_peek_tail
.BI "(struct sk_buff_head *" list_ ");"
.SH ARGUMENTS
.IP "list_" 12
 list to peek at
.SH "DESCRIPTION"
Peek an &amp;sk_buff. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.

Returns NULL for an empty list or a pointer to the tail element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.
.TH "skb_queue_len" 9 "skb_queue_len" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_len \-  get queue length
.SH SYNOPSIS
.B "__u32" skb_queue_len
.BI "(const struct sk_buff_head *" list_ ");"
.SH ARGUMENTS
.IP "list_" 12
 list to measure
.SH "DESCRIPTION"
Return the length of an &amp;sk_buff queue.
.TH "skb_queue_head" 9 "skb_queue_head" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_head \-  queue a buffer at the list head
.SH SYNOPSIS
.B "void" skb_queue_head
.BI "(struct sk_buff_head *" list ","
.BI "struct sk_buff *" newsk ");"
.SH ARGUMENTS
.IP "list" 12
 list to use
.IP "newsk" 12
 buffer to queue
.SH "DESCRIPTION"
Queue a buffer at the start of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.
.TH "skb_queue_tail" 9 "skb_queue_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_tail \-  queue a buffer at the list tail
.SH SYNOPSIS
.B "void" skb_queue_tail
.BI "(struct sk_buff_head *" list ","
.BI "struct sk_buff *" newsk ");"
.SH ARGUMENTS
.IP "list" 12
 list to use
.IP "newsk" 12
 buffer to queue
.SH "DESCRIPTION"
Queue a buffer at the end of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.
.TH "skb_dequeue" 9 "skb_dequeue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_dequeue \-  remove from the head of the queue
.SH SYNOPSIS
.B "struct sk_buff *" skb_dequeue
.BI "(struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list to dequeue from
.SH "DESCRIPTION"
Remove the head of the list. This function does not take any locks
so must be used with appropriate locks held only. The head item is
returned or NULL if the list is empty.
.TH "skb_dequeue_tail" 9 "skb_dequeue_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_dequeue_tail \-  remove from the tail of the queue
.SH SYNOPSIS
.B "struct sk_buff *" skb_dequeue_tail
.BI "(struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list to dequeue from
.SH "DESCRIPTION"
Remove the tail of the list. This function does not take any locks
so must be used with appropriate locks held only. The tail item is
returned or NULL if the list is empty.
.TH "skb_put" 9 "skb_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_put \-  add data to a buffer
.SH SYNOPSIS
.B "unsigned char *" skb_put
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to use
.IP "len" 12
 amount of data to add
.SH "DESCRIPTION"
This function extends the used data area of the buffer. If this would
exceed the total buffer size the kernel will panic. A pointer to the
first byte of the extra data is returned.
.TH "skb_push" 9 "skb_push" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_push \-  add data to the start of a buffer
.SH SYNOPSIS
.B "unsigned char *" skb_push
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to use
.IP "len" 12
 amount of data to add
.SH "DESCRIPTION"
This function extends the used data area of the buffer at the buffer
start. If this would exceed the total buffer headroom the kernel will
panic. A pointer to the first byte of the extra data is returned.
.TH "skb_pull" 9 "skb_pull" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_pull \-  remove data from the start of a buffer
.SH SYNOPSIS
.B "unsigned char *" skb_pull
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to use
.IP "len" 12
 amount of data to remove
.SH "DESCRIPTION"
This function removes data from the start of a buffer, returning
the memory to the headroom. A pointer to the next data in the buffer
is returned. Once the data has been pulled future pushes will overwrite
the old data.
.TH "skb_headroom" 9 "skb_headroom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_headroom \-  bytes at buffer head
.SH SYNOPSIS
.B "int" skb_headroom
.BI "(const struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to check
.SH "DESCRIPTION"
Return the number of bytes of free space at the head of an &amp;sk_buff.
.TH "skb_tailroom" 9 "skb_tailroom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_tailroom \-  bytes at buffer end
.SH SYNOPSIS
.B "int" skb_tailroom
.BI "(const struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to check
.SH "DESCRIPTION"
Return the number of bytes of free space at the tail of an sk_buff
.TH "skb_reserve" 9 "skb_reserve" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_reserve \-  adjust headroom
.SH SYNOPSIS
.B "void" skb_reserve
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to alter
.IP "len" 12
 bytes to move
.SH "DESCRIPTION"
Increase the headroom of an empty &amp;sk_buff by reducing the tail
room. This is only allowed for an empty buffer.
.TH "skb_trim" 9 "skb_trim" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_trim \-  remove end from a buffer
.SH SYNOPSIS
.B "void" skb_trim
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to alter
.IP "len" 12
 new length
.SH "DESCRIPTION"
Cut the length of a buffer down by removing data from the tail. If
the buffer is already under the length specified it is not modified.
.TH "skb_orphan" 9 "skb_orphan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_orphan \-  orphan a buffer
.SH SYNOPSIS
.B "void" skb_orphan
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to orphan
.SH "DESCRIPTION"
If a buffer currently has an owner then we call the owner's
destructor function and make the \fIskb\fP unowned. The buffer continues
to exist but is no longer charged to its former owner.
.TH "skb_queue_purge" 9 "skb_queue_purge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_purge \-  empty a list
.SH SYNOPSIS
.B "void" skb_queue_purge
.BI "(struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list to empty
.SH "DESCRIPTION"
Delete all buffers on an &amp;sk_buff list. Each buffer is removed from
the list and one reference dropped. This function does not take the
list lock and the caller must hold the relevant locks to use it.
.TH "__dev_alloc_skb" 9 "__dev_alloc_skb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__dev_alloc_skb \-  allocate an skbuff for sending
.SH SYNOPSIS
.B "struct sk_buff *" __dev_alloc_skb
.BI "(unsigned int " length ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "length" 12
 length to allocate
.IP "gfp_mask" 12
 get_free_pages mask, passed to alloc_skb
.SH "DESCRIPTION"
Allocate a new &amp;sk_buff and assign it a usage count of one. The
buffer has unspecified headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.

NULL is returned in there is no free memory.
.TH "dev_alloc_skb" 9 "dev_alloc_skb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_alloc_skb \-  allocate an skbuff for sending
.SH SYNOPSIS
.B "struct sk_buff *" dev_alloc_skb
.BI "(unsigned int " length ");"
.SH ARGUMENTS
.IP "length" 12
 length to allocate
.SH "DESCRIPTION"
Allocate a new &amp;sk_buff and assign it a usage count of one. The
buffer has unspecified headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.

NULL is returned in there is no free memory. Although this function
allocates memory it can be called from an interrupt.
.TH "skb_cow" 9 "skb_cow" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_cow \-  copy header of skb when it is required
.SH SYNOPSIS
.B "int" skb_cow
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " headroom ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to cow
.IP "headroom" 12
 needed headroom
.SH "DESCRIPTION"
If the skb passed lacks sufficient headroom or its data part
is shared, data is reallocated. If reallocation fails, an error
is returned and original skb is not changed.

The result is skb with writable area skb-&gt;head...skb-&gt;tail
and at least \fIheadroom\fP of space at head.
.TH "skb_padto" 9 "skb_padto" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_padto \-  pad an skbuff up to a minimal size
.SH SYNOPSIS
.B "struct sk_buff *" skb_padto
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to pad
.IP "len" 12
 minimal length
.SH "DESCRIPTION"
Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Returns the buffer, which may be a replacement
for the original, or NULL for out of memory - in which case
the original buffer is still freed.
.TH "__skb_linearize" 9 "__skb_linearize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__skb_linearize \-  convert paged skb to linear one
.SH SYNOPSIS
.B "int" __skb_linearize
.BI "(struct sk_buff *" skb ","
.BI "gfp_t " gfp ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to linarize
.IP "gfp" 12
 allocation mode
.SH "DESCRIPTION"
If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.
.TH "skb_postpull_rcsum" 9 "skb_postpull_rcsum" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_postpull_rcsum \-  update checksum for received skb after pull
.SH SYNOPSIS
.B "void" skb_postpull_rcsum
.BI "(struct sk_buff *" skb ","
.BI "const void *" start ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to update
.IP "start" 12
 start of data before pull
.IP "len" 12
 length of data pulled
.SH "DESCRIPTION"
After doing a pull on a received packet, you need to call this to
update the CHECKSUM_HW checksum, or set ip_summed to CHECKSUM_NONE
so that it can be recomputed from scratch.
.TH "pskb_trim_rcsum" 9 "pskb_trim_rcsum" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pskb_trim_rcsum \-  trim received skb and update checksum
.SH SYNOPSIS
.B "int" pskb_trim_rcsum
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to trim
.IP "len" 12
 new length
.SH "DESCRIPTION"
This is exactly the same as pskb_trim except that it ensures the
checksum of received packets are still valid after the operation.
.TH "skb_get_timestamp" 9 "skb_get_timestamp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_get_timestamp \-  get timestamp from a skb
.SH SYNOPSIS
.B "void" skb_get_timestamp
.BI "(const struct sk_buff *" skb ","
.BI "struct timeval *" stamp ");"
.SH ARGUMENTS
.IP "skb" 12
 skb to get stamp from
.IP "stamp" 12
 pointer to struct timeval to store stamp in
.SH "DESCRIPTION"
Timestamps are stored in the skb as offsets to a base timestamp.
This function converts the offset back to a struct timeval and stores
it in stamp.
.TH "skb_set_timestamp" 9 "skb_set_timestamp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_set_timestamp \-  set timestamp of a skb
.SH SYNOPSIS
.B "void" skb_set_timestamp
.BI "(struct sk_buff *" skb ","
.BI "const struct timeval *" stamp ");"
.SH ARGUMENTS
.IP "skb" 12
 skb to set stamp of
.IP "stamp" 12
 pointer to struct timeval to get stamp from
.SH "DESCRIPTION"
Timestamps are stored in the skb as offsets to a base timestamp.
This function converts a struct timeval to an offset and stores
it in the skb.
.TH "for_each_pgdat" 9 "for_each_pgdat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
for_each_pgdat \-  helper macro to iterate over all nodes
.SH SYNOPSIS
.B "" for_each_pgdat
.BI "(" pgdat ");"
.SH ARGUMENTS
.IP "pgdat" 12
.SH "DESCRIPTION"
\fIpgdat\fP - pointer to a pg_data_t variable

Meant to help with common loops of the form
pgdat = pgdat_list;
while(pgdat) {
...
pgdat = pgdat-&gt;pgdat_next;
}
.TH "for_each_zone" 9 "for_each_zone" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
for_each_zone \-  helper macro to iterate over all memory zones
.SH SYNOPSIS
.B "" for_each_zone
.BI "(" zone ");"
.SH ARGUMENTS
.IP "zone" 12
.SH "DESCRIPTION"
\fIzone\fP - pointer to struct zone variable

The user only needs to declare the zone variable, for_each_zone
fills it in. This basically means \fBfor_each_zone\fP is an
.SH "EASIER TO READ VERSION OF THIS PIECE OF CODE"

for (pgdat = pgdat_list; pgdat; pgdat = pgdat-&gt;node_next)
for (i = 0; i &lt; MAX_NR_ZONES; ++i) {
struct zone * z = pgdat-&gt;node_zones + i;
...
}
}
.TH "is_highmem" 9 "is_highmem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_highmem \-  helper function to quickly check if a struct zone is a 
.SH SYNOPSIS
.B "int" is_highmem
.BI "(struct zone *" zone ");"
.SH ARGUMENTS
.IP "zone" 12
-- undescribed --
.SH "DESCRIPTION"
highmem zone or not.  This is an attempt to keep references
to ZONE_{DMA/NORMAL/HIGHMEM/etc} in general code to a minimum.
\fIzone\fP - pointer to struct zone variable
.TH "FOPEN_DIRECT_IO" 9 "FOPEN_DIRECT_IO" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
FOPEN_DIRECT_IO \- 
.SH SYNOPSIS
.B "" FOPEN_DIRECT_IO
.BI "(1 << " 0 ");"
.SH ARGUMENTS
.IP "0" 12
-- undescribed --
.SH "DESCRIPTION"
.SH "FOPEN_DIRECT_IO"
 bypass page cache for this open file
.SH "FOPEN_KEEP_CACHE"
 don't invalidate the data cache on open
.TH "cpufreq_scale" 9 "cpufreq_scale" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpufreq_scale \-  "old * mult / div" calculation for large values (32-bit-arch safe)
.SH SYNOPSIS
.B "unsigned long" cpufreq_scale
.BI "(unsigned long " old ","
.BI "u_int " div ","
.BI "u_int " mult ");"
.SH ARGUMENTS
.IP "old" 12
   old value
.IP "div" 12
   divisor
.IP "mult" 12
  multiplier
.SH "DESCRIPTION"

new = old * mult / div
.TH "cond_resched" 9 "cond_resched" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cond_resched \-  annotation for functions that can sleep
.SH SYNOPSIS
.B "int" cond_resched
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

this macro will print a stack trace if it is executed in an atomic
context (spinlock, irq-handler, ...).

This is a useful debugging help to be able to catch problems early and not
be biten later when the calling function happens to sleep when it is not
supposed to.
.TH "container_of" 9 "container_of" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
container_of \-  cast a member of a structure out to the containing structure
.SH SYNOPSIS
.B "" container_of
.BI "(" ptr ","
.BI "" type ","
.BI "" member ");"
.SH ARGUMENTS
.IP "ptr" 12
	the pointer to the member.
.IP "type" 12
	the type of the container struct this is embedded in.
.IP "member" 12
	the name of the member within the struct.
.SH "DESCRIPTION"
.TH "Kernel API" 9 "struct nand_hw_control" "January 2021" "API Manual" LINUX
.SH NAME
struct nand_hw_control \-  Control structure for hardware controller (e.g ECC generator) shared among independend devices
.SH SYNOPSIS
struct nand_hw_control {
.br
.BI "    spinlock_t " lock ""
;

.br
.BI "    struct nand_chip *" active ""
;

.br
.BI "    wait_queue_head_t " wq ""
;

.br
};
.br
.SH Arguments
.IP "lock" 12
               protection lock  
.IP "active" 12
		the mtd device which holds the controller currently
.IP "wq" 12
			wait queue to sleep on if a NAND operation is in progress
used instead of the per chip wait queue when a hw controller is available
.TH "Kernel API" 9 "struct nand_chip" "January 2021" "API Manual" LINUX
.SH NAME
struct nand_chip \-  NAND Private Flash Chip Data
.SH SYNOPSIS
struct nand_chip {
.br
.BI "    void __iomem *" IO_ADDR_R ""
;

.br
.BI "    void __iomem *" IO_ADDR_W ""
;

.br
.BI "    u_char (*" read_byte ") (struct mtd_info *mtd)"
;

.br
.BI "    void (*" write_byte ") (struct mtd_info *mtd, u_char byte)"
;

.br
.BI "    u16 (*" read_word ") (struct mtd_info *mtd)"
;

.br
.BI "    void (*" write_word ") (struct mtd_info *mtd, u16 word)"
;

.br
.BI "    void (*" write_buf ") (struct mtd_info *mtd, const u_char *buf, int len)"
;

.br
.BI "    void (*" read_buf ") (struct mtd_info *mtd, u_char *buf, int len)"
;

.br
.BI "    int (*" verify_buf ") (struct mtd_info *mtd, const u_char *buf, int len)"
;

.br
.BI "    void (*" select_chip ") (struct mtd_info *mtd, int chip)"
;

.br
.BI "    int (*" block_bad ") (struct mtd_info *mtd, loff_t ofs, int getchip)"
;

.br
.BI "    int (*" block_markbad ") (struct mtd_info *mtd, loff_t ofs)"
;

.br
.BI "    void (*" hwcontrol ") (struct mtd_info *mtd, int cmd)"
;

.br
.BI "    int (*" dev_ready ") (struct mtd_info *mtd)"
;

.br
.BI "    void (*" cmdfunc ") (struct mtd_info *mtd, unsigned command, int column, int page_addr)"
;

.br
.BI "    int (*" waitfunc ") (struct mtd_info *mtd, struct nand_chip *this, int state)"
;

.br
.BI "    int (*" calculate_ecc ") (struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)"
;

.br
.BI "    int (*" correct_data ") (struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)"
;

.br
.BI "    void (*" enable_hwecc ") (struct mtd_info *mtd, int mode)"
;

.br
.BI "    void (*" erase_cmd ") (struct mtd_info *mtd, int page)"
;

.br
.BI "    int (*" scan_bbt ") (struct mtd_info *mtd)"
;

.br
.BI "    int " eccmode ""
;

.br
.BI "    int " eccsize ""
;

.br
.BI "    int " eccbytes ""
;

.br
.BI "    int " eccsteps ""
;

.br
.BI "    int " chip_delay ""
;

.br
.BI "    spinlock_t " chip_lock ""
;

.br
.BI "    wait_queue_head_t " wq ""
;

.br
.BI "    nand_state_t " state ""
;

.br
.BI "    int " page_shift ""
;

.br
.BI "    int " phys_erase_shift ""
;

.br
.BI "    int " bbt_erase_shift ""
;

.br
.BI "    int " chip_shift ""
;

.br
.BI "    u_char *" data_buf ""
;

.br
.BI "    u_char *" oob_buf ""
;

.br
.BI "    int " oobdirty ""
;

.br
.BI "    u_char *" data_poi ""
;

.br
.BI "    unsigned int " options ""
;

.br
.BI "    int " badblockpos ""
;

.br
.BI "    int " numchips ""
;

.br
.BI "    unsigned long " chipsize ""
;

.br
.BI "    int " pagemask ""
;

.br
.BI "    int " pagebuf ""
;

.br
.BI "    struct nand_oobinfo *" autooob ""
;

.br
.BI "    uint8_t *" bbt ""
;

.br
.BI "    struct nand_bbt_descr *" bbt_td ""
;

.br
.BI "    struct nand_bbt_descr *" bbt_md ""
;

.br
.BI "    struct nand_bbt_descr *" badblock_pattern ""
;

.br
.BI "    struct nand_hw_control *" controller ""
;

.br
.BI "    void *" priv ""
;

.br
.BI "    int (*" errstat ") (struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page)"
;

.br
};
.br
.SH Arguments
.IP "IO_ADDR_R" 12
		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device 
.IP "IO_ADDR_W" 12
		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device 
.IP "read_byte" 12
		[REPLACEABLE] read one byte from the chip
.IP "write_byte" 12
		[REPLACEABLE] write one byte to the chip
.IP "read_word" 12
		[REPLACEABLE] read one word from the chip
.IP "write_word" 12
		[REPLACEABLE] write one word to the chip
.IP "write_buf" 12
		[REPLACEABLE] write data from the buffer to the chip
.IP "read_buf" 12
		[REPLACEABLE] read data from the chip into the buffer
.IP "verify_buf" 12
		[REPLACEABLE] verify buffer contents against the chip data
.IP "select_chip" 12
	[REPLACEABLE] select chip nr
.IP "block_bad" 12
		[REPLACEABLE] check, if the block is bad
.IP "block_markbad" 12
	[REPLACEABLE] mark the block bad
.IP "hwcontrol" 12
		[BOARDSPECIFIC] hardwarespecific function for accesing control-lines
.IP "dev_ready" 12
		[BOARDSPECIFIC] hardwarespecific function for accesing device ready/busy line
If set to NULL no access to ready/busy is available and the ready/busy information
is read from the chip status register
.IP "cmdfunc" 12
		[REPLACEABLE] hardwarespecific function for writing commands to the chip
.IP "waitfunc" 12
		[REPLACEABLE] hardwarespecific function for wait on ready
.IP "calculate_ecc" 12
 	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
.IP "correct_data" 12
	[REPLACEABLE] function for ecc correction, matching to ecc generator (sw/hw)
.IP "enable_hwecc" 12
	[BOARDSPECIFIC] function to enable (reset) hardware ecc generator. Must only
be provided if a hardware ECC is available
.IP "erase_cmd" 12
		[INTERN] erase command write function, selectable due to AND support
.IP "scan_bbt" 12
		[REPLACEABLE] function to scan bad block table
.IP "eccmode" 12
		[BOARDSPECIFIC] mode of ecc, see defines 
.IP "eccsize" 12
 		[INTERN] databytes used per ecc-calculation
.IP "eccbytes" 12
 		[INTERN] number of ecc bytes per ecc-calculation step
.IP "eccsteps" 12
		[INTERN] number of ecc calculation steps per page
.IP "chip_delay" 12
		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
.IP "chip_lock" 12
		[INTERN] spinlock used to protect access to this structure and the chip
.IP "wq" 12
			[INTERN] wait queue to sleep on if a NAND operation is in progress
.IP "state" 12
 		[INTERN] the current state of the NAND device
.IP "page_shift" 12
		[INTERN] number of address bits in a page (column address bits)
.IP "phys_erase_shift" 12
	[INTERN] number of address bits in a physical eraseblock
.IP "bbt_erase_shift" 12
	[INTERN] number of address bits in a bbt entry
.IP "chip_shift" 12
		[INTERN] number of address bits in one chip
.IP "data_buf" 12
		[INTERN] internal buffer for one page + oob 
.IP "oob_buf" 12
		[INTERN] oob buffer for one eraseblock
.IP "oobdirty" 12
		[INTERN] indicates that oob_buf must be reinitialized
.IP "data_poi" 12
		[INTERN] pointer to a data buffer
.IP "options" 12
		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
special functionality. See the defines for further explanation
.IP "badblockpos" 12
	[INTERN] position of the bad block marker in the oob area
.IP "numchips" 12
		[INTERN] number of physical chips
.IP "chipsize" 12
		[INTERN] the size of one chip for multichip arrays
.IP "pagemask" 12
		[INTERN] page number mask = number of (pages / chip) - 1
.IP "pagebuf" 12
		[INTERN] holds the pagenumber which is currently in data_buf
.IP "autooob" 12
		[REPLACEABLE] the default (auto)placement scheme
.IP "bbt" 12
		[INTERN] bad block table pointer
.IP "bbt_td" 12
		[REPLACEABLE] bad block table descriptor for flash lookup
.IP "bbt_md" 12
		[REPLACEABLE] bad block table mirror descriptor
.IP "badblock_pattern" 12
	[REPLACEABLE] bad block scan pattern used for initial bad block scan 
.IP "controller" 12
		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
.IP "priv" 12
		[OPTIONAL] pointer to private chip date
.IP "errstat" 12
		[OPTIONAL] hardware specific function to perform additional error status checks 
(determine if errors are correctable)
.TH "Kernel API" 9 "struct nand_flash_dev" "January 2021" "API Manual" LINUX
.SH NAME
struct nand_flash_dev \-  NAND Flash Device ID Structure
.SH SYNOPSIS
struct nand_flash_dev {
.br
.BI "    char *" name ""
;

.br
.BI "    int " id ""
;

.br
.BI "    unsigned long " pagesize ""
;

.br
.BI "    unsigned long " chipsize ""
;

.br
.BI "    unsigned long " erasesize ""
;

.br
.BI "    unsigned long " options ""
;

.br
};
.br
.SH Arguments
.IP "name" 12
  	Identify the device type
.IP "id" 12
   	device ID code
.IP "pagesize" 12
  	Pagesize in bytes. Either 256 or 512 or 0
If the pagesize is 0, then the real pagesize 
and the eraseize are determined from the
extended id bytes in the chip
.IP "chipsize" 12
  	Total chipsize in Mega Bytes
.IP "erasesize" 12
 	Size of an erase block in the flash device.
.IP "options" 12
	Bitfield to store chip relevant options
.SH "Description"
.TH "Kernel API" 9 "struct nand_manufacturers" "January 2021" "API Manual" LINUX
.SH NAME
struct nand_manufacturers \-  NAND Flash Manufacturer ID Structure
.SH SYNOPSIS
struct nand_manufacturers {
.br
.BI "    int " id ""
;

.br
.BI "    char *" name ""
;

.br
};
.br
.SH Arguments
.IP "id" 12
 	manufacturer ID code of device.
.IP "name" 12
	Manufacturer name
.TH "Kernel API" 9 "struct nand_bbt_descr" "January 2021" "API Manual" LINUX
.SH NAME
struct nand_bbt_descr \-  bad block table descriptor
.SH SYNOPSIS
struct nand_bbt_descr {
.br
.BI "    int " options ""
;

.br
.BI "    int " pages[NAND_MAX_CHIPS] ""
;

.br
.BI "    int " offs ""
;

.br
.BI "    int " veroffs ""
;

.br
.BI "    uint8_t " version[NAND_MAX_CHIPS] ""
;

.br
.BI "    int " len ""
;

.br
.BI "    int " maxblocks ""
;

.br
.BI "    int " reserved_block_code ""
;

.br
.BI "    uint8_t *" pattern ""
;

.br
};
.br
.SH Arguments
.IP "options" 12
	options for this descriptor
.IP "pages[NAND_MAX_CHIPS]" 12
	the page(s) where we find the bbt, used with option BBT_ABSPAGE
when bbt is searched, then we store the found bbts pages here.
Its an array and supports up to 8 chips now
.IP "offs" 12
	offset of the pattern in the oob area of the page
.IP "veroffs" 12
	offset of the bbt version counter in the oob are of the page
.IP "version[NAND_MAX_CHIPS]" 12
	version read from the bbt page during scan
.IP "len" 12
	length of the pattern, if 0 no pattern check is performed
.IP "maxblocks" 12
	maximum number of blocks to search for a bbt. This number of
blocks is reserved at the end of the device where the tables are 
written.
.IP "reserved_block_code" 12
 if non-0, this pattern denotes a reserved (rather than
bad) block in the stored bbt
.IP "pattern" 12
	pattern to identify bad block table or factory marked good / 
bad blocks, can be NULL, if len = 0
.SH "Description"
Descriptor for the bad block table marker and the descriptor for the 
pattern which identifies good and bad blocks. The assumption is made
that the pattern and the version count are always located in the oob area
of the first block.
.TH "__d_drop" 9 "__d_drop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__d_drop \-  drop a dentry
.SH SYNOPSIS
.B "void" __d_drop
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry to drop
.SH "DESCRIPTION"
\fBd_drop\fP unhashes the entry from the parent dentry hashes, so that it won't
be found through a VFS lookup any more. Note that this is different from
deleting the dentry - d_delete will try to mark the dentry negative if
possible, giving a successful _negative_ lookup, while d_drop will
just make the cache lookup fail.

\fBd_drop\fP is used mainly for stuff that wants to invalidate a dentry for some
reason (NFS timeouts or autofs deletes).

__d_drop requires dentry-&gt;d_lock.
.TH "d_add" 9 "d_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_add \-  add dentry to hash queues
.SH SYNOPSIS
.B "void" d_add
.BI "(struct dentry *" entry ","
.BI "struct inode *" inode ");"
.SH ARGUMENTS
.IP "entry" 12
 dentry to add
.IP "inode" 12
 The inode to attach to this dentry
.SH "DESCRIPTION"
This adds the entry to the hash queues and initializes \fIinode\fP.
The entry was actually filled in earlier during \fBd_alloc\fP.
.TH "d_add_unique" 9 "d_add_unique" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_add_unique \-  add dentry to hash queues without aliasing
.SH SYNOPSIS
.B "struct dentry *" d_add_unique
.BI "(struct dentry *" entry ","
.BI "struct inode *" inode ");"
.SH ARGUMENTS
.IP "entry" 12
 dentry to add
.IP "inode" 12
 The inode to attach to this dentry
.SH "DESCRIPTION"
This adds the entry to the hash queues and initializes \fIinode\fP.
The entry was actually filled in earlier during \fBd_alloc\fP.
.TH "dget" 9 "dget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dget \- 	get a reference to a dentry
.SH SYNOPSIS
.B "struct dentry *" dget
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry to get a reference to
.SH "DESCRIPTION"
Given a dentry or NULL pointer increment the reference count
if appropriate and return the dentry. A dentry will not be 
destroyed when it has references. \fBdget\fP should never be
called for dentries with zero reference counter. For these cases
(preferably none, functions in dcache.c are sufficient for normal
needs and they take necessary precautions) you should hold dcache_lock
and call \fBdget_locked\fP instead of \fBdget\fP.
.TH "d_unhashed" 9 "d_unhashed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_unhashed \- 	is dentry hashed
.SH SYNOPSIS
.B "int" d_unhashed
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 entry to check
.SH "DESCRIPTION"
Returns true if the dentry passed is not currently hashed.
.TH "get_device" 9 "get_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_device \-  atomically increment the reference count for the device.
.SH SYNOPSIS
.B "struct device *" get_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "parport_yield" 9 "parport_yield" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_yield \-  relinquish a parallel port temporarily
.SH SYNOPSIS
.B "int" parport_yield
.BI "(struct pardevice *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 a device on the parallel port
.SH "DESCRIPTION"
This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
\fBparport_claim\fP, and the return value is the same as for
\fBparport_claim\fP.  If it fails, the port is left unclaimed and it is
the driver's responsibility to reclaim the port.

The \fBparport_yield\fP and \fBparport_yield_blocking\fP functions are for
marking points in the driver at which other drivers may claim the
port and use their devices.  Yielding the port is similar to
releasing it and reclaiming it, but is more efficient because no
action is taken if there are no other devices needing the port.  In
fact, nothing is done even if there are other devices waiting but
the current device is still within its "timeslice".  The default
timeslice is half a second, but it can be adjusted via the /proc
interface.
.TH "parport_yield_blocking" 9 "parport_yield_blocking" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_yield_blocking \-  relinquish a parallel port temporarily
.SH SYNOPSIS
.B "int" parport_yield_blocking
.BI "(struct pardevice *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 a device on the parallel port
.SH "DESCRIPTION"
This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
\fBparport_claim_or_block\fP, and the return value is the same as for
\fBparport_claim_or_block\fP.
.TH "get_unaligned" 9 "get_unaligned" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_unaligned \-  get value from possibly mis-aligned location
.SH SYNOPSIS
.B "" get_unaligned
.BI "(" ptr ");"
.SH ARGUMENTS
.IP "ptr" 12
 pointer to value
.SH "DESCRIPTION"
This macro should be used for accessing values larger in size than 
single bytes at locations that are expected to be improperly aligned, 
e.g. retrieving a u16 value from a location not u16-aligned.

Note that unaligned accesses can be very expensive on some architectures.
.TH "put_unaligned" 9 "put_unaligned" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_unaligned \-  put value to a possibly mis-aligned location
.SH SYNOPSIS
.B "" put_unaligned
.BI "(" val ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "val" 12
 value to place
.IP "ptr" 12
 pointer to location
.SH "DESCRIPTION"
This macro should be used for placing values larger in size than 
single bytes at locations that are expected to be improperly aligned, 
e.g. writing a u16 value to a location not u16-aligned.

Note that unaligned accesses can be very expensive on some architectures.
.TH "check_signature" 9 "check_signature" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_signature \- 	find BIOS signatures
.SH SYNOPSIS
.B "int" check_signature
.BI "(void __iomem *" io_addr ","
.BI "const unsigned char *" signature ","
.BI "int " length ");"
.SH ARGUMENTS
.IP "io_addr" 12
 mmio address to check 
.IP "signature" 12
  signature block
.IP "length" 12
 length of signature
.SH "DESCRIPTION"
Perform a signature comparison with the mmio address io_addr. This
address should have been obtained by ioremap.
Returns 1 on a match.
.TH "set_bit" 9 "set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_bit \-  Atomically set a bit in memory
.SH SYNOPSIS
.B "void" set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
This function is atomic and may not be reordered.  See \fB__set_bit\fP
if you do not require the atomic guarantees.
Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.
.TH "__set_bit" 9 "__set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__set_bit \-  Set a bit in memory
.SH SYNOPSIS
.B "void" __set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBset_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "clear_bit" 9 "clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clear_bit \-  Clears a bit in memory
.SH SYNOPSIS
.B "void" clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBclear_bit\fP is atomic and may not be reordered.  However, it does
not contain a memory barrier, so if it is used for locking purposes,
you should call \fBsmp_mb__before_clear_bit\fP and/or \fBsmp_mb__after_clear_bit\fP
in order to ensure changes are visible on other processors.
.TH "__change_bit" 9 "__change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" __change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to change
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBchange_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "change_bit" 9 "change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to change
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBchange_bit\fP is atomic and may not be reordered.
Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.
.TH "test_and_set_bit" 9 "test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "__test_and_set_bit" 9 "__test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.  
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_clear_bit" 9 "test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "__test_and_clear_bit" 9 "__test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.  
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_change_bit" 9 "test_and_change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_change_bit \-  Change a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to change
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "test_bit" 9 "test_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_bit \-  Determine whether a bit is set
.SH SYNOPSIS
.B "int" test_bit
.BI "(int " nr ","
.BI "const volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 bit number to test
.IP "addr" 12
 Address to start counting from
.TH "ffz" 9 "ffz" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffz \-  find first zero in word.
.SH SYNOPSIS
.B "unsigned long" ffz
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no zero exists, so code should check against ~0UL first.
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "ffs" 9 "ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffs \-  find first bit set
.SH SYNOPSIS
.B "int" ffs
.BI "(int " x ");"
.SH ARGUMENTS
.IP "x" 12
 the word to search
.SH "DESCRIPTION"
This is defined the same way as
the libc and compiler builtin ffs routines, therefore
differs in spirit from the above ffz (man ffs).
.TH "hweight64" 9 "hweight64" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hweight64 \-  returns the hamming weight of a N-bit word
.SH SYNOPSIS
.B "" hweight64
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
 the word to weigh
.SH "DESCRIPTION"
The Hamming Weight of a number is the total number of bits set in it.
.TH "set_nmi_callback" 9 "set_nmi_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_nmi_callback \- 
.SH SYNOPSIS
.B "void" set_nmi_callback
.BI "(nmi_callback_t " callback ");"
.SH ARGUMENTS
.IP "callback" 12
-- undescribed --
.SH "DESCRIPTION"

Set a handler for an NMI. Only one handler may be
set. Return 1 if the NMI was handled.
.TH "unset_nmi_callback" 9 "unset_nmi_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unset_nmi_callback \- 
.SH SYNOPSIS
.B "void" unset_nmi_callback
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Remove the handler previously set.
.TH "atomic_read" 9 "atomic_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_read \-  read atomic variable
.SH SYNOPSIS
.B "" atomic_read
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically reads the value of \fIv\fP.
.TH "atomic_set" 9 "atomic_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_set \-  set atomic variable
.SH SYNOPSIS
.B "" atomic_set
.BI "(" v ","
.BI "" i ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.IP "i" 12
 required value
.SH "DESCRIPTION"
Atomically sets the value of \fIv\fP to \fIi\fP.
.TH "atomic_add" 9 "atomic_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add \-  add integer to atomic variable
.SH SYNOPSIS
.B "void" atomic_add
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP.
.TH "atomic_sub" 9 "atomic_sub" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub \-  subtract the atomic variable
.SH SYNOPSIS
.B "void" atomic_sub
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP.
.TH "atomic_sub_and_test" 9 "atomic_sub_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub_and_test \-  subtract value from variable and test result
.SH SYNOPSIS
.B "int" atomic_sub_and_test
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP and returns
true if the result is zero, or false for all
other cases.
.TH "atomic_inc" 9 "atomic_inc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc \-  increment atomic variable
.SH SYNOPSIS
.B "void" atomic_inc
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1.
.TH "atomic_dec" 9 "atomic_dec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec \-  decrement atomic variable
.SH SYNOPSIS
.B "void" atomic_dec
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1.
.TH "atomic_dec_and_test" 9 "atomic_dec_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec_and_test \-  decrement and test
.SH SYNOPSIS
.B "int" atomic_dec_and_test
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1 and
returns true if the result is 0, or false for all other
cases.
.TH "atomic_inc_and_test" 9 "atomic_inc_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc_and_test \-  increment and test 
.SH SYNOPSIS
.B "int" atomic_inc_and_test
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1
and returns true if the result is zero, or false for all
other cases.
.TH "atomic_add_negative" 9 "atomic_add_negative" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add_negative \-  add and test if negative
.SH SYNOPSIS
.B "int" atomic_add_negative
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and returns true
if the result is negative, or false when
result is greater than or equal to zero.
.TH "atomic64_read" 9 "atomic64_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_read \-  read atomic64 variable
.SH SYNOPSIS
.B "" atomic64_read
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic64_t
.SH "DESCRIPTION"
Atomically reads the value of \fIv\fP.
Doesn't imply a read memory barrier.
.TH "atomic64_set" 9 "atomic64_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_set \-  set atomic64 variable
.SH SYNOPSIS
.B "" atomic64_set
.BI "(" v ","
.BI "" i ");"
.SH ARGUMENTS
.IP "v" 12
 pointer to type atomic64_t
.IP "i" 12
 required value
.SH "DESCRIPTION"
Atomically sets the value of \fIv\fP to \fIi\fP.
.TH "atomic64_add" 9 "atomic64_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_add \-  add integer to atomic64 variable
.SH SYNOPSIS
.B "void" atomic64_add
.BI "(long " i ","
.BI "atomic64_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer to type atomic64_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP.
.TH "atomic64_sub" 9 "atomic64_sub" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_sub \-  subtract the atomic64 variable
.SH SYNOPSIS
.B "void" atomic64_sub
.BI "(long " i ","
.BI "atomic64_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer to type atomic64_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP.
.TH "atomic64_sub_and_test" 9 "atomic64_sub_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_sub_and_test \-  subtract value from variable and test result
.SH SYNOPSIS
.B "int" atomic64_sub_and_test
.BI "(long " i ","
.BI "atomic64_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer to type atomic64_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP and returns
true if the result is zero, or false for all
other cases.
.TH "atomic64_inc" 9 "atomic64_inc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_inc \-  increment atomic64 variable
.SH SYNOPSIS
.B "void" atomic64_inc
.BI "(atomic64_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer to type atomic64_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1.
.TH "atomic64_dec" 9 "atomic64_dec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_dec \-  decrement atomic64 variable
.SH SYNOPSIS
.B "void" atomic64_dec
.BI "(atomic64_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer to type atomic64_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1.
.TH "atomic64_dec_and_test" 9 "atomic64_dec_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_dec_and_test \-  decrement and test
.SH SYNOPSIS
.B "int" atomic64_dec_and_test
.BI "(atomic64_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer to type atomic64_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1 and
returns true if the result is 0, or false for all other
cases.
.TH "atomic64_inc_and_test" 9 "atomic64_inc_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_inc_and_test \-  increment and test
.SH SYNOPSIS
.B "int" atomic64_inc_and_test
.BI "(atomic64_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer to type atomic64_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1
and returns true if the result is zero, or false for all
other cases.
.TH "atomic64_add_negative" 9 "atomic64_add_negative" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic64_add_negative \-  add and test if negative
.SH SYNOPSIS
.B "long" atomic64_add_negative
.BI "(long " i ","
.BI "atomic64_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer to atomic64_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and returns true
if the result is negative, or false when
result is greater than or equal to zero.
.TH "atomic_add_return" 9 "atomic_add_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add_return \-  add and return
.SH SYNOPSIS
.B "int" atomic_add_return
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and returns \fIi\fP + \fIv\fP
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word. returns 0 to "BITS_PER_LONG-1".
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " x ");"
.SH ARGUMENTS
.IP "x" 12
-- undescribed --
.SH "DESCRIPTION"
\fB__ffs\fP return is undefined if no bit is set.

32-bit fast __ffs by LaMont Jones "lamont At hp com".
64-bit enhancement by Grant Grundler "grundler At parisc-linux org".
(with help from willy/jejb to get the semantics right)

This algorithm avoids branches by making use of nullification.
One side effect of "extr" instructions is it sets PSW[N] bit.
How PSW[N] (nullify next insn) gets set is determined by the 
"condition" field (eg "&lt;&gt;" or "TR" below) in the extr* insn.
Only the 1st and one of either the 2cd or 3rd insn will get executed.
Each set of 3 insn will get executed in 2 cycles on PA8x00 vs 16 or so
cycles for each mispredicted branch.
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "kernel_ffs" 9 "kernel_ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kernel_ffs \-  find first bit set
.SH SYNOPSIS
.B "unsigned long" kernel_ffs
.BI "(unsigned long " w ");"
.SH ARGUMENTS
.IP "w" 12
-- undescribed --
.SH "DESCRIPTION"
This is defined the same way as
the libc and compiler builtin ffs routines, therefore
differs in spirit from the above ffz (man ffs).
.TH "test_and_set_bit" 9 "test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_set_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "test_and_clear_bit" 9 "test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_clear_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "__test_and_clear_bit" 9 "__test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_clear_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.  
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_change_bit" 9 "test_and_change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_change_bit \-  Change a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_change_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to change
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "test_bit" 9 "test_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_bit \-  Determine whether a bit is set
.SH SYNOPSIS
.B "int" test_bit
.BI "(int " nr ","
.BI "const volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 bit number to test
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
This routine doesn't need to be atomic.
.TH "find_next_zero_bit" 9 "find_next_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "int" find_next_zero_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "int" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_first_zero_bit" 9 "find_first_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "" find_first_zero_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first zero bit, not the number of the byte
containing a bit.
.TH "read_can_lock" 9 "read_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_can_lock \-  would read_trylock() succeed?
.SH SYNOPSIS
.B "" read_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "write_can_lock" 9 "write_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_can_lock \-  would write_trylock() succeed?
.SH SYNOPSIS
.B "" write_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "set_bit" 9 "set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_bit \-  Atomically set a bit in memory
.SH SYNOPSIS
.B "void" set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
This function is atomic and may not be reordered.  See \fB__set_bit\fP
if you do not require the atomic guarantees.
Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.
.TH "__set_bit" 9 "__set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__set_bit \-  Set a bit in memory
.SH SYNOPSIS
.B "void" __set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBset_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "clear_bit" 9 "clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clear_bit \-  Clears a bit in memory
.SH SYNOPSIS
.B "void" clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBclear_bit\fP is atomic and may not be reordered.  However, it does
not contain a memory barrier, so if it is used for locking purposes,
you should call \fBsmp_mb__before_clear_bit\fP and/or \fBsmp_mb__after_clear_bit\fP
in order to ensure changes are visible on other processors.
.TH "__change_bit" 9 "__change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" __change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBchange_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "change_bit" 9 "change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBchange_bit\fP is atomic and may not be reordered.
Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.
.TH "test_and_set_bit" 9 "test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.
It also implies a memory barrier.
.TH "__test_and_set_bit" 9 "__test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_clear_bit" 9 "test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.
It also implies a memory barrier.
.TH "__test_and_clear_bit" 9 "__test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_change_bit" 9 "test_and_change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_change_bit \-  Change a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.
It also implies a memory barrier.
.TH "test_bit" 9 "test_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_bit \-  Determine whether a bit is set
.SH SYNOPSIS
.B "int" test_bit
.BI "(int " nr ","
.BI "const volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 bit number to test
.IP "addr" 12
 Address to start counting from
.TH "ffz" 9 "ffz" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffz \-  find first zero in word.
.SH SYNOPSIS
.B "unsigned long" ffz
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no zero exists, so code should check against ~0UL first.
.TH "find_first_zero_bit" 9 "find_first_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "" find_first_zero_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first zero bit, not the number of the byte
containing a bit.
.TH "find_next_zero_bit" 9 "find_next_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "int" find_next_zero_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "unsigned long" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned long " size ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "ffs" 9 "ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffs \-  find first bit set
.SH SYNOPSIS
.B "" ffs
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
 the word to search
.SH "DESCRIPTION"
This is defined the same way as
the libc and compiler builtin ffs routines, therefore
differs in spirit from the above ffz (man ffs).
.TH "hweight32" 9 "hweight32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hweight32 \-  returns the hamming weight of a N-bit word
.SH SYNOPSIS
.B "" hweight32
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
 the word to weigh
.SH "DESCRIPTION"
The Hamming Weight of a number is the total number of bits set in it.
.TH "__raw_spin_trylock" 9 "__raw_spin_trylock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__raw_spin_trylock \-  Try spin lock and return a result
.SH SYNOPSIS
.B "int" __raw_spin_trylock
.BI "(raw_spinlock_t *" lock ");"
.SH ARGUMENTS
.IP "lock" 12
 Pointer to the lock variable
.SH "DESCRIPTION"
\fB__raw_spin_trylock\fP tries to get the lock and returns a result.
On the m32r, the result value is 1 (= Success) or 0 (= Failure).
.TH "__raw_read_can_lock" 9 "__raw_read_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__raw_read_can_lock \-  would read_trylock() succeed?
.SH SYNOPSIS
.B "" __raw_read_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "__raw_write_can_lock" 9 "__raw_write_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__raw_write_can_lock \-  would write_trylock() succeed?
.SH SYNOPSIS
.B "" __raw_write_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "virt_to_phys" 9 "virt_to_phys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
virt_to_phys \- 	map virtual addresses to physical
.SH SYNOPSIS
.B "unsigned long" virt_to_phys
.BI "(volatile void *" address ");"
.SH ARGUMENTS
.IP "address" 12
 address to remap
.SH "DESCRIPTION"
The returned physical address is the physical (CPU) mapping for
the memory address given. It is only valid to use this function on
addresses directly mapped or allocated via kmalloc.

This function does not give bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
.TH "phys_to_virt" 9 "phys_to_virt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
phys_to_virt \- 	map physical address to virtual
.SH SYNOPSIS
.B "void *" phys_to_virt
.BI "(unsigned long " address ");"
.SH ARGUMENTS
.IP "address" 12
 address to remap
.SH "DESCRIPTION"
The returned virtual address is a current CPU mapping for
the memory address given. It is only valid to use this function on
addresses that have a kernel mapping

This function does not handle bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
.TH "ioremap" 9 "ioremap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioremap \- 	map bus memory into CPU space
.SH SYNOPSIS
.B "void __iomem *" ioremap
.BI "(unsigned long " offset ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "offset" 12
	bus address of the memory
.IP "size" 12
		size of the resource to map
.SH "DESCRIPTION"
ioremap performs a platform specific sequence of operations to
make bus memory CPU accessible via the readb/readw/readl/writeb/
writew/writel functions and the other mmio helpers. The returned
address is not guaranteed to be usable directly as a virtual
address.
.TH "check_signature" 9 "check_signature" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_signature \- 	find BIOS signatures
.SH SYNOPSIS
.B "int" check_signature
.BI "(void __iomem *" io_addr ","
.BI "const unsigned char *" signature ","
.BI "int " length ");"
.SH ARGUMENTS
.IP "io_addr" 12
 mmio address to check
.IP "signature" 12
  signature block
.IP "length" 12
 length of signature
.SH "DESCRIPTION"
Perform a signature comparison with the ISA mmio address io_addr.
Returns 1 on a match.

This function is deprecated. New drivers should use ioremap and
check_signature.
.TH "atomic_read" 9 "atomic_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_read \-  read atomic variable
.SH SYNOPSIS
.B "" atomic_read
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically reads the value of \fIv\fP.
.TH "atomic_set" 9 "atomic_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_set \-  set atomic variable
.SH SYNOPSIS
.B "" atomic_set
.BI "(" v ","
.BI "" i ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.IP "i" 12
 required value
.SH "DESCRIPTION"
Atomically sets the value of \fIv\fP to \fIi\fP.
.TH "atomic_add_return" 9 "atomic_add_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add_return \-  add integer to atomic variable and return it
.SH SYNOPSIS
.B "int" atomic_add_return
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and return (\fIi\fP + \fIv\fP).
.TH "atomic_sub_return" 9 "atomic_sub_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub_return \-  subtract integer from atomic variable and return it
.SH SYNOPSIS
.B "int" atomic_sub_return
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP and return (\fIv\fP - \fIi\fP).
.TH "atomic_add" 9 "atomic_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add \-  add integer to atomic variable
.SH SYNOPSIS
.B "" atomic_add
.BI "(" i ","
.BI "" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP.
.TH "atomic_sub" 9 "atomic_sub" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub \-  subtract the atomic variable
.SH SYNOPSIS
.B "" atomic_sub
.BI "(" i ","
.BI "" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP.
.TH "atomic_sub_and_test" 9 "atomic_sub_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub_and_test \-  subtract value from variable and test result
.SH SYNOPSIS
.B "" atomic_sub_and_test
.BI "(" i ","
.BI "" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP and returns
true if the result is zero, or false for all
other cases.
.TH "atomic_inc_return" 9 "atomic_inc_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc_return \-  increment atomic variable and return it
.SH SYNOPSIS
.B "int" atomic_inc_return
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1 and returns the result.
.TH "atomic_dec_return" 9 "atomic_dec_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec_return \-  decrement atomic variable and return it
.SH SYNOPSIS
.B "int" atomic_dec_return
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1 and returns the result.
.TH "atomic_inc" 9 "atomic_inc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc \-  increment atomic variable
.SH SYNOPSIS
.B "" atomic_inc
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1.
.TH "atomic_dec" 9 "atomic_dec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec \-  decrement atomic variable
.SH SYNOPSIS
.B "" atomic_dec
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1.
.TH "atomic_inc_and_test" 9 "atomic_inc_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc_and_test \-  increment and test
.SH SYNOPSIS
.B "" atomic_inc_and_test
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1
and returns true if the result is zero, or false for all
other cases.
.TH "atomic_dec_and_test" 9 "atomic_dec_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec_and_test \-  decrement and test
.SH SYNOPSIS
.B "" atomic_dec_and_test
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1 and
returns true if the result is 0, or false for all
other cases.
.TH "atomic_add_negative" 9 "atomic_add_negative" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add_negative \-  add and test if negative
.SH SYNOPSIS
.B "" atomic_add_negative
.BI "(" i ","
.BI "" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and returns true
if the result is negative, or false when
result is greater than or equal to zero.
.TH "read_barrier_depends" 9 "read_barrier_depends" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_barrier_depends \-  Flush all pending reads that subsequents reads
.SH SYNOPSIS
.B "" read_barrier_depends
.SH ARGUMENTS
.SH "DESCRIPTION"
depend on.

No data-dependent reads from memory-like regions are ever reordered
over this barrier.  All reads preceding this primitive are guaranteed
to access memory (but not necessarily other CPUs' caches) before any
reads following this primitive that depend on the data return by
any of the preceding reads.  This primitive is much lighter weight than
\fBrmb\fP on most CPUs, and is never heavier weight than is
\fBrmb\fP.

These ordering constraints are respected by both the local CPU
and the compiler.

Ordering is not guaranteed by anything other than these primitives,
not even by data dependencies.  See the documentation for
\fBmemory_barrier\fP for examples and URLs to more information.

For example, the following code would force ordering (the initial
value of "a" is zero, "b" is one, and "p" is "&amp;a"):

&lt;programlisting&gt;
CPU 0                           CPU 1

b = 2;
\fBmemory_barrier\fP;
p = &amp;b;                         q = p;
\fBread_barrier_depends\fP;
d = *q;
&lt;/programlisting&gt;


because the read of "*q" depends on the read of "p" and these
two reads are separated by a \fBread_barrier_depends\fP.  However,
the following code, with the same initial values for "a" and "b":

&lt;programlisting&gt;
CPU 0                           CPU 1

a = 2;
\fBmemory_barrier\fP;
b = 3;                          y = b;
\fBread_barrier_depends\fP;
x = a;
&lt;/programlisting&gt;

does not enforce ordering, since there is no data dependency between
the read of "a" and the read of "b".  Therefore, on some CPUs, such
as Alpha, "y" could be set to 3 and "x" to 0.  Use \fBrmb\fP
in cases like thiswhere there are no data dependencies.
.TH "access_ok" 9 "access_ok" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
access_ok \-  Checks if a user space pointer is valid
.SH SYNOPSIS
.B "" access_ok
.BI "(" type ","
.BI "" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "type" 12
 Type of access: VERIFY_READ or VERIFY_WRITE.  Note that
VERIFY_WRITE is a superset of VERIFY_READ - if it is safe
to write to a block, it is always safe to read from it.
.IP "addr" 12
 User space pointer to start of block to check
.IP "size" 12
 Size of block to check
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Checks if a pointer to a block of memory in user space is valid.

Returns true (nonzero) if the memory block may be valid, false (zero)
if it is definitely invalid.

Note that, depending on architecture, this function probably just
checks that the pointer is in the user space range - after calling
this function, memory access functions may still return -EFAULT.
.TH "get_user" 9 "get_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_user \-  Get a simple variable from user space.
.SH SYNOPSIS
.B "" get_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Variable to store result.
.IP "ptr" 12
 Source address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and the result of
dereferencing \fIptr\fP must be assignable to \fIx\fP without a cast.

Returns zero on success, or -EFAULT on error.
On error, the variable \fIx\fP is set to zero.
.TH "put_user" 9 "put_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_user \-  Write a simple value into user space.
.SH SYNOPSIS
.B "" put_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Value to copy to user space.
.IP "ptr" 12
 Destination address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and \fIx\fP must be assignable
to the result of dereferencing \fIptr\fP.

Returns zero on success, or -EFAULT on error.
.TH "__get_user" 9 "__get_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_user \-  Get a simple variable from user space, with less checking.
.SH SYNOPSIS
.B "" __get_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Variable to store result.
.IP "ptr" 12
 Source address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and the result of
dereferencing \fIptr\fP must be assignable to \fIx\fP without a cast.

Caller must check the pointer with \fBaccess_ok\fP before calling this
function.

Returns zero on success, or -EFAULT on error.
On error, the variable \fIx\fP is set to zero.
.TH "__put_user" 9 "__put_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__put_user \-  Write a simple value into user space, with less checking.
.SH SYNOPSIS
.B "" __put_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Value to copy to user space.
.IP "ptr" 12
 Destination address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and \fIx\fP must be assignable
to the result of dereferencing \fIptr\fP.

Caller must check the pointer with \fBaccess_ok\fP before calling this
function.

Returns zero on success, or -EFAULT on error.
.TH "__copy_to_user" 9 "__copy_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__copy_to_user \-  Copy a block of data into user space, with less checking.
.SH SYNOPSIS
.B "" __copy_to_user
.BI "(" to ","
.BI "" from ","
.BI "" n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "from" 12
 Source address, in kernel space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from kernel space to user space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be copied.
On success, this will be zero.
.TH "copy_to_user" 9 "copy_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_to_user \-  Copy a block of data into user space.
.SH SYNOPSIS
.B "" copy_to_user
.BI "(" to ","
.BI "" from ","
.BI "" n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "from" 12
 Source address, in kernel space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from kernel space to user space.

Returns number of bytes that could not be copied.
On success, this will be zero.
.TH "__copy_from_user" 9 "__copy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__copy_from_user \-  Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
.SH SYNOPSIS
.B "" __copy_from_user
.BI "(" to ","
.BI "" from ","
.BI "" n ");"
.SH ARGUMENTS
.IP "to" 12
.IP "from" 12
 Source address, in user space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from user space to kernel space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be copied.
On success, this will be zero.

If some data could not be copied, this function will pad the copied
data to the requested size using zero bytes.
.TH "copy_from_user" 9 "copy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_from_user \-  Copy a block of data from user space.
.SH SYNOPSIS
.B "" copy_from_user
.BI "(" to ","
.BI "" from ","
.BI "" n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in kernel space.
.IP "from" 12
 Source address, in user space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from user space to kernel space.

Returns number of bytes that could not be copied.
On success, this will be zero.

If some data could not be copied, this function will pad the copied
data to the requested size using zero bytes.
.TH "__clear_user" 9 "__clear_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__clear_user \-  Zero a block of memory in user space, with less checking.
.SH SYNOPSIS
.B "unsigned long" __clear_user
.BI "(void __user *" mem ","
.BI "unsigned long " len ");"
.SH ARGUMENTS
.IP "mem" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
Zero a block of memory in user space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be cleared.
On success, this will be zero.
.TH "clear_user" 9 "clear_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clear_user \-  Zero a block of memory in user space.
.SH SYNOPSIS
.B "unsigned long" clear_user
.BI "(void __user *" mem ","
.BI "unsigned long " len ");"
.SH ARGUMENTS
.IP "mem" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
Zero a block of memory in user space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be cleared.
On success, this will be zero.
.TH "strlen_user" 9 "strlen_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlen_user \-  Get the size of a string in user space.
.SH SYNOPSIS
.B "" strlen_user
.BI "(" str ");"
.SH ARGUMENTS
.IP "str" 12
 The string to measure.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Get the size of a NUL-terminated string in user space.

Returns the size of the string INCLUDING the terminating NUL.
On exception, returns 0.

If there is a limit on the length of a valid string, you may wish to
consider using \fBstrnlen_user\fP instead.
.TH "LDIMM" 9 "LDIMM" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
LDIMM \-  load immediate value
.SH SYNOPSIS
.B "" LDIMM
.BI "(" reg ","
.BI "" x ");"
.SH ARGUMENTS
.IP "reg" 12
.IP "x" 12
.SH "DESCRIPTION"
STI - enable interruption
CLI - disable interruption
.TH "ib_sa_mcmember_rec_set" 9 "ib_sa_mcmember_rec_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_sa_mcmember_rec_set \-  Start an MCMember set query
.SH SYNOPSIS
.B "int" ib_sa_mcmember_rec_set
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "struct ib_sa_mcmember_rec *" rec ","
.BI "ib_sa_comp_mask " comp_mask ","
.BI "int " timeout_ms ","
.BI "gfp_t " gfp_mask ","
.BI "void (*" callback ") (int status, 					struct ib_sa_mcmember_rec *resp, 					void *context),"
.BI "void *" context ","
.BI "struct ib_sa_query **" query ");"
.SH ARGUMENTS
.IP "device" 12
device to send query on
.IP "port_num" 12
 port number to send query on
.IP "rec" 12
MCMember Record to send in query
.IP "comp_mask" 12
component mask to send in query
.IP "timeout_ms" 12
time to wait for response
.IP "gfp_mask" 12
GFP mask to use for internal allocations
.IP "callback" 12
function called when query completes, times out or is
canceled
.IP "context" 12
opaque user context passed to callback
.IP "query" 12
-- undescribed --
.SH "DESCRIPTION"
Send an MCMember Set query to the SA (eg to join a multicast
group).  The callback function will be called when the query
completes (or fails); status is 0 for a successful response, -EINTR
if the query is canceled, -ETIMEDOUT is the query timed out, or
-EIO if an error occurred sending the query.  The resp parameter of
the callback is only valid if status is 0.

If the return value of \fBib_sa_mcmember_rec_set\fP is negative, it is
an error code.  Otherwise it is a query ID that can be used to
cancel the query.
.TH "ib_sa_mcmember_rec_delete" 9 "ib_sa_mcmember_rec_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_sa_mcmember_rec_delete \-  Start an MCMember delete query
.SH SYNOPSIS
.B "int" ib_sa_mcmember_rec_delete
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "struct ib_sa_mcmember_rec *" rec ","
.BI "ib_sa_comp_mask " comp_mask ","
.BI "int " timeout_ms ","
.BI "gfp_t " gfp_mask ","
.BI "void (*" callback ") (int status, 					   struct ib_sa_mcmember_rec *resp, 					   void *context),"
.BI "void *" context ","
.BI "struct ib_sa_query **" query ");"
.SH ARGUMENTS
.IP "device" 12
device to send query on
.IP "port_num" 12
 port number to send query on
.IP "rec" 12
MCMember Record to send in query
.IP "comp_mask" 12
component mask to send in query
.IP "timeout_ms" 12
time to wait for response
.IP "gfp_mask" 12
GFP mask to use for internal allocations
.IP "callback" 12
function called when query completes, times out or is
canceled
.IP "context" 12
opaque user context passed to callback
.IP "query" 12
-- undescribed --
.SH "DESCRIPTION"
Send an MCMember Delete query to the SA (eg to leave a multicast
group).  The callback function will be called when the query
completes (or fails); status is 0 for a successful response, -EINTR
if the query is canceled, -ETIMEDOUT is the query timed out, or
-EIO if an error occurred sending the query.  The resp parameter of
the callback is only valid if status is 0.

If the return value of \fBib_sa_mcmember_rec_delete\fP is negative, it
is an error code.  Otherwise it is a query ID that can be used to
cancel the query.
.TH "ib_alloc_pd" 9 "ib_alloc_pd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_alloc_pd \-  Allocates an unused protection domain.
.SH SYNOPSIS
.B "struct ib_pd *" ib_alloc_pd
.BI "(struct ib_device *" device ");"
.SH ARGUMENTS
.IP "device" 12
 The device on which to allocate the protection domain.
.SH "DESCRIPTION"
A protection domain object provides an association between QPs, shared
receive queues, address handles, memory regions, and memory windows.
.TH "ib_dealloc_pd" 9 "ib_dealloc_pd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_dealloc_pd \-  Deallocates a protection domain.
.SH SYNOPSIS
.B "int" ib_dealloc_pd
.BI "(struct ib_pd *" pd ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain to deallocate.
.TH "ib_create_ah" 9 "ib_create_ah" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_create_ah \-  Creates an address handle for the given address vector.
.SH SYNOPSIS
.B "struct ib_ah *" ib_create_ah
.BI "(struct ib_pd *" pd ","
.BI "struct ib_ah_attr *" ah_attr ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated with the address handle.
.IP "ah_attr" 12
 The attributes of the address vector.
.SH "DESCRIPTION"
The address handle is used to reference a local or global destination
in all UD QP post sends.
.TH "ib_create_ah_from_wc" 9 "ib_create_ah_from_wc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_create_ah_from_wc \-  Creates an address handle associated with the
.SH SYNOPSIS
.B "struct ib_ah *" ib_create_ah_from_wc
.BI "(struct ib_pd *" pd ","
.BI "struct ib_wc *" wc ","
.BI "struct ib_grh *" grh ","
.BI "u8 " port_num ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated with the address handle.
.IP "wc" 12
 Work completion information associated with a received message.
.IP "grh" 12
 References the received global route header.  This parameter is
ignored unless the work completion indicates that the GRH is valid.
.IP "port_num" 12
 The outbound port number to associate with the address.
.SH "DESCRIPTION"
The address handle is used to reference a local or global destination
in all UD QP post sends.
.SH "DESCRIPTION"
The address handle is used to reference a local or global destination
in all UD QP post sends.
.TH "ib_modify_ah" 9 "ib_modify_ah" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_modify_ah \-  Modifies the address vector associated with an address
.SH SYNOPSIS
.B "int" ib_modify_ah
.BI "(struct ib_ah *" ah ","
.BI "struct ib_ah_attr *" ah_attr ");"
.SH ARGUMENTS
.IP "ah" 12
 The address handle to modify.
.IP "ah_attr" 12
 The new address vector attributes to associate with the
address handle.
.SH "DESCRIPTION"
handle.
.TH "ib_query_ah" 9 "ib_query_ah" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_ah \-  Queries the address vector associated with an address
.SH SYNOPSIS
.B "int" ib_query_ah
.BI "(struct ib_ah *" ah ","
.BI "struct ib_ah_attr *" ah_attr ");"
.SH ARGUMENTS
.IP "ah" 12
 The address handle to query.
.IP "ah_attr" 12
 The address vector attributes associated with the address
handle.
.SH "DESCRIPTION"
handle.
.TH "ib_destroy_ah" 9 "ib_destroy_ah" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_destroy_ah \-  Destroys an address handle.
.SH SYNOPSIS
.B "int" ib_destroy_ah
.BI "(struct ib_ah *" ah ");"
.SH ARGUMENTS
.IP "ah" 12
 The address handle to destroy.
.TH "ib_create_srq" 9 "ib_create_srq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_create_srq \-  Creates a SRQ associated with the specified protection
.SH SYNOPSIS
.B "struct ib_srq *" ib_create_srq
.BI "(struct ib_pd *" pd ","
.BI "struct ib_srq_init_attr *" srq_init_attr ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated with the SRQ.
.IP "srq_init_attr" 12
 A list of initial attributes required to create the SRQ.
.SH "DESCRIPTION"
srq_attr-&gt;max_wr and srq_attr-&gt;max_sge are read the determine the
requested size of the SRQ, and set to the actual values allocated
on return.  If \fBib_create_srq\fP succeeds, then max_wr and max_sge
will always be at least as large as the requested values.
.SH "DESCRIPTION"
srq_attr-&gt;max_wr and srq_attr-&gt;max_sge are read the determine the
requested size of the SRQ, and set to the actual values allocated
on return.  If \fBib_create_srq\fP succeeds, then max_wr and max_sge
will always be at least as large as the requested values.
.TH "ib_modify_srq" 9 "ib_modify_srq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_modify_srq \-  Modifies the attributes for the specified SRQ.
.SH SYNOPSIS
.B "int" ib_modify_srq
.BI "(struct ib_srq *" srq ","
.BI "struct ib_srq_attr *" srq_attr ","
.BI "enum ib_srq_attr_mask " srq_attr_mask ");"
.SH ARGUMENTS
.IP "srq" 12
 The SRQ to modify.
.IP "srq_attr" 12
 On input, specifies the SRQ attributes to modify.  On output,
the current values of selected SRQ attributes are returned.
.IP "srq_attr_mask" 12
 A bit-mask used to specify which attributes of the SRQ
are being modified.
.SH "DESCRIPTION"
The mask may contain IB_SRQ_MAX_WR to resize the SRQ and/or
IB_SRQ_LIMIT to set the SRQ's limit and request notification when
the number of receives queued drops below the limit.
.TH "ib_query_srq" 9 "ib_query_srq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_srq \-  Returns the attribute list and current values for the
.SH SYNOPSIS
.B "int" ib_query_srq
.BI "(struct ib_srq *" srq ","
.BI "struct ib_srq_attr *" srq_attr ");"
.SH ARGUMENTS
.IP "srq" 12
 The SRQ to query.
.IP "srq_attr" 12
 The attributes of the specified SRQ.
.SH "DESCRIPTION"
specified SRQ.
.TH "ib_destroy_srq" 9 "ib_destroy_srq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_destroy_srq \-  Destroys the specified SRQ.
.SH SYNOPSIS
.B "int" ib_destroy_srq
.BI "(struct ib_srq *" srq ");"
.SH ARGUMENTS
.IP "srq" 12
 The SRQ to destroy.
.TH "ib_post_srq_recv" 9 "ib_post_srq_recv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_post_srq_recv \-  Posts a list of work requests to the specified SRQ.
.SH SYNOPSIS
.B "int" ib_post_srq_recv
.BI "(struct ib_srq *" srq ","
.BI "struct ib_recv_wr *" recv_wr ","
.BI "struct ib_recv_wr **" bad_recv_wr ");"
.SH ARGUMENTS
.IP "srq" 12
 The SRQ to post the work request on.
.IP "recv_wr" 12
 A list of work requests to post on the receive queue.
.IP "bad_recv_wr" 12
 On an immediate failure, this parameter will reference
the work request that failed to be posted on the QP.
.TH "ib_create_qp" 9 "ib_create_qp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_create_qp \-  Creates a QP associated with the specified protection
.SH SYNOPSIS
.B "struct ib_qp *" ib_create_qp
.BI "(struct ib_pd *" pd ","
.BI "struct ib_qp_init_attr *" qp_init_attr ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated with the QP.
.IP "qp_init_attr" 12
 A list of initial attributes required to create the QP.
.SH "DESCRIPTION"
domain.
.TH "ib_modify_qp" 9 "ib_modify_qp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_modify_qp \-  Modifies the attributes for the specified QP and then
.SH SYNOPSIS
.B "int" ib_modify_qp
.BI "(struct ib_qp *" qp ","
.BI "struct ib_qp_attr *" qp_attr ","
.BI "int " qp_attr_mask ");"
.SH ARGUMENTS
.IP "qp" 12
 The QP to modify.
.IP "qp_attr" 12
 On input, specifies the QP attributes to modify.  On output,
the current values of selected QP attributes are returned.
.IP "qp_attr_mask" 12
 A bit-mask used to specify which attributes of the QP
are being modified.
.SH "DESCRIPTION"
transitions the QP to the given state.
.TH "ib_query_qp" 9 "ib_query_qp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_qp \-  Returns the attribute list and current values for the
.SH SYNOPSIS
.B "int" ib_query_qp
.BI "(struct ib_qp *" qp ","
.BI "struct ib_qp_attr *" qp_attr ","
.BI "int " qp_attr_mask ","
.BI "struct ib_qp_init_attr *" qp_init_attr ");"
.SH ARGUMENTS
.IP "qp" 12
 The QP to query.
.IP "qp_attr" 12
 The attributes of the specified QP.
.IP "qp_attr_mask" 12
 A bit-mask used to select specific attributes to query.
.IP "qp_init_attr" 12
 Additional attributes of the selected QP.
.SH "DESCRIPTION"
The qp_attr_mask may be used to limit the query to gathering only the
selected attributes.
.SH "DESCRIPTION"
The qp_attr_mask may be used to limit the query to gathering only the
selected attributes.
.TH "ib_destroy_qp" 9 "ib_destroy_qp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_destroy_qp \-  Destroys the specified QP.
.SH SYNOPSIS
.B "int" ib_destroy_qp
.BI "(struct ib_qp *" qp ");"
.SH ARGUMENTS
.IP "qp" 12
 The QP to destroy.
.TH "ib_post_send" 9 "ib_post_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_post_send \-  Posts a list of work requests to the send queue of
.SH SYNOPSIS
.B "int" ib_post_send
.BI "(struct ib_qp *" qp ","
.BI "struct ib_send_wr *" send_wr ","
.BI "struct ib_send_wr **" bad_send_wr ");"
.SH ARGUMENTS
.IP "qp" 12
 The QP to post the work request on.
.IP "send_wr" 12
 A list of work requests to post on the send queue.
.IP "bad_send_wr" 12
 On an immediate failure, this parameter will reference
the work request that failed to be posted on the QP.
.SH "DESCRIPTION"
the specified QP.
.TH "ib_post_recv" 9 "ib_post_recv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_post_recv \-  Posts a list of work requests to the receive queue of
.SH SYNOPSIS
.B "int" ib_post_recv
.BI "(struct ib_qp *" qp ","
.BI "struct ib_recv_wr *" recv_wr ","
.BI "struct ib_recv_wr **" bad_recv_wr ");"
.SH ARGUMENTS
.IP "qp" 12
 The QP to post the work request on.
.IP "recv_wr" 12
 A list of work requests to post on the receive queue.
.IP "bad_recv_wr" 12
 On an immediate failure, this parameter will reference
the work request that failed to be posted on the QP.
.SH "DESCRIPTION"
the specified QP.
.TH "ib_create_cq" 9 "ib_create_cq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_create_cq \-  Creates a CQ on the specified device.
.SH SYNOPSIS
.B "struct ib_cq *" ib_create_cq
.BI "(struct ib_device *" device ","
.BI "ib_comp_handler " comp_handler ","
.BI "void (*" event_handler ") (struct ib_event *, void *),"
.BI "void *" cq_context ","
.BI "int " cqe ");"
.SH ARGUMENTS
.IP "device" 12
 The device on which to create the CQ.
.IP "comp_handler" 12
 A user-specified callback that is invoked when a
completion event occurs on the CQ.
.IP "event_handler" 12
 A user-specified callback that is invoked when an
asynchronous event not associated with a completion occurs on the CQ.
.IP "cq_context" 12
 Context associated with the CQ returned to the user via
the associated completion and event handlers.
.IP "cqe" 12
 The minimum size of the CQ.
.SH "DESCRIPTION"
Users can examine the cq structure to determine the actual CQ size.
.TH "ib_resize_cq" 9 "ib_resize_cq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_resize_cq \-  Modifies the capacity of the CQ.
.SH SYNOPSIS
.B "int" ib_resize_cq
.BI "(struct ib_cq *" cq ","
.BI "int " cqe ");"
.SH ARGUMENTS
.IP "cq" 12
 The CQ to resize.
.IP "cqe" 12
 The minimum size of the CQ.
.SH "DESCRIPTION"
Users can examine the cq structure to determine the actual CQ size.
.TH "ib_destroy_cq" 9 "ib_destroy_cq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_destroy_cq \-  Destroys the specified CQ.
.SH SYNOPSIS
.B "int" ib_destroy_cq
.BI "(struct ib_cq *" cq ");"
.SH ARGUMENTS
.IP "cq" 12
 The CQ to destroy.
.TH "ib_poll_cq" 9 "ib_poll_cq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_poll_cq \-  poll a CQ for completion(s)
.SH SYNOPSIS
.B "int" ib_poll_cq
.BI "(struct ib_cq *" cq ","
.BI "int " num_entries ","
.BI "struct ib_wc *" wc ");"
.SH ARGUMENTS
.IP "cq" 12
the CQ being polled
.IP "num_entries" 12
maximum number of completions to return
.IP "wc" 12
array of at least \fInum_entries\fP &amp;struct ib_wc where completions
will be returned
.SH "DESCRIPTION"
Poll a CQ for (possibly multiple) completions.  If the return value
is &lt; 0, an error occurred.  If the return value is &gt;= 0, it is the
number of completions returned.  If the return value is
non-negative and &lt; num_entries, then the CQ was emptied.
.TH "ib_peek_cq" 9 "ib_peek_cq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_peek_cq \-  Returns the number of unreaped completions currently
.SH SYNOPSIS
.B "int" ib_peek_cq
.BI "(struct ib_cq *" cq ","
.BI "int " wc_cnt ");"
.SH ARGUMENTS
.IP "cq" 12
 The CQ to peek.
.IP "wc_cnt" 12
 A minimum number of unreaped completions to check for.
.SH "DESCRIPTION"
If the number of unreaped completions is greater than or equal to wc_cnt,
this function returns wc_cnt, otherwise, it returns the actual number of
unreaped completions.
.SH "DESCRIPTION"
If the number of unreaped completions is greater than or equal to wc_cnt,
this function returns wc_cnt, otherwise, it returns the actual number of
unreaped completions.
.TH "ib_req_notify_cq" 9 "ib_req_notify_cq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_req_notify_cq \-  Request completion notification on a CQ.
.SH SYNOPSIS
.B "int" ib_req_notify_cq
.BI "(struct ib_cq *" cq ","
.BI "enum ib_cq_notify " cq_notify ");"
.SH ARGUMENTS
.IP "cq" 12
 The CQ to generate an event for.
.IP "cq_notify" 12
 If set to IB_CQ_SOLICITED, completion notification will
occur on the next solicited event. If set to IB_CQ_NEXT_COMP,
notification will occur on the next completion.
.TH "ib_req_ncomp_notif" 9 "ib_req_ncomp_notif" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_req_ncomp_notif \-  Request completion notification when there are
.SH SYNOPSIS
.B "int" ib_req_ncomp_notif
.BI "(struct ib_cq *" cq ","
.BI "int " wc_cnt ");"
.SH ARGUMENTS
.IP "cq" 12
 The CQ to generate an event for.
.IP "wc_cnt" 12
 The number of unreaped completions that should be on the
CQ before an event is generated.
.SH "DESCRIPTION"
at least the specified number of unreaped completions on the CQ.
.TH "ib_get_dma_mr" 9 "ib_get_dma_mr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_get_dma_mr \-  Returns a memory region for system memory that is
.SH SYNOPSIS
.B "struct ib_mr *" ib_get_dma_mr
.BI "(struct ib_pd *" pd ","
.BI "int " mr_access_flags ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated with the memory region.
.IP "mr_access_flags" 12
 Specifies the memory access rights.
.SH "DESCRIPTION"
usable for DMA.
.TH "ib_reg_phys_mr" 9 "ib_reg_phys_mr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_reg_phys_mr \-  Prepares a virtually addressed memory region for use
.SH SYNOPSIS
.B "struct ib_mr *" ib_reg_phys_mr
.BI "(struct ib_pd *" pd ","
.BI "struct ib_phys_buf *" phys_buf_array ","
.BI "int " num_phys_buf ","
.BI "int " mr_access_flags ","
.BI "u64 *" iova_start ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated assigned to the registered region.
.IP "phys_buf_array" 12
 Specifies a list of physical buffers to use in the
memory region.
.IP "num_phys_buf" 12
 Specifies the size of the phys_buf_array.
.IP "mr_access_flags" 12
 Specifies the memory access rights.
.IP "iova_start" 12
 The offset of the region's starting I/O virtual address.
.SH "DESCRIPTION"
by an HCA.
.TH "ib_rereg_phys_mr" 9 "ib_rereg_phys_mr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_rereg_phys_mr \-  Modifies the attributes of an existing memory region.
.SH SYNOPSIS
.B "int" ib_rereg_phys_mr
.BI "(struct ib_mr *" mr ","
.BI "int " mr_rereg_mask ","
.BI "struct ib_pd *" pd ","
.BI "struct ib_phys_buf *" phys_buf_array ","
.BI "int " num_phys_buf ","
.BI "int " mr_access_flags ","
.BI "u64 *" iova_start ");"
.SH ARGUMENTS
.IP "mr" 12
 The memory region to modify.
.IP "mr_rereg_mask" 12
 A bit-mask used to indicate which of the following
properties of the memory region are being modified.
.IP "pd" 12
 If IB_MR_REREG_PD is set in mr_rereg_mask, this field specifies
the new protection domain to associated with the memory region,
otherwise, this parameter is ignored.
.IP "phys_buf_array" 12
 If IB_MR_REREG_TRANS is set in mr_rereg_mask, this
field specifies a list of physical buffers to use in the new
translation, otherwise, this parameter is ignored.
.IP "num_phys_buf" 12
 If IB_MR_REREG_TRANS is set in mr_rereg_mask, this
field specifies the size of the phys_buf_array, otherwise, this
parameter is ignored.
.IP "mr_access_flags" 12
 If IB_MR_REREG_ACCESS is set in mr_rereg_mask, this
field specifies the new memory access rights, otherwise, this
parameter is ignored.
.IP "iova_start" 12
 The offset of the region's starting I/O virtual address.
.SH "DESCRIPTION"
Conceptually, this call performs the functions deregister memory region
followed by register physical memory region.  Where possible,
resources are reused instead of deallocated and reallocated.
.TH "ib_query_mr" 9 "ib_query_mr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_mr \-  Retrieves information about a specific memory region.
.SH SYNOPSIS
.B "int" ib_query_mr
.BI "(struct ib_mr *" mr ","
.BI "struct ib_mr_attr *" mr_attr ");"
.SH ARGUMENTS
.IP "mr" 12
 The memory region to retrieve information about.
.IP "mr_attr" 12
 The attributes of the specified memory region.
.TH "ib_dereg_mr" 9 "ib_dereg_mr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_dereg_mr \-  Deregisters a memory region and removes it from the
.SH SYNOPSIS
.B "int" ib_dereg_mr
.BI "(struct ib_mr *" mr ");"
.SH ARGUMENTS
.IP "mr" 12
 The memory region to deregister.
.SH "DESCRIPTION"
HCA translation table.
.TH "ib_alloc_mw" 9 "ib_alloc_mw" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_alloc_mw \-  Allocates a memory window.
.SH SYNOPSIS
.B "struct ib_mw *" ib_alloc_mw
.BI "(struct ib_pd *" pd ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated with the memory window.
.TH "ib_bind_mw" 9 "ib_bind_mw" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_bind_mw \-  Posts a work request to the send queue of the specified
.SH SYNOPSIS
.B "int" ib_bind_mw
.BI "(struct ib_qp *" qp ","
.BI "struct ib_mw *" mw ","
.BI "struct ib_mw_bind *" mw_bind ");"
.SH ARGUMENTS
.IP "qp" 12
 QP to post the bind work request on.
.IP "mw" 12
 The memory window to bind.
.IP "mw_bind" 12
 Specifies information about the memory window, including
its address range, remote access rights, and associated memory region.
.SH "DESCRIPTION"
QP, which binds the memory window to the given address range and
remote access attributes.
.TH "ib_dealloc_mw" 9 "ib_dealloc_mw" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_dealloc_mw \-  Deallocates a memory window.
.SH SYNOPSIS
.B "int" ib_dealloc_mw
.BI "(struct ib_mw *" mw ");"
.SH ARGUMENTS
.IP "mw" 12
 The memory window to deallocate.
.TH "ib_alloc_fmr" 9 "ib_alloc_fmr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_alloc_fmr \-  Allocates a unmapped fast memory region.
.SH SYNOPSIS
.B "struct ib_fmr *" ib_alloc_fmr
.BI "(struct ib_pd *" pd ","
.BI "int " mr_access_flags ","
.BI "struct ib_fmr_attr *" fmr_attr ");"
.SH ARGUMENTS
.IP "pd" 12
 The protection domain associated with the unmapped region.
.IP "mr_access_flags" 12
 Specifies the memory access rights.
.IP "fmr_attr" 12
 Attributes of the unmapped region.
.SH "DESCRIPTION"
A fast memory region must be mapped before it can be used as part of
a work request.
.TH "ib_map_phys_fmr" 9 "ib_map_phys_fmr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_map_phys_fmr \-  Maps a list of physical pages to a fast memory region.
.SH SYNOPSIS
.B "int" ib_map_phys_fmr
.BI "(struct ib_fmr *" fmr ","
.BI "u64 *" page_list ","
.BI "int " list_len ","
.BI "u64 " iova ");"
.SH ARGUMENTS
.IP "fmr" 12
 The fast memory region to associate with the pages.
.IP "page_list" 12
 An array of physical pages to map to the fast memory region.
.IP "list_len" 12
 The number of pages in page_list.
.IP "iova" 12
 The I/O virtual address to use with the mapped region.
.TH "ib_unmap_fmr" 9 "ib_unmap_fmr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_unmap_fmr \-  Removes the mapping from a list of fast memory regions.
.SH SYNOPSIS
.B "int" ib_unmap_fmr
.BI "(struct list_head *" fmr_list ");"
.SH ARGUMENTS
.IP "fmr_list" 12
 A linked list of fast memory regions to unmap.
.TH "ib_dealloc_fmr" 9 "ib_dealloc_fmr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_dealloc_fmr \-  Deallocates a fast memory region.
.SH SYNOPSIS
.B "int" ib_dealloc_fmr
.BI "(struct ib_fmr *" fmr ");"
.SH ARGUMENTS
.IP "fmr" 12
 The fast memory region to deallocate.
.TH "ib_attach_mcast" 9 "ib_attach_mcast" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_attach_mcast \-  Attaches the specified QP to a multicast group.
.SH SYNOPSIS
.B "int" ib_attach_mcast
.BI "(struct ib_qp *" qp ","
.BI "union ib_gid *" gid ","
.BI "u16 " lid ");"
.SH ARGUMENTS
.IP "qp" 12
 QP to attach to the multicast group.  The QP must be type
IB_QPT_UD.
.IP "gid" 12
 Multicast group GID.
.IP "lid" 12
 Multicast group LID in host byte order.
.SH "DESCRIPTION"
In order to send and receive multicast packets, subnet
administration must have created the multicast group and configured
the fabric appropriately.  The port associated with the specified
QP must also be a member of the multicast group.
.TH "ib_detach_mcast" 9 "ib_detach_mcast" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_detach_mcast \-  Detaches the specified QP from a multicast group.
.SH SYNOPSIS
.B "int" ib_detach_mcast
.BI "(struct ib_qp *" qp ","
.BI "union ib_gid *" gid ","
.BI "u16 " lid ");"
.SH ARGUMENTS
.IP "qp" 12
 QP to detach from the multicast group.
.IP "gid" 12
 Multicast group GID.
.IP "lid" 12
 Multicast group LID in host byte order.
.TH "ib_get_cached_gid" 9 "ib_get_cached_gid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_get_cached_gid \-  Returns a cached GID table entry
.SH SYNOPSIS
.B "int" ib_get_cached_gid
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "int " index ","
.BI "union ib_gid *" gid ");"
.SH ARGUMENTS
.IP "device" 12
 The device to query.
.IP "port_num" 12
 The port number of the device to query.
.IP "index" 12
 The index into the cached GID table to query.
.IP "gid" 12
 The GID value found at the specified index.
.SH "DESCRIPTION"
\fBib_get_cached_gid\fP fetches the specified GID table entry stored in
the local software cache.
.TH "ib_find_cached_gid" 9 "ib_find_cached_gid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_find_cached_gid \-  Returns the port number and GID table index where
.SH SYNOPSIS
.B "int" ib_find_cached_gid
.BI "(struct ib_device *" device ","
.BI "union ib_gid *" gid ","
.BI "u8 *" port_num ","
.BI "u16 *" index ");"
.SH ARGUMENTS
.IP "device" 12
 The device to query.
.IP "gid" 12
 The GID value to search for.
.IP "port_num" 12
 The port number of the device where the GID value was found.
.IP "index" 12
 The index into the cached GID table where the GID was found.  This
parameter may be NULL.
.SH "DESCRIPTION"
\fBib_find_cached_gid\fP searches for the specified GID value in
the local software cache.
.SH "DESCRIPTION"
\fBib_find_cached_gid\fP searches for the specified GID value in
the local software cache.
.TH "ib_get_cached_pkey" 9 "ib_get_cached_pkey" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_get_cached_pkey \-  Returns a cached PKey table entry
.SH SYNOPSIS
.B "int" ib_get_cached_pkey
.BI "(struct ib_device *" device_handle ","
.BI "u8 " port_num ","
.BI "int " index ","
.BI "u16 *" pkey ");"
.SH ARGUMENTS
.IP "device_handle" 12
-- undescribed --
.IP "port_num" 12
 The port number of the device to query.
.IP "index" 12
 The index into the cached PKey table to query.
.IP "pkey" 12
 The PKey value found at the specified index.
.SH "DESCRIPTION"
\fBib_get_cached_pkey\fP fetches the specified PKey table entry stored in
the local software cache.
.TH "ib_find_cached_pkey" 9 "ib_find_cached_pkey" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_find_cached_pkey \-  Returns the PKey table index where a specified
.SH SYNOPSIS
.B "int" ib_find_cached_pkey
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "u16 " pkey ","
.BI "u16 *" index ");"
.SH ARGUMENTS
.IP "device" 12
 The device to query.
.IP "port_num" 12
 The port number of the device to search for the PKey.
.IP "pkey" 12
 The PKey value to search for.
.IP "index" 12
 The index into the cached PKey table where the PKey was found.
.SH "DESCRIPTION"
\fBib_find_cached_pkey\fP searches the specified PKey table in
the local software cache.
.SH "DESCRIPTION"
\fBib_find_cached_pkey\fP searches the specified PKey table in
the local software cache.
.TH "Kernel API" 9 "struct ib_fmr_pool_param" "January 2021" "API Manual" LINUX
.SH NAME
struct ib_fmr_pool_param \-  Parameters for creating FMR pool
.SH SYNOPSIS
struct ib_fmr_pool_param {
.br
.BI "    int " max_pages_per_fmr ""
;

.br
.BI "    enum ib_access_flags " access ""
;

.br
.BI "    int " pool_size ""
;

.br
.BI "    int " dirty_watermark ""
;

.br
.BI "    void (*" flush_function ") (struct ib_fmr_pool *pool,void *              arg)"
;

.br
.BI "    void *" flush_arg ""
;

.br
.BI "    unsigned" cache:1 ""
;

.br
};
.br
.SH Arguments
.IP "max_pages_per_fmr" 12
Maximum number of pages per map request.
.IP "access" 12
Access flags for FMRs in pool.
.IP "pool_size" 12
Number of FMRs to allocate for pool.
.IP "dirty_watermark" 12
Flush is triggered when \fIdirty_watermark\fP dirty
FMRs are present.
.IP "flush_function" 12
Callback called when unmapped FMRs are flushed and
more FMRs are possibly available for mapping
.IP "flush_arg" 12
Context passed to user's flush function.
.IP "cache" 12
If set, FMRs may be reused after unmapping for identical map
requests.
.TH "int" 9 "int" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
int \-  User-defined callback to process communication events.
.SH SYNOPSIS
.B "typedef" int
.BI "( *" ib_cm_handler ");"
.SH ARGUMENTS
.IP "ib_cm_handler" 12
-- undescribed --
.SH "DESCRIPTION"
IB_CM_REQ_RECEIVED and IB_CM_SIDR_REQ_RECEIVED communication events
generated as a result of listen requests result in the allocation of a
new \fIcm_id\fP.  The new \fIcm_id\fP is returned to the user through this callback.
Clients are responsible for destroying the new \fIcm_id\fP.  For peer-to-peer
IB_CM_REQ_RECEIVED and all other events, the returned \fIcm_id\fP corresponds
to a user's existing communication identifier.

Users may not call ib_destroy_cm_id while in the context of this callback;
however, returning a non-zero value instructs the communication manager to
destroy the \fIcm_id\fP after the callback completes.
.TH "ib_create_cm_id" 9 "ib_create_cm_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_create_cm_id \-  Allocate a communication identifier.
.SH SYNOPSIS
.B "struct ib_cm_id *" ib_create_cm_id
.BI "(ib_cm_handler " cm_handler ","
.BI "void *" context ");"
.SH ARGUMENTS
.IP "cm_handler" 12
 Callback invoked to notify the user of CM events.
.IP "context" 12
 User specified context associated with the communication
identifier.
.SH "DESCRIPTION"
Communication identifiers are used to track connection states, service
ID resolution requests, and listen requests.
.TH "ib_destroy_cm_id" 9 "ib_destroy_cm_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_destroy_cm_id \-  Destroy a connection identifier.
.SH SYNOPSIS
.B "void" ib_destroy_cm_id
.BI "(struct ib_cm_id *" cm_id ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier to destroy.
.SH "DESCRIPTION"
This call blocks until the connection identifier is destroyed.
.TH "ib_cm_listen" 9 "ib_cm_listen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_cm_listen \-  Initiates listening on the specified service ID for
.SH SYNOPSIS
.B "int" ib_cm_listen
.BI "(struct ib_cm_id *" cm_id ","
.BI "__be64 " service_id ","
.BI "__be64 " service_mask ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the listen request.
.IP "service_id" 12
 Service identifier matched against incoming connection
and service ID resolution requests.  The service ID should be specified
network-byte order.  If set to IB_CM_ASSIGN_SERVICE_ID, the CM will
assign a service ID to the caller.
.IP "service_mask" 12
 Mask applied to service ID used to listen across a
range of service IDs.  If set to 0, the service ID is matched
exactly.  This parameter is ignored if service_id is set to
IB_CM_ASSIGN_SERVICE_ID.
.SH "DESCRIPTION"
connection and service ID resolution requests.
.TH "ib_send_cm_req" 9 "ib_send_cm_req" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_req \-  Sends a connection request to the remote node.
.SH SYNOPSIS
.B "int" ib_send_cm_req
.BI "(struct ib_cm_id *" cm_id ","
.BI "struct ib_cm_req_param *" param ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier that will be associated with the
connection request.
.IP "param" 12
 Connection request information needed to establish the
connection.
.TH "ib_send_cm_rep" 9 "ib_send_cm_rep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_rep \-  Sends a connection reply in response to a connection
.SH SYNOPSIS
.B "int" ib_send_cm_rep
.BI "(struct ib_cm_id *" cm_id ","
.BI "struct ib_cm_rep_param *" param ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier that will be associated with the
connection request.
.IP "param" 12
 Connection reply information needed to establish the
connection.
.SH "DESCRIPTION"
request.
.TH "ib_send_cm_rtu" 9 "ib_send_cm_rtu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_rtu \-  Sends a connection ready to use message in response
.SH SYNOPSIS
.B "int" ib_send_cm_rtu
.BI "(struct ib_cm_id *" cm_id ","
.BI "const void *" private_data ","
.BI "u8 " private_data_len ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the connection request.
.IP "private_data" 12
 Optional user-defined private data sent with the
ready to use message.
.IP "private_data_len" 12
 Size of the private data buffer, in bytes.
.SH "DESCRIPTION"
to a connection reply message.
.TH "ib_send_cm_dreq" 9 "ib_send_cm_dreq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_dreq \-  Sends a disconnection request for an existing
.SH SYNOPSIS
.B "int" ib_send_cm_dreq
.BI "(struct ib_cm_id *" cm_id ","
.BI "const void *" private_data ","
.BI "u8 " private_data_len ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the connection being
released.
.IP "private_data" 12
 Optional user-defined private data sent with the
disconnection request message.
.IP "private_data_len" 12
 Size of the private data buffer, in bytes.
.SH "DESCRIPTION"
connection.
.TH "ib_send_cm_drep" 9 "ib_send_cm_drep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_drep \-  Sends a disconnection reply to a disconnection request.
.SH SYNOPSIS
.B "int" ib_send_cm_drep
.BI "(struct ib_cm_id *" cm_id ","
.BI "const void *" private_data ","
.BI "u8 " private_data_len ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the connection being
released.
.IP "private_data" 12
 Optional user-defined private data sent with the
disconnection reply message.
.IP "private_data_len" 12
 Size of the private data buffer, in bytes.
.SH "DESCRIPTION"
If the cm_id is in the correct state, the CM will transition the connection
to the timewait state, even if an error occurs sending the DREP message.
.TH "ib_cm_establish" 9 "ib_cm_establish" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_cm_establish \-  Forces a connection state to established.
.SH SYNOPSIS
.B "int" ib_cm_establish
.BI "(struct ib_cm_id *" cm_id ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier to transition to established.
.SH "DESCRIPTION"
This routine should be invoked by users who receive messages on a
connected QP before an RTU has been received.
.TH "ib_send_cm_rej" 9 "ib_send_cm_rej" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_rej \-  Sends a connection rejection message to the
.SH SYNOPSIS
.B "int" ib_send_cm_rej
.BI "(struct ib_cm_id *" cm_id ","
.BI "enum ib_cm_rej_reason " reason ","
.BI "void *" ari ","
.BI "u8 " ari_length ","
.BI "const void *" private_data ","
.BI "u8 " private_data_len ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the connection being
rejected.
.IP "reason" 12
 Reason for the connection request rejection.
.IP "ari" 12
 Optional additional rejection information.
.IP "ari_length" 12
 Size of the additional rejection information, in bytes.
.IP "private_data" 12
 Optional user-defined private data sent with the
rejection message.
.IP "private_data_len" 12
 Size of the private data buffer, in bytes.
.SH "DESCRIPTION"
remote node.
.TH "ib_send_cm_mra" 9 "ib_send_cm_mra" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_mra \-  Sends a message receipt acknowledgement to a connection
.SH SYNOPSIS
.B "int" ib_send_cm_mra
.BI "(struct ib_cm_id *" cm_id ","
.BI "u8 " service_timeout ","
.BI "const void *" private_data ","
.BI "u8 " private_data_len ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the connection message.
.IP "service_timeout" 12
 The maximum time required for the sender to reply to
to the connection message.
.IP "private_data" 12
 Optional user-defined private data sent with the
message receipt acknowledgement.
.IP "private_data_len" 12
 Size of the private data buffer, in bytes.
.SH "DESCRIPTION"
message.
.TH "ib_send_cm_lap" 9 "ib_send_cm_lap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_lap \-  Sends a load alternate path request.
.SH SYNOPSIS
.B "int" ib_send_cm_lap
.BI "(struct ib_cm_id *" cm_id ","
.BI "struct ib_sa_path_rec *" alternate_path ","
.BI "const void *" private_data ","
.BI "u8 " private_data_len ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the load alternate path
message.
.IP "alternate_path" 12
 A path record that identifies the alternate path to
load.
.IP "private_data" 12
 Optional user-defined private data sent with the
load alternate path message.
.IP "private_data_len" 12
 Size of the private data buffer, in bytes.
.TH "ib_cm_init_qp_attr" 9 "ib_cm_init_qp_attr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_cm_init_qp_attr \-  Initializes the QP attributes for use in transitioning
.SH SYNOPSIS
.B "int" ib_cm_init_qp_attr
.BI "(struct ib_cm_id *" cm_id ","
.BI "struct ib_qp_attr *" qp_attr ","
.BI "int *" qp_attr_mask ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Communication identifier associated with the QP attributes to
initialize.
.IP "qp_attr" 12
 On input, specifies the desired QP state.  On output, the
mandatory and desired optional attributes will be set in order to
modify the QP to the specified state.
.IP "qp_attr_mask" 12
 The QP attribute mask that may be used to transition the
QP to the specified state.
.SH "DESCRIPTION"
Users must set the \fIqp_attr\fP-&gt;qp_state to the desired QP state.  This call
will set all required attributes for the given transition, along with
known optional attributes.  Users may override the attributes returned from
this call before calling ib_modify_qp.
.SH "DESCRIPTION"
Users must set the \fIqp_attr\fP-&gt;qp_state to the desired QP state.  This call
will set all required attributes for the given transition, along with
known optional attributes.  Users may override the attributes returned from
this call before calling ib_modify_qp.
.TH "ib_send_cm_apr" 9 "ib_send_cm_apr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_apr \-  Sends an alternate path response message in response to
.SH SYNOPSIS
.B "int" ib_send_cm_apr
.BI "(struct ib_cm_id *" cm_id ","
.BI "enum ib_cm_apr_status " status ","
.BI "void *" info ","
.BI "u8 " info_length ","
.BI "const void *" private_data ","
.BI "u8 " private_data_len ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Connection identifier associated with the alternate path response.
.IP "status" 12
 Reply status sent with the alternate path response.
.IP "info" 12
 Optional additional information sent with the alternate path
response.
.IP "info_length" 12
 Size of the additional information, in bytes.
.IP "private_data" 12
 Optional user-defined private data sent with the
alternate path response message.
.IP "private_data_len" 12
 Size of the private data buffer, in bytes.
.SH "DESCRIPTION"
a load alternate path request.
.TH "ib_send_cm_sidr_req" 9 "ib_send_cm_sidr_req" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_sidr_req \-  Sends a service ID resolution request to the
.SH SYNOPSIS
.B "int" ib_send_cm_sidr_req
.BI "(struct ib_cm_id *" cm_id ","
.BI "struct ib_cm_sidr_req_param *" param ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Communication identifier that will be associated with the
service ID resolution request.
.IP "param" 12
 Service ID resolution request information.
.SH "DESCRIPTION"
remote node.
.TH "ib_send_cm_sidr_rep" 9 "ib_send_cm_sidr_rep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_send_cm_sidr_rep \-  Sends a service ID resolution request to the
.SH SYNOPSIS
.B "int" ib_send_cm_sidr_rep
.BI "(struct ib_cm_id *" cm_id ","
.BI "struct ib_cm_sidr_rep_param *" param ");"
.SH ARGUMENTS
.IP "cm_id" 12
 Communication identifier associated with the received service ID
resolution request.
.IP "param" 12
 Service ID resolution reply information.
.SH "DESCRIPTION"
remote node.
.TH "shost_for_each_device" 9 "shost_for_each_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shost_for_each_device \-   iterate over all devices of a host
.SH SYNOPSIS
.B "" shost_for_each_device
.BI "(" sdev ","
.BI "" shost ");"
.SH ARGUMENTS
.IP "sdev" 12
	iterator
.IP "shost" 12
.SH "DESCRIPTION"
This traverses over each devices of \fIshost\fP.  The devices have
a reference that must be released by scsi_host_put when breaking
out of the loop.
.TH "__shost_for_each_device" 9 "__shost_for_each_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__shost_for_each_device \-   iterate over all devices of a host (UNLOCKED)
.SH SYNOPSIS
.B "" __shost_for_each_device
.BI "(" sdev ","
.BI "" shost ");"
.SH ARGUMENTS
.IP "sdev" 12
	iterator
.IP "shost" 12
.SH "DESCRIPTION"
This traverses over each devices of \fIshost\fP.  It does _not_ take a
reference on the scsi_device, thus it the whole loop must be protected
by shost-&gt;host_lock.
.SH "NOTE"
  The only reason why drivers would want to use this is because
they're need to access the device list in irq context.  Otherwise you
really want to use shost_for_each_device instead.
.TH "scsi_host_scan_allowed" 9 "scsi_host_scan_allowed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_host_scan_allowed \-  Is scanning of this host allowed
.SH SYNOPSIS
.B "int" scsi_host_scan_allowed
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	Pointer to Scsi_Host.
.TH "scsi_get_tag_type" 9 "scsi_get_tag_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_get_tag_type \-  get the type of tag the device supports
.SH SYNOPSIS
.B "int" scsi_get_tag_type
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	the scsi device
.SH "NOTES"
If the drive only supports simple tags, returns MSG_SIMPLE_TAG
if it supports all tag types, returns MSG_ORDERED_TAG.
.TH "scsi_activate_tcq" 9 "scsi_activate_tcq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_activate_tcq \-  turn on tag command queueing
.SH SYNOPSIS
.B "void" scsi_activate_tcq
.BI "(struct scsi_device *" sdev ","
.BI "int " depth ");"
.SH ARGUMENTS
.IP "sdev" 12
-- undescribed --
.IP "depth" 12
	queue depth
.SH "NOTES"
Eventually, I hope depth would be the maximum depth
the device could cope with and the real queue depth
would be adjustable from 0 to depth.
.TH "scsi_deactivate_tcq" 9 "scsi_deactivate_tcq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_deactivate_tcq \-  turn off tag command queueing
.SH SYNOPSIS
.B "void" scsi_deactivate_tcq
.BI "(struct scsi_device *" sdev ","
.BI "int " depth ");"
.SH ARGUMENTS
.IP "sdev" 12
-- undescribed --
.IP "depth" 12
-- undescribed --
.TH "scsi_populate_tag_msg" 9 "scsi_populate_tag_msg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_populate_tag_msg \-  place a tag message in a buffer
.SH SYNOPSIS
.B "int" scsi_populate_tag_msg
.BI "(struct scsi_cmnd *" cmd ","
.BI "char *" msg ");"
.SH ARGUMENTS
.IP "cmd" 12
-- undescribed --
.IP "msg" 12
	pointer to the area to place the tag
.SH "NOTES"
designed to create the correct type of tag message for the 
particular request.  Returns the size of the tag message.
May return 0 if TCQ is disabled for this device.
.TH "scsi_find_tag" 9 "scsi_find_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_find_tag \-  find a tagged command by device
.SH SYNOPSIS
.B "struct scsi_cmnd *" scsi_find_tag
.BI "(struct scsi_device *" sdev ","
.BI "int " tag ");"
.SH ARGUMENTS
.IP "sdev" 12
-- undescribed --
.IP "tag" 12
	the tag number
.SH "NOTES"
Only works with tags allocated by the generic blk layer.
.TH "mca_enable_dma" 9 "mca_enable_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_enable_dma \- 	channel to enable DMA on
.SH SYNOPSIS
.B "void" mca_enable_dma
.BI "(unsigned int " dmanr ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.SH "DESCRIPTION"
Enable the MCA bus DMA on a channel. This can be called from
IRQ context.
.TH "mca_disable_dma" 9 "mca_disable_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_disable_dma \- 	channel to disable DMA on
.SH SYNOPSIS
.B "void" mca_disable_dma
.BI "(unsigned int " dmanr ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.SH "DESCRIPTION"
Enable the MCA bus DMA on a channel. This can be called from
IRQ context.
.TH "mca_set_dma_addr" 9 "mca_set_dma_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_set_dma_addr \- 	load a 24bit DMA address
.SH SYNOPSIS
.B "void" mca_set_dma_addr
.BI "(unsigned int " dmanr ","
.BI "unsigned int " a ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.IP "a" 12
 24bit bus address
.SH "DESCRIPTION"
Load the address register in the DMA controller. This has a 24bit
limitation (16Mb). 
.TH "mca_get_dma_addr" 9 "mca_get_dma_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_get_dma_addr \- 	load a 24bit DMA address
.SH SYNOPSIS
.B "unsigned int" mca_get_dma_addr
.BI "(unsigned int " dmanr ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.SH "DESCRIPTION"
Read the address register in the DMA controller. This has a 24bit
limitation (16Mb). The return is a bus address.
.TH "mca_set_dma_count" 9 "mca_set_dma_count" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_set_dma_count \- 	load a 16bit transfer count
.SH SYNOPSIS
.B "void" mca_set_dma_count
.BI "(unsigned int " dmanr ","
.BI "unsigned int " count ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.IP "count" 12
 count
.SH "DESCRIPTION"
Set the DMA count for this channel. This can be up to 64Kbytes.
Setting a count of zero will not do what you expect.
.TH "mca_get_dma_residue" 9 "mca_get_dma_residue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_get_dma_residue \- 	get the remaining bytes to transfer
.SH SYNOPSIS
.B "unsigned int" mca_get_dma_residue
.BI "(unsigned int " dmanr ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.SH "DESCRIPTION"
This function returns the number of bytes left to transfer
on this DMA channel.
.TH "mca_set_dma_io" 9 "mca_set_dma_io" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_set_dma_io \- 	set the port for an I/O transfer
.SH SYNOPSIS
.B "void" mca_set_dma_io
.BI "(unsigned int " dmanr ","
.BI "unsigned int " io_addr ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.IP "io_addr" 12
 an I/O port number
.SH "DESCRIPTION"
Unlike the ISA bus DMA controllers the DMA on MCA bus can transfer
with an I/O port target.
.TH "mca_set_dma_mode" 9 "mca_set_dma_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_set_dma_mode \- 	set the DMA mode
.SH SYNOPSIS
.B "void" mca_set_dma_mode
.BI "(unsigned int " dmanr ","
.BI "unsigned int " mode ");"
.SH ARGUMENTS
.IP "dmanr" 12
 DMA channel
.IP "mode" 12
 mode to set
.SH "DESCRIPTION"
The DMA controller supports several modes. The mode values you can
.SH "SET ARE "

MCA_DMA_MODE_READ when reading from the DMA device.

MCA_DMA_MODE_WRITE to writing to the DMA device.

MCA_DMA_MODE_IO to do DMA to or from an I/O port.

MCA_DMA_MODE_16 to do 16bit transfers.
.TH "get_unaligned" 9 "get_unaligned" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_unaligned \-  get value from possibly mis-aligned location
.SH SYNOPSIS
.B "" get_unaligned
.BI "(" ptr ");"
.SH ARGUMENTS
.IP "ptr" 12
 pointer to value
.SH "DESCRIPTION"
This macro should be used for accessing values larger in size than 
single bytes at locations that are expected to be improperly aligned, 
e.g. retrieving a u16 value from a location not u16-aligned.

Note that unaligned accesses can be very expensive on some architectures.
.TH "put_unaligned" 9 "put_unaligned" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_unaligned \-  put value to a possibly mis-aligned location
.SH SYNOPSIS
.B "" put_unaligned
.BI "(" val ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "val" 12
 value to place
.IP "ptr" 12
 pointer to location
.SH "DESCRIPTION"
This macro should be used for placing values larger in size than 
single bytes at locations that are expected to be improperly aligned, 
e.g. writing a u16 value to a location not u16-aligned.

Note that unaligned accesses can be very expensive on some architectures.
.TH "virt_to_phys" 9 "virt_to_phys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
virt_to_phys \- 	map virtual addresses to physical
.SH SYNOPSIS
.B "unsigned long" virt_to_phys
.BI "(volatile void *" address ");"
.SH ARGUMENTS
.IP "address" 12
 address to remap
.SH "DESCRIPTION"
The returned physical address is the physical (CPU) mapping for
the memory address given. It is only valid to use this function on
addresses directly mapped or allocated via kmalloc. 

This function does not give bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
.TH "phys_to_virt" 9 "phys_to_virt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
phys_to_virt \- 	map physical address to virtual
.SH SYNOPSIS
.B "void *" phys_to_virt
.BI "(unsigned long " address ");"
.SH ARGUMENTS
.IP "address" 12
 address to remap
.SH "DESCRIPTION"
The returned virtual address is a current CPU mapping for
the memory address given. It is only valid to use this function on
addresses that have a kernel mapping

This function does not handle bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
.TH "ioremap" 9 "ioremap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioremap \-    map bus memory into CPU space
.SH SYNOPSIS
.B "void __iomem *" ioremap
.BI "(unsigned long " offset ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "offset" 12
    bus address of the memory
.IP "size" 12
      size of the resource to map
.SH "DESCRIPTION"
ioremap performs a platform specific sequence of operations to
make bus memory CPU accessible via the readb/readw/readl/writeb/
writew/writel functions and the other mmio helpers. The returned
address is not guaranteed to be usable directly as a virtual
address. 
.TH "check_signature" 9 "check_signature" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_signature \- 	find BIOS signatures
.SH SYNOPSIS
.B "int" check_signature
.BI "(volatile void __iomem *" io_addr ","
.BI "const unsigned char *" signature ","
.BI "int " length ");"
.SH ARGUMENTS
.IP "io_addr" 12
 mmio address to check 
.IP "signature" 12
  signature block
.IP "length" 12
 length of signature
.SH "DESCRIPTION"
Perform a signature comparison with the mmio address io_addr. This
address should have been obtained by ioremap.
Returns 1 on a match.
.TH "Kernel API" 9 "struct timer_opts" "January 2021" "API Manual" LINUX
.SH NAME
struct timer_opts \-  used to define a timer source
.SH SYNOPSIS
struct timer_opts {
.br
.BI "    char *" name ""
;

.br
.BI "    void (*" mark_offset ") (void)"
;

.br
.BI "    unsigned long (*" get_offset ") (void)"
;

.br
.BI "    unsigned long long (*" monotonic_clock ") (void)"
;

.br
.BI "    void (*" delay ") (unsigned long)"
;

.br
};
.br
.SH Arguments
.IP "name" 12
 name of the timer.
.IP "mark_offset" 12
 called by the timer interrupt.
.IP "get_offset" 12
  called by \fBgettimeofday\fP. Returns the number of microseconds
since the last timer interupt.
.IP "monotonic_clock" 12
 returns the number of nanoseconds since the init of the
timer.
.IP "delay" 12
 delays this many clock cycles.
.SH "Description"
.TH "__raw_read_can_lock" 9 "__raw_read_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__raw_read_can_lock \-  would read_trylock() succeed?
.SH SYNOPSIS
.B "" __raw_read_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "__raw_write_can_lock" 9 "__raw_write_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__raw_write_can_lock \-  would write_trylock() succeed?
.SH SYNOPSIS
.B "" __raw_write_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "atomic_read" 9 "atomic_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_read \-  read atomic variable
.SH SYNOPSIS
.B "" atomic_read
.BI "(" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically reads the value of \fIv\fP.
.TH "atomic_set" 9 "atomic_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_set \-  set atomic variable
.SH SYNOPSIS
.B "" atomic_set
.BI "(" v ","
.BI "" i ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.IP "i" 12
 required value
.SH "DESCRIPTION"
Atomically sets the value of \fIv\fP to \fIi\fP.
.TH "atomic_add" 9 "atomic_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add \-  add integer to atomic variable
.SH SYNOPSIS
.B "void" atomic_add
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP.
.TH "atomic_sub" 9 "atomic_sub" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub \-  subtract the atomic variable
.SH SYNOPSIS
.B "void" atomic_sub
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP.
.TH "atomic_sub_and_test" 9 "atomic_sub_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_sub_and_test \-  subtract value from variable and test result
.SH SYNOPSIS
.B "int" atomic_sub_and_test
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to subtract
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically subtracts \fIi\fP from \fIv\fP and returns
true if the result is zero, or false for all
other cases.
.TH "atomic_inc" 9 "atomic_inc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc \-  increment atomic variable
.SH SYNOPSIS
.B "void" atomic_inc
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1.
.TH "atomic_dec" 9 "atomic_dec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec \-  decrement atomic variable
.SH SYNOPSIS
.B "void" atomic_dec
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1.
.TH "atomic_dec_and_test" 9 "atomic_dec_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_dec_and_test \-  decrement and test
.SH SYNOPSIS
.B "int" atomic_dec_and_test
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically decrements \fIv\fP by 1 and
returns true if the result is 0, or false for all other
cases.
.TH "atomic_inc_and_test" 9 "atomic_inc_and_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_inc_and_test \-  increment and test 
.SH SYNOPSIS
.B "int" atomic_inc_and_test
.BI "(atomic_t *" v ");"
.SH ARGUMENTS
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically increments \fIv\fP by 1
and returns true if the result is zero, or false for all
other cases.
.TH "atomic_add_negative" 9 "atomic_add_negative" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add_negative \-  add and test if negative
.SH SYNOPSIS
.B "int" atomic_add_negative
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and returns true
if the result is negative, or false when
result is greater than or equal to zero.
.TH "atomic_add_return" 9 "atomic_add_return" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atomic_add_return \-  add and return
.SH SYNOPSIS
.B "int" atomic_add_return
.BI "(int " i ","
.BI "atomic_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 integer value to add
.IP "v" 12
 pointer of type atomic_t
.SH "DESCRIPTION"
Atomically adds \fIi\fP to \fIv\fP and returns \fIi\fP + \fIv\fP
.TH "read_barrier_depends" 9 "read_barrier_depends" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_barrier_depends \-  Flush all pending reads that subsequents reads
.SH SYNOPSIS
.B "" read_barrier_depends
.SH ARGUMENTS
.SH "DESCRIPTION"
depend on.

No data-dependent reads from memory-like regions are ever reordered
over this barrier.  All reads preceding this primitive are guaranteed
to access memory (but not necessarily other CPUs' caches) before any
reads following this primitive that depend on the data return by
any of the preceding reads.  This primitive is much lighter weight than
\fBrmb\fP on most CPUs, and is never heavier weight than is
\fBrmb\fP.

These ordering constraints are respected by both the local CPU
and the compiler.

Ordering is not guaranteed by anything other than these primitives,
not even by data dependencies.  See the documentation for
\fBmemory_barrier\fP for examples and URLs to more information.

For example, the following code would force ordering (the initial
value of "a" is zero, "b" is one, and "p" is "&amp;a"):

&lt;programlisting&gt;
CPU 0				CPU 1

b = 2;
\fBmemory_barrier\fP;
p = &amp;b;				q = p;
\fBread_barrier_depends\fP;
d = *q;
&lt;/programlisting&gt;

because the read of "*q" depends on the read of "p" and these
two reads are separated by a \fBread_barrier_depends\fP.  However,
the following code, with the same initial values for "a" and "b":

&lt;programlisting&gt;
CPU 0				CPU 1

a = 2;
\fBmemory_barrier\fP;
b = 3;				y = b;
\fBread_barrier_depends\fP;
x = a;
&lt;/programlisting&gt;

does not enforce ordering, since there is no data dependency between
the read of "a" and the read of "b".  Therefore, on some CPUs, such
as Alpha, "y" could be set to 3 and "x" to 0.  Use \fBrmb\fP
in cases like thiswhere there are no data dependencies.
.TH "set_nmi_callback" 9 "set_nmi_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_nmi_callback \- 
.SH SYNOPSIS
.B "void" set_nmi_callback
.BI "(nmi_callback_t " callback ");"
.SH ARGUMENTS
.IP "callback" 12
-- undescribed --
.SH "DESCRIPTION"

Set a handler for an NMI. Only one handler may be
set. Return 1 if the NMI was handled.
.TH "unset_nmi_callback" 9 "unset_nmi_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unset_nmi_callback \- 
.SH SYNOPSIS
.B "void" unset_nmi_callback
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Remove the handler previously set.
.TH "access_ok" 9 "access_ok" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
access_ok \-  Checks if a user space pointer is valid
.SH SYNOPSIS
.B "" access_ok
.BI "(" type ","
.BI "" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "type" 12
 Type of access: VERIFY_READ or VERIFY_WRITE.  Note that
VERIFY_WRITE is a superset of VERIFY_READ - if it is safe
to write to a block, it is always safe to read from it.
.IP "addr" 12
 User space pointer to start of block to check
.IP "size" 12
 Size of block to check
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Checks if a pointer to a block of memory in user space is valid.

Returns true (nonzero) if the memory block may be valid, false (zero)
if it is definitely invalid.

Note that, depending on architecture, this function probably just
checks that the pointer is in the user space range - after calling
this function, memory access functions may still return -EFAULT.
.TH "get_user" 9 "get_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_user \-  Get a simple variable from user space.
.SH SYNOPSIS
.B "" get_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Variable to store result.
.IP "ptr" 12
 Source address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and the result of
dereferencing \fIptr\fP must be assignable to \fIx\fP without a cast.

Returns zero on success, or -EFAULT on error.
On error, the variable \fIx\fP is set to zero.
.TH "put_user" 9 "put_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_user \-  Write a simple value into user space.
.SH SYNOPSIS
.B "" put_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Value to copy to user space.
.IP "ptr" 12
 Destination address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and \fIx\fP must be assignable
to the result of dereferencing \fIptr\fP.

Returns zero on success, or -EFAULT on error.
.TH "__get_user" 9 "__get_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_user \-  Get a simple variable from user space, with less checking.
.SH SYNOPSIS
.B "" __get_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Variable to store result.
.IP "ptr" 12
 Source address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and the result of
dereferencing \fIptr\fP must be assignable to \fIx\fP without a cast.

Caller must check the pointer with \fBaccess_ok\fP before calling this
function.

Returns zero on success, or -EFAULT on error.
On error, the variable \fIx\fP is set to zero.
.TH "__put_user" 9 "__put_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__put_user \-  Write a simple value into user space, with less checking.
.SH SYNOPSIS
.B "" __put_user
.BI "(" x ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "x" 12
   Value to copy to user space.
.IP "ptr" 12
 Destination address, in user space.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.

\fIptr\fP must have pointer-to-simple-variable type, and \fIx\fP must be assignable
to the result of dereferencing \fIptr\fP.

Caller must check the pointer with \fBaccess_ok\fP before calling this
function.

Returns zero on success, or -EFAULT on error.
.TH "__copy_to_user_inatomic" 9 "__copy_to_user_inatomic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__copy_to_user_inatomic \-  Copy a block of data into user space, with less checking.
.SH SYNOPSIS
.B "unsigned long __must_check" __copy_to_user_inatomic
.BI "(void __user *" to ","
.BI "const void *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "from" 12
 Source address, in kernel space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from kernel space to user space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be copied.
On success, this will be zero.
.TH "__copy_from_user_inatomic" 9 "__copy_from_user_inatomic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__copy_from_user_inatomic \-  Copy a block of data from user space, with less checking.
.SH SYNOPSIS
.B "unsigned long" __copy_from_user_inatomic
.BI "(void *" to ","
.BI "const void __user *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in kernel space.
.IP "from" 12
 Source address, in user space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from user space to kernel space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be copied.
On success, this will be zero.

If some data could not be copied, this function will pad the copied
data to the requested size using zero bytes.
.TH "strlen_user" 9 "strlen_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlen_user \-  Get the size of a string in user space.
.SH SYNOPSIS
.B "" strlen_user
.BI "(" str ");"
.SH ARGUMENTS
.IP "str" 12
 The string to measure.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Get the size of a NUL-terminated string in user space.

Returns the size of the string INCLUDING the terminating NUL.
On exception, returns 0.

If there is a limit on the length of a valid string, you may wish to
consider using \fBstrnlen_user\fP instead.
.TH "set_bit" 9 "set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_bit \-  Atomically set a bit in memory
.SH SYNOPSIS
.B "void" set_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
This function is atomic and may not be reordered.  See \fB__set_bit\fP
if you do not require the atomic guarantees.
.SH "NOTE"
 there are no guarantees that this function will not be reordered
on non x86 architectures, so if you are writting portable code,
make sure not to rely on its reordering guarantees.

Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.
.TH "__set_bit" 9 "__set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__set_bit \-  Set a bit in memory
.SH SYNOPSIS
.B "void" __set_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBset_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "clear_bit" 9 "clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clear_bit \-  Clears a bit in memory
.SH SYNOPSIS
.B "void" clear_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBclear_bit\fP is atomic and may not be reordered.  However, it does
not contain a memory barrier, so if it is used for locking purposes,
you should call \fBsmp_mb__before_clear_bit\fP and/or \fBsmp_mb__after_clear_bit\fP
in order to ensure changes are visible on other processors.
.TH "__change_bit" 9 "__change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" __change_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to change
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBchange_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "change_bit" 9 "change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" change_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to change
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBchange_bit\fP is atomic and may not be reordered. It may be
reordered on other architectures than x86.
Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.
.TH "test_and_set_bit" 9 "test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_set_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It may be reordered on other architectures than x86.
It also implies a memory barrier.
.TH "__test_and_set_bit" 9 "__test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_set_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.  
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_clear_bit" 9 "test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_clear_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.
It can be reorderdered on other architectures other than x86.
It also implies a memory barrier.
.TH "__test_and_clear_bit" 9 "__test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_clear_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.  
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_change_bit" 9 "test_and_change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_change_bit \-  Change a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_change_bit
.BI "(int " nr ","
.BI "volatile unsigned long *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to change
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "test_bit" 9 "test_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_bit \-  Determine whether a bit is set
.SH SYNOPSIS
.B "int" test_bit
.BI "(int " nr ","
.BI "const volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 bit number to test
.IP "addr" 12
 Address to start counting from
.TH "find_first_zero_bit" 9 "find_first_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "int" find_first_zero_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned " size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first zero bit, not the number of the byte
containing a bit.
.TH "find_next_zero_bit" 9 "find_next_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "int" find_next_zero_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "int" find_first_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned " size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "int" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "ffz" 9 "ffz" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffz \-  find first zero in word.
.SH SYNOPSIS
.B "unsigned long" ffz
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no zero exists, so code should check against ~0UL first.
.TH "ffs" 9 "ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffs \-  find first bit set
.SH SYNOPSIS
.B "int" ffs
.BI "(int " x ");"
.SH ARGUMENTS
.IP "x" 12
 the word to search
.SH "DESCRIPTION"
This is defined the same way as
the libc and compiler builtin ffs routines, therefore
differs in spirit from the above ffz (man ffs).
.TH "hweight32" 9 "hweight32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hweight32 \-  returns the hamming weight of a N-bit word
.SH SYNOPSIS
.B "" hweight32
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
 the word to weigh
.SH "DESCRIPTION"
The Hamming Weight of a number is the total number of bits set in it.
.TH "do_timer_interrupt_hook" 9 "do_timer_interrupt_hook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_timer_interrupt_hook \-  hook into timer tick
.SH SYNOPSIS
.B "void" do_timer_interrupt_hook
.BI "(struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
	standard registers from interrupt
.SH "DESCRIPTION"
This hook is called immediately after the timer interrupt is ack'd.
It's primary purpose is to allow architectures that don't possess
individual per CPU clocks (like the CPU APICs supply) to broadcast the
timer interrupt as a means of triggering reschedules etc.
.TH "do_timer_overflow" 9 "do_timer_overflow" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_timer_overflow \-  process a detected timer overflow condition
.SH SYNOPSIS
.B "int" do_timer_overflow
.BI "(int " count ");"
.SH ARGUMENTS
.IP "count" 12
	hardware timer interrupt count on overflow
.SH "DESCRIPTION"
This call is invoked when the jiffies count has not incremented but
the hardware timer interrupt has.  It means that a timer tick interrupt
came along while the previous one was pending, thus a tick was missed
.TH "sa1100_stop_dma" 9 "sa1100_stop_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_stop_dma \-  stop DMA in progress
.SH SYNOPSIS
.B "" sa1100_stop_dma
.BI "(" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 identifier for the channel to use
.SH "DESCRIPTION"
This stops DMA without clearing buffer pointers. Unlike
\fBsa1100_clear_dma\fP this allows subsequent use of \fBsa1100_resume_dma\fP
or \fBsa1100_get_dma_pos\fP.

The \fIregs\fP identifier is provided by a successful call to
\fBsa1100_request_dma\fP.
.TH "sa1100_resume_dma" 9 "sa1100_resume_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_resume_dma \-  resume DMA on a stopped channel
.SH SYNOPSIS
.B "" sa1100_resume_dma
.BI "(" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 identifier for the channel to use
.SH "DESCRIPTION"
This resumes DMA on a channel previously stopped with
\fBsa1100_stop_dma\fP.

The \fIregs\fP identifier is provided by a successful call to
\fBsa1100_request_dma\fP.
.TH "sa1100_clear_dma" 9 "sa1100_clear_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_clear_dma \-  clear DMA pointers
.SH SYNOPSIS
.B "" sa1100_clear_dma
.BI "(" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 identifier for the channel to use
.SH "DESCRIPTION"
This clear any DMA state so the DMA engine is ready to restart
with new buffers through \fBsa1100_start_dma\fP. Any buffers in flight
are discarded.

The \fIregs\fP identifier is provided by a successful call to
\fBsa1100_request_dma\fP.
.TH "clk_get" 9 "clk_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_get \-  lookup and obtain a reference to a clock producer.
.SH SYNOPSIS
.B "struct clk *" clk_get
.BI "(struct device *" dev ","
.BI "const char *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 device for clock "consumer"
.IP "id" 12
 clock comsumer ID
.SH "DESCRIPTION"
Returns a struct clk corresponding to the clock producer, or
valid \fBIS_ERR\fP condition containing errno.  The implementation
uses \fIdev\fP and \fIid\fP to determine the clock consumer, and thereby
the clock producer.  (IOW, \fIid\fP may be identical strings, but
clk_get may return different clock producers depending on \fIdev\fP.)
.TH "clk_enable" 9 "clk_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_enable \-  inform the system when the clock source should be running.
.SH SYNOPSIS
.B "int" clk_enable
.BI "(struct clk *" clk ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.SH "DESCRIPTION"
If the clock can not be enabled/disabled, this should return success.

Returns success (0) or negative errno.
.TH "clk_disable" 9 "clk_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_disable \-  inform the system when the clock source is no longer required.
.SH SYNOPSIS
.B "void" clk_disable
.BI "(struct clk *" clk ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.TH "clk_use" 9 "clk_use" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_use \-  increment the use count
.SH SYNOPSIS
.B "int" clk_use
.BI "(struct clk *" clk ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.SH "DESCRIPTION"
Returns success (0) or negative errno.
.TH "clk_unuse" 9 "clk_unuse" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_unuse \-  decrement the use count
.SH SYNOPSIS
.B "void" clk_unuse
.BI "(struct clk *" clk ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.TH "clk_get_rate" 9 "clk_get_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_get_rate \-  obtain the current clock rate (in Hz) for a clock source.
.SH SYNOPSIS
.B "unsigned long" clk_get_rate
.BI "(struct clk *" clk ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.SH "DESCRIPTION"
This is only valid once the clock source has been enabled.
.TH "clk_put" 9 "clk_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_put \-  "free" the clock source
.SH SYNOPSIS
.B "void" clk_put
.BI "(struct clk *" clk ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.TH "clk_round_rate" 9 "clk_round_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_round_rate \-  adjust a rate to the exact rate a clock can provide
.SH SYNOPSIS
.B "long" clk_round_rate
.BI "(struct clk *" clk ","
.BI "unsigned long " rate ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.IP "rate" 12
 desired clock rate in Hz
.SH "DESCRIPTION"
Returns rounded clock rate in Hz, or negative errno.
.TH "clk_set_rate" 9 "clk_set_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_set_rate \-  set the clock rate for a clock source
.SH SYNOPSIS
.B "int" clk_set_rate
.BI "(struct clk *" clk ","
.BI "unsigned long " rate ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.IP "rate" 12
 desired clock rate in Hz
.SH "DESCRIPTION"
Returns success (0) or negative errno.
.TH "clk_set_parent" 9 "clk_set_parent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_set_parent \-  set the parent clock source for this clock
.SH SYNOPSIS
.B "int" clk_set_parent
.BI "(struct clk *" clk ","
.BI "struct clk *" parent ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.IP "parent" 12
 parent clock source
.SH "DESCRIPTION"
Returns success (0) or negative errno.
.TH "clk_get_parent" 9 "clk_get_parent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clk_get_parent \-  get the parent clock source for this clock
.SH SYNOPSIS
.B "struct clk *" clk_get_parent
.BI "(struct clk *" clk ");"
.SH ARGUMENTS
.IP "clk" 12
 clock source
.SH "DESCRIPTION"
Returns struct clk corresponding to parent clock source, or
valid \fBIS_ERR\fP condition containing errno.
.TH "dma_alloc_coherent" 9 "dma_alloc_coherent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_alloc_coherent \-  allocate consistent memory for DMA
.SH SYNOPSIS
.B "void *" dma_alloc_coherent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "dma_addr_t *" handle ","
.BI "int " gfp ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "size" 12
 required memory size
.IP "handle" 12
 bus-specific DMA address
.IP "gfp" 12
-- undescribed --
.SH "DESCRIPTION"
Allocate some uncached, unbuffered memory for a device for
performing DMA.  This function allocates pages, and will
return the CPU-viewed address, and sets \fIhandle\fP to be the
device-viewed address.
.TH "dma_free_coherent" 9 "dma_free_coherent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_free_coherent \-  free memory allocated by dma_alloc_coherent
.SH SYNOPSIS
.B "void" dma_free_coherent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "void *" cpu_addr ","
.BI "dma_addr_t " handle ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "size" 12
 size of memory originally requested in dma_alloc_coherent
.IP "cpu_addr" 12
 CPU-view address returned from dma_alloc_coherent
.IP "handle" 12
 device-view address returned from dma_alloc_coherent
.SH "DESCRIPTION"
Free (and unmap) a DMA buffer previously allocated by
\fBdma_alloc_coherent\fP.

References to memory and mappings associated with cpu_addr/handle
during and after this call executing are illegal.
.TH "dma_mmap_coherent" 9 "dma_mmap_coherent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_mmap_coherent \-  map a coherent DMA allocation into user space
.SH SYNOPSIS
.B "int" dma_mmap_coherent
.BI "(struct device *" dev ","
.BI "struct vm_area_struct *" vma ","
.BI "void *" cpu_addr ","
.BI "dma_addr_t " handle ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "vma" 12
 vm_area_struct describing requested user mapping
.IP "cpu_addr" 12
 kernel CPU-view address returned from dma_alloc_coherent
.IP "handle" 12
 device-view address returned from dma_alloc_coherent
.IP "size" 12
 size of memory originally requested in dma_alloc_coherent
.SH "DESCRIPTION"
Map a coherent DMA buffer previously allocated by dma_alloc_coherent
into user space.  The coherent DMA buffer must not be freed by the
driver until the user space mapping has been released.
.TH "dma_alloc_writecombine" 9 "dma_alloc_writecombine" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_alloc_writecombine \-  allocate writecombining memory for DMA
.SH SYNOPSIS
.B "void *" dma_alloc_writecombine
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "dma_addr_t *" handle ","
.BI "int " gfp ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "size" 12
 required memory size
.IP "handle" 12
 bus-specific DMA address
.IP "gfp" 12
-- undescribed --
.SH "DESCRIPTION"
Allocate some uncached, buffered memory for a device for
performing DMA.  This function allocates pages, and will
return the CPU-viewed address, and sets \fIhandle\fP to be the
device-viewed address.
.TH "dma_map_single" 9 "dma_map_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_map_single \-  map a single buffer for streaming DMA
.SH SYNOPSIS
.B "dma_addr_t" dma_map_single
.BI "(struct device *" dev ","
.BI "void *" cpu_addr ","
.BI "size_t " size ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "cpu_addr" 12
 CPU direct mapped address of buffer
.IP "size" 12
 size of buffer to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Ensure that any data held in the cache is appropriately discarded
or written back.

The device owns this memory once this call has completed.  The CPU
can regain ownership by calling \fBdma_unmap_single\fP or
\fBdma_sync_single_for_cpu\fP.
.TH "dma_map_page" 9 "dma_map_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_map_page \-  map a portion of a page for streaming DMA
.SH SYNOPSIS
.B "dma_addr_t" dma_map_page
.BI "(struct device *" dev ","
.BI "struct page *" page ","
.BI "unsigned long " offset ","
.BI "size_t " size ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "page" 12
 page that buffer resides in
.IP "offset" 12
 offset into page for start of buffer
.IP "size" 12
 size of buffer to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Ensure that any data held in the cache is appropriately discarded
or written back.

The device owns this memory once this call has completed.  The CPU
can regain ownership by calling \fBdma_unmap_page\fP or
\fBdma_sync_single_for_cpu\fP.
.TH "dma_unmap_single" 9 "dma_unmap_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_unmap_single \-  unmap a single buffer previously mapped
.SH SYNOPSIS
.B "void" dma_unmap_single
.BI "(struct device *" dev ","
.BI "dma_addr_t " handle ","
.BI "size_t " size ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "handle" 12
 DMA address of buffer
.IP "size" 12
 size of buffer to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Unmap a single streaming mode DMA translation.  The handle and size
must match what was provided in the previous \fBdma_map_single\fP call.
All other usages are undefined.

After this call, reads by the CPU to the buffer are guaranteed to see
whatever the device wrote there.
.TH "dma_unmap_page" 9 "dma_unmap_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_unmap_page \-  unmap a buffer previously mapped through dma_map_page()
.SH SYNOPSIS
.B "void" dma_unmap_page
.BI "(struct device *" dev ","
.BI "dma_addr_t " handle ","
.BI "size_t " size ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "handle" 12
 DMA address of buffer
.IP "size" 12
 size of buffer to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Unmap a single streaming mode DMA translation.  The handle and size
must match what was provided in the previous \fBdma_map_single\fP call.
All other usages are undefined.

After this call, reads by the CPU to the buffer are guaranteed to see
whatever the device wrote there.
.TH "dma_map_sg" 9 "dma_map_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_map_sg \-  map a set of SG buffers for streaming mode DMA
.SH SYNOPSIS
.B "int" dma_map_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sg ","
.BI "int " nents ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "sg" 12
 list of buffers
.IP "nents" 12
 number of buffers to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Map a set of buffers described by scatterlist in streaming
mode for DMA.  This is the scatter-gather version of the
above dma_map_single interface.  Here the scatter gather list
elements are each tagged with the appropriate dma address
and length.  They are obtained via sg_dma_{address,length}(SG).
.SH "NOTE"
 An implementation may be able to use a smaller number of
DMA address/length pairs than there are SG table elements.
(for example via virtual mapping capabilities)
The routine returns the number of addr/length pairs actually
used, at most nents.

Device ownership issues as mentioned above for dma_map_single are
the same here.
.TH "dma_unmap_sg" 9 "dma_unmap_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_unmap_sg \-  unmap a set of SG buffers mapped by dma_map_sg
.SH SYNOPSIS
.B "void" dma_unmap_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sg ","
.BI "int " nents ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "sg" 12
 list of buffers
.IP "nents" 12
 number of buffers to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Unmap a set of streaming mode DMA translations.
Again, CPU read rules concerning calls here are the same as for
\fBdma_unmap_single\fP above.
.TH "dma_sync_single_for_cpu" 9 "dma_sync_single_for_cpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_sync_single_for_cpu \- 
.SH SYNOPSIS
.B "void" dma_sync_single_for_cpu
.BI "(struct device *" dev ","
.BI "dma_addr_t " handle ","
.BI "size_t " size ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "handle" 12
 DMA address of buffer
.IP "size" 12
 size of buffer to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Make physical memory consistent for a single streaming mode DMA
translation after a transfer.

If you perform a \fBdma_map_single\fP but wish to interrogate the
buffer using the cpu, yet do not wish to teardown the PCI dma
mapping, you must call this function before doing so.  At the
next point you give the PCI dma address back to the card, you
must first the perform a dma_sync_for_device, and then the
device again owns the buffer.
.TH "dma_sync_sg_for_cpu" 9 "dma_sync_sg_for_cpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_sync_sg_for_cpu \- 
.SH SYNOPSIS
.B "void" dma_sync_sg_for_cpu
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sg ","
.BI "int " nents ","
.BI "enum dma_data_direction " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 valid struct device pointer, or NULL for ISA and EISA-like devices
.IP "sg" 12
 list of buffers
.IP "nents" 12
 number of buffers to map
.IP "dir" 12
 DMA transfer direction
.SH "DESCRIPTION"
Make physical memory consistent for a set of streaming
mode DMA translations after a transfer.

The same as dma_sync_single_for_* but for a scatter-gather list,
same rules and usage.
.TH "dmabounce_register_dev" 9 "dmabounce_register_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dmabounce_register_dev \- 
.SH SYNOPSIS
.B "int" dmabounce_register_dev
.BI "(struct device *"  ","
.BI "unsigned " long ","
.BI "unsigned " long ");"
.SH ARGUMENTS
.IP "" 12
-- undescribed --
.IP "long" 12
-- undescribed --
.IP "long" 12
-- undescribed --
.SH "DESCRIPTION"
This function should be called by low-level platform code to register
a device as requireing DMA buffer bouncing. The function will allocate
appropriate DMA pools for the device.
.SH "DESCRIPTION"
This function should be called by low-level platform code to register
a device as requireing DMA buffer bouncing. The function will allocate
appropriate DMA pools for the device.
.TH "dmabounce_unregister_dev" 9 "dmabounce_unregister_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dmabounce_unregister_dev \- 
.SH SYNOPSIS
.B "void" dmabounce_unregister_dev
.BI "(struct device *"  ");"
.SH ARGUMENTS
.IP "" 12
-- undescribed --
.SH "DESCRIPTION"
This function should be called by low-level platform code when device
that was previously registered with dmabounce_register_dev is removed
from the system.
.SH "DESCRIPTION"
This function should be called by low-level platform code when device
that was previously registered with dmabounce_register_dev is removed
from the system.
.TH "dma_needs_bounce" 9 "dma_needs_bounce" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_needs_bounce \- 
.SH SYNOPSIS
.B "int" dma_needs_bounce
.BI "(struct device *"  ","
.BI "" dma_addr_t ","
.BI "" size_t ");"
.SH ARGUMENTS
.IP "" 12
-- undescribed --
.IP "dma_addr_t" 12
.IP "size_t" 12
.SH "DESCRIPTION"
Platforms that utilize the dmabounce mechanism must implement
this function.

The dmabounce routines call this function whenever a dma-mapping
is requested to determine whether a given buffer needs to be bounced
or not. The function must return 0 if the the buffer is OK for
DMA access and 1 if the buffer needs to be bounced.
.SH "DESCRIPTION"
Platforms that utilize the dmabounce mechanism must implement
this function.

The dmabounce routines call this function whenever a dma-mapping
is requested to determine whether a given buffer needs to be bounced
or not. The function must return 0 if the the buffer is OK for
DMA access and 1 if the buffer needs to be bounced.
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "int" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "int" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.SH "DESCRIPTION"
Scheduler induced bitop, do not use.
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "Kernel API" 9 "struct cmbdata" "January 2021" "API Manual" LINUX
.SH NAME
struct cmbdata \- - channel measurement block data for user space
.SH SYNOPSIS
struct cmbdata {
.br
.BI "    __u64 " size ""
;

.br
.BI "    __u64 " ssch_rsch_count ""
;

.br
.BI "    __u64 " initial_command_response_time ""
;

.br
};
.br
.SH Arguments
.IP "size" 12
	size of the stored data
.IP "ssch_rsch_count" 12
 XXX
.IP "initial_command_response_time" 12
.SH "Description"
all values are stored as 64 bit for simplicity, especially
in 32 bit emulation mode. All time values are normalized to
nanoseconds.
Currently, two formats are known, which differ by the size of
this structure, i.e. the last two members are only set when
the extended channel measurement facility (first shipped in
z990 machines) is activated.
Potentially, more fields could be added, which results in a
new ioctl number.
.SH "Description"
all values are stored as 64 bit for simplicity, especially
in 32 bit emulation mode. All time values are normalized to
nanoseconds.
Currently, two formats are known, which differ by the size of
this structure, i.e. the last two members are only set when
the extended channel measurement facility (first shipped in
z990 machines) is activated.
Potentially, more fields could be added, which results in a
new ioctl number.
.TH "enable_cmf" 9 "enable_cmf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_cmf \-  switch on the channel measurement for a specific device
.SH SYNOPSIS
.B "int" enable_cmf
.BI "(struct ccw_device *" cdev ");"
.SH ARGUMENTS
.IP "cdev" 12
	The ccw device to be enabled
returns 0 for success or a negative error value.
.SH "CONTEXT"
non-atomic
.TH "disable_cmf" 9 "disable_cmf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_cmf \-  switch off the channel measurement for a specific device
.SH SYNOPSIS
.B "int" disable_cmf
.BI "(struct ccw_device *" cdev ");"
.SH ARGUMENTS
.IP "cdev" 12
	The ccw device to be disabled
returns 0 for success or a negative error value.
.SH "CONTEXT"
non-atomic
.TH "cmf_read" 9 "cmf_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cmf_read \-  read one value from the current channel measurement block
.SH SYNOPSIS
.B "u64" cmf_read
.BI "(struct ccw_device *" cdev ","
.BI "int " index ");"
.SH ARGUMENTS
.IP "cdev" 12
-- undescribed --
.IP "index" 12
	the name of the value that is read
.SH "CONTEXT"
any
.TH "cmf_readall" 9 "cmf_readall" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cmf_readall \-  read one value from the current channel measurement block
.SH SYNOPSIS
.B "int" cmf_readall
.BI "(struct ccw_device *" cdev ","
.BI "struct cmbdata *" data ");"
.SH ARGUMENTS
.IP "cdev" 12
-- undescribed --
.IP "data" 12
	a pointer to a data block that will be filled
.SH "CONTEXT"
any
.TH "__copy_to_user" 9 "__copy_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__copy_to_user \-  Copy a block of data into user space, with less checking.
.SH SYNOPSIS
.B "unsigned long" __copy_to_user
.BI "(void __user *" to ","
.BI "const void *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "from" 12
 Source address, in kernel space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from kernel space to user space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be copied.
On success, this will be zero.
.TH "copy_to_user" 9 "copy_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_to_user \-  Copy a block of data into user space.
.SH SYNOPSIS
.B "unsigned long" copy_to_user
.BI "(void __user *" to ","
.BI "const void *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "from" 12
 Source address, in kernel space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from kernel space to user space.

Returns number of bytes that could not be copied.
On success, this will be zero.
.TH "__copy_from_user" 9 "__copy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__copy_from_user \-  Copy a block of data from user space, with less checking.
.SH SYNOPSIS
.B "unsigned long" __copy_from_user
.BI "(void *" to ","
.BI "const void __user *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in kernel space.
.IP "from" 12
 Source address, in user space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from user space to kernel space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be copied.
On success, this will be zero.

If some data could not be copied, this function will pad the copied
data to the requested size using zero bytes.
.TH "copy_from_user" 9 "copy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_from_user \-  Copy a block of data from user space.
.SH SYNOPSIS
.B "unsigned long" copy_from_user
.BI "(void *" to ","
.BI "const void __user *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in kernel space.
.IP "from" 12
 Source address, in user space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from user space to kernel space.

Returns number of bytes that could not be copied.
On success, this will be zero.

If some data could not be copied, this function will pad the copied
data to the requested size using zero bytes.
.TH "strlen_user" 9 "strlen_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlen_user \-  Get the size of a string in user space.
.SH SYNOPSIS
.B "" strlen_user
.BI "(" str ");"
.SH ARGUMENTS
.IP "str" 12
 The string to measure.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Get the size of a NUL-terminated string in user space.

Returns the size of the string INCLUDING the terminating NUL.
On exception, returns 0.

If there is a limit on the length of a valid string, you may wish to
consider using \fBstrnlen_user\fP instead.
.TH "__raw_read_can_lock" 9 "__raw_read_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__raw_read_can_lock \-  would read_trylock() succeed?
.SH SYNOPSIS
.B "" __raw_read_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "__raw_write_can_lock" 9 "__raw_write_can_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__raw_write_can_lock \-  would write_trylock() succeed?
.SH SYNOPSIS
.B "" __raw_write_can_lock
.BI "(" x ");"
.SH ARGUMENTS
.IP "x" 12
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " word ");"
.SH ARGUMENTS
.IP "word" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the next set bit in a memory region
.SH SYNOPSIS
.B "unsigned long" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned long " size ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "sh_wdt_read_cnt" 9 "sh_wdt_read_cnt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_read_cnt \-  Read from Counter
.SH SYNOPSIS
.B "__u8" sh_wdt_read_cnt
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Reads back the WTCNT value.
.TH "sh_wdt_write_cnt" 9 "sh_wdt_write_cnt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_write_cnt \-  Write to Counter
.SH SYNOPSIS
.B "void" sh_wdt_write_cnt
.BI "(__u8 " val ");"
.SH ARGUMENTS
.IP "val" 12
 Value to write
.SH "DESCRIPTION"
Writes the given value \fIval\fP to the lower byte of the timer counter.
The upper byte is set manually on each write.
.SH "DESCRIPTION"
Writes the given value \fIval\fP to the lower byte of the timer counter.
The upper byte is set manually on each write.
.TH "sh_wdt_read_csr" 9 "sh_wdt_read_csr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_read_csr \-  Read from Control/Status Register
.SH SYNOPSIS
.B "__u8" sh_wdt_read_csr
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Reads back the WTCSR value.
.TH "sh_wdt_write_csr" 9 "sh_wdt_write_csr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_write_csr \-  Write to Control/Status Register
.SH SYNOPSIS
.B "void" sh_wdt_write_csr
.BI "(__u8 " val ");"
.SH ARGUMENTS
.IP "val" 12
 Value to write
.SH "DESCRIPTION"
Writes the given value \fIval\fP to the lower byte of the control/status
register. The upper byte is set manually on each write.
.SH "DESCRIPTION"
Writes the given value \fIval\fP to the lower byte of the control/status
register. The upper byte is set manually on each write.
.TH "sh_wdt_read_rstcsr" 9 "sh_wdt_read_rstcsr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_read_rstcsr \-  Read from Reset Control/Status Register
.SH SYNOPSIS
.B "__u8" sh_wdt_read_rstcsr
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Reads back the RSTCSR value.
.TH "sh_wdt_write_rstcsr" 9 "sh_wdt_write_rstcsr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_write_rstcsr \-  Write to Reset Control/Status Register
.SH SYNOPSIS
.B "void" sh_wdt_write_rstcsr
.BI "(__u8 " val ");"
.SH ARGUMENTS
.IP "val" 12
 Value to write
.SH "DESCRIPTION"
Writes the given value \fIval\fP to the lower byte of the control/status
register. The upper byte is set manually on each write.
.SH "DESCRIPTION"
Writes the given value \fIval\fP to the lower byte of the control/status
register. The upper byte is set manually on each write.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the next set bit in a memory region
.SH SYNOPSIS
.B "unsigned long" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned long " size ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "" find_first_bit
.BI "(" addr ","
.BI "" size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "sn_sal_rev" 9 "sn_sal_rev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_rev \-  get the SGI SAL revision number
.SH SYNOPSIS
.B "u32" sn_sal_rev
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

The SGI PROM stores its version in the sal_[ab]_rev_(major|minor).
This routine simply extracts the major and minor values and
presents them in a u32 format.

For example, version 4.05 would be represented at 0x0405.
.TH "ia64_sn_pod_mode" 9 "ia64_sn_pod_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ia64_sn_pod_mode \-  call the SN_SAL_POD_MODE function
.SH SYNOPSIS
.B "u64" ia64_sn_pod_mode
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

SN_SAL_POD_MODE actually takes an argument, but it's always
0 when we call it from the kernel, so we don't have to expose
it to the caller.
.TH "ia64_sn_probe_mem" 9 "ia64_sn_probe_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ia64_sn_probe_mem \-  read from memory safely
.SH SYNOPSIS
.B "u64" ia64_sn_probe_mem
.BI "(long " addr ","
.BI "long " size ","
.BI "void *" data_ptr ");"
.SH ARGUMENTS
.IP "addr" 12
 address to probe
.IP "size" 12
 number bytes to read (1,2,4,8)
.IP "data_ptr" 12
 address to store value read by probe (-1 returned if probe fails)
.SH "DESCRIPTION"
Call into the SAL to do a memory read.  If the read generates a machine
check, this routine will recover gracefully and return -1 to the caller.
\fIaddr\fP is usually a kernel virtual address in uncached space (i.e. the
address starts with 0xc), but if called in physical mode, \fIaddr\fP should
be a physical address.
.SH "RETURN VALUES"
0 - probe successful
1 - probe failed (generated MCA)
2 - Bad arg
&lt;0 - PAL error
.TH "ia64_sn_fru_capture" 9 "ia64_sn_fru_capture" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ia64_sn_fru_capture \-  tell the system controller to capture hw state
.SH SYNOPSIS
.B "u64" ia64_sn_fru_capture
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This routine will call the SAL which will tell the system controller(s)
to capture hw mmr information from each SHub in the system.
.TH "ia64_sn_get_fit_compt" 9 "ia64_sn_get_fit_compt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ia64_sn_get_fit_compt \-  read a FIT entry from the PROM header
.SH SYNOPSIS
.B "int" ia64_sn_get_fit_compt
.BI "(u64 " nasid ","
.BI "u64 " index ","
.BI "void *" fitentry ","
.BI "void *" banbuf ","
.BI "u64 " banlen ");"
.SH ARGUMENTS
.IP "nasid" 12
 NASID of node to read
.IP "index" 12
 FIT entry index to be retrieved (0..n)
.IP "fitentry" 12
 16 byte buffer where FIT entry will be stored.
.IP "banbuf" 12
 optional buffer for retrieving banner
.IP "banlen" 12
 length of banner buffer
.SH "DESCRIPTION"
Access to the physical PROM chips needs to be serialized since reads and
writes can't occur at the same time, so we need to call into the SAL when
we want to look at the FIT entries on the chips.
.SH "RETURNS"
SALRET_OK if ok
SALRET_INVALID_ARG if index too big
SALRET_NOT_IMPLEMENTED if running on older PROM
??? if nasid invalid OR banner buffer not large enough
.TH "tioca_paddr_to_gart" 9 "tioca_paddr_to_gart" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_paddr_to_gart \-  Convert an SGI coretalk address to a CA GART entry
.SH SYNOPSIS
.B "u64" tioca_paddr_to_gart
.BI "(unsigned long " paddr ");"
.SH ARGUMENTS
.IP "paddr" 12
 page address to convert
.SH "DESCRIPTION"
Convert a system [coretalk] address to a GART entry.  GART entries are
.SH "FORMED USING THE FOLLOWING"

data = ( (1&lt;&lt;63) |  ( (REMAP_NODE_ID &lt;&lt; 40) | (MD_CHIPLET_ID &lt;&lt; 38) | 
(REMAP_SYS_ADDR) ) &gt;&gt; 12 )

DATA written to 1 GART TABLE Entry in system memory is remapped system
addr for 1 page 

The data is for coretalk address format right shifted 12 bits with a
valid bit.

GART_TABLE_ENTRY [ 25:0 ]  -- REMAP_SYS_ADDRESS[37:12].
GART_TABLE_ENTRY [ 27:26 ] -- SHUB MD chiplet id.
GART_TABLE_ENTRY [ 41:28 ] -- REMAP_NODE_ID.
GART_TABLE_ENTRY [ 63 ]    -- Valid Bit 
.TH "tioca_physpage_to_gart" 9 "tioca_physpage_to_gart" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_physpage_to_gart \-  Map a host physical page for SGI CA based DMA
.SH SYNOPSIS
.B "unsigned long" tioca_physpage_to_gart
.BI "(uint64_t " page_addr ");"
.SH ARGUMENTS
.IP "page_addr" 12
 system page address to map
.TH "tioca_tlbflush" 9 "tioca_tlbflush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_tlbflush \-  invalidate cached SGI CA GART TLB entries
.SH SYNOPSIS
.B "void" tioca_tlbflush
.BI "(struct tioca_kernel *" tioca_kernel ");"
.SH ARGUMENTS
.IP "tioca_kernel" 12
 CA context 
.SH "DESCRIPTION"
Invalidate tlb entries for a given CA GART.  Main complexity is to account
for revA bug.
.TH "set_bit" 9 "set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_bit \-  Atomically set a bit in memory
.SH SYNOPSIS
.B "void" set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
This function is atomic and may not be reordered.  See \fB__set_bit\fP
if you do not require the atomic guarantees.
Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.

The address must be (at least) "long" aligned.
Note that there are driver (e.g., eepro100) which use these operations to operate on
hw-defined data-structures, so we can't easily change these operations to force a
bigger alignment.

bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
.TH "__set_bit" 9 "__set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__set_bit \-  Set a bit in memory
.SH SYNOPSIS
.B "void" __set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBset_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "clear_bit" 9 "clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clear_bit \-  Clears a bit in memory
.SH SYNOPSIS
.B "void" clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBclear_bit\fP is atomic and may not be reordered.  However, it does
not contain a memory barrier, so if it is used for locking purposes,
you should call \fBsmp_mb__before_clear_bit\fP and/or \fBsmp_mb__after_clear_bit\fP
in order to ensure changes are visible on other processors.
.TH "__clear_bit" 9 "__clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__clear_bit \-  Clears a bit in memory (non-atomic version)
.SH SYNOPSIS
.B "void" __clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
-- undescribed --
.IP "addr" 12
-- undescribed --
.TH "change_bit" 9 "change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to clear
.IP "addr" 12
 Address to start counting from
.SH "DESCRIPTION"
\fBchange_bit\fP is atomic and may not be reordered.
Note that \fInr\fP may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.
.TH "__change_bit" 9 "__change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__change_bit \-  Toggle a bit in memory
.SH SYNOPSIS
.B "void" __change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 the bit to set
.IP "addr" 12
 the address to start counting from
.SH "DESCRIPTION"
Unlike \fBchange_bit\fP, this function is non-atomic and may be reordered.
If it's called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.
.TH "test_and_set_bit" 9 "test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "__test_and_set_bit" 9 "__test_and_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_set_bit \-  Set a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_set_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.  
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_clear_bit" 9 "test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "__test_and_clear_bit" 9 "__test_and_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__test_and_clear_bit \-  Clear a bit and return its old value
.SH SYNOPSIS
.B "int" __test_and_clear_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is non-atomic and can be reordered.  
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.
.TH "test_and_change_bit" 9 "test_and_change_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
test_and_change_bit \-  Change a bit and return its old value
.SH SYNOPSIS
.B "int" test_and_change_bit
.BI "(int " nr ","
.BI "volatile void *" addr ");"
.SH ARGUMENTS
.IP "nr" 12
 Bit to set
.IP "addr" 12
 Address to count from
.SH "DESCRIPTION"
This operation is atomic and cannot be reordered.  
It also implies a memory barrier.
.TH "ffz" 9 "ffz" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffz \-  find the first zero bit in a long word
.SH SYNOPSIS
.B "unsigned long" ffz
.BI "(unsigned long " x ");"
.SH ARGUMENTS
.IP "x" 12
 The long word to find the bit in
.SH "DESCRIPTION"
Returns the bit-number (0..63) of the first (least significant) zero bit.  Undefined if
no zero exists, so code should check against ~0UL first...
.TH "__ffs" 9 "__ffs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ffs \-  find first bit in word.
.SH SYNOPSIS
.B "unsigned long" __ffs
.BI "(unsigned long " x ");"
.SH ARGUMENTS
.IP "x" 12
 The word to search
.SH "DESCRIPTION"
Undefined if no bit exists, so code should check against 0 first.
.TH "___ia64_mmiowb" 9 "___ia64_mmiowb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
___ia64_mmiowb \-  I/O write barrier
.SH SYNOPSIS
.B "void" ___ia64_mmiowb
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Ensure ordering of I/O space writes.  This will make sure that writes
following the barrier will arrive after all previous writes.  For most
ia64 platforms, this is a simple 'mf.a' instruction.

See Documentation/DocBook/deviceiobook.tmpl for more information.
.TH "ipc_init" 9 "ipc_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_init \- 	initialise IPC subsystem
.SH SYNOPSIS
.B "int __init" ipc_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

The various system5 IPC resources (semaphores, messages and shared
memory are initialised
.TH "ipc_init_ids" 9 "ipc_init_ids" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_init_ids \- 	initialise IPC identifiers
.SH SYNOPSIS
.B "void __init" ipc_init_ids
.BI "(struct ipc_ids *" ids ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "ids" 12
 Identifier set
.IP "size" 12
 Number of identifiers
.SH "DESCRIPTION"
Given a size for the ipc identifier range (limited below IPCMNI)
set up the sequence range to use then allocate and initialise the
array itself. 
.TH "ipc_init_proc_interface" 9 "ipc_init_proc_interface" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_init_proc_interface \-   Create a proc interface for sysipc types
.SH SYNOPSIS
.B "void __init" ipc_init_proc_interface
.BI "(const char *" path ","
.BI "const char *" header ","
.BI "struct ipc_ids *" ids ","
.BI "int (*" show ") (struct seq_file *, void *));"
.SH ARGUMENTS
.IP "path" 12
 Path in procfs
.IP "header" 12
 Banner to be printed at the beginning of the file.
.IP "ids" 12
 ipc id table to iterate.
.IP "show" 12
 show routine.
.SH "DESCRIPTION"
using a seq_file interface.
.TH "ipc_findkey" 9 "ipc_findkey" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_findkey \- 	find a key in an ipc identifier set	
.SH SYNOPSIS
.B "int" ipc_findkey
.BI "(struct ipc_ids *" ids ","
.BI "key_t " key ");"
.SH ARGUMENTS
.IP "ids" 12
 Identifier set
.IP "key" 12
 The key to find
.SH "DESCRIPTION"
Requires ipc_ids.sem locked.
Returns the identifier if found or -1 if not.
.TH "ipc_addid" 9 "ipc_addid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_addid \- 	add an IPC identifier
.SH SYNOPSIS
.B "int" ipc_addid
.BI "(struct ipc_ids *" ids ","
.BI "struct kern_ipc_perm *" new ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "ids" 12
 IPC identifier set
.IP "new" 12
 new IPC permission set
.IP "size" 12
 new size limit for the id array
.SH "DESCRIPTION"
Add an entry 'new' to the IPC arrays. The permissions object is
initialised and the first free entry is set up and the id assigned
is returned. The list is returned in a locked state on success.
On failure the list is not locked and -1 is returned.

Called with ipc_ids.sem held.
.TH "ipc_rmid" 9 "ipc_rmid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_rmid \- 	remove an IPC identifier
.SH SYNOPSIS
.B "struct kern_ipc_perm*" ipc_rmid
.BI "(struct ipc_ids *" ids ","
.BI "int " id ");"
.SH ARGUMENTS
.IP "ids" 12
 identifier set
.IP "id" 12
 Identifier to remove
.SH "DESCRIPTION"
The identifier must be valid, and in use. The kernel will panic if
fed an invalid identifier. The entry is removed and internal
variables recomputed. The object associated with the identifier
is returned.
ipc_ids.sem and the spinlock for this ID is hold before this function
is called, and remain locked on the exit.
.TH "ipc_alloc" 9 "ipc_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_alloc \- 	allocate ipc space
.SH SYNOPSIS
.B "void*" ipc_alloc
.BI "(int " size ");"
.SH ARGUMENTS
.IP "size" 12
 size desired
.SH "DESCRIPTION"
Allocate memory from the appropriate pools and return a pointer to it.
NULL is returned if the allocation fails
.TH "ipc_free" 9 "ipc_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_free \-        free ipc space
.SH SYNOPSIS
.B "void" ipc_free
.BI "(void *" ptr ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "ptr" 12
 pointer returned by ipc_alloc
.IP "size" 12
 size of block
.SH "DESCRIPTION"
Free a block created with ipc_alloc. The caller must know the size
used in the allocation call.
.TH "ipc_rcu_alloc" 9 "ipc_rcu_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_rcu_alloc \- 	allocate ipc and rcu space 
.SH SYNOPSIS
.B "void*" ipc_rcu_alloc
.BI "(int " size ");"
.SH ARGUMENTS
.IP "size" 12
 size desired
.SH "DESCRIPTION"
Allocate memory for the rcu header structure +  the object.
Returns the pointer to the object.
NULL is returned if the allocation fails. 
.TH "ipc_schedule_free" 9 "ipc_schedule_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_schedule_free \-  free ipc + rcu space
.SH SYNOPSIS
.B "void" ipc_schedule_free
.BI "(struct rcu_head *" head ");"
.SH ARGUMENTS
.IP "head" 12
-- undescribed --
.SH "DESCRIPTION"

Since RCU callback function is called in bh,
we need to defer the vfree to schedule_work
.TH "ipc_immediate_free" 9 "ipc_immediate_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_immediate_free \-  free ipc + rcu space
.SH SYNOPSIS
.B "void" ipc_immediate_free
.BI "(struct rcu_head *" head ");"
.SH ARGUMENTS
.IP "head" 12
-- undescribed --
.SH "DESCRIPTION"

Free from the RCU callback context
.TH "ipcperms" 9 "ipcperms" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipcperms \- 	check IPC permissions
.SH SYNOPSIS
.B "int" ipcperms
.BI "(struct kern_ipc_perm *" ipcp ","
.BI "short " flag ");"
.SH ARGUMENTS
.IP "ipcp" 12
 IPC permission set
.IP "flag" 12
 desired permission set.
.SH "DESCRIPTION"
Check user, group, other permissions for access
to ipc resources. return 0 if allowed
.TH "kernel_to_ipc64_perm" 9 "kernel_to_ipc64_perm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kernel_to_ipc64_perm \- 	convert kernel ipc permissions to user
.SH SYNOPSIS
.B "void" kernel_to_ipc64_perm
.BI "(struct kern_ipc_perm *" in ","
.BI "struct ipc64_perm *" out ");"
.SH ARGUMENTS
.IP "in" 12
 kernel permissions
.IP "out" 12
 new style IPC permissions
.SH "DESCRIPTION"
Turn the kernel object 'in' into a set of permissions descriptions
for returning to userspace (out).
.TH "ipc64_perm_to_ipc_perm" 9 "ipc64_perm_to_ipc_perm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc64_perm_to_ipc_perm \- 	convert old ipc permissions to new
.SH SYNOPSIS
.B "void" ipc64_perm_to_ipc_perm
.BI "(struct ipc64_perm *" in ","
.BI "struct ipc_perm *" out ");"
.SH ARGUMENTS
.IP "in" 12
 new style IPC permissions
.IP "out" 12
 old style IPC permissions
.SH "DESCRIPTION"
Turn the new style permissions object in into a compatibility
object and store it into the 'out' pointer.
.TH "ipc_parse_version" 9 "ipc_parse_version" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipc_parse_version \- 	IPC call version
.SH SYNOPSIS
.B "int" ipc_parse_version
.BI "(int *" cmd ");"
.SH ARGUMENTS
.IP "cmd" 12
 pointer to command
.SH "DESCRIPTION"
Return IPC_64 for new style IPC and IPC_OLD for old style IPC. 
The cmd value is turned from an encoding command and version into
just the command code.
.TH "klist_init" 9 "klist_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_init \-  Initialize a klist structure. 
.SH SYNOPSIS
.B "void" klist_init
.BI "(struct klist *" k ","
.BI "void (*" get ") (struct klist_node *),"
.BI "void (*" put ") (struct klist_node *));"
.SH ARGUMENTS
.IP "k" 12
	The klist we're initializing.
.IP "get" 12
	The get function for the embedding object (NULL if none)
.IP "put" 12
	The put function for the embedding object (NULL if none)
.SH "DESCRIPTION"
Initialises the klist structure.  If the klist_node structures are
going to be embedded in refcounted objects (necessary for safe
deletion) then the get/put arguments are used to initialise
functions that take and release references on the embedding
objects.
.TH "klist_add_head" 9 "klist_add_head" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_add_head \-  Initialize a klist_node and add it to front.
.SH SYNOPSIS
.B "void" klist_add_head
.BI "(struct klist_node *" n ","
.BI "struct klist *" k ");"
.SH ARGUMENTS
.IP "n" 12
	node we're adding.
.IP "k" 12
	klist it's going on.
.TH "klist_add_tail" 9 "klist_add_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_add_tail \-  Initialize a klist_node and add it to back.
.SH SYNOPSIS
.B "void" klist_add_tail
.BI "(struct klist_node *" n ","
.BI "struct klist *" k ");"
.SH ARGUMENTS
.IP "n" 12
	node we're adding.
.IP "k" 12
	klist it's going on.
.TH "klist_del" 9 "klist_del" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_del \-  Decrement the reference count of node and try to remove.
.SH SYNOPSIS
.B "void" klist_del
.BI "(struct klist_node *" n ");"
.SH ARGUMENTS
.IP "n" 12
	node we're deleting.
.TH "klist_remove" 9 "klist_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_remove \-  Decrement the refcount of node and wait for it to go away.
.SH SYNOPSIS
.B "void" klist_remove
.BI "(struct klist_node *" n ");"
.SH ARGUMENTS
.IP "n" 12
	node we're removing.
.TH "klist_node_attached" 9 "klist_node_attached" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_node_attached \-  Say whether a node is bound to a list or not.
.SH SYNOPSIS
.B "int" klist_node_attached
.BI "(struct klist_node *" n ");"
.SH ARGUMENTS
.IP "n" 12
	Node that we're testing.
.TH "klist_iter_init_node" 9 "klist_iter_init_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_iter_init_node \-  Initialize a klist_iter structure.
.SH SYNOPSIS
.B "void" klist_iter_init_node
.BI "(struct klist *" k ","
.BI "struct klist_iter *" i ","
.BI "struct klist_node *" n ");"
.SH ARGUMENTS
.IP "k" 12
	klist we're iterating.
.IP "i" 12
	klist_iter we're filling.
.IP "n" 12
	node to start with.
.SH "DESCRIPTION"
Similar to \fBklist_iter_init\fP, but starts the action off with \fIn\fP, 
instead of with the list head.
.TH "klist_iter_init" 9 "klist_iter_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_iter_init \-  Iniitalize a klist_iter structure.
.SH SYNOPSIS
.B "void" klist_iter_init
.BI "(struct klist *" k ","
.BI "struct klist_iter *" i ");"
.SH ARGUMENTS
.IP "k" 12
	klist we're iterating.
.IP "i" 12
	klist_iter structure we're filling.
.SH "DESCRIPTION"
Similar to \fBklist_iter_init_node\fP, but start with the list head.
.TH "klist_iter_exit" 9 "klist_iter_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_iter_exit \-  Finish a list iteration.
.SH SYNOPSIS
.B "void" klist_iter_exit
.BI "(struct klist_iter *" i ");"
.SH ARGUMENTS
.IP "i" 12
	Iterator structure.
.SH "DESCRIPTION"
Must be called when done iterating over list, as it decrements the 
refcount of the current node. Necessary in case iteration exited before
the end of the list was reached, and always good form.
.TH "klist_next" 9 "klist_next" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
klist_next \-  Ante up next node in list.
.SH SYNOPSIS
.B "struct klist_node *" klist_next
.BI "(struct klist_iter *" i ");"
.SH ARGUMENTS
.IP "i" 12
	Iterator structure.
.SH "DESCRIPTION"
First grab list lock. Decrement the reference count of the previous
node, if there was one. Grab the next node, increment its reference 
count, drop the lock, and return that next node.
.TH "crc_ccitt" 9 "crc_ccitt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc_ccitt \-  recompute the CRC for the data buffer
.SH SYNOPSIS
.B "u16" crc_ccitt
.BI "(u16 " crc ","
.BI "u8 const *" buffer ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "crc" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
\fIcrc\fP - previous CRC value
\fIbuffer\fP - data pointer
\fIlen\fP - number of bytes in the buffer
.TH "populate_dir" 9 "populate_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
populate_dir \-  populate directory with attributes.
.SH SYNOPSIS
.B "int" populate_dir
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object we're working on.
.SH "DESCRIPTION"
Most subsystems have a set of default attributes that 
are associated with an object that registers with them.
This is a helper called during object registration that 
loops through the default attributes of the subsystem 
and creates attributes files for them in sysfs.
.TH "kobject_get_path" 9 "kobject_get_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_get_path \-  generate and return the path associated with a given kobj
.SH SYNOPSIS
.B "char *" kobject_get_path
.BI "(struct kobject *" kobj ","
.BI "int " gfp_mask ");"
.SH ARGUMENTS
.IP "kobj" 12
	kobject in question, with which to build the path
.IP "gfp_mask" 12
	the allocation type used to allocate the path
.SH "DESCRIPTION"
and kset pair.  The result must be freed by the caller with \fBkfree\fP.
.TH "kobject_init" 9 "kobject_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_init \-  initialize object.
.SH SYNOPSIS
.B "void" kobject_init
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object in question.
.TH "unlink" 9 "unlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unlink \-  remove kobject from kset list.
.SH SYNOPSIS
.B "void" unlink
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	kobject.
.SH "DESCRIPTION"
Remove the kobject from the kset list and decrement
its parent's refcount.
This is separated out, so we can use it in both 
\fBkobject_del\fP and \fBkobject_add\fP on error.
.TH "kobject_add" 9 "kobject_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_add \-  add an object to the hierarchy.
.SH SYNOPSIS
.B "int" kobject_add
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.TH "kobject_register" 9 "kobject_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_register \-  initialize and add an object.
.SH SYNOPSIS
.B "int" kobject_register
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object in question.
.TH "kobject_set_name" 9 "kobject_set_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_set_name \-  Set the name of an object
.SH SYNOPSIS
.B "int" kobject_set_name
.BI "(struct kobject *" kobj ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.IP "fmt" 12
	format string used to build the name
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
If strlen(name) &gt;= KOBJ_NAME_LEN, then use a dynamically allocated
string that \fIkobj\fP-&gt;k_name points to. Otherwise, use the static 
\fIkobj\fP-&gt;name array.
.TH "kobject_rename" 9 "kobject_rename" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_rename \-  change the name of an object
.SH SYNOPSIS
.B "int" kobject_rename
.BI "(struct kobject *" kobj ","
.BI "const char *" new_name ");"
.SH ARGUMENTS
.IP "kobj" 12
	object in question.
.IP "new_name" 12
 object's new name
.TH "kobject_del" 9 "kobject_del" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_del \-  unlink kobject from hierarchy.
.SH SYNOPSIS
.B "void" kobject_del
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.TH "kobject_unregister" 9 "kobject_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_unregister \-  remove object from hierarchy and decrement refcount.
.SH SYNOPSIS
.B "void" kobject_unregister
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object going away.
.TH "kobject_get" 9 "kobject_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_get \-  increment refcount for object.
.SH SYNOPSIS
.B "struct kobject *" kobject_get
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.TH "kobject_cleanup" 9 "kobject_cleanup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_cleanup \-  free kobject resources. 
.SH SYNOPSIS
.B "void" kobject_cleanup
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.TH "kobject_put" 9 "kobject_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_put \-  decrement refcount for object.
.SH SYNOPSIS
.B "void" kobject_put
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.SH "DESCRIPTION"
Decrement the refcount, and if 0, call \fBkobject_cleanup\fP.
.TH "kset_init" 9 "kset_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kset_init \-  initialize a kset for use
.SH SYNOPSIS
.B "void" kset_init
.BI "(struct kset *" k ");"
.SH ARGUMENTS
.IP "k" 12
	kset 
.TH "kset_add" 9 "kset_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kset_add \-  add a kset object to the hierarchy.
.SH SYNOPSIS
.B "int" kset_add
.BI "(struct kset *" k ");"
.SH ARGUMENTS
.IP "k" 12
	kset.
.SH "DESCRIPTION"
Simply, this adds the kset's embedded kobject to the 
hierarchy. 
We also try to make sure that the kset's embedded kobject
has a parent before it is added. We only care if the embedded
kobject is not part of a kset itself, since \fBkobject_add\fP
assigns a parent in that case. 
If that is the case, and the kset has a controlling subsystem,
then we set the kset's parent to be said subsystem. 
.TH "kset_register" 9 "kset_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kset_register \-  initialize and add a kset.
.SH SYNOPSIS
.B "int" kset_register
.BI "(struct kset *" k ");"
.SH ARGUMENTS
.IP "k" 12
	kset.
.TH "kset_unregister" 9 "kset_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kset_unregister \-  remove a kset.
.SH SYNOPSIS
.B "void" kset_unregister
.BI "(struct kset *" k ");"
.SH ARGUMENTS
.IP "k" 12
	kset.
.TH "kset_find_obj" 9 "kset_find_obj" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kset_find_obj \-  search for object in kset.
.SH SYNOPSIS
.B "struct kobject *" kset_find_obj
.BI "(struct kset *" kset ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "kset" 12
	kset we're looking in.
.IP "name" 12
	object's name.
.SH "DESCRIPTION"
Lock kset via \fIkset\fP-&gt;subsys, and iterate over \fIkset\fP-&gt;list,
looking for a matching kobject. If matching object is found
take a reference and return the object.
.TH "subsystem_register" 9 "subsystem_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
subsystem_register \-  register a subsystem.
.SH SYNOPSIS
.B "int" subsystem_register
.BI "(struct subsystem *" s ");"
.SH ARGUMENTS
.IP "s" 12
	the subsystem we're registering.
.SH "DESCRIPTION"
Once we register the subsystem, we want to make sure that 
the kset points back to this subsystem for correct usage of 
the rwsem. 
.TH "subsys_create_file" 9 "subsys_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
subsys_create_file \-  export sysfs attribute file.
.SH SYNOPSIS
.B "int" subsys_create_file
.BI "(struct subsystem *" s ","
.BI "struct subsys_attribute *" a ");"
.SH ARGUMENTS
.IP "s" 12
	subsystem.
.IP "a" 12
	subsystem attribute descriptor.
.TH "subsys_remove_file" 9 "subsys_remove_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
subsys_remove_file \-  remove sysfs attribute file.
.SH SYNOPSIS
.B "void" subsys_remove_file
.BI "(struct subsystem *" s ","
.BI "struct subsys_attribute *" a ");"
.SH ARGUMENTS
.IP "s" 12
	subsystem.
.IP "a" 12
	attribute desciptor.
.TH "idr_pre_get" 9 "idr_pre_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idr_pre_get \-  reserver resources for idr allocation
.SH SYNOPSIS
.B "int" idr_pre_get
.BI "(struct idr *" idp ","
.BI "unsigned " gfp_mask ");"
.SH ARGUMENTS
.IP "idp" 12
	idr handle
.IP "gfp_mask" 12
	memory allocation flags
.SH "DESCRIPTION"
This function should be called prior to locking and calling the
following function.  It preallocates enough memory to satisfy
the worst possible allocation.

If the system is REALLY out of memory this function returns 0,
otherwise 1.
.TH "idr_get_new_above" 9 "idr_get_new_above" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idr_get_new_above \-  allocate new idr entry above or equal to a start id
.SH SYNOPSIS
.B "int" idr_get_new_above
.BI "(struct idr *" idp ","
.BI "void *" ptr ","
.BI "int " starting_id ","
.BI "int *" id ");"
.SH ARGUMENTS
.IP "idp" 12
 idr handle
.IP "ptr" 12
 pointer you want associated with the ide
.IP "starting_id" 12
-- undescribed --
.IP "id" 12
 pointer to the allocated handle
.SH "DESCRIPTION"
This is the allocate id function.  It should be called with any
required locks.

If memory is required, it will return -EAGAIN, you should unlock
and go back to the \fBidr_pre_get\fP call.  If the idr is full, it will
return -ENOSPC.

\fIid\fP returns a value in the range 0 ... 0x7fffffff
.TH "idr_get_new" 9 "idr_get_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idr_get_new \-  allocate new idr entry
.SH SYNOPSIS
.B "int" idr_get_new
.BI "(struct idr *" idp ","
.BI "void *" ptr ","
.BI "int *" id ");"
.SH ARGUMENTS
.IP "idp" 12
 idr handle
.IP "ptr" 12
 pointer you want associated with the ide
.IP "id" 12
 pointer to the allocated handle
.SH "DESCRIPTION"
This is the allocate id function.  It should be called with any
required locks.

If memory is required, it will return -EAGAIN, you should unlock
and go back to the \fBidr_pre_get\fP call.  If the idr is full, it will
return -ENOSPC.

\fIid\fP returns a value in the range 0 ... 0x7fffffff
.TH "idr_remove" 9 "idr_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idr_remove \-  remove the given id and free it's slot
.SH SYNOPSIS
.B "void" idr_remove
.BI "(struct idr *" idp ","
.BI "int " id ");"
.SH ARGUMENTS
.IP "idp" 12
-- undescribed --
.IP "id" 12
-- undescribed --
.SH "IDP"
 idr handle
.SH "ID"
 uniqueue key
.TH "idr_destroy" 9 "idr_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idr_destroy \-  release all cached layers within an idr tree
.SH SYNOPSIS
.B "void" idr_destroy
.BI "(struct idr *" idp ");"
.SH ARGUMENTS
.IP "idp" 12
-- undescribed --
.SH "IDP"
 idr handle
.TH "idr_find" 9 "idr_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idr_find \-  return pointer for given id
.SH SYNOPSIS
.B "void *" idr_find
.BI "(struct idr *" idp ","
.BI "int " id ");"
.SH ARGUMENTS
.IP "idp" 12
 idr handle
.IP "id" 12
 lookup key
.SH "DESCRIPTION"
Return the pointer given the id it has been registered with.  A NULL
return indicates that \fIid\fP is not valid or you passed NULL in
\fBidr_get_new\fP.

The caller must serialize \fBidr_find\fP vs \fBidr_get_new\fP and \fBidr_remove\fP.
.TH "idr_init" 9 "idr_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idr_init \-  initialize idr handle
.SH SYNOPSIS
.B "void" idr_init
.BI "(struct idr *" idp ");"
.SH ARGUMENTS
.IP "idp" 12
	idr handle
.SH "DESCRIPTION"
This function is use to set up the handle (\fIidp\fP) that you will pass
to the rest of the functions.
.TH "radix_tree_insert" 9 "radix_tree_insert" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_insert \-     insert into a radix tree
.SH SYNOPSIS
.B "int" radix_tree_insert
.BI "(struct radix_tree_root *" root ","
.BI "unsigned long " index ","
.BI "void *" item ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "index" 12
		index key
.IP "item" 12
		item to insert
.SH "DESCRIPTION"
Insert an item into the radix tree at position \fIindex\fP.
.TH "radix_tree_lookup" 9 "radix_tree_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_lookup \-     perform lookup operation on a radix tree
.SH SYNOPSIS
.B "void *" radix_tree_lookup
.BI "(struct radix_tree_root *" root ","
.BI "unsigned long " index ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "index" 12
		index key
.SH "DESCRIPTION"
Lookup the item at the position \fIindex\fP in the radix tree \fIroot\fP.
.TH "radix_tree_tag_set" 9 "radix_tree_tag_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_tag_set \-  set a tag on a radix tree node
.SH SYNOPSIS
.B "void *" radix_tree_tag_set
.BI "(struct radix_tree_root *" root ","
.BI "unsigned long " index ","
.BI "int " tag ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "index" 12
		index key
.IP "tag" 12
 		tag index
.SH "DESCRIPTION"
Set the search tag corresponging to \fIindex\fP in the radix tree.  From
the root all the way down to the leaf node.

Returns the address of the tagged item.   Setting a tag on a not-present
item is a bug.
.TH "radix_tree_tag_clear" 9 "radix_tree_tag_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_tag_clear \-  clear a tag on a radix tree node
.SH SYNOPSIS
.B "void *" radix_tree_tag_clear
.BI "(struct radix_tree_root *" root ","
.BI "unsigned long " index ","
.BI "int " tag ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "index" 12
		index key
.IP "tag" 12
 		tag index
.SH "DESCRIPTION"
Clear the search tag corresponging to \fIindex\fP in the radix tree.  If
this causes the leaf node to have no tags set then clear the tag in the
next-to-leaf node, etc.

Returns the address of the tagged item on success, else NULL.  ie:
has the same return value and semantics as \fBradix_tree_lookup\fP.
.TH "radix_tree_tag_get" 9 "radix_tree_tag_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_tag_get \-  get a tag on a radix tree node
.SH SYNOPSIS
.B "int" radix_tree_tag_get
.BI "(struct radix_tree_root *" root ","
.BI "unsigned long " index ","
.BI "int " tag ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "index" 12
		index key
.IP "tag" 12
 		tag index
.SH "RETURN VALUES"
.SH "0"
 tag not present
.SH "1"
 tag present, set
-1: tag present, unset
.TH "radix_tree_gang_lookup" 9 "radix_tree_gang_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_gang_lookup \-  perform multiple lookup on a radix tree
.SH SYNOPSIS
.B "unsigned int" radix_tree_gang_lookup
.BI "(struct radix_tree_root *" root ","
.BI "void **" results ","
.BI "unsigned long " first_index ","
.BI "unsigned int " max_items ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "results" 12
	where the results of the lookup are placed
.IP "first_index" 12
	start the lookup from this key
.IP "max_items" 12
	place up to this many items at *results
.SH "DESCRIPTION"
Performs an index-ascending scan of the tree for present items.  Places
them at *\fIresults\fP and returns the number of items which were placed at
*\fIresults\fP.

The implementation is naive.
.TH "radix_tree_gang_lookup_tag" 9 "radix_tree_gang_lookup_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_gang_lookup_tag \-  perform multiple lookup on a radix tree
.SH SYNOPSIS
.B "unsigned int" radix_tree_gang_lookup_tag
.BI "(struct radix_tree_root *" root ","
.BI "void **" results ","
.BI "unsigned long " first_index ","
.BI "unsigned int " max_items ","
.BI "int " tag ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "results" 12
	where the results of the lookup are placed
.IP "first_index" 12
	start the lookup from this key
.IP "max_items" 12
	place up to this many items at *results
.IP "tag" 12
		the tag index
.SH "DESCRIPTION"
Performs an index-ascending scan of the tree for present items which
have the tag indexed by \fItag\fP set.  Places the items at *\fIresults\fP and
returns the number of items which were placed at *\fIresults\fP.
.SH "DESCRIPTION"
Performs an index-ascending scan of the tree for present items which
have the tag indexed by \fItag\fP set.  Places the items at *\fIresults\fP and
returns the number of items which were placed at *\fIresults\fP.
.TH "radix_tree_delete" 9 "radix_tree_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_delete \-     delete an item from a radix tree
.SH SYNOPSIS
.B "void *" radix_tree_delete
.BI "(struct radix_tree_root *" root ","
.BI "unsigned long " index ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "index" 12
		index key
.SH "DESCRIPTION"
Remove the item at \fIindex\fP from the radix tree rooted at \fIroot\fP.

Returns the address of the deleted item, or NULL if it was not present.
.TH "radix_tree_tagged" 9 "radix_tree_tagged" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radix_tree_tagged \-  test whether any items in the tree are tagged
.SH SYNOPSIS
.B "int" radix_tree_tagged
.BI "(struct radix_tree_root *" root ","
.BI "int " tag ");"
.SH ARGUMENTS
.IP "root" 12
		radix tree root
.IP "tag" 12
		tag to test
.TH "crc16" 9 "crc16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc16 \- 16 for the data buffer
.SH SYNOPSIS
.B "u16" crc16
.BI "(u16 " crc ","
.BI "u8 const *" buffer ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "crc" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP crc     previous CRC value
\fIparam\fP buffer  data pointer
\fIparam\fP len     number of bytes in the buffer
\fIreturn\fP        the updated CRC value
.TH "kref_init" 9 "kref_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kref_init \-  initialize object.
.SH SYNOPSIS
.B "void" kref_init
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
 object in question.
.TH "kref_get" 9 "kref_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kref_get \-  increment refcount for object.
.SH SYNOPSIS
.B "void" kref_get
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
 object.
.TH "kref_put" 9 "kref_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kref_put \-  decrement refcount for object.
.SH SYNOPSIS
.B "int" kref_put
.BI "(struct kref *" kref ","
.BI "void (*" release ") (struct kref *kref));"
.SH ARGUMENTS
.IP "kref" 12
 object.
.IP "release" 12
 pointer to the function that will clean up the object when the
last reference to the object is released.
This pointer is required, and it is not acceptable to pass kfree
in as this function.
.SH "DESCRIPTION"
Decrement the refcount, and if 0, call \fBrelease\fP.
Return 1 if the object was removed, otherwise return 0.  Beware, if this
function returns 0, you still can not count on the kref from remaining in
memory.  Only use the return value if you want to see if the kref is now
gone, not present.
.TH "rs_init" 9 "rs_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rs_init \-  Initialize a Reed-Solomon codec
.SH SYNOPSIS
.B "struct rs_control *" rs_init
.BI "(int " symsize ","
.BI "int " gfpoly ","
.BI "int " fcr ","
.BI "int " prim ","
.BI "int " nroots ");"
.SH ARGUMENTS
.IP "symsize" 12
	symbol size, bits (1-8)
.IP "gfpoly" 12
	Field generator polynomial coefficients
.IP "fcr" 12
	first root of RS code generator polynomial, index form
.IP "prim" 12
	primitive element to generate polynomial roots
.IP "nroots" 12
	RS code generator polynomial degree (number of roots)
.SH "DESCRIPTION"
Allocate a control structure and the polynom arrays for faster
en/decoding. Fill the arrays according to the given parameters
.SH "DESCRIPTION"
Allocate a control structure and the polynom arrays for faster
en/decoding. Fill the arrays according to the given parameters
.TH "free_rs" 9 "free_rs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_rs \-  Free the rs control structure, if its not longer used
.SH SYNOPSIS
.B "void" free_rs
.BI "(struct rs_control *" rs ");"
.SH ARGUMENTS
.IP "rs" 12
	the control structure which is not longer used by the
caller
.SH "DESCRIPTION"
.TH "init_rs" 9 "init_rs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_rs \-  Find a matching or allocate a new rs control structure
.SH SYNOPSIS
.B "struct rs_control *" init_rs
.BI "(int " symsize ","
.BI "int " gfpoly ","
.BI "int " fcr ","
.BI "int " prim ","
.BI "int " nroots ");"
.SH ARGUMENTS
.IP "symsize" 12
	the symbol size (number of bits)
.IP "gfpoly" 12
	the extended Galois field generator polynomial coefficients,
with the 0th coefficient in the low order bit. The polynomial
must be primitive;
.IP "fcr" 12
  	the first consecutive root of the rs code generator polynomial 
in index form
.IP "prim" 12
	primitive element to generate polynomial roots
.IP "nroots" 12
	RS code generator polynomial degree (number of roots)
.SH "DESCRIPTION"
.TH "encode_rs8" 9 "encode_rs8" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
encode_rs8 \-  Calculate the parity for data values (8bit data width)
.SH SYNOPSIS
.B "int" encode_rs8
.BI "(struct rs_control *" rs ","
.BI "uint8_t *" data ","
.BI "int " len ","
.BI "uint16_t *" par ","
.BI "uint16_t " invmsk ");"
.SH ARGUMENTS
.IP "rs" 12
	the rs control structure
.IP "data" 12
	data field of a given type
.IP "len" 12
	data length 
.IP "par" 12
	parity data, must be initialized by caller (usually all 0)
.IP "invmsk" 12
	invert data mask (will be xored on data)
.SH "DESCRIPTION"
The parity uses a uint16_t data type to enable
symbol size &gt; 8. The calling code must take care of encoding of the
syndrome result for storage itself.
.SH "DESCRIPTION"
The parity uses a uint16_t data type to enable
symbol size &gt; 8. The calling code must take care of encoding of the
syndrome result for storage itself.
.TH "decode_rs8" 9 "decode_rs8" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
decode_rs8 \-  Decode codeword (8bit data width)
.SH SYNOPSIS
.B "int" decode_rs8
.BI "(struct rs_control *" rs ","
.BI "uint8_t *" data ","
.BI "uint16_t *" par ","
.BI "int " len ","
.BI "uint16_t *" s ","
.BI "int " no_eras ","
.BI "int *" eras_pos ","
.BI "uint16_t " invmsk ","
.BI "uint16_t *" corr ");"
.SH ARGUMENTS
.IP "rs" 12
	the rs control structure
.IP "data" 12
	data field of a given type
.IP "par" 12
	received parity data field
.IP "len" 12
	data length
.IP "s" 12
		syndrome data field (if NULL, syndrome is calculated)
.IP "no_eras" 12
	number of erasures
.IP "eras_pos" 12
	position of erasures, can be NULL
.IP "invmsk" 12
	invert data mask (will be xored on data, not on parity!)
.IP "corr" 12
	buffer to store correction bitmask on eras_pos
.SH "DESCRIPTION"
The syndrome and parity uses a uint16_t data type to enable
symbol size &gt; 8. The calling code must take care of decoding of the
syndrome result and the received parity before calling this code.
.SH "DESCRIPTION"
The syndrome and parity uses a uint16_t data type to enable
symbol size &gt; 8. The calling code must take care of decoding of the
syndrome result and the received parity before calling this code.
.TH "encode_rs16" 9 "encode_rs16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
encode_rs16 \-  Calculate the parity for data values (16bit data width)
.SH SYNOPSIS
.B "int" encode_rs16
.BI "(struct rs_control *" rs ","
.BI "uint16_t *" data ","
.BI "int " len ","
.BI "uint16_t *" par ","
.BI "uint16_t " invmsk ");"
.SH ARGUMENTS
.IP "rs" 12
	the rs control structure
.IP "data" 12
	data field of a given type
.IP "len" 12
	data length 
.IP "par" 12
	parity data, must be initialized by caller (usually all 0)
.IP "invmsk" 12
	invert data mask (will be xored on data, not on parity!)
.SH "DESCRIPTION"
Each field in the data array contains up to symbol size bits of valid data.
.SH "DESCRIPTION"
Each field in the data array contains up to symbol size bits of valid data.
.TH "decode_rs16" 9 "decode_rs16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
decode_rs16 \-  Decode codeword (16bit data width)
.SH SYNOPSIS
.B "int" decode_rs16
.BI "(struct rs_control *" rs ","
.BI "uint16_t *" data ","
.BI "uint16_t *" par ","
.BI "int " len ","
.BI "uint16_t *" s ","
.BI "int " no_eras ","
.BI "int *" eras_pos ","
.BI "uint16_t " invmsk ","
.BI "uint16_t *" corr ");"
.SH ARGUMENTS
.IP "rs" 12
	the rs control structure
.IP "data" 12
	data field of a given type
.IP "par" 12
	received parity data field
.IP "len" 12
	data length
.IP "s" 12
		syndrome data field (if NULL, syndrome is calculated)
.IP "no_eras" 12
	number of erasures
.IP "eras_pos" 12
	position of erasures, can be NULL
.IP "invmsk" 12
	invert data mask (will be xored on data, not on parity!) 
.IP "corr" 12
	buffer to store correction bitmask on eras_pos
.SH "DESCRIPTION"
Each field in the data array contains up to symbol size bits of valid data.
.SH "DESCRIPTION"
Each field in the data array contains up to symbol size bits of valid data.
.TH "crc32init_le" 9 "crc32init_le" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc32init_le \-  allocate and initialize LE table data
.SH SYNOPSIS
.B "void" crc32init_le
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

crc is the crc of the byte i; other entries are filled in based on the
fact that crctable[i^j] = crctable[i] ^ crctable[j].
.TH "crc32init_be" 9 "crc32init_be" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc32init_be \-  allocate and initialize BE table data
.SH SYNOPSIS
.B "void" crc32init_be
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "match_one" 9 "match_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_one \-  Determines if a string matches a simple pattern
.SH SYNOPSIS
.B "int" match_one
.BI "(char *" s ","
.BI "char *" p ","
.BI "substring_t " args[] ");"
.SH ARGUMENTS
.IP "s" 12
 the string to examine for presense of the pattern
.IP "p" 12
 the string containing the pattern
.IP "args[]" 12
 array of MAX_OPT_ARGS &amp;substring_t elements. Used to return match
locations.
.SH "DESCRIPTION"
 Determines if the pattern \fIp\fP is present in string \fIs\fP. Can only
match extremely simple token=arg style patterns. If the pattern is found,
the location(s) of the arguments will be returned in the \fIargs\fP array.
.TH "match_token" 9 "match_token" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_token \-  Find a token (and optional args) in a string
.SH SYNOPSIS
.B "int" match_token
.BI "(char *" s ","
.BI "match_table_t " table ","
.BI "substring_t " args[] ");"
.SH ARGUMENTS
.IP "s" 12
 the string to examine for token/argument pairs
.IP "table" 12
 match_table_t describing the set of allowed option tokens and the
arguments that may be associated with them. Must be terminated with a
&amp;struct match_token whose pattern is set to the NULL pointer.
.IP "args[]" 12
 array of MAX_OPT_ARGS &amp;substring_t elements. Used to return match
locations.
.SH "DESCRIPTION"
 Detects which if any of a set of token strings has been passed
to it. Tokens can include up to MAX_OPT_ARGS instances of basic c-style
format identifiers which will be taken into account when matching the
tokens, and whose locations will be returned in the \fIargs\fP array.
.TH "match_number" 9 "match_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_number \- 
.SH SYNOPSIS
.B "int" match_number
.BI "(substring_t *" s ","
.BI "int *" result ","
.BI "int " base ");"
.SH ARGUMENTS
.IP "s" 12
 substring to be scanned
.IP "result" 12
 resulting integer on success
.IP "base" 12
 base to use when converting string
.SH "DESCRIPTION"
 Given a &amp;substring_t and a base, attempts to parse the substring
as a number in that base. On success, sets \fIresult\fP to the integer represented
by the string and returns 0. Returns either -ENOMEM or -EINVAL on failure.
.TH "match_int" 9 "match_int" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_int \-  scan a decimal representation of an integer from a substring_t
.SH SYNOPSIS
.B "int" match_int
.BI "(substring_t *" s ","
.BI "int *" result ");"
.SH ARGUMENTS
.IP "s" 12
 substring_t to be scanned
.IP "result" 12
 resulting integer on success
.SH "DESCRIPTION"
 Attempts to parse the &amp;substring_t \fIs\fP as a decimal integer. On
success, sets \fIresult\fP to the integer represented by the string and returns 0.
Returns either -ENOMEM or -EINVAL on failure.
.TH "match_octal" 9 "match_octal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_octal \-  scan an octal representation of an integer from a substring_t
.SH SYNOPSIS
.B "int" match_octal
.BI "(substring_t *" s ","
.BI "int *" result ");"
.SH ARGUMENTS
.IP "s" 12
 substring_t to be scanned
.IP "result" 12
 resulting integer on success
.SH "DESCRIPTION"
 Attempts to parse the &amp;substring_t \fIs\fP as an octal integer. On
success, sets \fIresult\fP to the integer represented by the string and returns
0. Returns either -ENOMEM or -EINVAL on failure.
.TH "match_hex" 9 "match_hex" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_hex \-  scan a hex representation of an integer from a substring_t
.SH SYNOPSIS
.B "int" match_hex
.BI "(substring_t *" s ","
.BI "int *" result ");"
.SH ARGUMENTS
.IP "s" 12
 substring_t to be scanned
.IP "result" 12
 resulting integer on success
.SH "DESCRIPTION"
 Attempts to parse the &amp;substring_t \fIs\fP as a hexadecimal integer.
On success, sets \fIresult\fP to the integer represented by the string and
returns 0. Returns either -ENOMEM or -EINVAL on failure.
.TH "match_strcpy" 9 "match_strcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_strcpy \-  copies the characters from a substring_t to a string
.SH SYNOPSIS
.B "void" match_strcpy
.BI "(char *" to ","
.BI "substring_t *" s ");"
.SH ARGUMENTS
.IP "to" 12
 string to copy characters to.
.IP "s" 12
 &amp;substring_t to copy
.SH "DESCRIPTION"
 Copies the set of characters represented by the given
&amp;substring_t \fIs\fP to the c-style string \fIto\fP. Caller guarantees that \fIto\fP is
large enough to hold the characters of \fIs\fP.
.TH "match_strdup" 9 "match_strdup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_strdup \-  allocate a new string with the contents of a substring_t
.SH SYNOPSIS
.B "char *" match_strdup
.BI "(substring_t *" s ");"
.SH ARGUMENTS
.IP "s" 12
 &amp;substring_t to copy
.SH "DESCRIPTION"
 Allocates and returns a string filled with the contents of
the &amp;substring_t \fIs\fP. The caller is responsible for freeing the returned
string with \fBkfree\fP.
.TH "crc32_le" 9 "crc32_le" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc32_le \-  Calculate bitwise little-endian Ethernet AUTODIN II CRC32
.SH SYNOPSIS
.B "u32 __attribute_pure__" crc32_le
.BI "(u32 " crc ","
.BI "unsigned char const *" p ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "crc" 12
-- undescribed --
.IP "p" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
\fIcrc\fP - seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.
\fIp\fP   - pointer to buffer over which CRC is run
\fIlen\fP - length of buffer \fIp\fP
.TH "crc32_le" 9 "crc32_le" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc32_le \-  Calculate bitwise little-endian Ethernet AUTODIN II CRC32
.SH SYNOPSIS
.B "u32 __attribute_pure__" crc32_le
.BI "(u32 " crc ","
.BI "unsigned char const *" p ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "crc" 12
-- undescribed --
.IP "p" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
\fIcrc\fP - seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.
\fIp\fP   - pointer to buffer over which CRC is run
\fIlen\fP - length of buffer \fIp\fP
.TH "crc32_be" 9 "crc32_be" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc32_be \-  Calculate bitwise big-endian Ethernet AUTODIN II CRC32
.SH SYNOPSIS
.B "u32 __attribute_pure__" crc32_be
.BI "(u32 " crc ","
.BI "unsigned char const *" p ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "crc" 12
-- undescribed --
.IP "p" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
\fIcrc\fP - seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.
\fIp\fP   - pointer to buffer over which CRC is run
\fIlen\fP - length of buffer \fIp\fP
.TH "crc32_be" 9 "crc32_be" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crc32_be \-  Calculate bitwise big-endian Ethernet AUTODIN II CRC32
.SH SYNOPSIS
.B "u32 __attribute_pure__" crc32_be
.BI "(u32 " crc ","
.BI "unsigned char const *" p ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "crc" 12
-- undescribed --
.IP "p" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
\fIcrc\fP - seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.
\fIp\fP   - pointer to buffer over which CRC is run
\fIlen\fP - length of buffer \fIp\fP
.TH "simple_strtoul" 9 "simple_strtoul" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
simple_strtoul \-  convert a string to an unsigned long
.SH SYNOPSIS
.B "unsigned long" simple_strtoul
.BI "(const char *" cp ","
.BI "char **" endp ","
.BI "unsigned int " base ");"
.SH ARGUMENTS
.IP "cp" 12
 The start of the string
.IP "endp" 12
 A pointer to the end of the parsed string will be placed here
.IP "base" 12
 The number base to use
.TH "simple_strtol" 9 "simple_strtol" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
simple_strtol \-  convert a string to a signed long
.SH SYNOPSIS
.B "long" simple_strtol
.BI "(const char *" cp ","
.BI "char **" endp ","
.BI "unsigned int " base ");"
.SH ARGUMENTS
.IP "cp" 12
 The start of the string
.IP "endp" 12
 A pointer to the end of the parsed string will be placed here
.IP "base" 12
 The number base to use
.TH "simple_strtoull" 9 "simple_strtoull" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
simple_strtoull \-  convert a string to an unsigned long long
.SH SYNOPSIS
.B "unsigned long long" simple_strtoull
.BI "(const char *" cp ","
.BI "char **" endp ","
.BI "unsigned int " base ");"
.SH ARGUMENTS
.IP "cp" 12
 The start of the string
.IP "endp" 12
 A pointer to the end of the parsed string will be placed here
.IP "base" 12
 The number base to use
.TH "simple_strtoll" 9 "simple_strtoll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
simple_strtoll \-  convert a string to a signed long long
.SH SYNOPSIS
.B "long long" simple_strtoll
.BI "(const char *" cp ","
.BI "char **" endp ","
.BI "unsigned int " base ");"
.SH ARGUMENTS
.IP "cp" 12
 The start of the string
.IP "endp" 12
 A pointer to the end of the parsed string will be placed here
.IP "base" 12
 The number base to use
.TH "vsnprintf" 9 "vsnprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vsnprintf \-  Format a string and place it in a buffer
.SH SYNOPSIS
.B "int" vsnprintf
.BI "(char *" buf ","
.BI "size_t " size ","
.BI "const char *" fmt ","
.BI "va_list " args ");"
.SH ARGUMENTS
.IP "buf" 12
 The buffer to place the result into
.IP "size" 12
 The size of the buffer, including the trailing null space
.IP "fmt" 12
 The format string to use
.IP "args" 12
 Arguments for the format string
.SH "DESCRIPTION"
The return value is the number of characters which would
be generated for the given input, excluding the trailing
'\0', as per ISO C99. If you want to have the exact
number of characters written into \fIbuf\fP as return value
(not including the trailing '\0'), use vscnprintf. If the
return is greater than or equal to \fIsize\fP, the resulting
string is truncated.

Call this function if you are already dealing with a va_list.
You probably want snprintf instead.
.TH "vscnprintf" 9 "vscnprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vscnprintf \-  Format a string and place it in a buffer
.SH SYNOPSIS
.B "int" vscnprintf
.BI "(char *" buf ","
.BI "size_t " size ","
.BI "const char *" fmt ","
.BI "va_list " args ");"
.SH ARGUMENTS
.IP "buf" 12
 The buffer to place the result into
.IP "size" 12
 The size of the buffer, including the trailing null space
.IP "fmt" 12
 The format string to use
.IP "args" 12
 Arguments for the format string
.SH "DESCRIPTION"
The return value is the number of characters which have been written into
the \fIbuf\fP not including the trailing '\0'. If \fIsize\fP is &lt;= 0 the function
returns 0.

Call this function if you are already dealing with a va_list.
You probably want scnprintf instead.
.TH "snprintf" 9 "snprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snprintf \-  Format a string and place it in a buffer
.SH SYNOPSIS
.B "int" snprintf
.BI "(char *" buf ","
.BI "size_t " size ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "buf" 12
 The buffer to place the result into
.IP "size" 12
 The size of the buffer, including the trailing null space
.IP "fmt" 12
 The format string to use
@...: Arguments for the format string
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
The return value is the number of characters which would be
generated for the given input, excluding the trailing null,
as per ISO C99.  If the return is greater than or equal to
\fIsize\fP, the resulting string is truncated.
.TH "scnprintf" 9 "scnprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scnprintf \-  Format a string and place it in a buffer
.SH SYNOPSIS
.B "int" scnprintf
.BI "(char *" buf ","
.BI "size_t " size ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "buf" 12
 The buffer to place the result into
.IP "size" 12
 The size of the buffer, including the trailing null space
.IP "fmt" 12
 The format string to use
@...: Arguments for the format string
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
The return value is the number of characters written into \fIbuf\fP not including
the trailing '\0'. If \fIsize\fP is &lt;= 0 the function returns 0. If the return is
greater than or equal to \fIsize\fP, the resulting string is truncated.
.TH "vsprintf" 9 "vsprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vsprintf \-  Format a string and place it in a buffer
.SH SYNOPSIS
.B "int" vsprintf
.BI "(char *" buf ","
.BI "const char *" fmt ","
.BI "va_list " args ");"
.SH ARGUMENTS
.IP "buf" 12
 The buffer to place the result into
.IP "fmt" 12
 The format string to use
.IP "args" 12
 Arguments for the format string
.SH "DESCRIPTION"
The function returns the number of characters written
into \fIbuf\fP. Use vsnprintf or vscnprintf in order to avoid
buffer overflows.

Call this function if you are already dealing with a va_list.
You probably want sprintf instead.
.TH "sprintf" 9 "sprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sprintf \-  Format a string and place it in a buffer
.SH SYNOPSIS
.B "int" sprintf
.BI "(char *" buf ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "buf" 12
 The buffer to place the result into
.IP "fmt" 12
 The format string to use
@...: Arguments for the format string
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
The function returns the number of characters written
into \fIbuf\fP. Use snprintf or scnprintf in order to avoid
buffer overflows.
.TH "vsscanf" 9 "vsscanf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vsscanf \-  Unformat a buffer into a list of arguments
.SH SYNOPSIS
.B "int" vsscanf
.BI "(const char *" buf ","
.BI "const char *" fmt ","
.BI "va_list " args ");"
.SH ARGUMENTS
.IP "buf" 12
	input buffer
.IP "fmt" 12
	format of buffer
.IP "args" 12
	arguments
.TH "sscanf" 9 "sscanf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sscanf \-  Unformat a buffer into a list of arguments
.SH SYNOPSIS
.B "int" sscanf
.BI "(const char *" buf ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "buf" 12
	input buffer
.IP "fmt" 12
	formatting of buffer
@...:	resulting arguments
.IP "..." 12
variable arguments
.TH "get_option" 9 "get_option" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_option \-  Parse integer from an option string
.SH SYNOPSIS
.B "int" get_option
.BI "(char **" str ","
.BI "int *" pint ");"
.SH ARGUMENTS
.IP "str" 12
 option string
.IP "pint" 12
 (output) integer value parsed from \fIstr\fP
.SH "DESCRIPTION"
Read an int from an option string; if available accept a subsequent
comma as well.
.SH "0 "
 no int in string
.SH "1 "
 int found, no subsequent comma
.SH "2 "
 int found including a subsequent comma
.TH "get_options" 9 "get_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_options \-  Parse a string into a list of integers
.SH SYNOPSIS
.B "char *" get_options
.BI "(const char *" str ","
.BI "int " nints ","
.BI "int *" ints ");"
.SH ARGUMENTS
.IP "str" 12
 String to be parsed
.IP "nints" 12
 size of integer array
.IP "ints" 12
 integer array
.SH "DESCRIPTION"
This function parses a string containing a comma-separated
list of integers.  The parse halts when the array is
full, or when no more numbers can be retrieved from the
string.

Return value is the character in the string which caused
the parse to end (typically a null terminator, if \fIstr\fP is
completely parseable).
.TH "memparse" 9 "memparse" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memparse \-  parse a string with mem suffixes into a number
.SH SYNOPSIS
.B "unsigned long long" memparse
.BI "(char *" ptr ","
.BI "char **" retptr ");"
.SH ARGUMENTS
.IP "ptr" 12
 Where parse begins
.IP "retptr" 12
 (output) Pointer to next char after parse completes
.SH "DESCRIPTION"
Parses a string into a number.  The number stored at \fIptr\fP is
potentially suffixed with K (for kilobytes, or 1024 bytes),
M (for megabytes, or 1048576 bytes), or G (for gigabytes, or
1073741824).  If the number is suffixed with K, M, or G, then
the return value is the number multiplied by one kilobyte, one
megabyte, or one gigabyte, respectively.
.TH "strnicmp" 9 "strnicmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strnicmp \-  Case insensitive, length-limited string comparison
.SH SYNOPSIS
.B "int" strnicmp
.BI "(const char *" s1 ","
.BI "const char *" s2 ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "s1" 12
 One string
.IP "s2" 12
 The other string
.IP "len" 12
 the maximum number of characters to compare
.TH "strcpy" 9 "strcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strcpy \-  Copy a %NUL terminated string
.SH SYNOPSIS
.B "char *" strcpy
.BI "(char *" dest ","
.BI "const char *" src ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy the string to
.IP "src" 12
 Where to copy the string from
.TH "strncpy" 9 "strncpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strncpy \-  Copy a length-limited, %NUL-terminated string
.SH SYNOPSIS
.B "char *" strncpy
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy the string to
.IP "src" 12
 Where to copy the string from
.IP "count" 12
 The maximum number of bytes to copy
.SH "DESCRIPTION"
The result is not NUL-terminated if the source exceeds
\fIcount\fP bytes.

In the case where the length of \fIsrc\fP is less than  that  of
count, the remainder of \fIdest\fP will be padded with NUL.
.TH "strlcpy" 9 "strlcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlcpy \-  Copy a %NUL terminated string into a sized buffer
.SH SYNOPSIS
.B "size_t" strlcpy
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy the string to
.IP "src" 12
 Where to copy the string from
.IP "size" 12
 size of destination buffer
.SH "BSD"
 the result is always a valid
NUL-terminated string that fits in the buffer (unless,
of course, the buffer size is zero). It does not pad
out the result like \fBstrncpy\fP does.
.TH "strcat" 9 "strcat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strcat \-  Append one %NUL-terminated string to another
.SH SYNOPSIS
.B "char *" strcat
.BI "(char *" dest ","
.BI "const char *" src ");"
.SH ARGUMENTS
.IP "dest" 12
 The string to be appended to
.IP "src" 12
 The string to append to it
.TH "strncat" 9 "strncat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strncat \-  Append a length-limited, %NUL-terminated string to another
.SH SYNOPSIS
.B "char *" strncat
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dest" 12
 The string to be appended to
.IP "src" 12
 The string to append to it
.IP "count" 12
 The maximum numbers of bytes to copy
.SH "DESCRIPTION"
Note that in contrast to strncpy, strncat ensures the result is
terminated.
.TH "strlcat" 9 "strlcat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlcat \-  Append a length-limited, %NUL-terminated string to another
.SH SYNOPSIS
.B "size_t" strlcat
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dest" 12
 The string to be appended to
.IP "src" 12
 The string to append to it
.IP "count" 12
 The size of the destination buffer.
.TH "strcmp" 9 "strcmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strcmp \-  Compare two strings
.SH SYNOPSIS
.B "int" strcmp
.BI "(const char *" cs ","
.BI "const char *" ct ");"
.SH ARGUMENTS
.IP "cs" 12
 One string
.IP "ct" 12
 Another string
.TH "strncmp" 9 "strncmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strncmp \-  Compare two length-limited strings
.SH SYNOPSIS
.B "int" strncmp
.BI "(const char *" cs ","
.BI "const char *" ct ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "cs" 12
 One string
.IP "ct" 12
 Another string
.IP "count" 12
 The maximum number of bytes to compare
.TH "strchr" 9 "strchr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strchr \-  Find the first occurrence of a character in a string
.SH SYNOPSIS
.B "char *" strchr
.BI "(const char *" s ","
.BI "int " c ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be searched
.IP "c" 12
 The character to search for
.TH "strrchr" 9 "strrchr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strrchr \-  Find the last occurrence of a character in a string
.SH SYNOPSIS
.B "char *" strrchr
.BI "(const char *" s ","
.BI "int " c ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be searched
.IP "c" 12
 The character to search for
.TH "strnchr" 9 "strnchr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strnchr \-  Find a character in a length limited string
.SH SYNOPSIS
.B "char *" strnchr
.BI "(const char *" s ","
.BI "size_t " count ","
.BI "int " c ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be searched
.IP "count" 12
 The number of characters to be searched
.IP "c" 12
 The character to search for
.TH "strlen" 9 "strlen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlen \-  Find the length of a string
.SH SYNOPSIS
.B "size_t" strlen
.BI "(const char *" s ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be sized
.TH "strnlen" 9 "strnlen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strnlen \-  Find the length of a length-limited string
.SH SYNOPSIS
.B "size_t" strnlen
.BI "(const char *" s ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be sized
.IP "count" 12
 The maximum number of bytes to search
.TH "strspn" 9 "strspn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strspn \-  Calculate the length of the initial substring of @s which only
.SH SYNOPSIS
.B "size_t" strspn
.BI "(const char *" s ","
.BI "const char *" accept ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be searched
.IP "accept" 12
 The string to search for
.SH "DESCRIPTION"
contain letters in \fIaccept\fP
.TH "strcspn" 9 "strcspn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strcspn \-  Calculate the length of the initial substring of @s which does
.SH SYNOPSIS
.B "size_t" strcspn
.BI "(const char *" s ","
.BI "const char *" reject ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be searched
.IP "reject" 12
 The string to avoid
.SH "DESCRIPTION"
not contain letters in \fIreject\fP
.TH "strpbrk" 9 "strpbrk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strpbrk \-  Find the first occurrence of a set of characters
.SH SYNOPSIS
.B "char *" strpbrk
.BI "(const char *" cs ","
.BI "const char *" ct ");"
.SH ARGUMENTS
.IP "cs" 12
 The string to be searched
.IP "ct" 12
 The characters to search for
.TH "strsep" 9 "strsep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strsep \-  Split a string into tokens
.SH SYNOPSIS
.B "char *" strsep
.BI "(char **" s ","
.BI "const char *" ct ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be searched
.IP "ct" 12
 The characters to search for
.SH "DESCRIPTION"
\fBstrsep\fP updates \fIs\fP to point after the token, ready for the next call.

It returns empty tokens, too, behaving exactly like the libc function
of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
Same semantics, slimmer shape. ;)
.TH "memset" 9 "memset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memset \-  Fill a region of memory with the given value
.SH SYNOPSIS
.B "void *" memset
.BI "(void *" s ","
.BI "int " c ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "s" 12
 Pointer to the start of the area.
.IP "c" 12
 The byte to fill the area with
.IP "count" 12
 The size of the area.
.SH "DESCRIPTION"
Do not use \fBmemset\fP to access IO space, use \fBmemset_io\fP instead.
.TH "memcpy" 9 "memcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memcpy \-  Copy one area of memory to another
.SH SYNOPSIS
.B "void *" memcpy
.BI "(void *" dest ","
.BI "const void *" src ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy to
.IP "src" 12
 Where to copy from
.IP "count" 12
 The size of the area.
.SH "DESCRIPTION"
You should not use this function to access IO space, use \fBmemcpy_toio\fP
or \fBmemcpy_fromio\fP instead.
.TH "memmove" 9 "memmove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memmove \-  Copy one area of memory to another
.SH SYNOPSIS
.B "void *" memmove
.BI "(void *" dest ","
.BI "const void *" src ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy to
.IP "src" 12
 Where to copy from
.IP "count" 12
 The size of the area.
.SH "DESCRIPTION"
Unlike \fBmemcpy\fP, \fBmemmove\fP copes with overlapping areas.
.TH "memcmp" 9 "memcmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memcmp \-  Compare two areas of memory
.SH SYNOPSIS
.B "int" memcmp
.BI "(const void *" cs ","
.BI "const void *" ct ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "cs" 12
 One area of memory
.IP "ct" 12
 Another area of memory
.IP "count" 12
 The size of the area.
.TH "memscan" 9 "memscan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memscan \-  Find a character in an area of memory.
.SH SYNOPSIS
.B "void *" memscan
.BI "(void *" addr ","
.BI "int " c ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "addr" 12
 The memory area
.IP "c" 12
 The byte to search for
.IP "size" 12
 The size of the area.
.SH "DESCRIPTION"
returns the address of the first occurrence of \fIc\fP, or 1 byte past
the area if \fIc\fP is not found
.TH "strstr" 9 "strstr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strstr \-  Find the first substring in a %NUL terminated string
.SH SYNOPSIS
.B "char *" strstr
.BI "(const char *" s1 ","
.BI "const char *" s2 ");"
.SH ARGUMENTS
.IP "s1" 12
 The string to be searched
.IP "s2" 12
 The string to search for
.TH "memchr" 9 "memchr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memchr \-  Find a character in an area of memory.
.SH SYNOPSIS
.B "void *" memchr
.BI "(const void *" s ","
.BI "int " c ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "s" 12
 The memory area
.IP "c" 12
 The byte to search for
.IP "n" 12
 The size of the area.
.SH "DESCRIPTION"
returns the address of the first occurrence of \fIc\fP, or NULL
if \fIc\fP is not found
.TH "int_sqrt" 9 "int_sqrt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
int_sqrt \-  rough approximation to sqrt
.SH SYNOPSIS
.B "unsigned long" int_sqrt
.BI "(unsigned long " x ");"
.SH ARGUMENTS
.IP "x" 12
 integer of which to calculate the sqrt
.SH "DESCRIPTION"
A very rough approximation to the \fBsqrt\fP function.
.TH "send_uevent" 9 "send_uevent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
send_uevent \-  notify userspace by sending event trough netlink socket
.SH SYNOPSIS
.B "int" send_uevent
.BI "(const char *" signal ","
.BI "const char *" obj ","
.BI "char **" envp ","
.BI "int " gfp_mask ");"
.SH ARGUMENTS
.IP "signal" 12
 signal name
.IP "obj" 12
 object path (kobject)
.IP "envp" 12
 possible hotplug environment to pass with the message
.IP "gfp_mask" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "kobject_uevent" 9 "kobject_uevent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_uevent \-  notify userspace by sending event through netlink socket
.SH SYNOPSIS
.B "int" kobject_uevent
.BI "(struct kobject *" kobj ","
.BI "enum kobject_action " action ","
.BI "struct attribute *" attr ");"
.SH ARGUMENTS
.IP "kobj" 12
 struct kobject that the event is happening to
.IP "action" 12
-- undescribed --
.IP "attr" 12
 optional struct attribute the event belongs to
.TH "kobject_hotplug" 9 "kobject_hotplug" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kobject_hotplug \-  notify userspace by executing /sbin/hotplug
.SH SYNOPSIS
.B "void" kobject_hotplug
.BI "(struct kobject *" kobj ","
.BI "enum kobject_action " action ");"
.SH ARGUMENTS
.IP "kobj" 12
 struct kobject that the action is happening to
.IP "action" 12
 action that is happening (usually "ADD" or "REMOVE")
.SH "DESCRIPTION"
.TH "add_hotplug_env_var" 9 "add_hotplug_env_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
add_hotplug_env_var \-  helper for creating hotplug environment variables
.SH SYNOPSIS
.B "int" add_hotplug_env_var
.BI "(char **" envp ","
.BI "int " num_envp ","
.BI "int *" cur_index ","
.BI "char *" buffer ","
.BI "int " buffer_size ","
.BI "int *" cur_len ","
.BI "const char *" format ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "envp" 12
 Pointer to table of environment variables, as passed into
\fBhotplug\fP method.
.IP "num_envp" 12
 Number of environment variable slots available, as
passed into \fBhotplug\fP method.
.IP "cur_index" 12
 Pointer to current index into \fIenvp\fP.  It should be
initialized to 0 before the first call to \fBadd_hotplug_env_var\fP,
and will be incremented on success.
.IP "buffer" 12
 Pointer to buffer for environment variables, as passed
into \fBhotplug\fP method.
.IP "buffer_size" 12
 Length of \fIbuffer\fP, as passed into \fBhotplug\fP method.
.IP "cur_len" 12
 Pointer to current length of space used in \fIbuffer\fP.
Should be initialized to 0 before the first call to
\fBadd_hotplug_env_var\fP, and will be incremented on success.
.IP "format" 12
 Format for creating environment variable (of the form
"XXX=x") for \fBsnprintf\fP.
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Returns 0 if environment variable was added successfully or -ENOMEM
if no space was available.
.TH "bitmap_scnprintf" 9 "bitmap_scnprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bitmap_scnprintf \-  convert bitmap to an ASCII hex string.
.SH SYNOPSIS
.B "int" bitmap_scnprintf
.BI "(char *" buf ","
.BI "unsigned int " buflen ","
.BI "const unsigned long *" maskp ","
.BI "int " nmaskbits ");"
.SH ARGUMENTS
.IP "buf" 12
 byte buffer into which string is placed
.IP "buflen" 12
 reserved size of \fIbuf\fP, in bytes
.IP "maskp" 12
 pointer to bitmap to convert
.IP "nmaskbits" 12
 size of bitmap, in bits
.SH "DESCRIPTION"
Exactly \fInmaskbits\fP bits are displayed.  Hex digits are grouped into
comma-separated sets of eight digits per set.
.TH "bitmap_parse" 9 "bitmap_parse" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bitmap_parse \-  convert an ASCII hex string into a bitmap.
.SH SYNOPSIS
.B "int" bitmap_parse
.BI "(const char __user *" ubuf ","
.BI "unsigned int " ubuflen ","
.BI "unsigned long *" maskp ","
.BI "int " nmaskbits ");"
.SH ARGUMENTS
.IP "ubuf" 12
-- undescribed --
.IP "ubuflen" 12
-- undescribed --
.IP "maskp" 12
 pointer to bitmap array that will contain result.
.IP "nmaskbits" 12
 size of bitmap, in bits.
.SH "DESCRIPTION"
Commas group hex digits into chunks.  Each chunk defines exactly 32
bits of the resultant bitmask.  No chunk may specify a value larger
than 32 bits (-EOVERFLOW), and if a chunk specifies a smaller value
then leading 0-bits are prepended.  -EINVAL is returned for illegal
characters and for grouping errors such as "1,,5", ",44", "," and "".
Leading and trailing whitespace accepted, but not embedded whitespace.
.TH "bitmap_scnlistprintf" 9 "bitmap_scnlistprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bitmap_scnlistprintf \-  convert bitmap to list format ASCII string
.SH SYNOPSIS
.B "int" bitmap_scnlistprintf
.BI "(char *" buf ","
.BI "unsigned int " buflen ","
.BI "const unsigned long *" maskp ","
.BI "int " nmaskbits ");"
.SH ARGUMENTS
.IP "buf" 12
 byte buffer into which string is placed
.IP "buflen" 12
 reserved size of \fIbuf\fP, in bytes
.IP "maskp" 12
 pointer to bitmap to convert
.IP "nmaskbits" 12
 size of bitmap, in bits
.SH "DESCRIPTION"
Output format is a comma-separated list of decimal numbers and
ranges.  Consecutively set bits are shown as two hyphen-separated
decimal numbers, the smallest and largest bit numbers set in
the range.  Output format is compatible with the format
accepted as input by \fBbitmap_parselist\fP.

The return value is the number of characters which would be
generated for the given input, excluding the trailing '\0', as
per ISO C99.
.TH "bitmap_parselist" 9 "bitmap_parselist" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bitmap_parselist \-  convert list format ASCII string to bitmap
.SH SYNOPSIS
.B "int" bitmap_parselist
.BI "(const char *" bp ","
.BI "unsigned long *" maskp ","
.BI "int " nmaskbits ");"
.SH ARGUMENTS
.IP "bp" 12
-- undescribed --
.IP "maskp" 12
-- undescribed --
.IP "nmaskbits" 12
 number of bits in mask to be written
.SH "DESCRIPTION"
Input format is a comma-separated list of decimal numbers and
ranges.  Consecutively set bits are shown as two hyphen-separated
decimal numbers, the smallest and largest bit numbers set in
the range.

Returns 0 on success, -errno on invalid input strings:
-EINVAL:   second number in range smaller than first
-EINVAL:   invalid character in string
-ERANGE:   bit number specified too large for mask
.TH "bitmap_find_free_region" 9 "bitmap_find_free_region" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bitmap_find_free_region \-  find a contiguous aligned mem region
.SH SYNOPSIS
.B "int" bitmap_find_free_region
.BI "(unsigned long *" bitmap ","
.BI "int " bits ","
.BI "int " order ");"
.SH ARGUMENTS
.IP "bitmap" 12
 an array of unsigned longs corresponding to the bitmap
.IP "bits" 12
 number of bits in the bitmap
.IP "order" 12
 region size to find (size is actually 1&lt;&lt;order)
.SH "DESCRIPTION"
This is used to allocate a memory region from a bitmap.  The idea is
that the region has to be 1&lt;&lt;order sized and 1&lt;&lt;order aligned (this
makes the search algorithm much faster).

The region is marked as set bits in the bitmap if a free one is
found.

Returns either beginning of region or negative error
.TH "bitmap_release_region" 9 "bitmap_release_region" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bitmap_release_region \-  release allocated bitmap region
.SH SYNOPSIS
.B "void" bitmap_release_region
.BI "(unsigned long *" bitmap ","
.BI "int " pos ","
.BI "int " order ");"
.SH ARGUMENTS
.IP "bitmap" 12
 a pointer to the bitmap
.IP "pos" 12
 the beginning of the region
.IP "order" 12
 the order of the bits to release (number is 1&lt;&lt;order)
.SH "DESCRIPTION"
This is the complement to __bitmap_find_free_region and releases
the found region (by clearing it in the bitmap).
.TH "textsearch_register" 9 "textsearch_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
textsearch_register \-  register a textsearch module
.SH SYNOPSIS
.B "int" textsearch_register
.BI "(struct ts_ops *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
 operations lookup table
.SH "DESCRIPTION"
This function must be called by textsearch modules to announce
their presence. The specified &amp;\fIops\fP must have name set to a
unique identifier and the callbacks \fBfind\fP, \fBinit\fP, \fBget_pattern\fP,
and \fBget_pattern_len\fP must be implemented.

Returns 0 or -EEXISTS if another module has already registered
with same name.
.TH "textsearch_unregister" 9 "textsearch_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
textsearch_unregister \-  unregister a textsearch module
.SH SYNOPSIS
.B "int" textsearch_unregister
.BI "(struct ts_ops *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
 operations lookup table
.SH "DESCRIPTION"
This function must be called by textsearch modules to announce
their disappearance for examples when the module gets unloaded.
The &amp;ops parameter must be the same as the one during the
registration.

Returns 0 on success or -ENOENT if no matching textsearch
registration was found.
.TH "textsearch_find_continuous" 9 "textsearch_find_continuous" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
textsearch_find_continuous \-  search a pattern in continuous/linear data
.SH SYNOPSIS
.B "unsigned int" textsearch_find_continuous
.BI "(struct ts_config *" conf ","
.BI "struct ts_state *" state ","
.BI "const void *" data ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "conf" 12
 search configuration
.IP "state" 12
 search state
.IP "data" 12
 data to search in
.IP "len" 12
 length of data
.SH "DESCRIPTION"
A simplified version of \fBtextsearch_find\fP for continuous/linear data.
Call \fBtextsearch_next\fP to retrieve subsequent matches.

Returns the position of first occurrence of the pattern or
UINT_MAX if no occurrence was found.
.TH "textsearch_prepare" 9 "textsearch_prepare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
textsearch_prepare \-  Prepare a search
.SH SYNOPSIS
.B "struct ts_config *" textsearch_prepare
.BI "(const char *" algo ","
.BI "const void *" pattern ","
.BI "unsigned int " len ","
.BI "int " gfp_mask ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "algo" 12
 name of search algorithm
.IP "pattern" 12
 pattern data
.IP "len" 12
 length of pattern
.IP "gfp_mask" 12
 allocation mask
.IP "flags" 12
 search flags
.SH "DESCRIPTION"
Looks up the search algorithm module and creates a new textsearch
configuration for the specified pattern. Upon completion all
necessary refcnts are held and the configuration must be put back
using \fBtextsearch_put\fP after usage.
.SH "NOTE"
 The format of the pattern may not be compatible between
the various search algorithms.

Returns a new textsearch configuration according to the specified
parameters or a \fBERR_PTR\fP.
.TH "textsearch_destroy" 9 "textsearch_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
textsearch_destroy \-  destroy a search configuration
.SH SYNOPSIS
.B "void" textsearch_destroy
.BI "(struct ts_config *" conf ");"
.SH ARGUMENTS
.IP "conf" 12
 search configuration
.SH "DESCRIPTION"
Releases all references of the configuration and frees
up the memory.
.TH "smb_getopt" 9 "smb_getopt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
smb_getopt \-  option parser
.SH SYNOPSIS
.B "int" smb_getopt
.BI "(char *" caller ","
.BI "char **" options ","
.BI "struct option *" opts ","
.BI "char **" optopt ","
.BI "char **" optarg ","
.BI "unsigned long *" flag ","
.BI "unsigned long *" value ");"
.SH ARGUMENTS
.IP "caller" 12
 name of the caller, for error messages
.IP "options" 12
 the options string
.IP "opts" 12
 an array of &amp;struct option entries controlling parser operations
.IP "optopt" 12
 output; will contain the current option
.IP "optarg" 12
 output; will contain the value (if one exists)
.IP "flag" 12
 output; may be NULL; should point to a long for or'ing flags
.IP "value" 12
 output; may be NULL; will be overwritten with the integer value
of the current argument.
.SH "DESCRIPTION"
Helper to parse options on the format used by mount ("a=b,c=d,e,f").
Returns opts-&gt;val if a matching entry in the 'opts' array is found,
0 when no more tokens are found, -1 if an error is encountered.
.TH "__mark_inode_dirty" 9 "__mark_inode_dirty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__mark_inode_dirty \- 	internal function
.SH SYNOPSIS
.B "void" __mark_inode_dirty
.BI "(struct inode *" inode ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to mark
.IP "flags" 12
 what kind of dirty (i.e. I_DIRTY_SYNC)
Mark an inode as dirty. Callers should use mark_inode_dirty or
mark_inode_dirty_sync.
.SH "DESCRIPTION"
Put the inode on the super block's dirty list.

CAREFUL! We mark it dirty unconditionally, but move it onto the
dirty list only if it is hashed or if it refers to a blockdev.
If it was not hashed, it will never be added to the dirty list
even if it is later hashed, as it will have been marked dirty already.

In short, make sure you hash any inodes _before_ you start marking
them dirty.

This function *must* be atomic for the I_DIRTY_PAGES case -
\fBset_page_dirty\fP is called under spinlock in several places.

Note that for blockdevs, inode-&gt;dirtied_when represents the dirtying time of
the block-special inode (/dev/hda1) itself.  And the -&gt;dirtied_when field of
the kernel-internal blockdev inode represents the dirtying time of the
blockdev's pages.  This is why for I_DIRTY_PAGES we always use
page-&gt;mapping-&gt;host, so the page-dirtying time is recorded in the internal
blockdev inode.
.TH "__sync_inodes" 9 "__sync_inodes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__sync_inodes \-  writes all inodes to disk
.SH SYNOPSIS
.B "void" __sync_inodes
.BI "(int " wait ");"
.SH ARGUMENTS
.IP "wait" 12
 wait for completion
.SH "DESCRIPTION"
\fBsync_inodes\fP goes through each super block's dirty inode list, writes the
inodes out, waits on the writeout and puts the inodes back on the normal
list.

This is for \fBsys_sync\fP.  \fBfsync_dev\fP uses the same algorithm.  The subtle
part of the sync functions is that the blockdev "superblock" is processed
last.  This is because the \fBwrite_inode\fP function of a typical fs will
perform no I/O, but will mark buffers in the blockdev mapping as dirty.
What we want to do is to perform all that dirtying first, and then write
back all those inode blocks via the blockdev mapping in one sweep.  So the
additional (somewhat redundant) \fBsync_blockdev\fP calls here are to make
sure that really happens.  Because if we call sync_inodes_sb(wait=1) with
outstanding dirty inodes, the writeback goes block-at-a-time within the
filesystem's \fBwrite_inode\fP.  This is extremely slow.
.TH "write_inode_now" 9 "write_inode_now" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_inode_now \- 	write an inode to disk
.SH SYNOPSIS
.B "int" write_inode_now
.BI "(struct inode *" inode ","
.BI "int " sync ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to write to disk
.IP "sync" 12
 whether the write should be synchronous or not
.SH "DESCRIPTION"
This function commits an inode to disk immediately if it is
dirty. This is primarily needed by knfsd.
.TH "sync_inode" 9 "sync_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sync_inode \-  write an inode and its pages to disk.
.SH SYNOPSIS
.B "int" sync_inode
.BI "(struct inode *" inode ","
.BI "struct writeback_control *" wbc ");"
.SH ARGUMENTS
.IP "inode" 12
 the inode to sync
.IP "wbc" 12
 controls the writeback mode
.SH "DESCRIPTION"
\fBsync_inode\fP will write an inode and its pages to disk.  It will also
correctly update the inode on its superblock's dirty inode lists and will
update inode-&gt;i_state.

The caller must have a ref on the inode.
.TH "generic_osync_inode" 9 "generic_osync_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_osync_inode \-  flush all dirty data for a given inode to disk
.SH SYNOPSIS
.B "int" generic_osync_inode
.BI "(struct inode *" inode ","
.BI "struct address_space *" mapping ","
.BI "int " what ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to write
.IP "mapping" 12
 the address_space that should be flushed
.IP "what" 12
  what to write and wait upon
.SH "DESCRIPTION"
This can be called by file_write functions for files which have the
O_SYNC flag set, to flush dirty writes to disk.

\fIwhat\fP is a bitmask, specifying which part of the inode's data should be
.SH "WRITTEN AND WAITED UPON"
.SH "OSYNC_DATA"
     i_mapping's dirty data
.SH "OSYNC_METADATA"
 the buffers at i_mapping-&gt;private_list
.SH "OSYNC_INODE"
    the inode itself
.TH "writeback_acquire" 9 "writeback_acquire" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
writeback_acquire \- 
.SH SYNOPSIS
.B "int" writeback_acquire
.BI "(struct backing_dev_info *" bdi ");"
.SH ARGUMENTS
.IP "bdi" 12
 the device's backing_dev_info structure
.SH "DESCRIPTION"
It is a waste of resources to have more than one pdflush thread blocked on
a single request queue.  Exclusion at the request_queue level is obtained
via a flag in the request_queue's backing_dev_info.state.

Non-request_queue-backed address_spaces will share default_backing_dev_info,
unless they implement their own.  Which is somewhat inefficient, as this
may prevent concurrent writeback against multiple devices.
.TH "writeback_in_progress" 9 "writeback_in_progress" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
writeback_in_progress \- 
.SH SYNOPSIS
.B "int" writeback_in_progress
.BI "(struct backing_dev_info *" bdi ");"
.SH ARGUMENTS
.IP "bdi" 12
 the device's backing_dev_info structure.
.SH "DESCRIPTION"
against a backing device.
.TH "writeback_release" 9 "writeback_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
writeback_release \- 
.SH SYNOPSIS
.B "void" writeback_release
.BI "(struct backing_dev_info *" bdi ");"
.SH ARGUMENTS
.IP "bdi" 12
 the device's backing_dev_info structure
.TH "freeze_bdev" 9 "freeze_bdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
freeze_bdev \- -  lock a filesystem and force it into a consistent state
.SH SYNOPSIS
.B "struct super_block *" freeze_bdev
.BI "(struct block_device *" bdev ");"
.SH ARGUMENTS
.IP "bdev" 12
	blockdevice to lock
.SH "DESCRIPTION"
This takes the block device bd_mount_sem to make sure no new mounts
happen on bdev until \fBthaw_bdev\fP is called.
If a superblock is found on this device, we take the s_umount semaphore
on it to make sure nobody unmounts until the snapshot creation is done.
.TH "thaw_bdev" 9 "thaw_bdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
thaw_bdev \- - unlock filesystem
.SH SYNOPSIS
.B "void" thaw_bdev
.BI "(struct block_device *" bdev ","
.BI "struct super_block *" sb ");"
.SH ARGUMENTS
.IP "bdev" 12
	blockdevice to unlock
.IP "sb" 12
		associated superblock
.SH "DESCRIPTION"
Unlocks the filesystem and marks it writeable again after \fBfreeze_bdev\fP.
.TH "sync_mapping_buffers" 9 "sync_mapping_buffers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sync_mapping_buffers \-  write out and wait upon a mapping's "associated"
.SH SYNOPSIS
.B "int" sync_mapping_buffers
.BI "(struct address_space *" mapping ");"
.SH ARGUMENTS
.IP "mapping" 12
 the mapping which wants those buffers written
.SH "DESCRIPTION"
Starts I/O against the buffers at mapping-&gt;private_list, and waits upon
that I/O.

Basically, this is a convenience function for \fBfsync\fP.
\fImapping\fP is a file or directory which needs those buffers to be written for
a successful \fBfsync\fP.
.SH "DESCRIPTION"
Starts I/O against the buffers at mapping-&gt;private_list, and waits upon
that I/O.

Basically, this is a convenience function for \fBfsync\fP.
\fImapping\fP is a file or directory which needs those buffers to be written for
a successful \fBfsync\fP.
.TH "mark_buffer_dirty" 9 "mark_buffer_dirty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mark_buffer_dirty \-  mark a buffer_head as needing writeout
.SH SYNOPSIS
.B "void fastcall" mark_buffer_dirty
.BI "(struct buffer_head *" bh ");"
.SH ARGUMENTS
.IP "bh" 12
 the buffer_head to mark dirty
.SH "DESCRIPTION"
\fBmark_buffer_dirty\fP will set the dirty bit against the buffer, then set its
backing page dirty, then tag the page as dirty in its address_space's radix
tree and then attach the address_space's inode to its superblock's dirty
inode list.

\fBmark_buffer_dirty\fP is atomic.  It takes bh-&gt;b_page-&gt;mapping-&gt;private_lock,
mapping-&gt;tree_lock and the global inode_lock.
.TH "__bread" 9 "__bread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__bread \-  reads a specified block and returns the bh
.SH SYNOPSIS
.B "struct buffer_head *" __bread
.BI "(struct block_device *" bdev ","
.BI "sector_t " block ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "bdev" 12
 the block_device to read from
.IP "block" 12
 number of block
.IP "size" 12
 size (in bytes) to read
.SH "DESCRIPTION"
Reads a specified block, and returns buffer head that contains it.
It returns NULL if the block was unreadable.
.TH "try_to_release_page" 9 "try_to_release_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
try_to_release_page \-  release old fs-specific metadata on a page
.SH SYNOPSIS
.B "int" try_to_release_page
.BI "(struct page *" page ","
.BI "int " gfp_mask ");"
.SH ARGUMENTS
.IP "page" 12
 the page which the kernel is trying to free
.IP "gfp_mask" 12
 memory allocation flags (and I/O mode)
.SH "DESCRIPTION"
The address_space is to try to release any data against the page
(presumably at page-&gt;private).  If the release was successful, return `1'.
Otherwise return zero.

The \fIgfp_mask\fP argument specifies whether I/O may be performed to release
this page (__GFP_IO), and whether the call may block (__GFP_WAIT).
.SH "DESCRIPTION"
The address_space is to try to release any data against the page
(presumably at page-&gt;private).  If the release was successful, return `1'.
Otherwise return zero.

The \fIgfp_mask\fP argument specifies whether I/O may be performed to release
this page (__GFP_IO), and whether the call may block (__GFP_WAIT).
.SH "NOTE"
 \fIgfp_mask\fP may go away, and this function may become non-blocking.
.TH "block_invalidatepage" 9 "block_invalidatepage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
block_invalidatepage \-  invalidate part of all of a buffer-backed page
.SH SYNOPSIS
.B "int" block_invalidatepage
.BI "(struct page *" page ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "page" 12
 the page which is affected
.IP "offset" 12
 the index of the truncation point
.SH "DESCRIPTION"
\fBblock_invalidatepage\fP is called when all or part of the page has become
invalidatedby a truncate operation.

\fBblock_invalidatepage\fP does not have to release all buffers, but it must
ensure that no dirty buffer is left outside \fIoffset\fP and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.
.SH "DESCRIPTION"
\fBblock_invalidatepage\fP is called when all or part of the page has become
invalidatedby a truncate operation.

\fBblock_invalidatepage\fP does not have to release all buffers, but it must
ensure that no dirty buffer is left outside \fIoffset\fP and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.
.TH "ll_rw_block" 9 "ll_rw_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ll_rw_block \- level access to block devices (DEPRECATED)
.SH SYNOPSIS
.B "void" ll_rw_block
.BI "(int " rw ","
.BI "int " nr ","
.BI "struct buffer_head *" bhs[] ");"
.SH ARGUMENTS
.IP "rw" 12
 whether to READ or WRITE or SWRITE or maybe READA (readahead)
.IP "nr" 12
 number of &amp;struct buffer_heads in the array
.IP "bhs[]" 12
 array of pointers to &amp;struct buffer_head
.SH "DESCRIPTION"
\fBll_rw_block\fP takes an array of pointers to &amp;struct buffer_heads, and
requests an I/O operation on them, either a READ or a WRITE.  The third
SWRITE is like WRITE only we make sure that the *current* data in buffers
are sent to disk. The fourth READA option is described in the documentation
for \fBgeneric_make_request\fP which \fBll_rw_block\fP calls.

This function drops any buffer that it cannot get a lock on (with the
BH_Lock state bit) unless SWRITE is required, any buffer that appears to be
clean when doing a write request, and any buffer that appears to be
up-to-date when doing read request.  Further it marks as clean buffers that
are processed for writing (the buffer cache won't assume that they are
actually clean until the buffer gets unlocked).

ll_rw_block sets b_end_io to simple completion handler that marks
the buffer up-to-date (if approriate), unlocks the buffer and wakes
any waiters. 

All of the buffers must be for the same device, and must also be a
multiple of the current approved size for the device.
.TH "ext2_block_to_path" 9 "ext2_block_to_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_block_to_path \-  parse the block number into array of offsets
.SH SYNOPSIS
.B "int" ext2_block_to_path
.BI "(struct inode *" inode ","
.BI "long " i_block ","
.BI "int " offsets[4] ","
.BI "int *" boundary ");"
.SH ARGUMENTS
.IP "inode" 12
 inode in question (we are only interested in its superblock)
.IP "i_block" 12
 block number to be parsed
.IP "offsets[4]" 12
 array to store the offsets in
.IP "boundary" 12
 set this non-zero if the referred-to block is likely to be
followed (on disk) by an indirect block.
To store the locations of file's data ext2 uses a data structure common
for UNIX filesystems - tree of pointers anchored in the inode, with
data blocks at leaves and indirect blocks in intermediate nodes.
This function translates the block number into path in that tree -
return value is the path length and \fIoffsets\fP[n] is the offset of
pointer to (n+1)th node in the nth one. If \fIblock\fP is out of range
(negative or too large) warning is printed and zero returned.
.SH "NOTE"
 function doesn't find node addresses, so no IO is needed. All
we need to know is the capacity of indirect blocks (taken from the
inode-&gt;i_sb).
.TH "ext2_get_branch" 9 "ext2_get_branch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_get_branch \-  read the chain of indirect blocks leading to data
.SH SYNOPSIS
.B "Indirect *" ext2_get_branch
.BI "(struct inode *" inode ","
.BI "int " depth ","
.BI "int *" offsets ","
.BI "Indirect " chain[4] ","
.BI "int *" err ");"
.SH ARGUMENTS
.IP "inode" 12
 inode in question
.IP "depth" 12
 depth of the chain (1 - direct pointer, etc.)
.IP "offsets" 12
 offsets of pointers in inode/indirect blocks
.IP "chain[4]" 12
 place to store the result
.IP "err" 12
 here we store the error value
.SH "DESCRIPTION"
Function fills the array of triples &lt;key, p, bh&gt; and returns NULL
if everything went OK or the pointer to the last filled triple
(incomplete one) otherwise. Upon the return chain[i].key contains
the number of (i+1)-th block in the chain (as it is stored in memory,
i.e. little-endian 32-bit), chain[i].p contains the address of that
number (it points into struct inode for i==0 and into the bh-&gt;b_data
for i&gt;0) and chain[i].bh points to the buffer_head of i-th indirect
block for i&gt;0 and NULL for i==0. In other words, it holds the block
numbers of the chain, addresses they were taken from (and where we can
verify that chain did not change) and buffer_heads hosting these
numbers.

Function stops when it stumbles upon zero pointer (absent block)
(pointer to last triple returned, *\fIerr\fP == 0)
or when it gets an IO error reading an indirect block
(ditto, *\fIerr\fP == -EIO)
or when it notices that chain had been changed while it was reading
(ditto, *\fIerr\fP == -EAGAIN)
or when it reads all \fIdepth\fP-1 indirect blocks successfully and finds
the whole chain, all way to the data (returns NULL, *err == 0).
.TH "ext2_find_near" 9 "ext2_find_near" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_find_near \-  find a place for allocation with sufficient locality
.SH SYNOPSIS
.B "unsigned long" ext2_find_near
.BI "(struct inode *" inode ","
.BI "Indirect *" ind ");"
.SH ARGUMENTS
.IP "inode" 12
 owner
.IP "ind" 12
 descriptor of indirect block.
.SH "DESCRIPTION"
This function returns the prefered place for block allocation.
It is used when heuristic for sequential allocation fails.
.SH "RULES ARE"
+ if there is a block to the left of our position - allocate near it.
+ if pointer will live in indirect block - allocate near that block.
+ if pointer will live in inode - allocate in the same cylinder group.

In the latter case we colour the starting block by the callers PID to
prevent it from clashing with concurrent allocations for a different inode
in the same block group.   The PID is used here so that functionally related
files will be close-by on-disk.

Caller must make sure that \fIind\fP is valid and will stay that way.
.TH "ext2_find_goal" 9 "ext2_find_goal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_find_goal \-  find a prefered place for allocation.
.SH SYNOPSIS
.B "int" ext2_find_goal
.BI "(struct inode *" inode ","
.BI "long " block ","
.BI "Indirect " chain[4] ","
.BI "Indirect *" partial ","
.BI "unsigned long *" goal ");"
.SH ARGUMENTS
.IP "inode" 12
 owner
.IP "block" 12
  block we want
.IP "chain[4]" 12
  chain of indirect blocks
.IP "partial" 12
 pointer to the last triple within a chain
.IP "goal" 12
	place to store the result.
.SH "DESCRIPTION"
Normally this function find the prefered place for block allocation,
stores it in *\fIgoal\fP and returns zero. If the branch had been changed
under us we return -EAGAIN.
.TH "ext2_alloc_branch" 9 "ext2_alloc_branch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_alloc_branch \-  allocate and set up a chain of blocks.
.SH SYNOPSIS
.B "int" ext2_alloc_branch
.BI "(struct inode *" inode ","
.BI "int " num ","
.BI "unsigned long " goal ","
.BI "int *" offsets ","
.BI "Indirect *" branch ");"
.SH ARGUMENTS
.IP "inode" 12
 owner
.IP "num" 12
 depth of the chain (number of blocks to allocate)
.IP "goal" 12
-- undescribed --
.IP "offsets" 12
 offsets (in the blocks) to store the pointers to next.
.IP "branch" 12
 place to store the chain in.
.SH "DESCRIPTION"
This function allocates \fInum\fP blocks, zeroes out all but the last one,
links them into chain and (if we are synchronous) writes them to disk.
In other words, it prepares a branch that can be spliced onto the
inode. It stores the information about that chain in the branch[], in
the same format as \fBext2_get_branch\fP would do. We are calling it after
we had read the existing part of chain and partial points to the last
triple of that (one with zero -&gt;key). Upon the exit we have the same
picture as after the successful \fBext2_get_block\fP, excpet that in one
place chain is disconnected - *branch-&gt;p is still zero (we did not
set the last link), but branch-&gt;key contains the number that should
be placed into *branch-&gt;p to fill that gap.

If allocation fails we free all blocks we've allocated (and forget
their buffer_heads) and return the error value the from failed
\fBext2_alloc_block\fP (normally -ENOSPC). Otherwise we set the chain
as described above and return 0.
.TH "ext2_splice_branch" 9 "ext2_splice_branch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_splice_branch \-  splice the allocated branch onto inode.
.SH SYNOPSIS
.B "int" ext2_splice_branch
.BI "(struct inode *" inode ","
.BI "long " block ","
.BI "Indirect " chain[4] ","
.BI "Indirect *" where ","
.BI "int " num ");"
.SH ARGUMENTS
.IP "inode" 12
 owner
.IP "block" 12
 (logical) number of block we are adding
.IP "chain[4]" 12
 chain of indirect blocks (with a missing link - see
ext2_alloc_branch)
.IP "where" 12
 location of missing link
.IP "num" 12
   number of blocks we are adding
.SH "DESCRIPTION"
This function verifies that chain (up to the missing link) had not
changed, fills the missing link and does all housekeeping needed in
inode (-&gt;i_blocks, etc.). In case of success we end up with the full
chain to new block and return 0. Otherwise (== chain had been changed)
we free the new blocks (forgetting their buffer_heads, indeed) and
return -EAGAIN.
.TH "ext2_find_shared" 9 "ext2_find_shared" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_find_shared \-  find the indirect blocks for partial truncation.
.SH SYNOPSIS
.B "Indirect *" ext2_find_shared
.BI "(struct inode *" inode ","
.BI "int " depth ","
.BI "int " offsets[4] ","
.BI "Indirect " chain[4] ","
.BI "__le32 *" top ");"
.SH ARGUMENTS
.IP "inode" 12
	  inode in question
.IP "depth" 12
	  depth of the affected branch
.IP "offsets[4]" 12
 offsets of pointers in that branch (see ext2_block_to_path)
.IP "chain[4]" 12
	  place to store the pointers to partial indirect blocks
.IP "top" 12
	  place to the (detached) top of branch
.SH "DESCRIPTION"
This is a helper function used by \fBext2_truncate\fP.

When we do \fBtruncate\fP we may have to clean the ends of several indirect
blocks but leave the blocks themselves alive. Block is partially
truncated if some data below the new i_size is refered from it (and
it is on the path to the first completely truncated data block, indeed).
We have to free the top of that path along with everything to the right
of the path. Since no allocation past the truncation point is possible
until \fBext2_truncate\fP finishes, we may safely do the latter, but top
of branch may require special attention - pageout below the truncation
point might try to populate it.

We atomically detach the top of branch from the tree, store the block
number of its root in *\fItop\fP, pointers to buffer_heads of partially
truncated blocks - in \fIchain\fP[].bh and pointers to their last elements
that should not be removed - in \fIchain\fP[].p. Return value is the pointer
to last filled element of \fIchain\fP.
.SH "THE WORK LEFT TO CALLER TO DO THE ACTUAL FREEING OF SUBTREES"
a) free the subtree starting from *\fItop\fP
b) free the subtrees whose roots are stored in
(\fIchain\fP[i].p+1 .. end of \fIchain\fP[i].bh-&gt;b_data)
c) free the subtrees growing from the inode past the \fIchain\fP[0].p
(no partially truncated stuff there).
.TH "ext2_free_data" 9 "ext2_free_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_free_data \-  free a list of data blocks
.SH SYNOPSIS
.B "void" ext2_free_data
.BI "(struct inode *" inode ","
.BI "__le32 *" p ","
.BI "__le32 *" q ");"
.SH ARGUMENTS
.IP "inode" 12
	inode we are dealing with
.IP "p" 12
	array of block numbers
.IP "q" 12
	points immediately past the end of array
.SH "DESCRIPTION"
We are freeing all blocks refered from that array (numbers are
stored as little-endian 32-bit) and updating \fIinode\fP-&gt;i_blocks
appropriately.
.TH "ext2_free_branches" 9 "ext2_free_branches" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_free_branches \-  free an array of branches
.SH SYNOPSIS
.B "void" ext2_free_branches
.BI "(struct inode *" inode ","
.BI "__le32 *" p ","
.BI "__le32 *" q ","
.BI "int " depth ");"
.SH ARGUMENTS
.IP "inode" 12
	inode we are dealing with
.IP "p" 12
	array of block numbers
.IP "q" 12
	pointer immediately past the end of array
.IP "depth" 12
	depth of the branches to free
.SH "DESCRIPTION"
We are freeing all blocks refered from these branches (numbers are
stored as little-endian 32-bit) and updating \fIinode\fP-&gt;i_blocks
appropriately.
.TH "ext2_bg_has_super" 9 "ext2_bg_has_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_bg_has_super \-  number of blocks used by the superblock in group
.SH SYNOPSIS
.B "int" ext2_bg_has_super
.BI "(struct super_block *" sb ","
.BI "int " group ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock for filesystem
.IP "group" 12
 group number to check
.SH "DESCRIPTION"
Return the number of blocks used by the superblock (primary or backup)
in this group.  Currently this will be only 0 or 1.
.TH "ext2_bg_num_gdb" 9 "ext2_bg_num_gdb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext2_bg_num_gdb \-  number of blocks used by the group table in group
.SH SYNOPSIS
.B "unsigned long" ext2_bg_num_gdb
.BI "(struct super_block *" sb ","
.BI "int " group ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock for filesystem
.IP "group" 12
 group number to check
.SH "DESCRIPTION"
Return the number of blocks used by the group descriptor table
(primary or backup) in this group.  In the future there may be a
different number of descriptor blocks in each group.
.TH "ntfs_cluster_free" 9 "ntfs_cluster_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_cluster_free \-  free clusters on an ntfs volume
.SH SYNOPSIS
.B "s64" ntfs_cluster_free
.BI "(ntfs_inode *" ni ","
.BI "const VCN " start_vcn ","
.BI "s64 " count ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode whose runlist describes the clusters to free
.IP "start_vcn" 12
	vcn in the runlist of \fIni\fP at which to start freeing clusters
.IP "count" 12
	number of clusters to free or -1 for all clusters
.SH "DESCRIPTION"
Free \fIcount\fP clusters starting at the cluster \fIstart_vcn\fP in the runlist
described by the ntfs inode \fIni\fP.

If \fIcount\fP is -1, all clusters from \fIstart_vcn\fP to the end of the runlist are
deallocated.  Thus, to completely free all clusters in a runlist, use
\fIstart_vcn\fP = 0 and \fIcount\fP = -1.

Note, \fBntfs_cluster_free\fP does not modify the runlist at all, so the caller
has to deal with it later.

Return the number of deallocated clusters (not counting sparse ones) on
success and -errno on error.
.SH "LOCKING"
 - The runlist described by \fIni\fP must be locked for writing on entry
and is locked on return.  Note the runlist may be modified when
needed runlist fragments need to be mapped.
- The volume lcn bitmap must be unlocked on entry and is unlocked
on return.
- This function takes the volume lcn bitmap lock for writing and
modifies the bitmap contents.
.TH "ntfs_cluster_free_from_rl" 9 "ntfs_cluster_free_from_rl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_cluster_free_from_rl \-  free clusters from runlist
.SH SYNOPSIS
.B "int" ntfs_cluster_free_from_rl
.BI "(ntfs_volume *" vol ","
.BI "const runlist_element *" rl ");"
.SH ARGUMENTS
.IP "vol" 12
	mounted ntfs volume on which to free the clusters
.IP "rl" 12
		runlist describing the clusters to free
.SH "DESCRIPTION"
Free all the clusters described by the runlist \fIrl\fP on the volume \fIvol\fP.  In
the case of an error being returned, at least some of the clusters were not
freed.

Return 0 on success and -errno on error.
.SH "LOCKING"
 - This function takes the volume lcn bitmap lock for writing and
modifies the bitmap contents.
- The caller must have locked the runlist \fIrl\fP for reading or
writing.
.TH "ntfs_mark_quotas_out_of_date" 9 "ntfs_mark_quotas_out_of_date" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mark_quotas_out_of_date \-  mark the quotas out of date on an ntfs volume
.SH SYNOPSIS
.B "BOOL" ntfs_mark_quotas_out_of_date
.BI "(ntfs_volume *" vol ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume on which to mark the quotas out of date
.SH "DESCRIPTION"
Mark the quotas out of date on the ntfs volume \fIvol\fP and return TRUE on
success and FALSE on error.
.TH "ntfs_index_entry_flush_dcache_page" 9 "ntfs_index_entry_flush_dcache_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_index_entry_flush_dcache_page \-  flush_dcache_page() for index entries
.SH SYNOPSIS
.B "void" ntfs_index_entry_flush_dcache_page
.BI "(ntfs_index_context *" ictx ");"
.SH ARGUMENTS
.IP "ictx" 12
	ntfs index context describing the index entry
.SH "DESCRIPTION"
Call \fBflush_dcache_page\fP for the page in which an index entry resides.

This must be called every time an index entry is modified, just after the
modification.

If the index entry is in the index root attribute, simply flush the page
containing the mft record containing the index root attribute.

If the index entry is in an index block belonging to the index allocation
attribute, simply flush the page cache page containing the index block.
.TH "ntfs_index_entry_mark_dirty" 9 "ntfs_index_entry_mark_dirty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_index_entry_mark_dirty \-  mark an index entry dirty
.SH SYNOPSIS
.B "void" ntfs_index_entry_mark_dirty
.BI "(ntfs_index_context *" ictx ");"
.SH ARGUMENTS
.IP "ictx" 12
	ntfs index context describing the index entry
.SH "DESCRIPTION"
Mark the index entry described by the index entry context \fIictx\fP dirty.

If the index entry is in the index root attribute, simply mark the mft
record containing the index root attribute dirty.  This ensures the mft
record, and hence the index root attribute, will be written out to disk
later.

If the index entry is in an index block belonging to the index allocation
attribute, mark the buffers belonging to the index record as well as the
page cache page the index block is in dirty.  This automatically marks the
VFS inode of the ntfs index inode to which the index entry belongs dirty,
too (I_DIRTY_PAGES) and this in turn ensures the page buffers, and hence the
dirty index block, will be written out to disk later.
.TH "__ntfs_warning" 9 "__ntfs_warning" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntfs_warning \-  output a warning to the syslog
.SH SYNOPSIS
.B "void" __ntfs_warning
.BI "(const char *" function ","
.BI "const struct super_block *" sb ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "function" 12
	name of function outputting the warning
.IP "sb" 12
		super block of mounted ntfs filesystem
.IP "fmt" 12
	warning string containing format specifications
@...:	a variable number of arguments specified in \fIfmt\fP
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Outputs a warning to the syslog for the mounted ntfs filesystem described
by \fIsb\fP.

\fIfmt\fP and the corresponding @... is printf style format string containing
the warning string and the corresponding format arguments, respectively.

\fIfunction\fP is the name of the function from which __ntfs_warning is being
called.

Note, you should be using debug.h::ntfs_warning(\fIsb\fP, \fIfmt\fP, @...) instead
as this provides the \fIfunction\fP parameter automatically.
.TH "__ntfs_error" 9 "__ntfs_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntfs_error \-  output an error to the syslog
.SH SYNOPSIS
.B "void" __ntfs_error
.BI "(const char *" function ","
.BI "const struct super_block *" sb ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "function" 12
	name of function outputting the error
.IP "sb" 12
		super block of mounted ntfs filesystem
.IP "fmt" 12
	error string containing format specifications
@...:	a variable number of arguments specified in \fIfmt\fP
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Outputs an error to the syslog for the mounted ntfs filesystem described
by \fIsb\fP.

\fIfmt\fP and the corresponding @... is printf style format string containing
the error string and the corresponding format arguments, respectively.

\fIfunction\fP is the name of the function from which __ntfs_error is being
called.

Note, you should be using debug.h::ntfs_error(\fIsb\fP, \fIfmt\fP, @...) instead
as this provides the \fIfunction\fP parameter automatically.
.TH "ntfs_bitmap_set_bits_in_run" 9 "ntfs_bitmap_set_bits_in_run" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_bitmap_set_bits_in_run \-  set a run of bits in a bitmap to a value
.SH SYNOPSIS
.B "int" ntfs_bitmap_set_bits_in_run
.BI "(struct inode *" vi ","
.BI "const s64 " start_bit ","
.BI "const s64 " count ","
.BI "const u8 " value ");"
.SH ARGUMENTS
.IP "vi" 12
			vfs inode describing the bitmap
.IP "start_bit" 12
		first bit to set
.IP "count" 12
		number of bits to set
.IP "value" 12
		value to set the bits to (i.e. 0 or 1)
.SH "DESCRIPTION"
Set \fIcount\fP bits starting at bit \fIstart_bit\fP in the bitmap described by the
vfs inode \fIvi\fP to \fIvalue\fP, where \fIvalue\fP is either 0 or 1.

Return 0 on success and -errno on error.
.TH "ntfs_bitmap_set_run" 9 "ntfs_bitmap_set_run" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_bitmap_set_run \-  set a run of bits in a bitmap
.SH SYNOPSIS
.B "int" ntfs_bitmap_set_run
.BI "(struct inode *" vi ","
.BI "const s64 " start_bit ","
.BI "const s64 " count ");"
.SH ARGUMENTS
.IP "vi" 12
		vfs inode describing the bitmap
.IP "start_bit" 12
	first bit to set
.IP "count" 12
	number of bits to set
.SH "DESCRIPTION"
Set \fIcount\fP bits starting at bit \fIstart_bit\fP in the bitmap described by the
vfs inode \fIvi\fP.

Return 0 on success and -errno on error.
.TH "ntfs_bitmap_clear_run" 9 "ntfs_bitmap_clear_run" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_bitmap_clear_run \-  clear a run of bits in a bitmap
.SH SYNOPSIS
.B "int" ntfs_bitmap_clear_run
.BI "(struct inode *" vi ","
.BI "const s64 " start_bit ","
.BI "const s64 " count ");"
.SH ARGUMENTS
.IP "vi" 12
		vfs inode describing the bitmap
.IP "start_bit" 12
	first bit to clear
.IP "count" 12
	number of bits to clear
.SH "DESCRIPTION"
Clear \fIcount\fP bits starting at bit \fIstart_bit\fP in the bitmap described by the
vfs inode \fIvi\fP.

Return 0 on success and -errno on error.
.TH "ntfs_bitmap_set_bit" 9 "ntfs_bitmap_set_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_bitmap_set_bit \-  set a bit in a bitmap
.SH SYNOPSIS
.B "int" ntfs_bitmap_set_bit
.BI "(struct inode *" vi ","
.BI "const s64 " bit ");"
.SH ARGUMENTS
.IP "vi" 12
		vfs inode describing the bitmap
.IP "bit" 12
	bit to set
.SH "DESCRIPTION"
Set bit \fIbit\fP in the bitmap described by the vfs inode \fIvi\fP.

Return 0 on success and -errno on error.
.TH "ntfs_bitmap_clear_bit" 9 "ntfs_bitmap_clear_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_bitmap_clear_bit \-  clear a bit in a bitmap
.SH SYNOPSIS
.B "int" ntfs_bitmap_clear_bit
.BI "(struct inode *" vi ","
.BI "const s64 " bit ");"
.SH ARGUMENTS
.IP "vi" 12
		vfs inode describing the bitmap
.IP "bit" 12
	bit to clear
.SH "DESCRIPTION"
Clear bit \fIbit\fP in the bitmap described by the vfs inode \fIvi\fP.

Return 0 on success and -errno on error.
.TH "ntfs_stamp_usnjrnl" 9 "ntfs_stamp_usnjrnl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_stamp_usnjrnl \-  stamp the transaction log ($UsnJrnl) on an ntfs volume
.SH SYNOPSIS
.B "BOOL" ntfs_stamp_usnjrnl
.BI "(ntfs_volume *" vol ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume on which to stamp the transaction log
.SH "DESCRIPTION"
Stamp the transaction log ($UsnJrnl) on the ntfs volume \fIvol\fP and return
TRUE on success and FALSE on error.

This function assumes that the transaction log has already been loaded and
consistency checked by a call to fs/ntfs/super.c::\fBload_and_init_usnjrnl\fP.
.TH "flush_dcache_mft_record_page" 9 "flush_dcache_mft_record_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
flush_dcache_mft_record_page \-  flush_dcache_page() for mft records
.SH SYNOPSIS
.B "void" flush_dcache_mft_record_page
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode structure of mft record
.SH "DESCRIPTION"
Call \fBflush_dcache_page\fP for the page in which an mft record resides.

This must be called every time an mft record is modified, just after the
modification.
.TH "mark_mft_record_dirty" 9 "mark_mft_record_dirty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mark_mft_record_dirty \-  set the mft record and the page containing it dirty
.SH SYNOPSIS
.B "void" mark_mft_record_dirty
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode describing the mapped mft record
.SH "DESCRIPTION"
Set the mapped (extent) mft record of the (base or extent) ntfs inode \fIni\fP,
as well as the page containing the mft record, dirty.  Also, mark the base
vfs inode dirty.  This ensures that any changes to the mft record are
written out to disk.
.SH "NOTE"
  Do not do anything if the mft record is already marked dirty.
.TH "write_mft_record" 9 "write_mft_record" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_mft_record \-  write out a mapped (extent) mft record
.SH SYNOPSIS
.B "int" write_mft_record
.BI "(ntfs_inode *" ni ","
.BI "MFT_RECORD *" m ","
.BI "int " sync ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode describing the mapped (extent) mft record
.IP "m" 12
		mapped (extent) mft record to write
.IP "sync" 12
	if true, wait for i/o completion
.SH "DESCRIPTION"
This is just a wrapper for \fBwrite_mft_record_nolock\fP (see mft.c), which
locks the page for the duration of the write.  This ensures that there are
no race conditions between writing the mft record via the dirty inode code
paths and via the page cache write back code paths or between writing
neighbouring mft records residing in the same page.

Locking the page also serializes us against -&gt;\fBreadpage\fP if the page is not
uptodate.

On success, clean the mft record and return 0.  On error, leave the mft
record dirty and return -errno.  The caller should call \fBmake_bad_inode\fP on
the base inode to ensure no more access happens to this inode.  We do not do
it here as the caller may want to finish writing other extent mft records
first to minimize on-disk metadata inconsistencies.
.TH "ntfs_rl_mm" 9 "ntfs_rl_mm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_mm \-  NTFS runlist handling code.  Part of the Linux-NTFS project.
.SH SYNOPSIS
.B "void" ntfs_rl_mm
.BI "(runlist_element *" base ","
.BI "int " dst ","
.BI "int " src ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "base" 12
-- undescribed --
.IP "dst" 12
-- undescribed --
.IP "src" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"

Copyright (c) 2001-2005 Anton Altaparmakov
Copyright (c) 2002-2005 Richard Russon

This program/include file is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program/include file is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (in the main directory of the Linux-NTFS
distribution in the file COPYING); if not, write to the Free Software
Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
.TH "ntfs_rl_mc" 9 "ntfs_rl_mc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_mc \-  runlist memory copy
.SH SYNOPSIS
.B "void" ntfs_rl_mc
.BI "(runlist_element *" dstbase ","
.BI "int " dst ","
.BI "runlist_element *" srcbase ","
.BI "int " src ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "dstbase" 12
-- undescribed --
.IP "dst" 12
-- undescribed --
.IP "srcbase" 12
-- undescribed --
.IP "src" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"

It is up to the caller to serialize access to the runlists \fIdstbase\fP and
\fIsrcbase\fP.
.TH "ntfs_rl_realloc" 9 "ntfs_rl_realloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_realloc \-  Reallocate memory for runlists
.SH SYNOPSIS
.B "runlist_element *" ntfs_rl_realloc
.BI "(runlist_element *" rl ","
.BI "int " old_size ","
.BI "int " new_size ");"
.SH ARGUMENTS
.IP "rl" 12
		original runlist
.IP "old_size" 12
	number of runlist elements in the original runlist \fIrl\fP
.IP "new_size" 12
	number of runlist elements we need space for
.SH "DESCRIPTION"
As the runlists grow, more memory will be required.  To prevent the
kernel having to allocate and reallocate large numbers of small bits of
memory, this function returns an entire page of memory.

It is up to the caller to serialize access to the runlist \fIrl\fP.

N.B.  If the new allocation doesn't require a different number of pages in
memory, the function will return the original pointer.

On success, return a pointer to the newly allocated, or recycled, memory.
On error, return -errno. The following error codes are defined:
-ENOMEM	- Not enough memory to allocate runlist array.
-EINVAL	- Invalid parameters were passed in.
.TH "ntfs_rl_realloc_nofail" 9 "ntfs_rl_realloc_nofail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_realloc_nofail \-  Reallocate memory for runlists
.SH SYNOPSIS
.B "runlist_element *" ntfs_rl_realloc_nofail
.BI "(runlist_element *" rl ","
.BI "int " old_size ","
.BI "int " new_size ");"
.SH ARGUMENTS
.IP "rl" 12
		original runlist
.IP "old_size" 12
	number of runlist elements in the original runlist \fIrl\fP
.IP "new_size" 12
	number of runlist elements we need space for
.SH "DESCRIPTION"
As the runlists grow, more memory will be required.  To prevent the
kernel having to allocate and reallocate large numbers of small bits of
memory, this function returns an entire page of memory.

This function guarantees that the allocation will succeed.  It will sleep
for as long as it takes to complete the allocation.

It is up to the caller to serialize access to the runlist \fIrl\fP.

N.B.  If the new allocation doesn't require a different number of pages in
memory, the function will return the original pointer.

On success, return a pointer to the newly allocated, or recycled, memory.
On error, return -errno. The following error codes are defined:
-ENOMEM	- Not enough memory to allocate runlist array.
-EINVAL	- Invalid parameters were passed in.
.TH "ntfs_are_rl_mergeable" 9 "ntfs_are_rl_mergeable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_are_rl_mergeable \-  test if two runlists can be joined together
.SH SYNOPSIS
.B "BOOL" ntfs_are_rl_mergeable
.BI "(runlist_element *" dst ","
.BI "runlist_element *" src ");"
.SH ARGUMENTS
.IP "dst" 12
	original runlist
.IP "src" 12
	new runlist to test for mergeability with \fIdst\fP
.SH "DESCRIPTION"
Test if two runlists can be joined together. For this, their VCNs and LCNs
must be adjacent.

It is up to the caller to serialize access to the runlists \fIdst\fP and \fIsrc\fP.
.SH "RETURN"
 TRUE   Success, the runlists can be merged.
FALSE  Failure, the runlists cannot be merged.
.TH "__ntfs_rl_merge" 9 "__ntfs_rl_merge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntfs_rl_merge \-  merge two runlists without testing if they can be merged
.SH SYNOPSIS
.B "void" __ntfs_rl_merge
.BI "(runlist_element *" dst ","
.BI "runlist_element *" src ");"
.SH ARGUMENTS
.IP "dst" 12
	original, destination runlist
.IP "src" 12
	new runlist to merge with \fIdst\fP
.SH "DESCRIPTION"
Merge the two runlists, writing into the destination runlist \fIdst\fP. The
caller must make sure the runlists can be merged or this will corrupt the
destination runlist.

It is up to the caller to serialize access to the runlists \fIdst\fP and \fIsrc\fP.
.TH "ntfs_rl_append" 9 "ntfs_rl_append" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_append \-  append a runlist after a given element
.SH SYNOPSIS
.B "runlist_element *" ntfs_rl_append
.BI "(runlist_element *" dst ","
.BI "int " dsize ","
.BI "runlist_element *" src ","
.BI "int " ssize ","
.BI "int " loc ");"
.SH ARGUMENTS
.IP "dst" 12
	original runlist to be worked on
.IP "dsize" 12
	number of elements in \fIdst\fP (including end marker)
.IP "src" 12
	runlist to be inserted into \fIdst\fP
.IP "ssize" 12
	number of elements in \fIsrc\fP (excluding end marker)
.IP "loc" 12
	append the new runlist \fIsrc\fP after this element in \fIdst\fP
.SH "DESCRIPTION"
Append the runlist \fIsrc\fP after element \fIloc\fP in \fIdst\fP.  Merge the right end of
the new runlist, if necessary. Adjust the size of the hole before the
appended runlist.

It is up to the caller to serialize access to the runlists \fIdst\fP and \fIsrc\fP.

On success, return a pointer to the new, combined, runlist. Note, both
runlists \fIdst\fP and \fIsrc\fP are deallocated before returning so you cannot use
the pointers for anything any more. (Strictly speaking the returned runlist
may be the same as \fIdst\fP but this is irrelevant.)

On error, return -errno. Both runlists are left unmodified. The following
.SH "ERROR CODES ARE DEFINED"
-ENOMEM	- Not enough memory to allocate runlist array.
-EINVAL	- Invalid parameters were passed in.
.TH "ntfs_rl_insert" 9 "ntfs_rl_insert" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_insert \-  insert a runlist into another
.SH SYNOPSIS
.B "runlist_element *" ntfs_rl_insert
.BI "(runlist_element *" dst ","
.BI "int " dsize ","
.BI "runlist_element *" src ","
.BI "int " ssize ","
.BI "int " loc ");"
.SH ARGUMENTS
.IP "dst" 12
	original runlist to be worked on
.IP "dsize" 12
	number of elements in \fIdst\fP (including end marker)
.IP "src" 12
	new runlist to be inserted
.IP "ssize" 12
	number of elements in \fIsrc\fP (excluding end marker)
.IP "loc" 12
	insert the new runlist \fIsrc\fP before this element in \fIdst\fP
.SH "DESCRIPTION"
Insert the runlist \fIsrc\fP before element \fIloc\fP in the runlist \fIdst\fP. Merge the
left end of the new runlist, if necessary. Adjust the size of the hole
after the inserted runlist.

It is up to the caller to serialize access to the runlists \fIdst\fP and \fIsrc\fP.

On success, return a pointer to the new, combined, runlist. Note, both
runlists \fIdst\fP and \fIsrc\fP are deallocated before returning so you cannot use
the pointers for anything any more. (Strictly speaking the returned runlist
may be the same as \fIdst\fP but this is irrelevant.)

On error, return -errno. Both runlists are left unmodified. The following
.SH "ERROR CODES ARE DEFINED"
-ENOMEM	- Not enough memory to allocate runlist array.
-EINVAL	- Invalid parameters were passed in.
.TH "ntfs_rl_replace" 9 "ntfs_rl_replace" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_replace \-  overwrite a runlist element with another runlist
.SH SYNOPSIS
.B "runlist_element *" ntfs_rl_replace
.BI "(runlist_element *" dst ","
.BI "int " dsize ","
.BI "runlist_element *" src ","
.BI "int " ssize ","
.BI "int " loc ");"
.SH ARGUMENTS
.IP "dst" 12
	original runlist to be worked on
.IP "dsize" 12
	number of elements in \fIdst\fP (including end marker)
.IP "src" 12
	new runlist to be inserted
.IP "ssize" 12
	number of elements in \fIsrc\fP (excluding end marker)
.IP "loc" 12
	index in runlist \fIdst\fP to overwrite with \fIsrc\fP
.SH "DESCRIPTION"
Replace the runlist element \fIdst\fP at \fIloc\fP with \fIsrc\fP. Merge the left and
right ends of the inserted runlist, if necessary.

It is up to the caller to serialize access to the runlists \fIdst\fP and \fIsrc\fP.

On success, return a pointer to the new, combined, runlist. Note, both
runlists \fIdst\fP and \fIsrc\fP are deallocated before returning so you cannot use
the pointers for anything any more. (Strictly speaking the returned runlist
may be the same as \fIdst\fP but this is irrelevant.)

On error, return -errno. Both runlists are left unmodified. The following
.SH "ERROR CODES ARE DEFINED"
-ENOMEM	- Not enough memory to allocate runlist array.
-EINVAL	- Invalid parameters were passed in.
.TH "ntfs_rl_split" 9 "ntfs_rl_split" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_split \-  insert a runlist into the centre of a hole
.SH SYNOPSIS
.B "runlist_element *" ntfs_rl_split
.BI "(runlist_element *" dst ","
.BI "int " dsize ","
.BI "runlist_element *" src ","
.BI "int " ssize ","
.BI "int " loc ");"
.SH ARGUMENTS
.IP "dst" 12
	original runlist to be worked on
.IP "dsize" 12
	number of elements in \fIdst\fP (including end marker)
.IP "src" 12
	new runlist to be inserted
.IP "ssize" 12
	number of elements in \fIsrc\fP (excluding end marker)
.IP "loc" 12
	index in runlist \fIdst\fP at which to split and insert \fIsrc\fP
.SH "DESCRIPTION"
Split the runlist \fIdst\fP at \fIloc\fP into two and insert \fInew\fP in between the two
fragments. No merging of runlists is necessary. Adjust the size of the
holes either side.

It is up to the caller to serialize access to the runlists \fIdst\fP and \fIsrc\fP.

On success, return a pointer to the new, combined, runlist. Note, both
runlists \fIdst\fP and \fIsrc\fP are deallocated before returning so you cannot use
the pointers for anything any more. (Strictly speaking the returned runlist
may be the same as \fIdst\fP but this is irrelevant.)

On error, return -errno. Both runlists are left unmodified. The following
.SH "ERROR CODES ARE DEFINED"
-ENOMEM	- Not enough memory to allocate runlist array.
-EINVAL	- Invalid parameters were passed in.
.TH "ntfs_runlists_merge" 9 "ntfs_runlists_merge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_runlists_merge \-  merge two runlists into one
.SH SYNOPSIS
.B "runlist_element *" ntfs_runlists_merge
.BI "(runlist_element *" drl ","
.BI "runlist_element *" srl ");"
.SH ARGUMENTS
.IP "drl" 12
	original runlist to be worked on
.IP "srl" 12
	new runlist to be merged into \fIdrl\fP
.SH "DESCRIPTION"
First we sanity check the two runlists \fIsrl\fP and \fIdrl\fP to make sure that they
are sensible and can be merged. The runlist \fIsrl\fP must be either after the
runlist \fIdrl\fP or completely within a hole (or unmapped region) in \fIdrl\fP.

It is up to the caller to serialize access to the runlists \fIdrl\fP and \fIsrl\fP.
.SH "MERGING OF RUNLISTS IS NECESSARY IN TWO CASES"
1. When attribute lists are used and a further extent is being mapped.
2. When new clusters are allocated to fill a hole or extend a file.

There are four possible ways \fIsrl\fP can be merged. It can:
- be inserted at the beginning of a hole,
- split the hole in two and be inserted between the two fragments,
- be appended at the end of a hole, or it can
- replace the whole hole.
It can also be appended to the end of the runlist, which is just a variant
of the insert case.

On success, return a pointer to the new, combined, runlist. Note, both
runlists \fIdrl\fP and \fIsrl\fP are deallocated before returning so you cannot use
the pointers for anything any more. (Strictly speaking the returned runlist
may be the same as \fIdst\fP but this is irrelevant.)

On error, return -errno. Both runlists are left unmodified. The following
.SH "ERROR CODES ARE DEFINED"
-ENOMEM	- Not enough memory to allocate runlist array.
-EINVAL	- Invalid parameters were passed in.
-ERANGE	- The runlists overlap and cannot be merged.
.TH "ntfs_mapping_pairs_decompress" 9 "ntfs_mapping_pairs_decompress" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mapping_pairs_decompress \-  convert mapping pairs array to runlist
.SH SYNOPSIS
.B "runlist_element *" ntfs_mapping_pairs_decompress
.BI "(const ntfs_volume *" vol ","
.BI "const ATTR_RECORD *" attr ","
.BI "runlist_element *" old_rl ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume on which the attribute resides
.IP "attr" 12
	attribute record whose mapping pairs array to decompress
.IP "old_rl" 12
	optional runlist in which to insert \fIattr\fP's runlist
.SH "DESCRIPTION"
It is up to the caller to serialize access to the runlist \fIold_rl\fP.

Decompress the attribute \fIattr\fP's mapping pairs array into a runlist. On
success, return the decompressed runlist.

If \fIold_rl\fP is not NULL, decompressed runlist is inserted into the
appropriate place in \fIold_rl\fP and the resultant, combined runlist is
returned. The original \fIold_rl\fP is deallocated.

On error, return -errno. \fIold_rl\fP is left unmodified in that case.
.SH "THE FOLLOWING ERROR CODES ARE DEFINED"
-ENOMEM	- Not enough memory to allocate runlist array.
-EIO	- Corrupt runlist.
-EINVAL	- Invalid parameters were passed in.
-ERANGE	- The two runlists overlap.
.SH "FIXME"
 For now we take the conceptionally simplest approach of creating the
new runlist disregarding the already existing one and then splicing the
two into one, if that is possible (we check for overlap and discard the new
runlist if overlap present before returning ERR_PTR(-ERANGE)).
.TH "ntfs_rl_vcn_to_lcn" 9 "ntfs_rl_vcn_to_lcn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_vcn_to_lcn \-  convert a vcn into a lcn given a runlist
.SH SYNOPSIS
.B "LCN" ntfs_rl_vcn_to_lcn
.BI "(const runlist_element *" rl ","
.BI "const VCN " vcn ");"
.SH ARGUMENTS
.IP "rl" 12
		runlist to use for conversion
.IP "vcn" 12
	vcn to convert
.SH "DESCRIPTION"
Convert the virtual cluster number \fIvcn\fP of an attribute into a logical
cluster number (lcn) of a device using the runlist \fIrl\fP to map vcns to their
corresponding lcns.

It is up to the caller to serialize access to the runlist \fIrl\fP.

Since lcns must be &gt;= 0, we use negative return codes with special meaning:

Return code		Meaning / Description
==================================================
LCN_HOLE		Hole / not allocated on disk.
LCN_RL_NOT_MAPPED	This is part of the runlist which has not been
inserted into the runlist yet.
LCN_ENOENT		There is no such vcn in the attribute.
.SH "LOCKING"
 - The caller must have locked the runlist (for reading or writing).
- This function does not touch the lock, nor does it modify the
runlist.
.TH "ntfs_rl_find_vcn_nolock" 9 "ntfs_rl_find_vcn_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_find_vcn_nolock \-  find a vcn in a runlist
.SH SYNOPSIS
.B "runlist_element *" ntfs_rl_find_vcn_nolock
.BI "(runlist_element *" rl ","
.BI "const VCN " vcn ");"
.SH ARGUMENTS
.IP "rl" 12
		runlist to search
.IP "vcn" 12
	vcn to find
.SH "DESCRIPTION"
Find the virtual cluster number \fIvcn\fP in the runlist \fIrl\fP and return the
address of the runlist element containing the \fIvcn\fP on success.

Return NULL if \fIrl\fP is NULL or \fIvcn\fP is in an unmapped part/out of bounds of
the runlist.
.SH "LOCKING"
 The runlist must be locked on entry.
.TH "ntfs_get_nr_significant_bytes" 9 "ntfs_get_nr_significant_bytes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_get_nr_significant_bytes \-  get number of bytes needed to store a number
.SH SYNOPSIS
.B "int" ntfs_get_nr_significant_bytes
.BI "(const s64 " n ");"
.SH ARGUMENTS
.IP "n" 12
		number for which to get the number of bytes for
.SH "DESCRIPTION"
Return the number of bytes required to store \fIn\fP unambiguously as
a signed number.

This is used in the context of the mapping pairs array to determine how
many bytes will be needed in the array to store a given logical cluster
number (lcn) or a specific run length.

Return the number of bytes written.  This function cannot fail.
.TH "ntfs_get_size_for_mapping_pairs" 9 "ntfs_get_size_for_mapping_pairs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_get_size_for_mapping_pairs \-  get bytes needed for mapping pairs array
.SH SYNOPSIS
.B "int" ntfs_get_size_for_mapping_pairs
.BI "(const ntfs_volume *" vol ","
.BI "const runlist_element *" rl ","
.BI "const VCN " first_vcn ","
.BI "const VCN " last_vcn ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume (needed for the ntfs version)
.IP "rl" 12
		locked runlist to determine the size of the mapping pairs of
.IP "first_vcn" 12
	first vcn which to include in the mapping pairs array
.IP "last_vcn" 12
	last vcn which to include in the mapping pairs array
.SH "DESCRIPTION"
Walk the locked runlist \fIrl\fP and calculate the size in bytes of the mapping
pairs array corresponding to the runlist \fIrl\fP, starting at vcn \fIfirst_vcn\fP and
finishing with vcn \fIlast_vcn\fP.

A \fIlast_vcn\fP of -1 means end of runlist and in that case the size of the
mapping pairs array corresponding to the runlist starting at vcn \fIfirst_vcn\fP
and finishing at the end of the runlist is determined.

This for example allows us to allocate a buffer of the right size when
building the mapping pairs array.

If \fIrl\fP is NULL, just return 1 (for the single terminator byte).

Return the calculated size in bytes on success.  On error, return -errno.
.SH "THE FOLLOWING ERROR CODES ARE DEFINED"
-EINVAL	- Run list contains unmapped elements.  Make sure to only pass
fully mapped runlists to this function.
-EIO	- The runlist is corrupt.
.SH "LOCKING"
 \fIrl\fP must be locked on entry (either for reading or writing), it
remains locked throughout, and is left locked upon return.
.TH "ntfs_write_significant_bytes" 9 "ntfs_write_significant_bytes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_write_significant_bytes \-  write the significant bytes of a number
.SH SYNOPSIS
.B "int" ntfs_write_significant_bytes
.BI "(s8 *" dst ","
.BI "const s8 *" dst_max ","
.BI "const s64 " n ");"
.SH ARGUMENTS
.IP "dst" 12
	destination buffer to write to
.IP "dst_max" 12
	pointer to last byte of destination buffer for bounds checking
.IP "n" 12
		number whose significant bytes to write
.SH "DESCRIPTION"
Store in \fIdst\fP, the minimum bytes of the number \fIn\fP which are required to
identify \fIn\fP unambiguously as a signed number, taking care not to exceed
\fIdest_max\fP, the maximum position within \fIdst\fP to which we are allowed to
write.

This is used when building the mapping pairs array of a runlist to compress
a given logical cluster number (lcn) or a specific run length to the minumum
size possible.

Return the number of bytes written on success.  On error, i.e. the
destination buffer \fIdst\fP is too small, return -ENOSPC.
.TH "ntfs_mapping_pairs_build" 9 "ntfs_mapping_pairs_build" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mapping_pairs_build \-  build the mapping pairs array from a runlist
.SH SYNOPSIS
.B "int" ntfs_mapping_pairs_build
.BI "(const ntfs_volume *" vol ","
.BI "s8 *" dst ","
.BI "const int " dst_len ","
.BI "const runlist_element *" rl ","
.BI "const VCN " first_vcn ","
.BI "const VCN " last_vcn ","
.BI "VCN *const " stop_vcn ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume (needed for the ntfs version)
.IP "dst" 12
	destination buffer to which to write the mapping pairs array
.IP "dst_len" 12
	size of destination buffer \fIdst\fP in bytes
.IP "rl" 12
		locked runlist for which to build the mapping pairs array
.IP "first_vcn" 12
	first vcn which to include in the mapping pairs array
.IP "last_vcn" 12
	last vcn which to include in the mapping pairs array
.IP "stop_vcn" 12
	first vcn outside destination buffer on success or -ENOSPC
.SH "DESCRIPTION"
Create the mapping pairs array from the locked runlist \fIrl\fP, starting at vcn
\fIfirst_vcn\fP and finishing with vcn \fIlast_vcn\fP and save the array in \fIdst\fP.
\fIdst_len\fP is the size of \fIdst\fP in bytes and it should be at least equal to the
value obtained by calling \fBntfs_get_size_for_mapping_pairs\fP.

A \fIlast_vcn\fP of -1 means end of runlist and in that case the mapping pairs
array corresponding to the runlist starting at vcn \fIfirst_vcn\fP and finishing
at the end of the runlist is created.

If \fIrl\fP is NULL, just write a single terminator byte to \fIdst\fP.

On success or -ENOSPC error, if \fIstop_vcn\fP is not NULL, *\fIstop_vcn\fP is set to
the first vcn outside the destination buffer.  Note that on error, \fIdst\fP has
been filled with all the mapping pairs that will fit, thus it can be treated
as partial success, in that a new attribute extent needs to be created or
the next extent has to be used and the mapping pairs build has to be
continued with \fIfirst_vcn\fP set to *\fIstop_vcn\fP.

Return 0 on success and -errno on error.  The following error codes are
.SH "DEFINED"
-EINVAL	- Run list contains unmapped elements.  Make sure to only pass
fully mapped runlists to this function.
-EIO	- The runlist is corrupt.
-ENOSPC	- The destination buffer is too small.
.SH "LOCKING"
 \fIrl\fP must be locked on entry (either for reading or writing), it
remains locked throughout, and is left locked upon return.
.TH "ntfs_rl_truncate_nolock" 9 "ntfs_rl_truncate_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_truncate_nolock \-  truncate a runlist starting at a specified vcn
.SH SYNOPSIS
.B "int" ntfs_rl_truncate_nolock
.BI "(const ntfs_volume *" vol ","
.BI "runlist *const " runlist ","
.BI "const s64 " new_length ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume (needed for error output)
.IP "runlist" 12
	runlist to truncate
.IP "new_length" 12
	the new length of the runlist in VCNs
.SH "DESCRIPTION"
Truncate the runlist described by \fIrunlist\fP as well as the memory buffer
holding the runlist elements to a length of \fInew_length\fP VCNs.

If \fInew_length\fP lies within the runlist, the runlist elements with VCNs of
\fInew_length\fP and above are discarded.  As a special case if \fInew_length\fP is
zero, the runlist is discarded and set to NULL.

If \fInew_length\fP lies beyond the runlist, a sparse runlist element is added to
the end of the runlist \fIrunlist\fP or if the last runlist element is a sparse
one already, this is extended.

Note, no checking is done for unmapped runlist elements.  It is assumed that
the caller has mapped any elements that need to be mapped already.

Return 0 on success and -errno on error.
.SH "LOCKING"
 The caller must hold \fIrunlist\fP-&gt;lock for writing.
.TH "ntfs_rl_punch_nolock" 9 "ntfs_rl_punch_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_rl_punch_nolock \-  punch a hole into a runlist
.SH SYNOPSIS
.B "int" ntfs_rl_punch_nolock
.BI "(const ntfs_volume *" vol ","
.BI "runlist *const " runlist ","
.BI "const VCN " start ","
.BI "const s64 " length ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume (needed for error output)
.IP "runlist" 12
	runlist to punch a hole into
.IP "start" 12
	starting VCN of the hole to be created
.IP "length" 12
	size of the hole to be created in units of clusters
.SH "DESCRIPTION"
Punch a hole into the runlist \fIrunlist\fP starting at VCN \fIstart\fP and of size
\fIlength\fP clusters.

Return 0 on success and -errno on error, in which case \fIrunlist\fP has not been
modified.

If \fIstart\fP and/or \fIstart\fP + \fIlength\fP are outside the runlist return error code
-ENOENT.

If the runlist contains unmapped or error elements between \fIstart\fP and \fIstart\fP
+ \fIlength\fP return error code -EINVAL.
.SH "LOCKING"
 The caller must hold \fIrunlist\fP-&gt;lock for writing.
.TH "ntfs_map_runlist_nolock" 9 "ntfs_map_runlist_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_map_runlist_nolock \-  NTFS attribute operations.  Part of the Linux-NTFS project.
.SH SYNOPSIS
.B "int" ntfs_map_runlist_nolock
.BI "(ntfs_inode *" ni ","
.BI "VCN " vcn ");"
.SH ARGUMENTS
.IP "ni" 12
-- undescribed --
.IP "vcn" 12
-- undescribed --
.SH "DESCRIPTION"

Copyright (c) 2001-2005 Anton Altaparmakov
Copyright (c) 2002 Richard Russon

This program/include file is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program/include file is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (in the main directory of the Linux-NTFS
distribution in the file COPYING); if not, write to the Free Software
Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
.TH "ntfs_map_runlist" 9 "ntfs_map_runlist" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_map_runlist \-  map (a part of) a runlist of an ntfs inode
.SH SYNOPSIS
.B "int" ntfs_map_runlist
.BI "(ntfs_inode *" ni ","
.BI "VCN " vcn ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode for which to map (part of) a runlist
.IP "vcn" 12
	map runlist part containing this vcn
.SH "DESCRIPTION"
Map the part of a runlist containing the \fIvcn\fP of the ntfs inode \fIni\fP.

Return 0 on success and -errno on error.  There is one special error code
which is not an error as such.  This is -ENOENT.  It means that \fIvcn\fP is out
of bounds of the runlist.
.SH "LOCKING"
 - The runlist must be unlocked on entry and is unlocked on return.
- This function takes the runlist lock for writing and modifies the
runlist.
.TH "ntfs_attr_vcn_to_lcn_nolock" 9 "ntfs_attr_vcn_to_lcn_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_vcn_to_lcn_nolock \-  convert a vcn into a lcn given an ntfs inode
.SH SYNOPSIS
.B "LCN" ntfs_attr_vcn_to_lcn_nolock
.BI "(ntfs_inode *" ni ","
.BI "const VCN " vcn ","
.BI "const BOOL " write_locked ");"
.SH ARGUMENTS
.IP "ni" 12
			ntfs inode of the attribute whose runlist to search
.IP "vcn" 12
		vcn to convert
.IP "write_locked" 12
	true if the runlist is locked for writing
.SH "DESCRIPTION"
Find the virtual cluster number \fIvcn\fP in the runlist of the ntfs attribute
described by the ntfs inode \fIni\fP and return the corresponding logical cluster
number (lcn).

If the \fIvcn\fP is not mapped yet, the attempt is made to map the attribute
extent containing the \fIvcn\fP and the vcn to lcn conversion is retried.

If \fIwrite_locked\fP is true the caller has locked the runlist for writing and
if false for reading.

Since lcns must be &gt;= 0, we use negative return codes with special meaning:

Return code	Meaning / Description
==========================================
LCN_HOLE	Hole / not allocated on disk.
LCN_ENOENT	There is no such vcn in the runlist, i.e. \fIvcn\fP is out of bounds.
LCN_ENOMEM	Not enough memory to map runlist.
LCN_EIO	Critical error (runlist/file is corrupt, i/o error, etc).
.SH "LOCKING"
 - The runlist must be locked on entry and is left locked on return.
- If \fIwrite_locked\fP is FALSE, i.e. the runlist is locked for reading,
the lock may be dropped inside the function so you cannot rely on
the runlist still being the same when this function returns.
.TH "ntfs_attr_find_vcn_nolock" 9 "ntfs_attr_find_vcn_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_find_vcn_nolock \-  find a vcn in the runlist of an ntfs inode
.SH SYNOPSIS
.B "runlist_element *" ntfs_attr_find_vcn_nolock
.BI "(ntfs_inode *" ni ","
.BI "const VCN " vcn ","
.BI "const BOOL " write_locked ");"
.SH ARGUMENTS
.IP "ni" 12
			ntfs inode describing the runlist to search
.IP "vcn" 12
		vcn to find
.IP "write_locked" 12
	true if the runlist is locked for writing
.SH "DESCRIPTION"
Find the virtual cluster number \fIvcn\fP in the runlist described by the ntfs
inode \fIni\fP and return the address of the runlist element containing the \fIvcn\fP.

If the \fIvcn\fP is not mapped yet, the attempt is made to map the attribute
extent containing the \fIvcn\fP and the vcn to lcn conversion is retried.

If \fIwrite_locked\fP is true the caller has locked the runlist for writing and
if false for reading.

Note you need to distinguish between the lcn of the returned runlist element
being &gt;= 0 and LCN_HOLE.  In the later case you have to return zeroes on
read and allocate clusters on write.

Return the runlist element containing the \fIvcn\fP on success and
ERR_PTR(-errno) on error.  You need to test the return value with \fBIS_ERR\fP
to decide if the return is success or failure and \fBPTR_ERR\fP to get to the
error code if \fBIS_ERR\fP is true.
.SH "THE POSSIBLE ERROR RETURN CODES ARE"
-ENOENT - No such vcn in the runlist, i.e. \fIvcn\fP is out of bounds.
-ENOMEM - Not enough memory to map runlist.
-EIO	- Critical error (runlist/file is corrupt, i/o error, etc).
.SH "LOCKING"
 - The runlist must be locked on entry and is left locked on return.
- If \fIwrite_locked\fP is FALSE, i.e. the runlist is locked for reading,
the lock may be dropped inside the function so you cannot rely on
the runlist still being the same when this function returns.
.TH "ntfs_attr_find" 9 "ntfs_attr_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_find \-  find (next) attribute in mft record
.SH SYNOPSIS
.B "int" ntfs_attr_find
.BI "(const ATTR_TYPE " type ","
.BI "const ntfschar *" name ","
.BI "const u32 " name_len ","
.BI "const IGNORE_CASE_BOOL " ic ","
.BI "const u8 *" val ","
.BI "const u32 " val_len ","
.BI "ntfs_attr_search_ctx *" ctx ");"
.SH ARGUMENTS
.IP "type" 12
	attribute type to find
.IP "name" 12
	attribute name to find (optional, i.e. NULL means don't care)
.IP "name_len" 12
	attribute name length (only needed if \fIname\fP present)
.IP "ic" 12
		IGNORE_CASE or CASE_SENSITIVE (ignored if \fIname\fP not present)
.IP "val" 12
	attribute value to find (optional, resident attributes only)
.IP "val_len" 12
	attribute value length
.IP "ctx" 12
	search context with mft record and attribute to search from
.SH "DESCRIPTION"
You should not need to call this function directly.  Use \fBntfs_attr_lookup\fP
instead.

\fBntfs_attr_find\fP takes a search context \fIctx\fP as parameter and searches the
mft record specified by \fIctx\fP-&gt;mrec, beginning at \fIctx\fP-&gt;attr, for an
attribute of \fItype\fP, optionally \fIname\fP and \fIval\fP.

If the attribute is found, \fBntfs_attr_find\fP returns 0 and \fIctx\fP-&gt;attr will
point to the found attribute.

If the attribute is not found, \fBntfs_attr_find\fP returns -ENOENT and
\fIctx\fP-&gt;attr will point to the attribute before which the attribute being
searched for would need to be inserted if such an action were to be desired.

On actual error, \fBntfs_attr_find\fP returns -EIO.  In this case \fIctx\fP-&gt;attr is
undefined and in particular do not rely on it not changing.

If \fIctx\fP-&gt;is_first is TRUE, the search begins with \fIctx\fP-&gt;attr itself.  If it
is FALSE, the search begins after \fIctx\fP-&gt;attr.

If \fIic\fP is IGNORE_CASE, the \fIname\fP comparisson is not case sensitive and
\fIctx\fP-&gt;ntfs_ino must be set to the ntfs inode to which the mft record
\fIctx\fP-&gt;mrec belongs.  This is so we can get at the ntfs volume and hence at
the upcase table.  If \fIic\fP is CASE_SENSITIVE, the comparison is case
sensitive.  When \fIname\fP is present, \fIname_len\fP is the \fIname\fP length in Unicode
characters.

If \fIname\fP is not present (NULL), we assume that the unnamed attribute is
being searched for.

Finally, the resident attribute value \fIval\fP is looked for, if present.  If
\fIval\fP is not present (NULL), \fIval_len\fP is ignored.

\fBntfs_attr_find\fP only searches the specified mft record and it ignores the
presence of an attribute list attribute (unless it is the one being searched
for, obviously).  If you need to take attribute lists into consideration,
use \fBntfs_attr_lookup\fP instead (see below).  This also means that you cannot
use \fBntfs_attr_find\fP to search for extent records of non-resident
attributes, as extents with lowest_vcn != 0 are usually described by the
attribute list attribute only. - Note that it is possible that the first
extent is only in the attribute list while the last extent is in the base
mft record, so do not rely on being able to find the first extent in the
base mft record.
.SH "WARNING"
 Never use \fIval\fP when looking for attribute types which can be
non-resident as this most likely will result in a crash!
.TH "load_attribute_list" 9 "load_attribute_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
load_attribute_list \-  load an attribute list into memory
.SH SYNOPSIS
.B "int" load_attribute_list
.BI "(ntfs_volume *" vol ","
.BI "runlist *" runlist ","
.BI "u8 *" al_start ","
.BI "const s64 " size ","
.BI "const s64 " initialized_size ");"
.SH ARGUMENTS
.IP "vol" 12
		ntfs volume from which to read
.IP "runlist" 12
		runlist of the attribute list
.IP "al_start" 12
		destination buffer
.IP "size" 12
		size of the destination buffer in bytes
.IP "initialized_size" 12
	initialized size of the attribute list
.SH "DESCRIPTION"
Walk the runlist \fIrunlist\fP and load all clusters from it copying them into
the linear buffer \fIal\fP. The maximum number of bytes copied to \fIal\fP is \fIsize\fP
bytes. Note, \fIsize\fP does not need to be a multiple of the cluster size. If
\fIinitialized_size\fP is less than \fIsize\fP, the region in \fIal\fP between
\fIinitialized_size\fP and \fIsize\fP will be zeroed and not read from disk.

Return 0 on success or -errno on error.
.TH "ntfs_external_attr_find" 9 "ntfs_external_attr_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_external_attr_find \-  find an attribute in the attribute list of an inode
.SH SYNOPSIS
.B "int" ntfs_external_attr_find
.BI "(const ATTR_TYPE " type ","
.BI "const ntfschar *" name ","
.BI "const u32 " name_len ","
.BI "const IGNORE_CASE_BOOL " ic ","
.BI "const VCN " lowest_vcn ","
.BI "const u8 *" val ","
.BI "const u32 " val_len ","
.BI "ntfs_attr_search_ctx *" ctx ");"
.SH ARGUMENTS
.IP "type" 12
	attribute type to find
.IP "name" 12
	attribute name to find (optional, i.e. NULL means don't care)
.IP "name_len" 12
	attribute name length (only needed if \fIname\fP present)
.IP "ic" 12
		IGNORE_CASE or CASE_SENSITIVE (ignored if \fIname\fP not present)
.IP "lowest_vcn" 12
	lowest vcn to find (optional, non-resident attributes only)
.IP "val" 12
	attribute value to find (optional, resident attributes only)
.IP "val_len" 12
	attribute value length
.IP "ctx" 12
	search context with mft record and attribute to search from
.SH "DESCRIPTION"
You should not need to call this function directly.  Use \fBntfs_attr_lookup\fP
instead.

Find an attribute by searching the attribute list for the corresponding
attribute list entry.  Having found the entry, map the mft record if the
attribute is in a different mft record/inode, \fBntfs_attr_find\fP the attribute
in there and return it.

On first search \fIctx\fP-&gt;ntfs_ino must be the base mft record and \fIctx\fP must
have been obtained from a call to \fBntfs_attr_get_search_ctx\fP.  On subsequent
calls \fIctx\fP-&gt;ntfs_ino can be any extent inode, too (\fIctx\fP-&gt;base_ntfs_ino is
then the base inode).

After finishing with the attribute/mft record you need to call
\fBntfs_attr_put_search_ctx\fP to cleanup the search context (unmapping any
mapped inodes, etc).

If the attribute is found, \fBntfs_external_attr_find\fP returns 0 and
\fIctx\fP-&gt;attr will point to the found attribute.  \fIctx\fP-&gt;mrec will point to the
mft record in which \fIctx\fP-&gt;attr is located and \fIctx\fP-&gt;al_entry will point to
the attribute list entry for the attribute.

If the attribute is not found, \fBntfs_external_attr_find\fP returns -ENOENT and
\fIctx\fP-&gt;attr will point to the attribute in the base mft record before which
the attribute being searched for would need to be inserted if such an action
were to be desired.  \fIctx\fP-&gt;mrec will point to the mft record in which
\fIctx\fP-&gt;attr is located and \fIctx\fP-&gt;al_entry will point to the attribute list
entry of the attribute before which the attribute being searched for would
need to be inserted if such an action were to be desired.

Thus to insert the not found attribute, one wants to add the attribute to
\fIctx\fP-&gt;mrec (the base mft record) and if there is not enough space, the
attribute should be placed in a newly allocated extent mft record.  The
attribute list entry for the inserted attribute should be inserted in the
attribute list attribute at \fIctx\fP-&gt;al_entry.

On actual error, \fBntfs_external_attr_find\fP returns -EIO.  In this case
\fIctx\fP-&gt;attr is undefined and in particular do not rely on it not changing.
.TH "ntfs_attr_lookup" 9 "ntfs_attr_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_lookup \-  find an attribute in an ntfs inode
.SH SYNOPSIS
.B "int" ntfs_attr_lookup
.BI "(const ATTR_TYPE " type ","
.BI "const ntfschar *" name ","
.BI "const u32 " name_len ","
.BI "const IGNORE_CASE_BOOL " ic ","
.BI "const VCN " lowest_vcn ","
.BI "const u8 *" val ","
.BI "const u32 " val_len ","
.BI "ntfs_attr_search_ctx *" ctx ");"
.SH ARGUMENTS
.IP "type" 12
	attribute type to find
.IP "name" 12
	attribute name to find (optional, i.e. NULL means don't care)
.IP "name_len" 12
	attribute name length (only needed if \fIname\fP present)
.IP "ic" 12
		IGNORE_CASE or CASE_SENSITIVE (ignored if \fIname\fP not present)
.IP "lowest_vcn" 12
	lowest vcn to find (optional, non-resident attributes only)
.IP "val" 12
	attribute value to find (optional, resident attributes only)
.IP "val_len" 12
	attribute value length
.IP "ctx" 12
	search context with mft record and attribute to search from
.SH "DESCRIPTION"
Find an attribute in an ntfs inode.  On first search \fIctx\fP-&gt;ntfs_ino must
be the base mft record and \fIctx\fP must have been obtained from a call to
\fBntfs_attr_get_search_ctx\fP.

This function transparently handles attribute lists and \fIctx\fP is used to
continue searches where they were left off at.

After finishing with the attribute/mft record you need to call
\fBntfs_attr_put_search_ctx\fP to cleanup the search context (unmapping any
mapped inodes, etc).

Return 0 if the search was successful and -errno if not.

When 0, \fIctx\fP-&gt;attr is the found attribute and it is in mft record
\fIctx\fP-&gt;mrec.  If an attribute list attribute is present, \fIctx\fP-&gt;al_entry is
the attribute list entry of the found attribute.

When -ENOENT, \fIctx\fP-&gt;attr is the attribute which collates just after the
attribute being searched for, i.e. if one wants to add the attribute to the
mft record this is the correct place to insert it into.  If an attribute
list attribute is present, \fIctx\fP-&gt;al_entry is the attribute list entry which
collates just after the attribute list entry of the attribute being searched
for, i.e. if one wants to add the attribute to the mft record this is the
correct place to insert its attribute list entry into.

When -errno != -ENOENT, an error occured during the lookup.  \fIctx\fP-&gt;attr is
then undefined and in particular you should not rely on it not changing.
.TH "ntfs_attr_init_search_ctx" 9 "ntfs_attr_init_search_ctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_init_search_ctx \-  initialize an attribute search context
.SH SYNOPSIS
.B "void" ntfs_attr_init_search_ctx
.BI "(ntfs_attr_search_ctx *" ctx ","
.BI "ntfs_inode *" ni ","
.BI "MFT_RECORD *" mrec ");"
.SH ARGUMENTS
.IP "ctx" 12
	attribute search context to initialize
.IP "ni" 12
		ntfs inode with which to initialize the search context
.IP "mrec" 12
	mft record with which to initialize the search context
.SH "DESCRIPTION"
Initialize the attribute search context \fIctx\fP with \fIni\fP and \fImrec\fP.
.TH "ntfs_attr_reinit_search_ctx" 9 "ntfs_attr_reinit_search_ctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_reinit_search_ctx \-  reinitialize an attribute search context
.SH SYNOPSIS
.B "void" ntfs_attr_reinit_search_ctx
.BI "(ntfs_attr_search_ctx *" ctx ");"
.SH ARGUMENTS
.IP "ctx" 12
	attribute search context to reinitialize
.SH "DESCRIPTION"
Reinitialize the attribute search context \fIctx\fP, unmapping an associated
extent mft record if present, and initialize the search context again.

This is used when a search for a new attribute is being started to reset
the search context to the beginning.
.TH "ntfs_attr_get_search_ctx" 9 "ntfs_attr_get_search_ctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_get_search_ctx \-  allocate/initialize a new attribute search context
.SH SYNOPSIS
.B "ntfs_attr_search_ctx *" ntfs_attr_get_search_ctx
.BI "(ntfs_inode *" ni ","
.BI "MFT_RECORD *" mrec ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode with which to initialize the search context
.IP "mrec" 12
	mft record with which to initialize the search context
.SH "DESCRIPTION"
Allocate a new attribute search context, initialize it with \fIni\fP and \fImrec\fP,
and return it. Return NULL if allocation failed.
.TH "ntfs_attr_put_search_ctx" 9 "ntfs_attr_put_search_ctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_put_search_ctx \-  release an attribute search context
.SH SYNOPSIS
.B "void" ntfs_attr_put_search_ctx
.BI "(ntfs_attr_search_ctx *" ctx ");"
.SH ARGUMENTS
.IP "ctx" 12
	attribute search context to free
.SH "DESCRIPTION"
Release the attribute search context \fIctx\fP, unmapping an associated extent
mft record if present.
.TH "ntfs_attr_find_in_attrdef" 9 "ntfs_attr_find_in_attrdef" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_find_in_attrdef \-  find an attribute in the $AttrDef system file
.SH SYNOPSIS
.B "ATTR_DEF *" ntfs_attr_find_in_attrdef
.BI "(const ntfs_volume *" vol ","
.BI "const ATTR_TYPE " type ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume to which the attribute belongs
.IP "type" 12
	attribute type which to find
.SH "DESCRIPTION"
Search for the attribute definition record corresponding to the attribute
\fItype\fP in the $AttrDef system file.

Return the attribute type definition record if found and NULL if not found.
.TH "ntfs_attr_size_bounds_check" 9 "ntfs_attr_size_bounds_check" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_size_bounds_check \-  check a size of an attribute type for validity
.SH SYNOPSIS
.B "int" ntfs_attr_size_bounds_check
.BI "(const ntfs_volume *" vol ","
.BI "const ATTR_TYPE " type ","
.BI "const s64 " size ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume to which the attribute belongs
.IP "type" 12
	attribute type which to check
.IP "size" 12
	size which to check
.SH "DESCRIPTION"
Check whether the \fIsize\fP in bytes is valid for an attribute of \fItype\fP on the
ntfs volume \fIvol\fP.  This information is obtained from $AttrDef system file.

Return 0 if valid, -ERANGE if not valid, or -ENOENT if the attribute is not
listed in $AttrDef.
.TH "ntfs_attr_can_be_non_resident" 9 "ntfs_attr_can_be_non_resident" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_can_be_non_resident \-  check if an attribute can be non-resident
.SH SYNOPSIS
.B "int" ntfs_attr_can_be_non_resident
.BI "(const ntfs_volume *" vol ","
.BI "const ATTR_TYPE " type ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume to which the attribute belongs
.IP "type" 12
	attribute type which to check
.SH "DESCRIPTION"
Check whether the attribute of \fItype\fP on the ntfs volume \fIvol\fP is allowed to
be non-resident.  This information is obtained from $AttrDef system file.

Return 0 if the attribute is allowed to be non-resident, -EPERM if not, and
-ENOENT if the attribute is not listed in $AttrDef.
.TH "ntfs_attr_can_be_resident" 9 "ntfs_attr_can_be_resident" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_can_be_resident \-  check if an attribute can be resident
.SH SYNOPSIS
.B "int" ntfs_attr_can_be_resident
.BI "(const ntfs_volume *" vol ","
.BI "const ATTR_TYPE " type ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume to which the attribute belongs
.IP "type" 12
	attribute type which to check
.SH "DESCRIPTION"
Check whether the attribute of \fItype\fP on the ntfs volume \fIvol\fP is allowed to
be resident.  This information is derived from our ntfs knowledge and may
not be completely accurate, especially when user defined attributes are
present.  Basically we allow everything to be resident except for index
allocation and $EA attributes.

Return 0 if the attribute is allowed to be non-resident and -EPERM if not.
.SH "WARNING"
 In the system file $MFT the attribute $Bitmap must be non-resident
otherwise windows will not boot (blue screen of death)!  We cannot
check for this here as we do not know which inode's $Bitmap is
being asked about so the caller needs to special case this.
.TH "ntfs_attr_record_resize" 9 "ntfs_attr_record_resize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_record_resize \-  resize an attribute record
.SH SYNOPSIS
.B "int" ntfs_attr_record_resize
.BI "(MFT_RECORD *" m ","
.BI "ATTR_RECORD *" a ","
.BI "u32 " new_size ");"
.SH ARGUMENTS
.IP "m" 12
		mft record containing attribute record
.IP "a" 12
		attribute record to resize
.IP "new_size" 12
	new size in bytes to which to resize the attribute record \fIa\fP
.SH "DESCRIPTION"
Resize the attribute record \fIa\fP, i.e. the resident part of the attribute, in
the mft record \fIm\fP to \fInew_size\fP bytes.

Return 0 on success and -errno on error.  The following error codes are
.SH "DEFINED"
-ENOSPC	- Not enough space in the mft record \fIm\fP to perform the resize.
.SH "NOTE"
 On error, no modifications have been performed whatsoever.
.SH "WARNING"
 If you make a record smaller without having copied all the data you
are interested in the data may be overwritten.
.TH "ntfs_resident_attr_value_resize" 9 "ntfs_resident_attr_value_resize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_resident_attr_value_resize \-  resize the value of a resident attribute
.SH SYNOPSIS
.B "int" ntfs_resident_attr_value_resize
.BI "(MFT_RECORD *" m ","
.BI "ATTR_RECORD *" a ","
.BI "const u32 " new_size ");"
.SH ARGUMENTS
.IP "m" 12
		mft record containing attribute record
.IP "a" 12
		attribute record whose value to resize
.IP "new_size" 12
	new size in bytes to which to resize the attribute value of \fIa\fP
.SH "DESCRIPTION"
Resize the value of the attribute \fIa\fP in the mft record \fIm\fP to \fInew_size\fP bytes.
If the value is made bigger, the newly allocated space is cleared.

Return 0 on success and -errno on error.  The following error codes are
.SH "DEFINED"
-ENOSPC	- Not enough space in the mft record \fIm\fP to perform the resize.
.SH "NOTE"
 On error, no modifications have been performed whatsoever.
.SH "WARNING"
 If you make a record smaller without having copied all the data you
are interested in the data may be overwritten.
.TH "ntfs_attr_make_non_resident" 9 "ntfs_attr_make_non_resident" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_make_non_resident \-  convert a resident to a non-resident attribute
.SH SYNOPSIS
.B "int" ntfs_attr_make_non_resident
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode describing the attribute to convert
.SH "DESCRIPTION"
Convert the resident ntfs attribute described by the ntfs inode \fIni\fP to a
non-resident one.

Return 0 on success and -errno on error.  The following error return codes
.SH "ARE DEFINED"
-EPERM	- The attribute is not allowed to be non-resident.
-ENOMEM	- Not enough memory.
-ENOSPC	- Not enough disk space.
-EINVAL	- Attribute not defined on the volume.
-EIO	- I/o error or other error.
Note that -ENOSPC is also returned in the case that there is not enough
space in the mft record to do the conversion.  This can happen when the mft
record is already very full.  The caller is responsible for trying to make
space in the mft record and trying again.  FIXME: Do we need a separate
error return code for this kind of -ENOSPC or is it always worth trying
again in case the attribute may then fit in a resident state so no need to
make it non-resident at all?  Ho-hum...  (AIA)
.SH "NOTE TO SELF"
 No changes in the attribute list are required to move from
a resident to a non-resident attribute.
.SH "LOCKING"
 - The caller must hold i_sem on the inode.
.TH "ntfs_attr_set" 9 "ntfs_attr_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_set \-  fill (a part of) an attribute with a byte
.SH SYNOPSIS
.B "int" ntfs_attr_set
.BI "(ntfs_inode *" ni ","
.BI "const s64 " ofs ","
.BI "const s64 " cnt ","
.BI "const u8 " val ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode describing the attribute to fill
.IP "ofs" 12
	offset inside the attribute at which to start to fill
.IP "cnt" 12
	number of bytes to fill
.IP "val" 12
	the unsigned 8-bit value with which to fill the attribute
.SH "DESCRIPTION"
Fill \fIcnt\fP bytes of the attribute described by the ntfs inode \fIni\fP starting at
byte offset \fIofs\fP inside the attribute with the constant byte \fIval\fP.

This function is effectively like \fBmemset\fP applied to an ntfs attribute.
Note thie function actually only operates on the page cache pages belonging
to the ntfs attribute and it marks them dirty after doing the \fBmemset\fP.
Thus it relies on the vm dirty page write code paths to cause the modified
pages to be written to the mft record/disk.

Return 0 on success and -errno on error.  An error code of -ESPIPE means
that \fIofs\fP + \fIcnt\fP were outside the end of the attribute and no write was
performed.
.TH "ntfs_test_inode" 9 "ntfs_test_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_test_inode \-  NTFS kernel inode handling. Part of the Linux-NTFS project.
.SH SYNOPSIS
.B "int" ntfs_test_inode
.BI "(struct inode *" vi ","
.BI "ntfs_attr *" na ");"
.SH ARGUMENTS
.IP "vi" 12
-- undescribed --
.IP "na" 12
-- undescribed --
.SH "DESCRIPTION"

Copyright (c) 2001-2005 Anton Altaparmakov

This program/include file is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program/include file is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (in the main directory of the Linux-NTFS
distribution in the file COPYING); if not, write to the Free Software
Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
.TH "ntfs_init_locked_inode" 9 "ntfs_init_locked_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_init_locked_inode \-  initialize an inode
.SH SYNOPSIS
.B "int" ntfs_init_locked_inode
.BI "(struct inode *" vi ","
.BI "ntfs_attr *" na ");"
.SH ARGUMENTS
.IP "vi" 12
		vfs inode to initialize
.IP "na" 12
		ntfs attribute which to initialize \fIvi\fP to
.SH "DESCRIPTION"
Initialize the vfs inode \fIvi\fP with the values from the ntfs attribute \fIna\fP in
order to enable \fBntfs_test_inode\fP to do its work.

If initializing the normal file/directory inode, set \fIna\fP-&gt;type to AT_UNUSED.
In that case, \fIna\fP-&gt;name and \fIna\fP-&gt;name_len should be set to NULL and 0,
respectively. Although that is not strictly necessary as
\fBntfs_read_inode_locked\fP will fill them in later.

Return 0 on success and -errno on error.
.SH "NOTE"
 This function runs with the inode_lock spin lock held so it is not
allowed to sleep. (Hence the GFP_ATOMIC allocation.)
.TH "ntfs_iget" 9 "ntfs_iget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_iget \-  obtain a struct inode corresponding to a specific normal inode
.SH SYNOPSIS
.B "struct inode *" ntfs_iget
.BI "(struct super_block *" sb ","
.BI "unsigned long " mft_no ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of mounted volume
.IP "mft_no" 12
	mft record number / inode number to obtain
.SH "DESCRIPTION"
Obtain the struct inode corresponding to a specific normal inode (i.e. a
file or directory).

If the inode is in the cache, it is just returned with an increased
reference count. Otherwise, a new struct inode is allocated and initialized,
and finally \fBntfs_read_locked_inode\fP is called to read in the inode and
fill in the remainder of the inode structure.

Return the struct inode on success. Check the return value with \fBIS_ERR\fP and
if true, the function failed and the error code is obtained from \fBPTR_ERR\fP.
.TH "ntfs_attr_iget" 9 "ntfs_attr_iget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_attr_iget \-  obtain a struct inode corresponding to an attribute
.SH SYNOPSIS
.B "struct inode *" ntfs_attr_iget
.BI "(struct inode *" base_vi ","
.BI "ATTR_TYPE " type ","
.BI "ntfschar *" name ","
.BI "u32 " name_len ");"
.SH ARGUMENTS
.IP "base_vi" 12
	vfs base inode containing the attribute
.IP "type" 12
	attribute type
.IP "name" 12
	Unicode name of the attribute (NULL if unnamed)
.IP "name_len" 12
	length of \fIname\fP in Unicode characters (0 if unnamed)
.SH "DESCRIPTION"
Obtain the (fake) struct inode corresponding to the attribute specified by
\fItype\fP, \fIname\fP, and \fIname_len\fP, which is present in the base mft record
specified by the vfs inode \fIbase_vi\fP.

If the attribute inode is in the cache, it is just returned with an
increased reference count. Otherwise, a new struct inode is allocated and
initialized, and finally \fBntfs_read_locked_attr_inode\fP is called to read the
attribute and fill in the inode structure.

Note, for index allocation attributes, you need to use \fBntfs_index_iget\fP
instead of \fBntfs_attr_iget\fP as working with indices is a lot more complex.

Return the struct inode of the attribute inode on success. Check the return
value with \fBIS_ERR\fP and if true, the function failed and the error code is
obtained from \fBPTR_ERR\fP.
.TH "ntfs_index_iget" 9 "ntfs_index_iget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_index_iget \-  obtain a struct inode corresponding to an index
.SH SYNOPSIS
.B "struct inode *" ntfs_index_iget
.BI "(struct inode *" base_vi ","
.BI "ntfschar *" name ","
.BI "u32 " name_len ");"
.SH ARGUMENTS
.IP "base_vi" 12
	vfs base inode containing the index related attributes
.IP "name" 12
	Unicode name of the index
.IP "name_len" 12
	length of \fIname\fP in Unicode characters
.SH "DESCRIPTION"
Obtain the (fake) struct inode corresponding to the index specified by \fIname\fP
and \fIname_len\fP, which is present in the base mft record specified by the vfs
inode \fIbase_vi\fP.

If the index inode is in the cache, it is just returned with an increased
reference count.  Otherwise, a new struct inode is allocated and
initialized, and finally \fBntfs_read_locked_index_inode\fP is called to read
the index related attributes and fill in the inode structure.

Return the struct inode of the index inode on success. Check the return
value with \fBIS_ERR\fP and if true, the function failed and the error code is
obtained from \fBPTR_ERR\fP.
.TH "__ntfs_init_inode" 9 "__ntfs_init_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntfs_init_inode \-  initialize ntfs specific part of an inode
.SH SYNOPSIS
.B "void" __ntfs_init_inode
.BI "(struct super_block *" sb ","
.BI "ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of mounted volume
.IP "ni" 12
		freshly allocated ntfs inode which to initialize
.SH "DESCRIPTION"
Initialize an ntfs inode to defaults.
.SH "NOTE"
 ni-&gt;mft_no, ni-&gt;state, ni-&gt;type, ni-&gt;name, and ni-&gt;name_len are left
untouched. Make sure to initialize them elsewhere.

Return zero on success and -ENOMEM on error.
.TH "ntfs_is_extended_system_file" 9 "ntfs_is_extended_system_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_is_extended_system_file \-  check if a file is in the $Extend directory
.SH SYNOPSIS
.B "int" ntfs_is_extended_system_file
.BI "(ntfs_attr_search_ctx *" ctx ");"
.SH ARGUMENTS
.IP "ctx" 12
	initialized attribute search context
.SH "DESCRIPTION"
Search all file name attributes in the inode described by the attribute
search context \fIctx\fP and check if any of the names are in the $Extend system
directory.
.SH "1"
 file is in $Extend directory
.SH "0"
 file is not in $Extend directory
-errno: failed to determine if the file is in the $Extend directory
.TH "ntfs_read_locked_inode" 9 "ntfs_read_locked_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_read_locked_inode \-  read an inode from its device
.SH SYNOPSIS
.B "int" ntfs_read_locked_inode
.BI "(struct inode *" vi ");"
.SH ARGUMENTS
.IP "vi" 12
		inode to read
.SH "DESCRIPTION"
\fBntfs_read_locked_inode\fP is called from \fBntfs_iget\fP to read the inode
described by \fIvi\fP into memory from the device.

The only fields in \fIvi\fP that we need to/can look at when the function is
called are i_sb, pointing to the mounted device's super block, and i_ino,
the number of the inode to load.

\fBntfs_read_locked_inode\fP maps, pins and locks the mft record number i_ino
for reading and sets up the necessary \fIvi\fP fields as well as initializing
the ntfs inode.
.SH "Q"
 What locks are held when the function is called?
.SH "A"
 i_state has I_LOCK set, hence the inode is locked, also
i_count is set to 1, so it is not going to go away
i_flags is set to 0 and we have no business touching it.  Only an \fBioctl\fP
is allowed to write to them. We should of course be honouring them but
we need to do that using the IS_* macros defined in include/linux/fs.h.
In any case \fBntfs_read_locked_inode\fP has nothing to do with i_flags.

Return 0 on success and -errno on error.  In the error case, the inode will
have had \fBmake_bad_inode\fP executed on it.
.TH "ntfs_read_locked_attr_inode" 9 "ntfs_read_locked_attr_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_read_locked_attr_inode \-  read an attribute inode from its base inode
.SH SYNOPSIS
.B "int" ntfs_read_locked_attr_inode
.BI "(struct inode *" base_vi ","
.BI "struct inode *" vi ");"
.SH ARGUMENTS
.IP "base_vi" 12
	base inode
.IP "vi" 12
		attribute inode to read
.SH "DESCRIPTION"
\fBntfs_read_locked_attr_inode\fP is called from \fBntfs_attr_iget\fP to read the
attribute inode described by \fIvi\fP into memory from the base mft record
described by \fIbase_ni\fP.

\fBntfs_read_locked_attr_inode\fP maps, pins and locks the base inode for
reading and looks up the attribute described by \fIvi\fP before setting up the
necessary fields in \fIvi\fP as well as initializing the ntfs inode.
.SH "Q"
 What locks are held when the function is called?
.SH "A"
 i_state has I_LOCK set, hence the inode is locked, also
i_count is set to 1, so it is not going to go away

Return 0 on success and -errno on error.  In the error case, the inode will
have had \fBmake_bad_inode\fP executed on it.

Note this cannot be called for AT_INDEX_ALLOCATION.
.TH "ntfs_read_locked_index_inode" 9 "ntfs_read_locked_index_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_read_locked_index_inode \-  read an index inode from its base inode
.SH SYNOPSIS
.B "int" ntfs_read_locked_index_inode
.BI "(struct inode *" base_vi ","
.BI "struct inode *" vi ");"
.SH ARGUMENTS
.IP "base_vi" 12
	base inode
.IP "vi" 12
		index inode to read
.SH "DESCRIPTION"
\fBntfs_read_locked_index_inode\fP is called from \fBntfs_index_iget\fP to read the
index inode described by \fIvi\fP into memory from the base mft record described
by \fIbase_ni\fP.

\fBntfs_read_locked_index_inode\fP maps, pins and locks the base inode for
reading and looks up the attributes relating to the index described by \fIvi\fP
before setting up the necessary fields in \fIvi\fP as well as initializing the
ntfs inode.

Note, index inodes are essentially attribute inodes (\fBNInoAttr\fP is true)
with the attribute type set to AT_INDEX_ALLOCATION.  Apart from that, they
are setup like directory inodes since directories are a special case of
indices ao they need to be treated in much the same way.  Most importantly,
for small indices the index allocation attribute might not actually exist.
However, the index root attribute always exists but this does not need to
have an inode associated with it and this is why we define a new inode type
index.  Also, like for directories, we need to have an attribute inode for
the bitmap attribute corresponding to the index allocation attribute and we
can store this in the appropriate field of the inode, just like we do for
normal directory inodes.
.SH "Q"
 What locks are held when the function is called?
.SH "A"
 i_state has I_LOCK set, hence the inode is locked, also
i_count is set to 1, so it is not going to go away

Return 0 on success and -errno on error.  In the error case, the inode will
have had \fBmake_bad_inode\fP executed on it.
.TH "ntfs_read_inode_mount" 9 "ntfs_read_inode_mount" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_read_inode_mount \-  special read_inode for mount time use only
.SH SYNOPSIS
.B "int" ntfs_read_inode_mount
.BI "(struct inode *" vi ");"
.SH ARGUMENTS
.IP "vi" 12
		inode to read
.SH "DESCRIPTION"
Read inode FILE_MFT at mount time, only called with super_block lock
held from within the \fBread_super\fP code path.

This function exists because when it is called the page cache for $MFT/$DATA
is not initialized and hence we cannot get at the contents of mft records
by calling map_mft_record*().

Further it needs to cope with the circular references problem, i.e. cannot
load any attributes other than $ATTRIBUTE_LIST until $DATA is loaded, because
we do not know where the other extent mft records are yet and again, because
we cannot call map_mft_record*() yet.  Obviously this applies only when an
attribute list is actually present in $MFT inode.

We solve these problems by starting with the $DATA attribute before anything
else and iterating using ntfs_attr_lookup($DATA) over all extents.  As each
extent is found, we \fBntfs_mapping_pairs_decompress\fP including the implied
\fBntfs_runlists_merge\fP.  Each step of the iteration necessarily provides
sufficient information for the next step to complete.

This should work but there are two possible pit falls (see inline comments
below), but only time will tell if they are real pits or just smoke...
.TH "ntfs_put_inode" 9 "ntfs_put_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_put_inode \-  handler for when the inode reference count is decremented
.SH SYNOPSIS
.B "void" ntfs_put_inode
.BI "(struct inode *" vi ");"
.SH ARGUMENTS
.IP "vi" 12
		vfs inode
.SH "DESCRIPTION"
The VFS calls \fBntfs_put_inode\fP every time the inode reference count (i_count)
is about to be decremented (but before the decrement itself.

If the inode \fIvi\fP is a directory with two references, one of which is being
dropped, we need to put the attribute inode for the directory index bitmap,
if it is present, otherwise the directory inode would remain pinned for
ever.
.TH "ntfs_clear_big_inode" 9 "ntfs_clear_big_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_clear_big_inode \-  clean up the ntfs specific part of an inode
.SH SYNOPSIS
.B "void" ntfs_clear_big_inode
.BI "(struct inode *" vi ");"
.SH ARGUMENTS
.IP "vi" 12
		vfs inode pending annihilation
.SH "DESCRIPTION"
When the VFS is going to remove an inode from memory, \fBntfs_clear_big_inode\fP
is called, which deallocates all memory belonging to the NTFS specific part
of the inode and returns.

If the MFT record is dirty, we commit it before doing anything else.
.TH "ntfs_show_options" 9 "ntfs_show_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_show_options \-  show mount options in /proc/mounts
.SH SYNOPSIS
.B "int" ntfs_show_options
.BI "(struct seq_file *" sf ","
.BI "struct vfsmount *" mnt ");"
.SH ARGUMENTS
.IP "sf" 12
		seq_file in which to write our mount options
.IP "mnt" 12
	vfs mount whose mount options to display
.SH "DESCRIPTION"
Called by the VFS once for each mounted ntfs volume when someone reads
/proc/mounts in order to display the NTFS specific mount options of each
mount. The mount options of the vfs mount \fImnt\fP are written to the seq file
\fIsf\fP and success is returned.
.TH "ntfs_truncate" 9 "ntfs_truncate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_truncate \-  called when the i_size of an ntfs inode is changed
.SH SYNOPSIS
.B "int" ntfs_truncate
.BI "(struct inode *" vi ");"
.SH ARGUMENTS
.IP "vi" 12
		inode for which the i_size was changed
.SH "DESCRIPTION"
We do not support i_size changes yet.

The kernel guarantees that \fIvi\fP is a regular file (\fBS_ISREG\fP is true) and
that the change is allowed.

This implies for us that \fIvi\fP is a file inode rather than a directory, index,
or attribute inode as well as that \fIvi\fP is a base inode.

Returns 0 on success or -errno on error.

Called with -&gt;i_sem held.  In all but one case -&gt;i_alloc_sem is held for
writing.  The only case where -&gt;i_alloc_sem is not held is
mm/filemap.c::\fBgeneric_file_buffered_write\fP where \fBvmtruncate\fP is called
with the current i_size as the offset which means that it is a noop as far
as \fBntfs_truncate\fP is concerned.
.TH "ntfs_truncate_vfs" 9 "ntfs_truncate_vfs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_truncate_vfs \-  wrapper for ntfs_truncate() that has no return value
.SH SYNOPSIS
.B "void" ntfs_truncate_vfs
.BI "(struct inode *" vi ");"
.SH ARGUMENTS
.IP "vi" 12
		inode for which the i_size was changed
.SH "DESCRIPTION"
Wrapper for \fBntfs_truncate\fP that has no return value.

See \fBntfs_truncate\fP description above for details.
.TH "ntfs_setattr" 9 "ntfs_setattr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_setattr \-  called from notify_change() when an attribute is being changed
.SH SYNOPSIS
.B "int" ntfs_setattr
.BI "(struct dentry *" dentry ","
.BI "struct iattr *" attr ");"
.SH ARGUMENTS
.IP "dentry" 12
	dentry whose attributes to change
.IP "attr" 12
	structure describing the attributes and the changes
.SH "DESCRIPTION"
We have to trap VFS attempts to truncate the file described by \fIdentry\fP as
soon as possible, because we do not implement changes in i_size yet.  So we
abort all i_size changes here.

We also abort all changes of user, group, and mode as we do not implement
the NTFS ACLs yet.

Called with -&gt;i_sem held.  For the ATTR_SIZE (i.e. -&gt;truncate) case, also
called with -&gt;i_alloc_sem held for writing.

Basically this is a copy of generic \fBnotify_change\fP and \fBinode_setattr\fP
functionality, except we intercept and abort changes in i_size.
.TH "ntfs_write_inode" 9 "ntfs_write_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_write_inode \-  write out a dirty inode
.SH SYNOPSIS
.B "int" ntfs_write_inode
.BI "(struct inode *" vi ","
.BI "int " sync ");"
.SH ARGUMENTS
.IP "vi" 12
		inode to write out
.IP "sync" 12
	if true, write out synchronously
.SH "DESCRIPTION"
Write out a dirty inode to disk including any extent inodes if present.

If \fIsync\fP is true, commit the inode to disk and wait for io completion.  This
is done using \fBwrite_mft_record\fP.

If \fIsync\fP is false, just schedule the write to happen but do not wait for i/o
completion.  In 2.6 kernels, scheduling usually happens just by virtue of
marking the page (and in this case mft record) dirty but we do not implement
this yet as \fBwrite_mft_record\fP largely ignores the \fIsync\fP parameter and
always performs synchronous writes.

Return 0 on success and -errno on error.
.TH "map_mft_record_page" 9 "map_mft_record_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
map_mft_record_page \-  NTFS kernel mft record operations. Part of the Linux-NTFS project.
.SH SYNOPSIS
.B "MFT_RECORD *" map_mft_record_page
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
-- undescribed --
.SH "DESCRIPTION"

Copyright (c) 2001-2005 Anton Altaparmakov
Copyright (c) 2002 Richard Russon

This program/include file is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program/include file is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (in the main directory of the Linux-NTFS
distribution in the file COPYING); if not, write to the Free Software
Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
.TH "map_mft_record" 9 "map_mft_record" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
map_mft_record \-  map, pin and lock an mft record
.SH SYNOPSIS
.B "MFT_RECORD *" map_mft_record
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode whose MFT record to map
.SH "DESCRIPTION"
First, take the mrec_lock semaphore. We might now be sleeping, while waiting
for the semaphore if it was already locked by someone else.

The page of the record is mapped using \fBmap_mft_record_page\fP before being
returned to the caller.

This in turn uses \fBntfs_map_page\fP to get the page containing the wanted mft
record (it in turn calls \fBread_cache_page\fP which reads it in from disk if
necessary, increments the use count on the page so that it cannot disappear
under us and returns a reference to the page cache page).

If \fBread_cache_page\fP invokes \fBntfs_readpage\fP to load the page from disk, it
sets PG_locked and clears PG_uptodate on the page. Once I/O has completed
and the post-read mst fixups on each mft record in the page have been
performed, the page gets PG_uptodate set and PG_locked cleared (this is done
in our asynchronous I/O completion handler \fBend_buffer_read_mft_async\fP).
\fBntfs_map_page\fP waits for PG_locked to become clear and checks if
PG_uptodate is set and returns an error code if not. This provides
sufficient protection against races when reading/using the page.

However there is the write mapping to think about. Doing the above described
checking here will be fine, because when initiating the write we will set
PG_locked and clear PG_uptodate making sure nobody is touching the page
contents. Doing the locking this way means that the commit to disk code in
the page cache code paths is automatically sufficiently locked with us as
we will not touch a page that has been locked or is not uptodate. The only
locking problem then is them locking the page while we are accessing it.

So that code will end up having to own the mrec_lock of all mft
records/inodes present in the page before I/O can proceed. In that case we
wouldn't need to bother with PG_locked and PG_uptodate as nobody will be
accessing anything without owning the mrec_lock semaphore. But we do need
to use them because of the \fBread_cache_page\fP invocation and the code becomes
so much simpler this way that it is well worth it.

The mft record is now ours and we return a pointer to it. You need to check
the returned pointer with \fBIS_ERR\fP and if that is true, \fBPTR_ERR\fP will return
the error code.
.SH "NOTE"
 Caller is responsible for setting the mft record dirty before calling
\fBunmap_mft_record\fP. This is obviously only necessary if the caller really
modified the mft record...
.SH "Q"
 Do we want to recycle one of the VFS inode state bits instead?
.SH "A"
 No, the inode ones mean we want to change the mft record, not we want to
write it out.
.TH "unmap_mft_record_page" 9 "unmap_mft_record_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unmap_mft_record_page \-  unmap the page in which a specific mft record resides
.SH SYNOPSIS
.B "void" unmap_mft_record_page
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode whose mft record page to unmap
.SH "DESCRIPTION"
This unmaps the page in which the mft record of the ntfs inode \fIni\fP is
situated and returns. This is a NOOP if highmem is not configured.

The unmap happens via \fBntfs_unmap_page\fP which in turn decrements the use
count on the page thus releasing it from the pinned state.

We do not actually unmap the page from memory of course, as that will be
done by the page cache code itself when memory pressure increases or
whatever.
.TH "unmap_mft_record" 9 "unmap_mft_record" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unmap_mft_record \-  release a mapped mft record
.SH SYNOPSIS
.B "void" unmap_mft_record
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode whose MFT record to unmap
.SH "DESCRIPTION"
We release the page mapping and the mrec_lock mutex which unmaps the mft
record and releases it for others to get hold of. We also release the ntfs
inode by decrementing the ntfs inode reference count.
.SH "NOTE"
 If caller has modified the mft record, it is imperative to set the mft
record dirty BEFORE calling \fBunmap_mft_record\fP.
.TH "map_extent_mft_record" 9 "map_extent_mft_record" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
map_extent_mft_record \-  load an extent inode and attach it to its base
.SH SYNOPSIS
.B "MFT_RECORD *" map_extent_mft_record
.BI "(ntfs_inode *" base_ni ","
.BI "MFT_REF " mref ","
.BI "ntfs_inode **" ntfs_ino ");"
.SH ARGUMENTS
.IP "base_ni" 12
	base ntfs inode
.IP "mref" 12
	mft reference of the extent inode to load
.IP "ntfs_ino" 12
	on successful return, pointer to the ntfs_inode structure
.SH "DESCRIPTION"
Load the extent mft record \fImref\fP and attach it to its base inode \fIbase_ni\fP.
Return the mapped extent mft record if IS_ERR(result) is false.  Otherwise
PTR_ERR(result) gives the negative error code.

On successful return, \fIntfs_ino\fP contains a pointer to the ntfs_inode
structure of the mapped extent inode.
.TH "__mark_mft_record_dirty" 9 "__mark_mft_record_dirty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__mark_mft_record_dirty \-  set the mft record and the page containing it dirty
.SH SYNOPSIS
.B "void" __mark_mft_record_dirty
.BI "(ntfs_inode *" ni ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode describing the mapped mft record
.SH "DESCRIPTION"
Internal function.  Users should call \fBmark_mft_record_dirty\fP instead.

Set the mapped (extent) mft record of the (base or extent) ntfs inode \fIni\fP,
as well as the page containing the mft record, dirty.  Also, mark the base
vfs inode dirty.  This ensures that any changes to the mft record are
written out to disk.
.SH "NOTE"
  We only set I_DIRTY_SYNC and I_DIRTY_DATASYNC (and not I_DIRTY_PAGES)
on the base vfs inode, because even though file data may have been modified,
it is dirty in the inode meta data rather than the data page cache of the
inode, and thus there are no data pages that need writing out.  Therefore, a
full \fBmark_inode_dirty\fP is overkill.  A \fBmark_inode_dirty_sync\fP, on the
other hand, is not sufficient, because I_DIRTY_DATASYNC needs to be set to
ensure -&gt;write_inode is called from \fBgeneric_osync_inode\fP and this needs to
happen or the file data would not necessarily hit the device synchronously,
even though the vfs inode has the O_SYNC flag set.  Also, I_DIRTY_DATASYNC
simply "feels" better than just I_DIRTY_SYNC, since the file data has not
actually hit the block device yet, which is not what I_DIRTY_SYNC on its own
would suggest.
.TH "ntfs_sync_mft_mirror_umount" 9 "ntfs_sync_mft_mirror_umount" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_sync_mft_mirror_umount \-  synchronise an mft record to the mft mirror
.SH SYNOPSIS
.B "int" ntfs_sync_mft_mirror_umount
.BI "(ntfs_volume *" vol ","
.BI "const unsigned long " mft_no ","
.BI "MFT_RECORD *" m ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume on which the mft record to synchronize resides
.IP "mft_no" 12
	mft record number of mft record to synchronize
.IP "m" 12
		mapped, mst protected (extent) mft record to synchronize
.SH "DESCRIPTION"
Write the mapped, mst protected (extent) mft record \fIm\fP with mft record
number \fImft_no\fP to the mft mirror ($MFTMirr) of the ntfs volume \fIvol\fP,
bypassing the page cache and the $MFTMirr inode itself.

This function is only for use at umount time when the mft mirror inode has
already been disposed off.  We \fBBUG\fP if we are called while the mft mirror
inode is still attached to the volume.

On success return 0.  On error return -errno.
.SH "NOTE"
  This function is not implemented yet as I am not convinced it can
actually be triggered considering the sequence of commits we do in super.c::
\fBntfs_put_super\fP.  But just in case we provide this place holder as the
alternative would be either to \fBBUG\fP or to get a NULL pointer dereference
and Oops.
.TH "ntfs_sync_mft_mirror" 9 "ntfs_sync_mft_mirror" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_sync_mft_mirror \-  synchronize an mft record to the mft mirror
.SH SYNOPSIS
.B "int" ntfs_sync_mft_mirror
.BI "(ntfs_volume *" vol ","
.BI "const unsigned long " mft_no ","
.BI "MFT_RECORD *" m ","
.BI "int " sync ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume on which the mft record to synchronize resides
.IP "mft_no" 12
	mft record number of mft record to synchronize
.IP "m" 12
		mapped, mst protected (extent) mft record to synchronize
.IP "sync" 12
	if true, wait for i/o completion
.SH "DESCRIPTION"
Write the mapped, mst protected (extent) mft record \fIm\fP with mft record
number \fImft_no\fP to the mft mirror ($MFTMirr) of the ntfs volume \fIvol\fP.

On success return 0.  On error return -errno and set the volume errors flag
in the ntfs volume \fIvol\fP.
.SH "NOTE"
  We always perform synchronous i/o and ignore the \fIsync\fP parameter.
.SH "TODO"
  If \fIsync\fP is false, want to do truly asynchronous i/o, i.e. just
schedule i/o via -&gt;writepage or do it via kntfsd or whatever.
.TH "write_mft_record_nolock" 9 "write_mft_record_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_mft_record_nolock \-  write out a mapped (extent) mft record
.SH SYNOPSIS
.B "int" write_mft_record_nolock
.BI "(ntfs_inode *" ni ","
.BI "MFT_RECORD *" m ","
.BI "int " sync ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode describing the mapped (extent) mft record
.IP "m" 12
		mapped (extent) mft record to write
.IP "sync" 12
	if true, wait for i/o completion
.SH "DESCRIPTION"
Write the mapped (extent) mft record \fIm\fP described by the (regular or extent)
ntfs inode \fIni\fP to backing store.  If the mft record \fIm\fP has a counterpart in
the mft mirror, that is also updated.

We only write the mft record if the ntfs inode \fIni\fP is dirty and the first
buffer belonging to its mft record is dirty, too.  We ignore the dirty state
of subsequent buffers because we could have raced with
fs/ntfs/aops.c::\fBmark_ntfs_record_dirty\fP.

On success, clean the mft record and return 0.  On error, leave the mft
record dirty and return -errno.  The caller should call \fBmake_bad_inode\fP on
the base inode to ensure no more access happens to this inode.  We do not do
it here as the caller may want to finish writing other extent mft records
first to minimize on-disk metadata inconsistencies.
.SH "NOTE"
  We always perform synchronous i/o and ignore the \fIsync\fP parameter.
However, if the mft record has a counterpart in the mft mirror and \fIsync\fP is
true, we write the mft record, wait for i/o completion, and only then write
the mft mirror copy.  This ensures that if the system crashes either the mft
or the mft mirror will contain a self-consistent mft record \fIm\fP.  If \fIsync\fP is
false on the other hand, we start i/o on both and then wait for completion
on them.  This provides a speedup but no longer guarantees that you will end
up with a self-consistent mft record in the case of a crash but if you asked
for asynchronous writing you probably do not care about that anyway.
.SH "TODO"
  If \fIsync\fP is false, want to do truly asynchronous i/o, i.e. just
schedule i/o via -&gt;writepage or do it via kntfsd or whatever.
.TH "ntfs_may_write_mft_record" 9 "ntfs_may_write_mft_record" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_may_write_mft_record \-  check if an mft record may be written out
.SH SYNOPSIS
.B "BOOL" ntfs_may_write_mft_record
.BI "(ntfs_volume *" vol ","
.BI "const unsigned long " mft_no ","
.BI "const MFT_RECORD *" m ","
.BI "ntfs_inode **" locked_ni ");"
.SH ARGUMENTS
.IP "vol" 12
	[IN]  ntfs volume on which the mft record to check resides
.IP "mft_no" 12
	[IN]  mft record number of the mft record to check
.IP "m" 12
		[IN]  mapped mft record to check
.IP "locked_ni" 12
	[OUT] caller has to unlock this ntfs inode if one is returned
.SH "DESCRIPTION"
Check if the mapped (base or extent) mft record \fIm\fP with mft record number
\fImft_no\fP belonging to the ntfs volume \fIvol\fP may be written out.  If necessary
and possible the ntfs inode of the mft record is locked and the base vfs
inode is pinned.  The locked ntfs inode is then returned in \fIlocked_ni\fP.  The
caller is responsible for unlocking the ntfs inode and unpinning the base
vfs inode.

Return TRUE if the mft record may be written out and FALSE if not.

The caller has locked the page and cleared the uptodate flag on it which
means that we can safely write out any dirty mft records that do not have
their inodes in icache as determined by \fBilookup5\fP as anyone
opening/creating such an inode would block when attempting to map the mft
record in \fBread_cache_page\fP until we are finished with the write out.
.SH "HERE IS A DESCRIPTION OF THE TESTS WE PERFORM"

If the inode is found in icache we know the mft record must be a base mft
record.  If it is dirty, we do not write it and return FALSE as the vfs
inode write paths will result in the access times being updated which would
cause the base mft record to be redirtied and written out again.  (We know
the access time update will modify the base mft record because Windows
chkdsk complains if the standard information attribute is not in the base
mft record.)

If the inode is in icache and not dirty, we attempt to lock the mft record
and if we find the lock was already taken, it is not safe to write the mft
record and we return FALSE.

If we manage to obtain the lock we have exclusive access to the mft record,
which also allows us safe writeout of the mft record.  We then set
\fIlocked_ni\fP to the locked ntfs inode and return TRUE.

Note we cannot just lock the mft record and sleep while waiting for the lock
because this would deadlock due to lock reversal (normally the mft record is
locked before the page is locked but we already have the page locked here
when we try to lock the mft record).

If the inode is not in icache we need to perform further checks.

If the mft record is not a FILE record or it is a base mft record, we can
safely write it and return TRUE.

We now know the mft record is an extent mft record.  We check if the inode
corresponding to its base mft record is in icache and obtain a reference to
it if it is.  If it is not, we can safely write it and return TRUE.

We now have the base inode for the extent mft record.  We check if it has an
ntfs inode for the extent mft record attached and if not it is safe to write
the extent mft record and we return TRUE.

The ntfs inode for the extent mft record is attached to the base inode so we
attempt to lock the extent mft record and if we find the lock was already
taken, it is not safe to write the extent mft record and we return FALSE.

If we manage to obtain the lock we have exclusive access to the extent mft
record, which also allows us safe writeout of the extent mft record.  We
set the ntfs inode of the extent mft record clean and then set \fIlocked_ni\fP to
the now locked ntfs inode and return TRUE.

Note, the reason for actually writing dirty mft records here and not just
relying on the vfs inode dirty code paths is that we can have mft records
modified without them ever having actual inodes in memory.  Also we can have
dirty mft records with clean ntfs inodes in memory.  None of the described
cases would result in the dirty mft records being written out if we only
relied on the vfs inode dirty code paths.  And these cases can really occur
during allocation of new mft records and in particular when the
initialized_size of the $MFT/$DATA attribute is extended and the new space
is initialized using \fBntfs_mft_record_format\fP.  The clean inode can then
appear if the mft record is reused for a new inode before it got written
out.
.TH "ntfs_mft_bitmap_find_and_alloc_free_rec_nolock" 9 "ntfs_mft_bitmap_find_and_alloc_free_rec_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mft_bitmap_find_and_alloc_free_rec_nolock \-  see name
.SH SYNOPSIS
.B "int" ntfs_mft_bitmap_find_and_alloc_free_rec_nolock
.BI "(ntfs_volume *" vol ","
.BI "ntfs_inode *" base_ni ");"
.SH ARGUMENTS
.IP "vol" 12
	volume on which to search for a free mft record
.IP "base_ni" 12
	open base inode if allocating an extent mft record or NULL
.SH "DESCRIPTION"
Search for a free mft record in the mft bitmap attribute on the ntfs volume
\fIvol\fP.

If \fIbase_ni\fP is NULL start the search at the default allocator position.

If \fIbase_ni\fP is not NULL start the search at the mft record after the base
mft record \fIbase_ni\fP.

Return the free mft record on success and -errno on error.  An error code of
-ENOSPC means that there are no free mft records in the currently
initialized mft bitmap.
.SH "LOCKING"
 Caller must hold vol-&gt;mftbmp_lock for writing.
.TH "ntfs_mft_bitmap_extend_allocation_nolock" 9 "ntfs_mft_bitmap_extend_allocation_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mft_bitmap_extend_allocation_nolock \-  extend mft bitmap by a cluster
.SH SYNOPSIS
.B "int" ntfs_mft_bitmap_extend_allocation_nolock
.BI "(ntfs_volume *" vol ");"
.SH ARGUMENTS
.IP "vol" 12
	volume on which to extend the mft bitmap attribute
.SH "DESCRIPTION"
Extend the mft bitmap attribute on the ntfs volume \fIvol\fP by one cluster.
.SH "NOTE"
 Only changes allocated_size, i.e. does not touch initialized_size or
data_size.

Return 0 on success and -errno on error.
.SH "LOCKING"
 - Caller must hold vol-&gt;mftbmp_lock for writing.
- This function takes NTFS_I(vol-&gt;mftbmp_ino)-&gt;runlist.lock for
writing and releases it before returning.
- This function takes vol-&gt;lcnbmp_lock for writing and releases it
before returning.
.TH "ntfs_mft_bitmap_extend_initialized_nolock" 9 "ntfs_mft_bitmap_extend_initialized_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mft_bitmap_extend_initialized_nolock \-  extend mftbmp initialized data
.SH SYNOPSIS
.B "int" ntfs_mft_bitmap_extend_initialized_nolock
.BI "(ntfs_volume *" vol ");"
.SH ARGUMENTS
.IP "vol" 12
	volume on which to extend the mft bitmap attribute
.SH "DESCRIPTION"
Extend the initialized portion of the mft bitmap attribute on the ntfs
volume \fIvol\fP by 8 bytes.
.SH "NOTE"
  Only changes initialized_size and data_size, i.e. requires that
allocated_size is big enough to fit the new initialized_size.

Return 0 on success and -error on error.
.SH "LOCKING"
 Caller must hold vol-&gt;mftbmp_lock for writing.
.TH "ntfs_mft_data_extend_allocation_nolock" 9 "ntfs_mft_data_extend_allocation_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mft_data_extend_allocation_nolock \-  extend mft data attribute
.SH SYNOPSIS
.B "int" ntfs_mft_data_extend_allocation_nolock
.BI "(ntfs_volume *" vol ");"
.SH ARGUMENTS
.IP "vol" 12
	volume on which to extend the mft data attribute
.SH "DESCRIPTION"
Extend the mft data attribute on the ntfs volume \fIvol\fP by 16 mft records
worth of clusters or if not enough space for this by one mft record worth
of clusters.
.SH "NOTE"
  Only changes allocated_size, i.e. does not touch initialized_size or
data_size.

Return 0 on success and -errno on error.
.SH "LOCKING"
 - Caller must hold vol-&gt;mftbmp_lock for writing.
- This function takes NTFS_I(vol-&gt;mft_ino)-&gt;runlist.lock for
writing and releases it before returning.
- This function calls functions which take vol-&gt;lcnbmp_lock for
writing and release it before returning.
.TH "ntfs_mft_record_layout" 9 "ntfs_mft_record_layout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mft_record_layout \-  layout an mft record into a memory buffer
.SH SYNOPSIS
.B "int" ntfs_mft_record_layout
.BI "(const ntfs_volume *" vol ","
.BI "const s64 " mft_no ","
.BI "MFT_RECORD *" m ");"
.SH ARGUMENTS
.IP "vol" 12
	volume to which the mft record will belong
.IP "mft_no" 12
	mft reference specifying the mft record number
.IP "m" 12
		destination buffer of size &gt;= \fIvol\fP-&gt;mft_record_size bytes
.SH "DESCRIPTION"
Layout an empty, unused mft record with the mft record number \fImft_no\fP into
the buffer \fIm\fP.  The volume \fIvol\fP is needed because the mft record structure
was modified in NTFS 3.1 so we need to know which volume version this mft
record will be used on.

Return 0 on success and -errno on error.
.TH "ntfs_mft_record_format" 9 "ntfs_mft_record_format" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mft_record_format \-  format an mft record on an ntfs volume
.SH SYNOPSIS
.B "int" ntfs_mft_record_format
.BI "(const ntfs_volume *" vol ","
.BI "const s64 " mft_no ");"
.SH ARGUMENTS
.IP "vol" 12
	volume on which to format the mft record
.IP "mft_no" 12
	mft record number to format
.SH "DESCRIPTION"
Format the mft record \fImft_no\fP in $MFT/$DATA, i.e. lay out an empty, unused
mft record into the appropriate place of the mft data attribute.  This is
used when extending the mft data attribute.

Return 0 on success and -errno on error.
.TH "ntfs_mft_record_alloc" 9 "ntfs_mft_record_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_mft_record_alloc \-  allocate an mft record on an ntfs volume
.SH SYNOPSIS
.B "ntfs_inode *" ntfs_mft_record_alloc
.BI "(ntfs_volume *" vol ","
.BI "const int " mode ","
.BI "ntfs_inode *" base_ni ","
.BI "MFT_RECORD **" mrec ");"
.SH ARGUMENTS
.IP "vol" 12
	[IN]  volume on which to allocate the mft record
.IP "mode" 12
	[IN]  mode if want a file or directory, i.e. base inode or 0
.IP "base_ni" 12
	[IN]  open base inode if allocating an extent mft record or NULL
.IP "mrec" 12
	[OUT] on successful return this is the mapped mft record
.SH "DESCRIPTION"
Allocate an mft record in $MFT/$DATA of an open ntfs volume \fIvol\fP.

If \fIbase_ni\fP is NULL make the mft record a base mft record, i.e. a file or
direvctory inode, and allocate it at the default allocator position.  In
this case \fImode\fP is the file mode as given to us by the caller.  We in
particular use \fImode\fP to distinguish whether a file or a directory is being
created (S_IFDIR(mode) and S_IFREG(mode), respectively).

If \fIbase_ni\fP is not NULL make the allocated mft record an extent record,
allocate it starting at the mft record after the base mft record and attach
the allocated and opened ntfs inode to the base inode \fIbase_ni\fP.  In this
case \fImode\fP must be 0 as it is meaningless for extent inodes.

You need to check the return value with \fBIS_ERR\fP.  If false, the function
was successful and the return value is the now opened ntfs inode of the
allocated mft record.  *\fImrec\fP is then set to the allocated, mapped, pinned,
and locked mft record.  If \fBIS_ERR\fP is true, the function failed and the
error code is obtained from PTR_ERR(return value).  *\fImrec\fP is undefined in
this case.
.SH "ALLOCATION STRATEGY"

To find a free mft record, we scan the mft bitmap for a zero bit.  To
optimize this we start scanning at the place specified by \fIbase_ni\fP or if
\fIbase_ni\fP is NULL we start where we last stopped and we perform wrap around
when we reach the end.  Note, we do not try to allocate mft records below
number 24 because numbers 0 to 15 are the defined system files anyway and 16
to 24 are special in that they are used for storing extension mft records
for the $DATA attribute of $MFT.  This is required to avoid the possibility
of creating a runlist with a circular dependency which once written to disk
can never be read in again.  Windows will only use records 16 to 24 for
normal files if the volume is completely out of space.  We never use them
which means that when the volume is really out of space we cannot create any
more files while Windows can still create up to 8 small files.  We can start
doing this at some later time, it does not matter much for now.

When scanning the mft bitmap, we only search up to the last allocated mft
record.  If there are no free records left in the range 24 to number of
allocated mft records, then we extend the $MFT/$DATA attribute in order to
create free mft records.  We extend the allocated size of $MFT/$DATA by 16
records at a time or one cluster, if cluster size is above 16kiB.  If there
is not sufficient space to do this, we try to extend by a single mft record
or one cluster, if cluster size is above the mft record size.

No matter how many mft records we allocate, we initialize only the first
allocated mft record, incrementing mft data size and initialized size
accordingly, open an ntfs_inode for it and return it to the caller, unless
there are less than 24 mft records, in which case we allocate and initialize
mft records until we reach record 24 which we consider as the first free mft
record for use by normal files.

If during any stage we overflow the initialized data in the mft bitmap, we
extend the initialized size (and data size) by 8 bytes, allocating another
cluster if required.  The bitmap data size has to be at least equal to the
number of mft records in the mft, but it can be bigger, in which case the
superflous bits are padded with zeroes.

Thus, when we return successfully (\fBIS_ERR\fP is false), we will have:
- initialized / extended the mft bitmap if necessary,
- initialized / extended the mft data if necessary,
- set the bit corresponding to the mft record being allocated in the
mft bitmap,
- opened an ntfs_inode for the allocated mft record, and we will have
- returned the ntfs_inode as well as the allocated mapped, pinned, and
locked mft record.

On error, the volume will be left in a consistent state and no record will
be allocated.  If rolling back a partial operation fails, we may leave some
inconsistent metadata in which case we set \fBNVolErrors\fP so the volume is
left dirty when unmounted.

Note, this function cannot make use of most of the normal functions, like
for example for attribute resizing, etc, because when the run list overflows
the base mft record and an attribute list is used, it is very important that
the extension mft records used to store the $DATA attribute of $MFT can be
reached without having to read the information contained inside them, as
this would make it impossible to find them in the first place after the
volume is unmounted.  $MFT/$BITMAP probably does not need to follow this
rule because the bitmap is not essential for finding the mft records, but on
the other hand, handling the bitmap in this special way would make life
easier because otherwise there might be circular invocations of functions
when reading the bitmap.
.TH "ntfs_extent_mft_record_free" 9 "ntfs_extent_mft_record_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_extent_mft_record_free \-  free an extent mft record on an ntfs volume
.SH SYNOPSIS
.B "int" ntfs_extent_mft_record_free
.BI "(ntfs_inode *" ni ","
.BI "MFT_RECORD *" m ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode of the mapped extent mft record to free
.IP "m" 12
		mapped extent mft record of the ntfs inode \fIni\fP
.SH "DESCRIPTION"
Free the mapped extent mft record \fIm\fP of the extent ntfs inode \fIni\fP.

Note that this function unmaps the mft record and closes and destroys \fIni\fP
internally and hence you cannot use either \fIni\fP nor \fIm\fP any more after this
function returns success.

On success return 0 and on error return -errno.  \fIni\fP and \fIm\fP are still valid
in this case and have not been freed.

For some errors an error message is displayed and the success code 0 is
returned and the volume is then left dirty on umount.  This makes sense in
case we could not rollback the changes that were already done since the
caller no longer wants to reference this mft record so it does not matter to
the caller if something is wrong with it as long as it is properly detached
from the base inode.
.TH "ntfs_collate" 9 "ntfs_collate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_collate \-  collate two data items using a specified collation rule
.SH SYNOPSIS
.B "int" ntfs_collate
.BI "(ntfs_volume *" vol ","
.BI "COLLATION_RULE " cr ","
.BI "const void *" data1 ","
.BI "const int " data1_len ","
.BI "const void *" data2 ","
.BI "const int " data2_len ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume to which the data items belong
.IP "cr" 12
		collation rule to use when comparing the items
.IP "data1" 12
	first data item to collate
.IP "data1_len" 12
	length in bytes of \fIdata1\fP
.IP "data2" 12
	second data item to collate
.IP "data2_len" 12
	length in bytes of \fIdata2\fP
.SH "DESCRIPTION"
Collate the two data items \fIdata1\fP and \fIdata2\fP using the collation rule \fIcr\fP
and return -1, 0, ir 1 if \fIdata1\fP is found, respectively, to collate before,
to match, or to collate after \fIdata2\fP.

For speed we use the collation rule \fIcr\fP as an index into two tables of
function pointers to call the appropriate collation function.
.TH "__ntfs_malloc" 9 "__ntfs_malloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntfs_malloc \-  allocate memory in multiples of pages
.SH SYNOPSIS
.B "void *" __ntfs_malloc
.BI "(unsigned long " size ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "size" 12
	number of bytes to allocate
.IP "gfp_mask" 12
	extra flags for the allocator
.SH "DESCRIPTION"
Internal function.  You probably want \fBntfs_malloc_nofs\fP...

Allocates \fIsize\fP bytes of memory, rounded up to multiples of PAGE_SIZE and
returns a pointer to the allocated memory.

If there was insufficient memory to complete the request, return NULL.
Depending on \fIgfp_mask\fP the allocation may be guaranteed to succeed.
.TH "ntfs_malloc_nofs" 9 "ntfs_malloc_nofs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_malloc_nofs \-  allocate memory in multiples of pages
.SH SYNOPSIS
.B "void *" ntfs_malloc_nofs
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
	number of bytes to allocate
.SH "DESCRIPTION"
Allocates \fIsize\fP bytes of memory, rounded up to multiples of PAGE_SIZE and
returns a pointer to the allocated memory.

If there was insufficient memory to complete the request, return NULL.
.TH "ntfs_malloc_nofs_nofail" 9 "ntfs_malloc_nofs_nofail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_malloc_nofs_nofail \-  allocate memory in multiples of pages
.SH SYNOPSIS
.B "void *" ntfs_malloc_nofs_nofail
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
	number of bytes to allocate
.SH "DESCRIPTION"
Allocates \fIsize\fP bytes of memory, rounded up to multiples of PAGE_SIZE and
returns a pointer to the allocated memory.

This function guarantees that the allocation will succeed.  It will sleep
for as long as it takes to complete the allocation.

If there was insufficient memory to complete the request, return NULL.
.TH "ntfs_are_names_equal" 9 "ntfs_are_names_equal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_are_names_equal \-  compare two Unicode names for equality
.SH SYNOPSIS
.B "BOOL" ntfs_are_names_equal
.BI "(const ntfschar *" s1 ","
.BI "size_t " s1_len ","
.BI "const ntfschar *" s2 ","
.BI "size_t " s2_len ","
.BI "const IGNORE_CASE_BOOL " ic ","
.BI "const ntfschar *" upcase ","
.BI "const u32 " upcase_size ");"
.SH ARGUMENTS
.IP "s1" 12
			name to compare to \fIs2\fP
.IP "s1_len" 12
		length in Unicode characters of \fIs1\fP
.IP "s2" 12
			name to compare to \fIs1\fP
.IP "s2_len" 12
		length in Unicode characters of \fIs2\fP
.IP "ic" 12
			ignore case bool
.IP "upcase" 12
		upcase table (only if \fIic\fP == IGNORE_CASE)
.IP "upcase_size" 12
	length in Unicode characters of \fIupcase\fP (if present)
.SH "DESCRIPTION"
Compare the names \fIs1\fP and \fIs2\fP and return TRUE (1) if the names are
identical, or FALSE (0) if they are not identical. If \fIic\fP is IGNORE_CASE,
the \fIupcase\fP table is used to performa a case insensitive comparison.
.TH "ntfs_collate_names" 9 "ntfs_collate_names" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_collate_names \-  collate two Unicode names
.SH SYNOPSIS
.B "int" ntfs_collate_names
.BI "(const ntfschar *" name1 ","
.BI "const u32 " name1_len ","
.BI "const ntfschar *" name2 ","
.BI "const u32 " name2_len ","
.BI "const int " err_val ","
.BI "const IGNORE_CASE_BOOL " ic ","
.BI "const ntfschar *" upcase ","
.BI "const u32 " upcase_len ");"
.SH ARGUMENTS
.IP "name1" 12
	first Unicode name to compare
.IP "name1_len" 12
-- undescribed --
.IP "name2" 12
	second Unicode name to compare
.IP "name2_len" 12
-- undescribed --
.IP "err_val" 12
	if \fIname1\fP contains an invalid character return this value
.IP "ic" 12
		either CASE_SENSITIVE or IGNORE_CASE
.IP "upcase" 12
	upcase table (ignored if \fIic\fP is CASE_SENSITIVE)
.IP "upcase_len" 12
	upcase table size (ignored if \fIic\fP is CASE_SENSITIVE)
.SH "NTFS_COLLATE_NAMES COLLATES TWO UNICODE NAMES AND RETURNS"

-1 if the first name collates before the second one,
0 if the names match,
1 if the second name collates before the first one, or
\fIerr_val\fP if an invalid character is found in \fIname1\fP during the comparison.
.SH "THE FOLLOWING CHARACTERS ARE CONSIDERED INVALID"
 '"', '*', '&lt;', '&gt;' and '?'.
.TH "ntfs_ucsncmp" 9 "ntfs_ucsncmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_ucsncmp \-  compare two little endian Unicode strings
.SH SYNOPSIS
.B "int" ntfs_ucsncmp
.BI "(const ntfschar *" s1 ","
.BI "const ntfschar *" s2 ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "s1" 12
		first string
.IP "s2" 12
		second string
.IP "n" 12
		maximum unicode characters to compare
.SH "DESCRIPTION"
Compare the first \fIn\fP characters of the Unicode strings \fIs1\fP and \fIs2\fP,
The strings in little endian format and appropriate \fBle16_to_cpu\fP
conversion is performed on non-little endian machines.

The function returns an integer less than, equal to, or greater than zero
if \fIs1\fP (or the first \fIn\fP Unicode characters thereof) is found, respectively,
to be less than, to match, or be greater than \fIs2\fP.
.TH "ntfs_ucsncasecmp" 9 "ntfs_ucsncasecmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_ucsncasecmp \-  compare two little endian Unicode strings, ignoring case
.SH SYNOPSIS
.B "int" ntfs_ucsncasecmp
.BI "(const ntfschar *" s1 ","
.BI "const ntfschar *" s2 ","
.BI "size_t " n ","
.BI "const ntfschar *" upcase ","
.BI "const u32 " upcase_size ");"
.SH ARGUMENTS
.IP "s1" 12
			first string
.IP "s2" 12
			second string
.IP "n" 12
			maximum unicode characters to compare
.IP "upcase" 12
		upcase table
.IP "upcase_size" 12
	upcase table size in Unicode characters
.SH "DESCRIPTION"
Compare the first \fIn\fP characters of the Unicode strings \fIs1\fP and \fIs2\fP,
ignoring case. The strings in little endian format and appropriate
\fBle16_to_cpu\fP conversion is performed on non-little endian machines.

Each character is uppercased using the \fIupcase\fP table before the comparison.

The function returns an integer less than, equal to, or greater than zero
if \fIs1\fP (or the first \fIn\fP Unicode characters thereof) is found, respectively,
to be less than, to match, or be greater than \fIs2\fP.
.TH "ntfs_nlstoucs" 9 "ntfs_nlstoucs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_nlstoucs \-  convert NLS string to little endian Unicode string
.SH SYNOPSIS
.B "int" ntfs_nlstoucs
.BI "(const ntfs_volume *" vol ","
.BI "const char *" ins ","
.BI "const int " ins_len ","
.BI "ntfschar **" outs ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume which we are working with
.IP "ins" 12
	input NLS string buffer
.IP "ins_len" 12
	length of input string in bytes
.IP "outs" 12
	on return contains the allocated output Unicode string buffer
.SH "DESCRIPTION"
Convert the input string \fIins\fP, which is in whatever format the loaded NLS
map dictates, into a little endian, 2-byte Unicode string.

This function allocates the string and the caller is responsible for
calling kmem_cache_free(ntfs_name_cache, \fIouts\fP); when finished with it.

On success the function returns the number of Unicode characters written to
the output string *\fIouts\fP (&gt;= 0), not counting the terminating Unicode NULL
character. *\fIouts\fP is set to the allocated output string buffer.

On error, a negative number corresponding to the error code is returned. In
that case the output string is not allocated. Both *\fIouts\fP and *\fIouts_len\fP
are then undefined.

This might look a bit odd due to fast path optimization...
.TH "ntfs_ucstonls" 9 "ntfs_ucstonls" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_ucstonls \-  convert little endian Unicode string to NLS string
.SH SYNOPSIS
.B "int" ntfs_ucstonls
.BI "(const ntfs_volume *" vol ","
.BI "const ntfschar *" ins ","
.BI "const int " ins_len ","
.BI "unsigned char **" outs ","
.BI "int " outs_len ");"
.SH ARGUMENTS
.IP "vol" 12
	ntfs volume which we are working with
.IP "ins" 12
	input Unicode string buffer
.IP "ins_len" 12
	length of input string in Unicode characters
.IP "outs" 12
	on return contains the (allocated) output NLS string buffer
.IP "outs_len" 12
	length of output string buffer in bytes
.SH "DESCRIPTION"
Convert the input little endian, 2-byte Unicode string \fIins\fP, of length
\fIins_len\fP into the string format dictated by the loaded NLS.

If *\fIouts\fP is NULL, this function allocates the string and the caller is
responsible for calling kfree(*\fIouts\fP); when finished with it. In this case
\fIouts_len\fP is ignored and can be 0.

On success the function returns the number of bytes written to the output
string *\fIouts\fP (&gt;= 0), not counting the terminating NULL byte. If the output
string buffer was allocated, *\fIouts\fP is set to it.

On error, a negative number corresponding to the error code is returned. In
that case the output string is not allocated. The contents of *\fIouts\fP are
then undefined.

This might look a bit odd due to fast path optimization...
.TH "__ntfs_bitmap_set_bits_in_run" 9 "__ntfs_bitmap_set_bits_in_run" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntfs_bitmap_set_bits_in_run \-  set a run of bits in a bitmap to a value
.SH SYNOPSIS
.B "int" __ntfs_bitmap_set_bits_in_run
.BI "(struct inode *" vi ","
.BI "const s64 " start_bit ","
.BI "const s64 " count ","
.BI "const u8 " value ","
.BI "const BOOL " is_rollback ");"
.SH ARGUMENTS
.IP "vi" 12
			vfs inode describing the bitmap
.IP "start_bit" 12
		first bit to set
.IP "count" 12
		number of bits to set
.IP "value" 12
		value to set the bits to (i.e. 0 or 1)
.IP "is_rollback" 12
	if TRUE this is a rollback operation
.SH "DESCRIPTION"
Set \fIcount\fP bits starting at bit \fIstart_bit\fP in the bitmap described by the
vfs inode \fIvi\fP to \fIvalue\fP, where \fIvalue\fP is either 0 or 1.

\fIis_rollback\fP should always be FALSE, it is for internal use to rollback
errors.  You probably want to use \fBntfs_bitmap_set_bits_in_run\fP instead.

Return 0 on success and -errno on error.
.TH "post_read_mst_fixup" 9 "post_read_mst_fixup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
post_read_mst_fixup \-  deprotect multi sector transfer protected data
.SH SYNOPSIS
.B "int" post_read_mst_fixup
.BI "(NTFS_RECORD *" b ","
.BI "const u32 " size ");"
.SH ARGUMENTS
.IP "b" 12
		pointer to the data to deprotect
.IP "size" 12
	size in bytes of \fIb\fP
.SH "DESCRIPTION"
Perform the necessary post read multi sector transfer fixup and detect the
presence of incomplete multi sector transfers. - In that case, overwrite the
magic of the ntfs record header being processed with "BAAD" (in memory only!)
and abort processing.

Return 0 on success and -EINVAL on error ("BAAD" magic will be present).
.SH "NOTE"
 We consider the absence / invalidity of an update sequence array to
mean that the structure is not protected at all and hence doesn't need to
be fixed up. Thus, we return success and not failure in this case. This is
in contrast to \fBpre_write_mst_fixup\fP, see below.
.TH "pre_write_mst_fixup" 9 "pre_write_mst_fixup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pre_write_mst_fixup \-  apply multi sector transfer protection
.SH SYNOPSIS
.B "int" pre_write_mst_fixup
.BI "(NTFS_RECORD *" b ","
.BI "const u32 " size ");"
.SH ARGUMENTS
.IP "b" 12
		pointer to the data to protect
.IP "size" 12
	size in bytes of \fIb\fP
.SH "DESCRIPTION"
Perform the necessary pre write multi sector transfer fixup on the data
pointer to by \fIb\fP of \fIsize\fP.

Return 0 if fixup applied (success) or -EINVAL if no fixup was performed
(assumed not needed). This is in contrast to \fBpost_read_mst_fixup\fP above.
.SH "NOTE"
 We consider the absence / invalidity of an update sequence array to
mean that the structure is not subject to protection and hence doesn't need
to be fixed up. This means that you have to create a valid update sequence
array header in the ntfs record before calling this function, otherwise it
will fail (the header needs to contain the position of the update sequence
array together with the number of elements in the array). You also need to
initialise the update sequence number before calling this function
otherwise a random word will be used (whatever was in the record at that
position at that time).
.TH "post_write_mst_fixup" 9 "post_write_mst_fixup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
post_write_mst_fixup \-  fast deprotect multi sector transfer protected data
.SH SYNOPSIS
.B "void" post_write_mst_fixup
.BI "(NTFS_RECORD *" b ");"
.SH ARGUMENTS
.IP "b" 12
		pointer to the data to deprotect
.SH "DESCRIPTION"
Perform the necessary post write multi sector transfer fixup, not checking
for any errors, because we assume we have just used \fBpre_write_mst_fixup\fP,
thus the data will be fine or we would never have gotten here.
.TH "ntfs_index_ctx_get" 9 "ntfs_index_ctx_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_index_ctx_get \-  allocate and initialize a new index context
.SH SYNOPSIS
.B "ntfs_index_context *" ntfs_index_ctx_get
.BI "(ntfs_inode *" idx_ni ");"
.SH ARGUMENTS
.IP "idx_ni" 12
	ntfs index inode with which to initialize the context
.SH "DESCRIPTION"
Allocate a new index context, initialize it with \fIidx_ni\fP and return it.
Return NULL if allocation failed.
.SH "LOCKING"
  Caller must hold i_sem on the index inode.
.TH "ntfs_index_ctx_put" 9 "ntfs_index_ctx_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_index_ctx_put \-  release an index context
.SH SYNOPSIS
.B "void" ntfs_index_ctx_put
.BI "(ntfs_index_context *" ictx ");"
.SH ARGUMENTS
.IP "ictx" 12
	index context to free
.SH "DESCRIPTION"
Release the index context \fIictx\fP, releasing all associated resources.
.SH "LOCKING"
  Caller must hold i_sem on the index inode.
.TH "ntfs_index_lookup" 9 "ntfs_index_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_index_lookup \-  find a key in an index and return its index entry
.SH SYNOPSIS
.B "int" ntfs_index_lookup
.BI "(const void *" key ","
.BI "const int " key_len ","
.BI "ntfs_index_context *" ictx ");"
.SH ARGUMENTS
.IP "key" 12
	[IN] key for which to search in the index
.IP "key_len" 12
	[IN] length of \fIkey\fP in bytes
.IP "ictx" 12
	[IN/OUT] context describing the index and the returned entry
.SH "DESCRIPTION"
Before calling \fBntfs_index_lookup\fP, \fIictx\fP must have been obtained from a
call to \fBntfs_index_ctx_get\fP.

Look for the \fIkey\fP in the index specified by the index lookup context \fIictx\fP.
\fBntfs_index_lookup\fP walks the contents of the index looking for the \fIkey\fP.

If the \fIkey\fP is found in the index, 0 is returned and \fIictx\fP is setup to
describe the index entry containing the matching \fIkey\fP.  \fIictx\fP-&gt;entry is the
index entry and \fIictx\fP-&gt;data and \fIictx\fP-&gt;data_len are the index entry data and
its length in bytes, respectively.

If the \fIkey\fP is not found in the index, -ENOENT is returned and \fIictx\fP is
setup to describe the index entry whose key collates immediately after the
search \fIkey\fP, i.e. this is the position in the index at which an index entry
with a key of \fIkey\fP would need to be inserted.

If an error occurs return the negative error code and \fIictx\fP is left
untouched.

When finished with the entry and its data, call \fBntfs_index_ctx_put\fP to free
the context and other associated resources.

If the index entry was modified, call \fBflush_dcache_index_entry_page\fP
immediately after the modification and either \fBntfs_index_entry_mark_dirty\fP
or \fBntfs_index_entry_write\fP before the call to \fBntfs_index_ctx_put\fP to
ensure that the changes are written to disk.
.SH "LOCKING"
  - Caller must hold i_sem on the index inode.
- Each page cache page in the index allocation mapping must be
locked whilst being accessed otherwise we may find a corrupt
page due to it being under -&gt;writepage at the moment which
applies the mst protection fixups before writing out and then
removes them again after the write is complete after which it 
unlocks the page.
.TH "ntfs_debug" 9 "ntfs_debug" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_debug \-  write a debug level message to syslog
.SH SYNOPSIS
.B "void" ntfs_debug
.BI "(const char *" f ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "f" 12
		a printf format string containing the message
@...:	the variables to substitute into \fIf\fP
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
\fBntfs_debug\fP writes a DEBUG level message to the syslog but only if the
driver was compiled with -DDEBUG. Otherwise, the call turns into a NOP.
.TH "ntfs_sysctl" 9 "ntfs_sysctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_sysctl \-  add or remove the debug sysctl
.SH SYNOPSIS
.B "int" ntfs_sysctl
.BI "(int " add ");"
.SH ARGUMENTS
.IP "add" 12
	add (1) or remove (0) the sysctl
.SH "DESCRIPTION"
Add or remove the debug sysctl. Return 0 on success or -errno on error.
.TH "ntfs_cluster_free_from_rl_nolock" 9 "ntfs_cluster_free_from_rl_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_cluster_free_from_rl_nolock \-  free clusters from runlist
.SH SYNOPSIS
.B "int" ntfs_cluster_free_from_rl_nolock
.BI "(ntfs_volume *" vol ","
.BI "const runlist_element *" rl ");"
.SH ARGUMENTS
.IP "vol" 12
	mounted ntfs volume on which to free the clusters
.IP "rl" 12
		runlist describing the clusters to free
.SH "DESCRIPTION"
Free all the clusters described by the runlist \fIrl\fP on the volume \fIvol\fP.  In
the case of an error being returned, at least some of the clusters were not
freed.

Return 0 on success and -errno on error.
.SH "LOCKING"
 - The volume lcn bitmap must be locked for writing on entry and is
left locked on return.
.TH "ntfs_cluster_alloc" 9 "ntfs_cluster_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_cluster_alloc \-  allocate clusters on an ntfs volume
.SH SYNOPSIS
.B "runlist_element *" ntfs_cluster_alloc
.BI "(ntfs_volume *" vol ","
.BI "const VCN " start_vcn ","
.BI "const s64 " count ","
.BI "const LCN " start_lcn ","
.BI "const NTFS_CLUSTER_ALLOCATION_ZONES " zone ");"
.SH ARGUMENTS
.IP "vol" 12
	mounted ntfs volume on which to allocate the clusters
.IP "start_vcn" 12
	vcn to use for the first allocated cluster
.IP "count" 12
	number of clusters to allocate
.IP "start_lcn" 12
	starting lcn at which to allocate the clusters (or -1 if none)
.IP "zone" 12
	zone from which to allocate the clusters
.SH "DESCRIPTION"
Allocate \fIcount\fP clusters preferably starting at cluster \fIstart_lcn\fP or at the
current allocator position if \fIstart_lcn\fP is -1, on the mounted ntfs volume
\fIvol\fP. \fIzone\fP is either DATA_ZONE for allocation of normal clusters or
MFT_ZONE for allocation of clusters for the master file table, i.e. the
$MFT/$DATA attribute.

\fIstart_vcn\fP specifies the vcn of the first allocated cluster.  This makes
merging the resulting runlist with the old runlist easier.

You need to check the return value with \fBIS_ERR\fP.  If this is false, the
function was successful and the return value is a runlist describing the
allocated cluster(s).  If \fBIS_ERR\fP is true, the function failed and
\fBPTR_ERR\fP gives you the error code.

Notes on the allocation algorithm
=================================

There are two data zones.  First is the area between the end of the mft zone
and the end of the volume, and second is the area between the start of the
volume and the start of the mft zone.  On unmodified/standard NTFS 1.x
volumes, the second data zone does not exist due to the mft zone being
expanded to cover the start of the volume in order to reserve space for the
mft bitmap attribute.

This is not the prettiest function but the complexity stems from the need of
implementing the mft vs data zoned approach and from the fact that we have
access to the lcn bitmap in portions of up to 8192 bytes at a time, so we
need to cope with crossing over boundaries of two buffers.  Further, the
fact that the allocator allows for caller supplied hints as to the location
of where allocation should begin and the fact that the allocator keeps track
of where in the data zones the next natural allocation should occur,
contribute to the complexity of the function.  But it should all be
worthwhile, because this allocator should: 1) be a full implementation of
the MFT zone approach used by Windows NT, 2) cause reduction in
fragmentation, and 3) be speedy in allocations (the code is not optimized
for speed, but the algorithm is, so further speed improvements are probably
possible).
.SH "FIXME"
 We should be monitoring cluster allocation and increment the MFT zone
size dynamically but this is something for the future.  We will just cause
heavier fragmentation by not doing it and I am not even sure Windows would
grow the MFT zone dynamically, so it might even be correct not to do this.
The overhead in doing dynamic MFT zone expansion would be very large and
unlikely worth the effort. (AIA)
.SH "TODO"
 I have added in double the required zone position pointer wrap around
logic which can be optimized to having only one of the two logic sets.
However, having the double logic will work fine, but if we have only one of
the sets and we get it wrong somewhere, then we get into trouble, so
removing the duplicate logic requires _very_ careful consideration of _all_
possible code paths.  So at least for now, I am leaving the double logic -
better safe than sorry... (AIA)
.SH "LOCKING"
 - The volume lcn bitmap must be unlocked on entry and is unlocked
on return.
- This function takes the volume lcn bitmap lock for writing and
modifies the bitmap contents.
.TH "__ntfs_cluster_free" 9 "__ntfs_cluster_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntfs_cluster_free \-  free clusters on an ntfs volume
.SH SYNOPSIS
.B "s64" __ntfs_cluster_free
.BI "(ntfs_inode *" ni ","
.BI "const VCN " start_vcn ","
.BI "s64 " count ","
.BI "const BOOL " is_rollback ");"
.SH ARGUMENTS
.IP "ni" 12
		ntfs inode whose runlist describes the clusters to free
.IP "start_vcn" 12
	vcn in the runlist of \fIni\fP at which to start freeing clusters
.IP "count" 12
	number of clusters to free or -1 for all clusters
.IP "is_rollback" 12
	true if this is a rollback operation
.SH "DESCRIPTION"
Free \fIcount\fP clusters starting at the cluster \fIstart_vcn\fP in the runlist
described by the vfs inode \fIni\fP.

If \fIcount\fP is -1, all clusters from \fIstart_vcn\fP to the end of the runlist are
deallocated.  Thus, to completely free all clusters in a runlist, use
\fIstart_vcn\fP = 0 and \fIcount\fP = -1.

\fIis_rollback\fP should always be FALSE, it is for internal use to rollback
errors.  You probably want to use \fBntfs_cluster_free\fP instead.

Note, \fBntfs_cluster_free\fP does not modify the runlist at all, so the caller
has to deal with it later.

Return the number of deallocated clusters (not counting sparse ones) on
success and -errno on error.
.SH "LOCKING"
 - The runlist described by \fIni\fP must be locked for writing on entry
and is locked on return.  Note the runlist may be modified when
needed runlist fragments need to be mapped.
- The volume lcn bitmap must be unlocked on entry and is unlocked
on return.
- This function takes the volume lcn bitmap lock for writing and
modifies the bitmap contents.
.TH "NTFS_SB" 9 "NTFS_SB" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NTFS_SB \-  return the ntfs volume given a vfs super block
.SH SYNOPSIS
.B "ntfs_volume *" NTFS_SB
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
		VFS super block
.SH "DESCRIPTION"
\fBNTFS_SB\fP returns the ntfs volume associated with the VFS super block \fIsb\fP.
.TH "ntfs_check_restart_page_header" 9 "ntfs_check_restart_page_header" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_check_restart_page_header \-  check the page header for consistency
.SH SYNOPSIS
.B "BOOL" ntfs_check_restart_page_header
.BI "(struct inode *" vi ","
.BI "RESTART_PAGE_HEADER *" rp ","
.BI "s64 " pos ");"
.SH ARGUMENTS
.IP "vi" 12
		$LogFile inode to which the restart page header belongs
.IP "rp" 12
		restart page header to check
.IP "pos" 12
	position in \fIvi\fP at which the restart page header resides
.SH "DESCRIPTION"
Check the restart page header \fIrp\fP for consistency and return TRUE if it is
consistent and FALSE otherwise.

This function only needs NTFS_BLOCK_SIZE bytes in \fIrp\fP, i.e. it does not
require the full restart page.
.TH "ntfs_check_restart_area" 9 "ntfs_check_restart_area" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_check_restart_area \-  check the restart area for consistency
.SH SYNOPSIS
.B "BOOL" ntfs_check_restart_area
.BI "(struct inode *" vi ","
.BI "RESTART_PAGE_HEADER *" rp ");"
.SH ARGUMENTS
.IP "vi" 12
		$LogFile inode to which the restart page belongs
.IP "rp" 12
		restart page whose restart area to check
.SH "DESCRIPTION"
Check the restart area of the restart page \fIrp\fP for consistency and return
TRUE if it is consistent and FALSE otherwise.

This function assumes that the restart page header has already been
consistency checked.

This function only needs NTFS_BLOCK_SIZE bytes in \fIrp\fP, i.e. it does not
require the full restart page.
.TH "ntfs_check_log_client_array" 9 "ntfs_check_log_client_array" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_check_log_client_array \-  check the log client array for consistency
.SH SYNOPSIS
.B "BOOL" ntfs_check_log_client_array
.BI "(struct inode *" vi ","
.BI "RESTART_PAGE_HEADER *" rp ");"
.SH ARGUMENTS
.IP "vi" 12
		$LogFile inode to which the restart page belongs
.IP "rp" 12
		restart page whose log client array to check
.SH "DESCRIPTION"
Check the log client array of the restart page \fIrp\fP for consistency and
return TRUE if it is consistent and FALSE otherwise.

This function assumes that the restart page header and the restart area have
already been consistency checked.

Unlike \fBntfs_check_restart_page_header\fP and \fBntfs_check_restart_area\fP, this
function needs \fIrp\fP-&gt;system_page_size bytes in \fIrp\fP, i.e. it requires the full
restart page and the page must be multi sector transfer deprotected.
.TH "ntfs_check_and_load_restart_page" 9 "ntfs_check_and_load_restart_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_check_and_load_restart_page \-  check the restart page for consistency
.SH SYNOPSIS
.B "int" ntfs_check_and_load_restart_page
.BI "(struct inode *" vi ","
.BI "RESTART_PAGE_HEADER *" rp ","
.BI "s64 " pos ","
.BI "RESTART_PAGE_HEADER **" wrp ","
.BI "LSN *" lsn ");"
.SH ARGUMENTS
.IP "vi" 12
		$LogFile inode to which the restart page belongs
.IP "rp" 12
		restart page to check
.IP "pos" 12
	position in \fIvi\fP at which the restart page resides
.IP "wrp" 12
	[OUT] copy of the multi sector transfer deprotected restart page
.IP "lsn" 12
	[OUT] set to the current logfile lsn on success
.SH "DESCRIPTION"
Check the restart page \fIrp\fP for consistency and return 0 if it is consistent
and -errno otherwise.  The restart page may have been modified by chkdsk in
which case its magic is CHKD instead of RSTR.

This function only needs NTFS_BLOCK_SIZE bytes in \fIrp\fP, i.e. it does not
require the full restart page.

If \fIwrp\fP is not NULL, on success, *\fIwrp\fP will point to a buffer containing a
copy of the complete multi sector transfer deprotected page.  On failure,
*\fIwrp\fP is undefined.

Simillarly, if \fIlsn\fP is not NULL, on succes *\fIlsn\fP will be set to the current
logfile lsn according to this restart page.  On failure, *\fIlsn\fP is undefined.
.SH "THE FOLLOWING ERROR CODES ARE DEFINED"
-EINVAL	- The restart page is inconsistent.
-ENOMEM	- Not enough memory to load the restart page.
-EIO	- Failed to reading from $LogFile.
.TH "ntfs_check_logfile" 9 "ntfs_check_logfile" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_check_logfile \-  check the journal for consistency
.SH SYNOPSIS
.B "BOOL" ntfs_check_logfile
.BI "(struct inode *" log_vi ","
.BI "RESTART_PAGE_HEADER **" rp ");"
.SH ARGUMENTS
.IP "log_vi" 12
	struct inode of loaded journal $LogFile to check
.IP "rp" 12
		[OUT] on success this is a copy of the current restart page
.SH "DESCRIPTION"
Check the $LogFile journal for consistency and return TRUE if it is
consistent and FALSE if not.  On success, the current restart page is
returned in *\fIrp\fP.  Caller must call ntfs_free(*\fIrp\fP) when finished with it.

At present we only check the two restart pages and ignore the log record
pages.

Note that the MstProtected flag is not set on the $LogFile inode and hence
when reading pages they are not deprotected.  This is because we do not know
if the $LogFile was created on a system with a different page size to ours
yet and mst deprotection would fail if our page size is smaller.
.TH "ntfs_is_logfile_clean" 9 "ntfs_is_logfile_clean" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_is_logfile_clean \-  check in the journal if the volume is clean
.SH SYNOPSIS
.B "BOOL" ntfs_is_logfile_clean
.BI "(struct inode *" log_vi ","
.BI "const RESTART_PAGE_HEADER *" rp ");"
.SH ARGUMENTS
.IP "log_vi" 12
	struct inode of loaded journal $LogFile to check
.IP "rp" 12
		copy of the current restart page
.SH "DESCRIPTION"
Analyze the $LogFile journal and return TRUE if it indicates the volume was
shutdown cleanly and FALSE if not.

At present we only look at the two restart pages and ignore the log record
pages.  This is a little bit crude in that there will be a very small number
of cases where we think that a volume is dirty when in fact it is clean.
This should only affect volumes that have not been shutdown cleanly but did
not have any pending, non-check-pointed i/o, i.e. they were completely idle
at least for the five seconds preceeding the unclean shutdown.

This function assumes that the $LogFile journal has already been consistency
checked by a call to \fBntfs_check_logfile\fP and in particular if the $LogFile
is empty this function requires that \fBNVolLogFileEmpty\fP is true otherwise an
empty volume will be reported as dirty.
.TH "ntfs_empty_logfile" 9 "ntfs_empty_logfile" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_empty_logfile \-  empty the contents of the $LogFile journal
.SH SYNOPSIS
.B "BOOL" ntfs_empty_logfile
.BI "(struct inode *" log_vi ");"
.SH ARGUMENTS
.IP "log_vi" 12
	struct inode of loaded journal $LogFile to empty
.SH "DESCRIPTION"
Empty the contents of the $LogFile journal \fIlog_vi\fP and return TRUE on
success and FALSE on error.

This function assumes that the $LogFile journal has already been consistency
checked by a call to \fBntfs_check_logfile\fP and that \fBntfs_is_logfile_clean\fP
has been used to ensure that the $LogFile is clean.
.TH "utc2ntfs" 9 "utc2ntfs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
utc2ntfs \-  convert Linux UTC time to NTFS time
.SH SYNOPSIS
.B "sle64" utc2ntfs
.BI "(const struct timespec " ts ");"
.SH ARGUMENTS
.IP "ts" 12
		Linux UTC time to convert to NTFS time
.SH "DESCRIPTION"
Convert the Linux UTC time \fIts\fP to its corresponding NTFS time and return
that in little endian format.

Linux stores time in a struct timespec consisting of a time_t (long at
present) tv_sec and a long tv_nsec where tv_sec is the number of 1-second
intervals since 1st January 1970, 00:00:00 UTC and tv_nsec is the number of
1-nano-second intervals since the value of tv_sec.

NTFS uses Microsoft's standard time format which is stored in a s64 and is
measured as the number of 100-nano-second intervals since 1st January 1601,
.SH "00"
00:00 UTC.
.TH "get_current_ntfs_time" 9 "get_current_ntfs_time" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_current_ntfs_time \-  get the current time in little endian NTFS format
.SH SYNOPSIS
.B "sle64" get_current_ntfs_time
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Get the current time from the Linux kernel, convert it to its corresponding
NTFS time and return that in little endian format.
.TH "ntfs2utc" 9 "ntfs2utc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs2utc \-  convert NTFS time to Linux time
.SH SYNOPSIS
.B "struct timespec" ntfs2utc
.BI "(const sle64 " time ");"
.SH ARGUMENTS
.IP "time" 12
	NTFS time (little endian) to convert to Linux UTC
.SH "DESCRIPTION"
Convert the little endian NTFS time \fItime\fP to its corresponding Linux UTC
time and return that in cpu format.

Linux stores time in a struct timespec consisting of a time_t (long at
present) tv_sec and a long tv_nsec where tv_sec is the number of 1-second
intervals since 1st January 1970, 00:00:00 UTC and tv_nsec is the number of
1-nano-second intervals since the value of tv_sec.

NTFS uses Microsoft's standard time format which is stored in a s64 and is
measured as the number of 100 nano-second intervals since 1st January 1601,
.SH "00"
00:00 UTC.
.TH "ntfs_file_open" 9 "ntfs_file_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_file_open \-  called when an inode is about to be opened
.SH SYNOPSIS
.B "int" ntfs_file_open
.BI "(struct inode *" vi ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "vi" 12
		inode to be opened
.IP "filp" 12
	file structure describing the inode
.SH "DESCRIPTION"
Limit file size to the page cache limit on architectures where unsigned long
is 32-bits. This is the most we can do for now without overflowing the page
cache page index. Doing it this way means we don't run into problems because
of existing too large files. It would be better to allow the user to read
the beginning of the file but I doubt very much anyone is going to hit this
check on a 32-bit architecture, so there is no point in adding the extra
complexity required to support this.

On 64-bit architectures, the check is hopefully optimized away by the
compiler.

After the check passes, just call \fBgeneric_file_open\fP to do its work.
.TH "ntfs_file_fsync" 9 "ntfs_file_fsync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ntfs_file_fsync \-  sync a file to disk
.SH SYNOPSIS
.B "int" ntfs_file_fsync
.BI "(struct file *" filp ","
.BI "struct dentry *" dentry ","
.BI "int " datasync ");"
.SH ARGUMENTS
.IP "filp" 12
	file to be synced
.IP "dentry" 12
	dentry describing the file to sync
.IP "datasync" 12
	if non-zero only flush user data and not metadata
.SH "DESCRIPTION"
Data integrity sync of a file to disk.  Used for fsync, fdatasync, and msync
system calls.  This function is inspired by fs/buffer.c::\fBfile_fsync\fP.

If \fIdatasync\fP is false, write the mft record and all associated extent mft
records as well as the $DATA attribute and then sync the block device.

If \fIdatasync\fP is true and the attribute is non-resident, we skip the writing
of the mft record and all associated extent mft records (this might still
happen due to the \fBwrite_inode_now\fP call).

Also, if \fIdatasync\fP is true, we do not wait on the inode to be written out
but we always wait on the page cache pages to be written out.
.SH "NOTE"
 In the past \fIfilp\fP could be NULL so we ignore it as we don't need it
anyway.
.SH "LOCKING"
 Caller must hold i_sem on the inode.
.SH "TODO"
 We should probably also write all attribute/index inodes associated
with this inode but since we have no simple way of getting to them we ignore
this problem for now.
.TH "make_bad_inode" 9 "make_bad_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
make_bad_inode \-  mark an inode bad due to an I/O error
.SH SYNOPSIS
.B "void" make_bad_inode
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 Inode to mark bad
.SH "DESCRIPTION"
When an inode cannot be read due to a media or remote network
failure this function makes the inode "bad" and causes I/O operations
on it to fail from this point on.
.TH "is_bad_inode" 9 "is_bad_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_bad_inode \-  is an inode errored
.SH SYNOPSIS
.B "int" is_bad_inode
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to test
.SH "DESCRIPTION"
Returns true if the inode in question has been marked as bad.
.TH "relayfs_create_entry" 9 "relayfs_create_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_create_entry \-  create a relayfs directory or file
.SH SYNOPSIS
.B "struct dentry *" relayfs_create_entry
.BI "(const char *" name ","
.BI "struct dentry *" parent ","
.BI "int " mode ","
.BI "struct rchan *" chan ");"
.SH ARGUMENTS
.IP "name" 12
 the name of the file to create
.IP "parent" 12
 parent directory
.IP "mode" 12
 mode
.IP "chan" 12
 relay channel associated with the file
.SH "DESCRIPTION"
Returns the new dentry, NULL on failure

Creates a file or directory with the specifed permissions.
.TH "relayfs_create_file" 9 "relayfs_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_create_file \-  create a file in the relay filesystem
.SH SYNOPSIS
.B "struct dentry *" relayfs_create_file
.BI "(const char *" name ","
.BI "struct dentry *" parent ","
.BI "int " mode ","
.BI "struct rchan *" chan ");"
.SH ARGUMENTS
.IP "name" 12
 the name of the file to create
.IP "parent" 12
 parent directory
.IP "mode" 12
 mode, if not specied the default perms are used
.IP "chan" 12
 channel associated with the file
.SH "DESCRIPTION"
Returns file dentry if successful, NULL otherwise.

The file will be created user r on behalf of current user.
.TH "relayfs_create_dir" 9 "relayfs_create_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_create_dir \-  create a directory in the relay filesystem
.SH SYNOPSIS
.B "struct dentry *" relayfs_create_dir
.BI "(const char *" name ","
.BI "struct dentry *" parent ");"
.SH ARGUMENTS
.IP "name" 12
 the name of the directory to create
.IP "parent" 12
 parent directory, NULL if parent should be fs root
.SH "DESCRIPTION"
Returns directory dentry if successful, NULL otherwise.

The directory will be created world rwx on behalf of current user.
.TH "relayfs_remove" 9 "relayfs_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_remove \-  remove a file or directory in the relay filesystem
.SH SYNOPSIS
.B "int" relayfs_remove
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 file or directory dentry
.SH "DESCRIPTION"
Returns 0 if successful, negative otherwise.
.TH "relayfs_remove_dir" 9 "relayfs_remove_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_remove_dir \-  remove a directory in the relay filesystem
.SH SYNOPSIS
.B "int" relayfs_remove_dir
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 directory dentry
.SH "DESCRIPTION"
Returns 0 if successful, negative otherwise.
.TH "relayfs_open" 9 "relayfs_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_open \-  open file op for relayfs files
.SH SYNOPSIS
.B "int" relayfs_open
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
 the inode
.IP "filp" 12
 the file
.SH "DESCRIPTION"
Increments the channel buffer refcount.
.TH "relayfs_mmap" 9 "relayfs_mmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_mmap \-  mmap file op for relayfs files
.SH SYNOPSIS
.B "int" relayfs_mmap
.BI "(struct file *" filp ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "filp" 12
 the file
.IP "vma" 12
 the vma describing what to map
.SH "DESCRIPTION"
Calls upon relay_mmap_buf to map the file into user space.
.TH "relayfs_poll" 9 "relayfs_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_poll \-  poll file op for relayfs files
.SH SYNOPSIS
.B "unsigned int" relayfs_poll
.BI "(struct file *" filp ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "filp" 12
 the file
.IP "wait" 12
 poll table
.SH "DESCRIPTION"
Poll implemention.
.TH "relayfs_release" 9 "relayfs_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_release \-  release file op for relayfs files
.SH SYNOPSIS
.B "int" relayfs_release
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
 the inode
.IP "filp" 12
 the file
.SH "DESCRIPTION"
Decrements the channel refcount, as the filesystem is
no longer using it.
.TH "relayfs_read_consume" 9 "relayfs_read_consume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_read_consume \-  update the consumed count for the buffer
.SH SYNOPSIS
.B "void" relayfs_read_consume
.BI "(struct rchan_buf *" buf ","
.BI "size_t " read_pos ","
.BI "size_t " bytes_consumed ");"
.SH ARGUMENTS
.IP "buf" 12
-- undescribed --
.IP "read_pos" 12
-- undescribed --
.IP "bytes_consumed" 12
-- undescribed --
.TH "relayfs_read_avail" 9 "relayfs_read_avail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_read_avail \-  boolean, are there unconsumed bytes available?
.SH SYNOPSIS
.B "int" relayfs_read_avail
.BI "(struct rchan_buf *" buf ","
.BI "size_t " read_pos ");"
.SH ARGUMENTS
.IP "buf" 12
-- undescribed --
.IP "read_pos" 12
-- undescribed --
.TH "relayfs_read_subbuf_avail" 9 "relayfs_read_subbuf_avail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_read_subbuf_avail \-  return bytes available in sub-buffer
.SH SYNOPSIS
.B "size_t" relayfs_read_subbuf_avail
.BI "(size_t " read_pos ","
.BI "struct rchan_buf *" buf ");"
.SH ARGUMENTS
.IP "read_pos" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.TH "relayfs_read_start_pos" 9 "relayfs_read_start_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_read_start_pos \-  find the first available byte to read
.SH SYNOPSIS
.B "size_t" relayfs_read_start_pos
.BI "(size_t " read_pos ","
.BI "struct rchan_buf *" buf ");"
.SH ARGUMENTS
.IP "read_pos" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"

If the read_pos is in the middle of padding, return the
position of the first actually available byte, otherwise
return the original value.
.TH "relayfs_read_end_pos" 9 "relayfs_read_end_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_read_end_pos \-  return the new read position
.SH SYNOPSIS
.B "size_t" relayfs_read_end_pos
.BI "(struct rchan_buf *" buf ","
.BI "size_t " read_pos ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "buf" 12
-- undescribed --
.IP "read_pos" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.TH "relayfs_read" 9 "relayfs_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_read \-  read file op for relayfs files
.SH SYNOPSIS
.B "ssize_t" relayfs_read
.BI "(struct file *" filp ","
.BI "char __user *" buffer ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "filp" 12
 the file
.IP "buffer" 12
 the userspace buffer
.IP "count" 12
 number of bytes to read
.IP "ppos" 12
 position to read from
.SH "DESCRIPTION"
Reads count bytes or the number of bytes available in the
current sub-buffer being read, whichever is smaller.
.TH "relayfs_alloc_inode" 9 "relayfs_alloc_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_alloc_inode \- 
.SH SYNOPSIS
.B "struct inode *" relayfs_alloc_inode
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
-- undescribed --
.TH "relayfs_destroy_inode" 9 "relayfs_destroy_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relayfs_destroy_inode \- 
.SH SYNOPSIS
.B "void" relayfs_destroy_inode
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.TH "relay_buf_empty" 9 "relay_buf_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_buf_empty \-  boolean, is the channel buffer empty?
.SH SYNOPSIS
.B "int" relay_buf_empty
.BI "(struct rchan_buf *" buf ");"
.SH ARGUMENTS
.IP "buf" 12
 channel buffer
.SH "DESCRIPTION"
Returns 1 if the buffer is empty, 0 otherwise.
.TH "relay_buf_full" 9 "relay_buf_full" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_buf_full \-  boolean, is the channel buffer full?
.SH SYNOPSIS
.B "int" relay_buf_full
.BI "(struct rchan_buf *" buf ");"
.SH ARGUMENTS
.IP "buf" 12
 channel buffer
.SH "DESCRIPTION"
Returns 1 if the buffer is full, 0 otherwise.
.TH "wakeup_readers" 9 "wakeup_readers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wakeup_readers \-  wake up readers waiting on a channel
.SH SYNOPSIS
.B "void" wakeup_readers
.BI "(void *" private ");"
.SH ARGUMENTS
.IP "private" 12
 the channel buffer
.SH "DESCRIPTION"
This is the work function used to defer reader waking.  The
reason waking is deferred is that calling directly from write
causes problems if you're writing from say the scheduler.
.TH "__relay_reset" 9 "__relay_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__relay_reset \-  reset a channel buffer
.SH SYNOPSIS
.B "void" __relay_reset
.BI "(struct rchan_buf *" buf ","
.BI "unsigned int " init ");"
.SH ARGUMENTS
.IP "buf" 12
 the channel buffer
.IP "init" 12
 1 if this is a first-time initialization
.SH "DESCRIPTION"
See relay_reset for description of effect.
.TH "relay_reset" 9 "relay_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_reset \-  reset the channel
.SH SYNOPSIS
.B "void" relay_reset
.BI "(struct rchan *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 the channel
.SH "DESCRIPTION"
This has the effect of erasing all data from all channel buffers
and restarting the channel in its initial state.  The buffers
are not freed, so any mappings are still in effect.
.SH "NOTE"
 Care should be taken that the channel isn't actually
being used by anything when this call is made.
.TH "relay_open_buf" 9 "relay_open_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_open_buf \-  create a new channel buffer in relayfs
.SH SYNOPSIS
.B "struct rchan_buf *" relay_open_buf
.BI "(struct rchan *" chan ","
.BI "const char *" filename ","
.BI "struct dentry *" parent ");"
.SH ARGUMENTS
.IP "chan" 12
-- undescribed --
.IP "filename" 12
-- undescribed --
.IP "parent" 12
-- undescribed --
.SH "DESCRIPTION"

Internal - used by \fBrelay_open\fP.
.TH "relay_close_buf" 9 "relay_close_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_close_buf \-  close a channel buffer
.SH SYNOPSIS
.B "void" relay_close_buf
.BI "(struct rchan_buf *" buf ");"
.SH ARGUMENTS
.IP "buf" 12
 channel buffer
.SH "DESCRIPTION"
Marks the buffer finalized and restores the default callbacks.
The channel buffer and channel buffer data structure are then freed
automatically when the last reference is given up.
.TH "relay_open" 9 "relay_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_open \-  create a new relayfs channel
.SH SYNOPSIS
.B "struct rchan *" relay_open
.BI "(const char *" base_filename ","
.BI "struct dentry *" parent ","
.BI "size_t " subbuf_size ","
.BI "size_t " n_subbufs ","
.BI "struct rchan_callbacks *" cb ");"
.SH ARGUMENTS
.IP "base_filename" 12
 base name of files to create
.IP "parent" 12
 dentry of parent directory, NULL for root directory
.IP "subbuf_size" 12
 size of sub-buffers
.IP "n_subbufs" 12
 number of sub-buffers
.IP "cb" 12
 client callback functions
.SH "DESCRIPTION"
Returns channel pointer if successful, NULL otherwise.

Creates a channel buffer for each cpu using the sizes and
attributes specified.  The created channel buffer files
will be named base_filename0...base_filenameN-1.  File
permissions will be S_IRUSR.
.TH "relay_switch_subbuf" 9 "relay_switch_subbuf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_switch_subbuf \-  switch to a new sub-buffer
.SH SYNOPSIS
.B "size_t" relay_switch_subbuf
.BI "(struct rchan_buf *" buf ","
.BI "size_t " length ");"
.SH ARGUMENTS
.IP "buf" 12
 channel buffer
.IP "length" 12
 size of current event
.SH "DESCRIPTION"
Returns either the length passed in or 0 if full.
Performs sub-buffer-switch tasks such as invoking callbacks,
updating padding counts, waking up readers, etc.
.TH "relay_subbufs_consumed" 9 "relay_subbufs_consumed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_subbufs_consumed \-  update the buffer's sub-buffers-consumed count
.SH SYNOPSIS
.B "void" relay_subbufs_consumed
.BI "(struct rchan *" chan ","
.BI "unsigned int " cpu ","
.BI "size_t " subbufs_consumed ");"
.SH ARGUMENTS
.IP "chan" 12
 the channel
.IP "cpu" 12
 the cpu associated with the channel buffer to update
.IP "subbufs_consumed" 12
 number of sub-buffers to add to current buf's count
.SH "DESCRIPTION"
Adds to the channel buffer's consumed sub-buffer count.
subbufs_consumed should be the number of sub-buffers newly consumed,
not the total consumed.
.SH "NOTE"
 kernel clients don't need to call this function if the channel
mode is 'overwrite'.
.TH "relay_destroy_channel" 9 "relay_destroy_channel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_destroy_channel \-  free the channel struct
.SH SYNOPSIS
.B "void" relay_destroy_channel
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
-- undescribed --
.SH "DESCRIPTION"

Should only be called from \fBkref_put\fP.
.TH "relay_close" 9 "relay_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_close \-  close the channel
.SH SYNOPSIS
.B "void" relay_close
.BI "(struct rchan *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 the channel
.SH "DESCRIPTION"
Closes all channel buffers and frees the channel.
.TH "relay_flush" 9 "relay_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_flush \-  close the channel
.SH SYNOPSIS
.B "void" relay_flush
.BI "(struct rchan *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 the channel
.SH "DESCRIPTION"
Flushes all channel buffers i.e. forces buffer switch.
.TH "relay_mmap_buf" 9 "relay_mmap_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_mmap_buf \-  mmap channel buffer to process address space
.SH SYNOPSIS
.B "int" relay_mmap_buf
.BI "(struct rchan_buf *" buf ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "buf" 12
 relay channel buffer
.IP "vma" 12
 vm_area_struct describing memory to be mapped
.SH "DESCRIPTION"
Returns 0 if ok, negative on error

Caller should already have grabbed mmap_sem.
.TH "relay_alloc_buf" 9 "relay_alloc_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_alloc_buf \-  allocate a channel buffer
.SH SYNOPSIS
.B "void *" relay_alloc_buf
.BI "(struct rchan_buf *" buf ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "buf" 12
 the buffer struct
.IP "size" 12
 total size of the buffer
.SH "DESCRIPTION"
Returns a pointer to the resulting buffer, NULL if unsuccessful
.TH "relay_create_buf" 9 "relay_create_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_create_buf \-  allocate and initialize a channel buffer
.SH SYNOPSIS
.B "struct rchan_buf *" relay_create_buf
.BI "(struct rchan *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
-- undescribed --
.SH "DESCRIPTION"
Returns channel buffer if successful, NULL otherwise
.TH "relay_destroy_buf" 9 "relay_destroy_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_destroy_buf \-  destroy an rchan_buf struct and associated buffer
.SH SYNOPSIS
.B "void" relay_destroy_buf
.BI "(struct rchan_buf *" buf ");"
.SH ARGUMENTS
.IP "buf" 12
 the buffer struct
.TH "relay_remove_buf" 9 "relay_remove_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
relay_remove_buf \-  remove a channel buffer
.SH SYNOPSIS
.B "void" relay_remove_buf
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
-- undescribed --
.SH "DESCRIPTION"

Removes the file from the relayfs fileystem, which also frees the
rchan_buf_struct and the channel buffer.  Should only be called from
\fBkref_put\fP.
.TH "nfs_get_user_pages" 9 "nfs_get_user_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_get_user_pages \-  find and set up pages underlying user's buffer
.SH SYNOPSIS
.B "int" nfs_get_user_pages
.BI "(int " rw ","
.BI "unsigned long " user_addr ","
.BI "size_t " size ","
.BI "struct page ***" pages ");"
.SH ARGUMENTS
.IP "rw" 12
-- undescribed --
.IP "user_addr" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.IP "pages" 12
 returned array of page struct pointers underlying user's buffer
.SH "RW"
 direction (read or write)
.SH "USER_ADDR"
 starting address of this segment of user's buffer
.SH "COUNT"
 size of this segment
.TH "nfs_free_user_pages" 9 "nfs_free_user_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_free_user_pages \-  tear down page struct array
.SH SYNOPSIS
.B "void" nfs_free_user_pages
.BI "(struct page **" pages ","
.BI "int " npages ","
.BI "int " do_dirty ");"
.SH ARGUMENTS
.IP "pages" 12
 array of page struct pointers underlying target buffer
.IP "npages" 12
 number of pages in the array
.IP "do_dirty" 12
 dirty the pages as we release them
.TH "nfs_direct_req_release" 9 "nfs_direct_req_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_req_release \-  release  nfs_direct_req structure for direct read
.SH SYNOPSIS
.B "void" nfs_direct_req_release
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
 kref object embedded in an nfs_direct_req structure
.TH "nfs_direct_read_alloc" 9 "nfs_direct_read_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_read_alloc \-  allocate nfs_read_data structures for direct read
.SH SYNOPSIS
.B "struct nfs_direct_req *" nfs_direct_read_alloc
.BI "(size_t " nbytes ","
.BI "unsigned int " rsize ");"
.SH ARGUMENTS
.IP "nbytes" 12
-- undescribed --
.IP "rsize" 12
 local rsize setting
.SH "DESCRIPTION"
Note we also set the number of requests we have in the dreq when we are
done.  This prevents races with I/O completion so we will always wait
until all requests have been dispatched and completed.
.TH "nfs_direct_read_result" 9 "nfs_direct_read_result" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_read_result \-  handle a read reply for a direct read request
.SH SYNOPSIS
.B "void" nfs_direct_read_result
.BI "(struct nfs_read_data *" data ","
.BI "int " status ");"
.SH ARGUMENTS
.IP "data" 12
 address of NFS READ operation control block
.IP "status" 12
 status of this NFS READ operation
.SH "DESCRIPTION"
We must hold a reference to all the pages in this direct read request
until the RPCs complete.  This could be long *after* we are woken up in
nfs_direct_read_wait (for instance, if someone hits ^C on a slow server).
.TH "nfs_direct_read_schedule" 9 "nfs_direct_read_schedule" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_read_schedule \-  dispatch NFS READ operations for a direct read
.SH SYNOPSIS
.B "void" nfs_direct_read_schedule
.BI "(struct nfs_direct_req *" dreq ","
.BI "struct inode *" inode ","
.BI "struct nfs_open_context *" ctx ","
.BI "unsigned long " user_addr ","
.BI "size_t " count ","
.BI "loff_t " file_offset ");"
.SH ARGUMENTS
.IP "dreq" 12
 address of nfs_direct_req struct for this request
.IP "inode" 12
 target inode
.IP "ctx" 12
 target file open context
.IP "user_addr" 12
 starting address of this segment of user's buffer
.IP "count" 12
 size of this segment
.IP "file_offset" 12
 offset in file to begin the operation
.SH "DESCRIPTION"
For each nfs_read_data struct that was allocated on the list, dispatch
an NFS READ operation
.TH "nfs_direct_read_wait" 9 "nfs_direct_read_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_read_wait \-  wait for I/O completion for direct reads
.SH SYNOPSIS
.B "ssize_t" nfs_direct_read_wait
.BI "(struct nfs_direct_req *" dreq ","
.BI "int " intr ");"
.SH ARGUMENTS
.IP "dreq" 12
 request on which we are to wait
.IP "intr" 12
 whether or not this wait can be interrupted
.SH "DESCRIPTION"
Collects and returns the final error value/byte-count.
.TH "nfs_direct_read_seg" 9 "nfs_direct_read_seg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_read_seg \-  Read in one iov segment.  Generate separate
.SH SYNOPSIS
.B "ssize_t" nfs_direct_read_seg
.BI "(struct inode *" inode ","
.BI "struct nfs_open_context *" ctx ","
.BI "unsigned long " user_addr ","
.BI "size_t " count ","
.BI "loff_t " file_offset ","
.BI "struct page **" pages ","
.BI "unsigned int " nr_pages ");"
.SH ARGUMENTS
.IP "inode" 12
 target inode
.IP "ctx" 12
 target file open context
.IP "user_addr" 12
 starting address of this segment of user's buffer
.IP "count" 12
 size of this segment
.IP "file_offset" 12
 offset in file to begin the operation
.IP "pages" 12
 array of addresses of page structs defining user's buffer
.IP "nr_pages" 12
 number of pages in the array
.SH "DESCRIPTION"
read RPCs for each "rsize" bytes.
.TH "nfs_direct_read" 9 "nfs_direct_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_read \-  For each iov segment, map the user's buffer
.SH SYNOPSIS
.B "ssize_t" nfs_direct_read
.BI "(struct inode *" inode ","
.BI "struct nfs_open_context *" ctx ","
.BI "const struct iovec *" iov ","
.BI "loff_t " file_offset ","
.BI "unsigned long " nr_segs ");"
.SH ARGUMENTS
.IP "inode" 12
 target inode
.IP "ctx" 12
 target file open context
.IP "iov" 12
 array of vectors that define I/O buffer
.IP "file_offset" 12
-- undescribed --
.IP "nr_segs" 12
-- undescribed --
.SH "DESCRIPTION"
then generate read RPCs.
.SH "FILE_OFFSET"
 offset in file to begin the operation
.SH "NR_SEGS"
 size of iovec array

We've already pushed out any non-direct writes so that this read
will see them when we read from the server.
.TH "nfs_direct_write_seg" 9 "nfs_direct_write_seg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_write_seg \-  Write out one iov segment.  Generate separate
.SH SYNOPSIS
.B "ssize_t" nfs_direct_write_seg
.BI "(struct inode *" inode ","
.BI "struct nfs_open_context *" ctx ","
.BI "unsigned long " user_addr ","
.BI "size_t " count ","
.BI "loff_t " file_offset ","
.BI "struct page **" pages ","
.BI "int " nr_pages ");"
.SH ARGUMENTS
.IP "inode" 12
 target inode
.IP "ctx" 12
 target file open context
.IP "user_addr" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "file_offset" 12
-- undescribed --
.IP "pages" 12
 array of addresses of page structs defining user's buffer
.IP "nr_pages" 12
-- undescribed --
.SH "DESCRIPTION"
write RPCs for each "wsize" bytes, then commit.
.SH "USER_ADDR"
 starting address of this segment of user's buffer
.SH "COUNT"
 size of this segment
.SH "FILE_OFFSET"
 offset in file to begin the operation
.SH "NR_PAGES"
 size of pages array
.TH "nfs_direct_write" 9 "nfs_direct_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_write \-  For each iov segment, map the user's buffer
.SH SYNOPSIS
.B "ssize_t" nfs_direct_write
.BI "(struct inode *" inode ","
.BI "struct nfs_open_context *" ctx ","
.BI "const struct iovec *" iov ","
.BI "loff_t " file_offset ","
.BI "unsigned long " nr_segs ");"
.SH ARGUMENTS
.IP "inode" 12
 target inode
.IP "ctx" 12
 target file open context
.IP "iov" 12
 array of vectors that define I/O buffer
.IP "file_offset" 12
-- undescribed --
.IP "nr_segs" 12
-- undescribed --
.SH "DESCRIPTION"
then generate write and commit RPCs.
.SH "FILE_OFFSET"
 offset in file to begin the operation
.SH "NR_SEGS"
 size of iovec array

Upon return, generic_file_direct_IO invalidates any cached pages
that non-direct readers might access, so they will pick up these
writes immediately.
.TH "nfs_direct_IO" 9 "nfs_direct_IO" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_direct_IO \-  NFS address space operation for direct I/O
.SH SYNOPSIS
.B "ssize_t" nfs_direct_IO
.BI "(int " rw ","
.BI "struct kiocb *" iocb ","
.BI "const struct iovec *" iov ","
.BI "loff_t " file_offset ","
.BI "unsigned long " nr_segs ");"
.SH ARGUMENTS
.IP "rw" 12
-- undescribed --
.IP "iocb" 12
 target I/O control block
.IP "iov" 12
 array of vectors that define I/O buffer
.IP "file_offset" 12
-- undescribed --
.IP "nr_segs" 12
-- undescribed --
.SH "RW"
 direction (read or write)
.SH "FILE_OFFSET"
 offset in file to begin the operation
.SH "NR_SEGS"
 size of iovec array
.TH "nfs_file_direct_read" 9 "nfs_file_direct_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_file_direct_read \-  file direct read operation for NFS files
.SH SYNOPSIS
.B "ssize_t" nfs_file_direct_read
.BI "(struct kiocb *" iocb ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t " pos ");"
.SH ARGUMENTS
.IP "iocb" 12
 target I/O control block
.IP "buf" 12
 user's buffer into which to read data
.IP "count" 12
-- undescribed --
.IP "pos" 12
-- undescribed --
.SH "COUNT"
 number of bytes to read
.SH "POS"
 byte offset in file where reading starts

We use this function for direct reads instead of calling
\fBgeneric_file_aio_read\fP in order to avoid gfar's check to see if
the request starts before the end of the file.  For that check
to work, we must generate a GETATTR before each direct read, and
even then there is a window between the GETATTR and the subsequent
READ where the file size could change.  So our preference is simply
to do all reads the application wants, and the server will take
care of managing the end of file boundary.

This function also eliminates unnecessarily updating the file's
atime locally, as the NFS server sets the file's atime, and this
client must read the updated atime from the server back into its
cache.
.TH "nfs_file_direct_write" 9 "nfs_file_direct_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_file_direct_write \-  file direct write operation for NFS files
.SH SYNOPSIS
.B "ssize_t" nfs_file_direct_write
.BI "(struct kiocb *" iocb ","
.BI "const char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t " pos ");"
.SH ARGUMENTS
.IP "iocb" 12
 target I/O control block
.IP "buf" 12
 user's buffer from which to write data
.IP "count" 12
-- undescribed --
.IP "pos" 12
-- undescribed --
.SH "COUNT"
 number of bytes to write
.SH "POS"
 byte offset in file where writing starts

We use this function for direct writes instead of calling
\fBgeneric_file_aio_write\fP in order to avoid taking the inode
semaphore and updating the i_size.  The NFS server will set
the new i_size and this client must read the updated size
back into its cache.  We let the server do generic write
parameter checking and report problems.

We also avoid an unnecessary invocation of \fBgeneric_osync_inode\fP,
as it is fairly meaningless to sync the metadata of an NFS file.

We eliminate local atime updates, see direct read above.

We avoid unnecessary page cache invalidations for normal cached
readers of this file.

Note that O_APPEND is not supported for NFS direct writes, as there
is no atomic O_APPEND write facility in the NFS protocol.
.TH "nfs_detach_unlinkdata" 9 "nfs_detach_unlinkdata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_detach_unlinkdata \-  Remove asynchronous unlink from global list
.SH SYNOPSIS
.B "void" nfs_detach_unlinkdata
.BI "(struct nfs_unlinkdata *" data ");"
.SH ARGUMENTS
.IP "data" 12
 pointer to descriptor
.TH "nfs_put_unlinkdata" 9 "nfs_put_unlinkdata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_put_unlinkdata \-  release data from a sillydelete operation.
.SH SYNOPSIS
.B "void" nfs_put_unlinkdata
.BI "(struct nfs_unlinkdata *" data ");"
.SH ARGUMENTS
.IP "data" 12
 pointer to unlink structure.
.TH "nfs_copy_dname" 9 "nfs_copy_dname" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_copy_dname \-  copy dentry name to data structure
.SH SYNOPSIS
.B "void" nfs_copy_dname
.BI "(struct dentry *" dentry ","
.BI "struct nfs_unlinkdata *" data ");"
.SH ARGUMENTS
.IP "dentry" 12
 pointer to dentry
.IP "data" 12
 nfs_unlinkdata
.TH "nfs_async_unlink_init" 9 "nfs_async_unlink_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_async_unlink_init \-  Initialize the RPC info
.SH SYNOPSIS
.B "void" nfs_async_unlink_init
.BI "(struct rpc_task *" task ");"
.SH ARGUMENTS
.IP "task" 12
 rpc_task of the sillydelete
.SH "DESCRIPTION"
We delay initializing RPC info until after the call to \fBdentry_iput\fP
in order to minimize races against \fBrename\fP.
.TH "nfs_async_unlink_done" 9 "nfs_async_unlink_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_async_unlink_done \-  Sillydelete post-processing
.SH SYNOPSIS
.B "void" nfs_async_unlink_done
.BI "(struct rpc_task *" task ");"
.SH ARGUMENTS
.IP "task" 12
 rpc_task of the sillydelete
.SH "DESCRIPTION"
Do the directory attribute update.
.TH "nfs_async_unlink_release" 9 "nfs_async_unlink_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_async_unlink_release \-  Release the sillydelete data.
.SH SYNOPSIS
.B "void" nfs_async_unlink_release
.BI "(struct rpc_task *" task ");"
.SH ARGUMENTS
.IP "task" 12
 rpc_task of the sillydelete
.SH "DESCRIPTION"
We need to call nfs_put_unlinkdata as a 'tk_release' task since the
rpc_task would be freed too.
.TH "nfs_async_unlink" 9 "nfs_async_unlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_async_unlink \-  asynchronous unlinking of a file
.SH SYNOPSIS
.B "int" nfs_async_unlink
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry to unlink
.TH "nfs_complete_unlink" 9 "nfs_complete_unlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_complete_unlink \-  Initialize completion of the sillydelete
.SH SYNOPSIS
.B "void" nfs_complete_unlink
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry to delete
.SH "DESCRIPTION"
Since we're most likely to be called by \fBdentry_iput\fP, we
only use the dentry to find the sillydelete. We then copy the name
into the qstr.
.TH "nfs_create_request" 9 "nfs_create_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_create_request \-  Create an NFS read/write request.
.SH SYNOPSIS
.B "struct nfs_page *" nfs_create_request
.BI "(struct nfs_open_context *" ctx ","
.BI "struct inode *" inode ","
.BI "struct page *" page ","
.BI "unsigned int " offset ","
.BI "unsigned int " count ");"
.SH ARGUMENTS
.IP "ctx" 12
-- undescribed --
.IP "inode" 12
 inode to which the request is attached
.IP "page" 12
 page to write
.IP "offset" 12
 starting offset within the page for the write
.IP "count" 12
 number of bytes to read/write
.SH "DESCRIPTION"
The page must be locked by the caller. This makes sure we never
create two different requests for the same page, and avoids
a possible deadlock when we reach the hard limit on the number
of dirty pages.
User should ensure it is safe to sleep in this function.
.TH "nfs_unlock_request" 9 "nfs_unlock_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_unlock_request \-  Unlock request and wake up sleepers.
.SH SYNOPSIS
.B "void" nfs_unlock_request
.BI "(struct nfs_page *" req ");"
.SH ARGUMENTS
.IP "req" 12
-- undescribed --
.TH "nfs_set_page_writeback_locked" 9 "nfs_set_page_writeback_locked" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_set_page_writeback_locked \-  Lock a request for writeback
.SH SYNOPSIS
.B "int" nfs_set_page_writeback_locked
.BI "(struct nfs_page *" req ");"
.SH ARGUMENTS
.IP "req" 12
-- undescribed --
.TH "nfs_clear_page_writeback" 9 "nfs_clear_page_writeback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_clear_page_writeback \-  Unlock request and wake up sleepers
.SH SYNOPSIS
.B "void" nfs_clear_page_writeback
.BI "(struct nfs_page *" req ");"
.SH ARGUMENTS
.IP "req" 12
-- undescribed --
.TH "nfs_clear_request" 9 "nfs_clear_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_clear_request \-  Free up all resources allocated to the request
.SH SYNOPSIS
.B "void" nfs_clear_request
.BI "(struct nfs_page *" req ");"
.SH ARGUMENTS
.IP "req" 12
.SH "DESCRIPTION"
Release page resources associated with a write request after it
has completed.
.TH "nfs_release_request" 9 "nfs_release_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_release_request \-  Release the count on an NFS read/write request
.SH SYNOPSIS
.B "void" nfs_release_request
.BI "(struct nfs_page *" req ");"
.SH ARGUMENTS
.IP "req" 12
 request to release
.SH "NOTE"
 Should never be called with the spinlock held!
.TH "nfs_wait_on_request" 9 "nfs_wait_on_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_wait_on_request \-  Wait for a request to complete.
.SH SYNOPSIS
.B "int" nfs_wait_on_request
.BI "(struct nfs_page *" req ");"
.SH ARGUMENTS
.IP "req" 12
 request to wait upon.
.SH "DESCRIPTION"
Interruptible by signals only if mounted with intr flag.
The user is responsible for holding a count on the request.
.TH "nfs_coalesce_requests" 9 "nfs_coalesce_requests" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_coalesce_requests \-  Split coalesced requests out from a list.
.SH SYNOPSIS
.B "int" nfs_coalesce_requests
.BI "(struct list_head *" head ","
.BI "struct list_head *" dst ","
.BI "unsigned int " nmax ");"
.SH ARGUMENTS
.IP "head" 12
 source list
.IP "dst" 12
 destination list
.IP "nmax" 12
 maximum number of requests to coalesce
.SH "DESCRIPTION"
Moves a maximum of 'nmax' elements from one list to another.
The elements are checked to ensure that they form a contiguous set
of pages, and that the RPC credentials are the same.
.TH "nfs_scan_lock_dirty" 9 "nfs_scan_lock_dirty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_scan_lock_dirty \-  Scan the radix tree for dirty requests
.SH SYNOPSIS
.B "int" nfs_scan_lock_dirty
.BI "(struct nfs_inode *" nfsi ","
.BI "struct list_head *" dst ","
.BI "unsigned long " idx_start ","
.BI "unsigned int " npages ");"
.SH ARGUMENTS
.IP "nfsi" 12
 NFS inode
.IP "dst" 12
 Destination list
.IP "idx_start" 12
 lower bound of page-&gt;index to scan
.IP "npages" 12
 idx_start + npages sets the upper bound to scan.
.SH "DESCRIPTION"
Moves elements from one of the inode request lists.
If the number of requests is set to 0, the entire address_space
starting at index idx_start, is scanned.
The requests are *not* checked to ensure that they form a contiguous set.
You must be holding the inode's req_lock when calling this function
.TH "nfs_scan_list" 9 "nfs_scan_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_scan_list \-  Scan a list for matching requests
.SH SYNOPSIS
.B "int" nfs_scan_list
.BI "(struct list_head *" head ","
.BI "struct list_head *" dst ","
.BI "unsigned long " idx_start ","
.BI "unsigned int " npages ");"
.SH ARGUMENTS
.IP "head" 12
 One of the NFS inode request lists
.IP "dst" 12
 Destination list
.IP "idx_start" 12
 lower bound of page-&gt;index to scan
.IP "npages" 12
 idx_start + npages sets the upper bound to scan.
.SH "DESCRIPTION"
Moves elements from one of the inode request lists.
If the number of requests is set to 0, the entire address_space
starting at index idx_start, is scanned.
The requests are *not* checked to ensure that they form a contiguous set.
You must be holding the inode's req_lock when calling this function
.TH "nfs_revalidate_file" 9 "nfs_revalidate_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_revalidate_file \-  Revalidate the page cache \\\amp; related metadata
.SH SYNOPSIS
.B "int" nfs_revalidate_file
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to inode struct
\fIfile\fP - pointer to file
.TH "nfs_revalidate_file_size" 9 "nfs_revalidate_file_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_revalidate_file_size \-  Revalidate the file size
.SH SYNOPSIS
.B "int" nfs_revalidate_file_size
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to inode struct
\fIfile\fP - pointer to struct file

Revalidates the file length. This is basically a wrapper around
\fBnfs_revalidate_inode\fP that takes into account the fact that we may
have cached writes (in which case we don't care about the server's
idea of what the file length is), or O_DIRECT (in which case we
shouldn't trust the cache).
.TH "nfs_setattr_update_inode" 9 "nfs_setattr_update_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_setattr_update_inode \-  Update inode metadata after a setattr call.
.SH SYNOPSIS
.B "void" nfs_setattr_update_inode
.BI "(struct inode *" inode ","
.BI "struct iattr *" attr ");"
.SH ARGUMENTS
.IP "inode" 12
 pointer to struct inode
.IP "attr" 12
 pointer to struct iattr
.SH "NOTE"
 we do this in the *proc.c in order to ensure that
it works for things like exclusive creates too.
.TH "nfs_revalidate_inode" 9 "nfs_revalidate_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_revalidate_inode \-  Revalidate the inode attributes
.SH SYNOPSIS
.B "int" nfs_revalidate_inode
.BI "(struct nfs_server *" server ","
.BI "struct inode *" inode ");"
.SH ARGUMENTS
.IP "server" 12
-- undescribed --
.IP "inode" 12
-- undescribed --
.SH "DESCRIPTION"
\fIserver\fP - pointer to nfs_server struct
\fIinode\fP - pointer to inode struct

Updates inode attribute information by retrieving the data from the server.
.TH "nfs_revalidate_mapping" 9 "nfs_revalidate_mapping" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_revalidate_mapping \-  Revalidate the pagecache
.SH SYNOPSIS
.B "void" nfs_revalidate_mapping
.BI "(struct inode *" inode ","
.BI "struct address_space *" mapping ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "mapping" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to host inode
\fImapping\fP - pointer to mapping
.TH "nfs_begin_data_update" 9 "nfs_begin_data_update" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_begin_data_update \- 
.SH SYNOPSIS
.B "void" nfs_begin_data_update
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to inode
Declare that a set of operations will update file data on the server
.TH "nfs_end_data_update" 9 "nfs_end_data_update" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_end_data_update \- 
.SH SYNOPSIS
.B "void" nfs_end_data_update
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to inode
Declare end of the operations that will update file data
This will mark the inode as immediately needing revalidation
of its attribute cache.
.TH "nfs_refresh_inode" 9 "nfs_refresh_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfs_refresh_inode \-  verify consistency of the inode attribute cache
.SH SYNOPSIS
.B "int" nfs_refresh_inode
.BI "(struct inode *" inode ","
.BI "struct nfs_fattr *" fattr ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "fattr" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - pointer to inode
\fIfattr\fP - updated attributes

Verifies the attribute cache. If we have just changed the attributes,
so that fattr carries weak cache consistency data, then it may
also update the ctime/mtime/change_attribute.
.TH "inotify_inode_queue_event" 9 "inotify_inode_queue_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inotify_inode_queue_event \-  queue an event to all watches on this inode
.SH SYNOPSIS
.B "void" inotify_inode_queue_event
.BI "(struct inode *" inode ","
.BI "u32 " mask ","
.BI "u32 " cookie ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "inode" 12
 inode event is originating from
.IP "mask" 12
 event mask describing this event
.IP "cookie" 12
 cookie for synchronization, or zero
.IP "name" 12
 filename, if any
.TH "inotify_dentry_parent_queue_event" 9 "inotify_dentry_parent_queue_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inotify_dentry_parent_queue_event \-  queue an event to a dentry's parent
.SH SYNOPSIS
.B "void" inotify_dentry_parent_queue_event
.BI "(struct dentry *" dentry ","
.BI "u32 " mask ","
.BI "u32 " cookie ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dentry" 12
 the dentry in question, we queue against this dentry's parent
.IP "mask" 12
 event mask describing this event
.IP "cookie" 12
 cookie for synchronization, or zero
.IP "name" 12
 filename, if any
.TH "inotify_get_cookie" 9 "inotify_get_cookie" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inotify_get_cookie \-  return a unique cookie for use in synchronizing events.
.SH SYNOPSIS
.B "u32" inotify_get_cookie
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "inotify_unmount_inodes" 9 "inotify_unmount_inodes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inotify_unmount_inodes \-  an sb is unmounting.  handle any watched inodes.
.SH SYNOPSIS
.B "void" inotify_unmount_inodes
.BI "(struct list_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list of inodes being unmounted (sb-&gt;s_inodes)
.SH "DESCRIPTION"
Called with inode_lock held, protecting the unmounting super block's list
of inodes, and with iprune_sem held, keeping \fBshrink_icache_memory\fP at bay.
We temporarily drop inode_lock, however, and CAN block.
.TH "inotify_inode_is_dead" 9 "inotify_inode_is_dead" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inotify_inode_is_dead \-  an inode has been deleted, cleanup any watches
.SH SYNOPSIS
.B "void" inotify_inode_is_dead
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode that is about to be removed
.TH "ncp_getopt" 9 "ncp_getopt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ncp_getopt \-  option parser
.SH SYNOPSIS
.B "int" ncp_getopt
.BI "(const char *" caller ","
.BI "char **" options ","
.BI "const struct ncp_option *" opts ","
.BI "char **" optopt ","
.BI "char **" optarg ","
.BI "unsigned long *" value ");"
.SH ARGUMENTS
.IP "caller" 12
 name of the caller, for error messages
.IP "options" 12
 the options string
.IP "opts" 12
 an array of &amp;struct option entries controlling parser operations
.IP "optopt" 12
 output; will contain the current option
.IP "optarg" 12
 output; will contain the value (if one exists)
.IP "value" 12
 output; may be NULL; will be overwritten with the integer value
of the current argument.
.SH "DESCRIPTION"
Helper to parse options on the format used by mount ("a=b,c=d,e,f").
Returns opts-&gt;val if a matching entry in the 'opts' array is found,
0 when no more tokens are found, -1 if an error is encountered.
.TH "v9fs_fd_recv" 9 "v9fs_fd_recv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fd_recv \-  receive from a socket
.SH SYNOPSIS
.B "int" v9fs_fd_recv
.BI "(struct v9fs_transport *" trans ","
.BI "void *" v ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "trans" 12
-- undescribed --
.IP "v" 12
 buffer to receive data into
.IP "len" 12
 size of receive buffer
.TH "v9fs_fd_send" 9 "v9fs_fd_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fd_send \-  send to a socket
.SH SYNOPSIS
.B "int" v9fs_fd_send
.BI "(struct v9fs_transport *" trans ","
.BI "void *" v ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "trans" 12
-- undescribed --
.IP "v" 12
 buffer to send data from
.IP "len" 12
 size of send buffer
.TH "v9fs_fd_init" 9 "v9fs_fd_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fd_init \-  initialize file descriptor transport
.SH SYNOPSIS
.B "int" v9fs_fd_init
.BI "(struct v9fs_session_info *" v9ses ","
.BI "const char *" addr ","
.BI "char *" data ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session information
.IP "addr" 12
 address of server to mount
.IP "data" 12
 mount options
.TH "v9fs_fd_close" 9 "v9fs_fd_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fd_close \-  shutdown file descriptor
.SH SYNOPSIS
.B "void" v9fs_fd_close
.BI "(struct v9fs_transport *" trans ");"
.SH ARGUMENTS
.IP "trans" 12
 private socket structure
.TH "v9fs_size_stat" 9 "v9fs_size_stat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_size_stat \-  calculate the size of a variable length stat struct
.SH SYNOPSIS
.B "int" v9fs_size_stat
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_stat *" stat ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session information
.IP "stat" 12
 metadata (stat) structure
.TH "serialize_stat" 9 "serialize_stat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serialize_stat \-  safely format a stat structure for transmission
.SH SYNOPSIS
.B "int" serialize_stat
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_stat *" stat ","
.BI "struct cbuf *" bufp ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info
.IP "stat" 12
 metadata (stat) structure
.IP "bufp" 12
 buffer to serialize structure into
.TH "deserialize_stat" 9 "deserialize_stat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
deserialize_stat \-  safely decode a recieved metadata (stat) structure
.SH SYNOPSIS
.B "int" deserialize_stat
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct cbuf *" bufp ","
.BI "struct v9fs_stat *" stat ","
.BI "struct cbuf *" dbufp ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info
.IP "bufp" 12
 buffer to deserialize
.IP "stat" 12
 metadata (stat) structure
.IP "dbufp" 12
 buffer to deserialize variable strings into
.TH "deserialize_statb" 9 "deserialize_statb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
deserialize_statb \-  wrapper for decoding a received metadata structure
.SH SYNOPSIS
.B "struct v9fs_stat *" deserialize_statb
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct cbuf *" bufp ","
.BI "struct cbuf *" dbufp ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info
.IP "bufp" 12
 buffer to deserialize
.IP "dbufp" 12
 buffer to deserialize variable strings into
.TH "v9fs_deserialize_stat" 9 "v9fs_deserialize_stat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_deserialize_stat \-  decode a received metadata structure
.SH SYNOPSIS
.B "int" v9fs_deserialize_stat
.BI "(struct v9fs_session_info *" v9ses ","
.BI "void *" buf ","
.BI "u32 " buflen ","
.BI "struct v9fs_stat *" stat ","
.BI "u32 " statlen ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info
.IP "buf" 12
 buffer to deserialize
.IP "buflen" 12
 length of received buffer
.IP "stat" 12
 metadata structure to decode into
.IP "statlen" 12
 length of destination metadata structure
.TH "v9fs_deserialize_fcall" 9 "v9fs_deserialize_fcall" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_deserialize_fcall \-  unmarshal a response
.SH SYNOPSIS
.B "int" v9fs_deserialize_fcall
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " msgsize ","
.BI "void *" buf ","
.BI "u32 " buflen ","
.BI "struct v9fs_fcall *" rcall ","
.BI "int " rcalllen ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session information
.IP "msgsize" 12
 size of rcall message
.IP "buf" 12
 recieved buffer
.IP "buflen" 12
 length of received buffer
.IP "rcall" 12
 fcall structure to populate
.IP "rcalllen" 12
 length of fcall structure to populate
.TH "v9fs_clear_inode" 9 "v9fs_clear_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_clear_inode \-  release an inode
.SH SYNOPSIS
.B "void" v9fs_clear_inode
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to release
.TH "v9fs_set_super" 9 "v9fs_set_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_set_super \-  set the superblock
.SH SYNOPSIS
.B "int" v9fs_set_super
.BI "(struct super_block *" s ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "s" 12
 super block
.IP "data" 12
 file system specific data
.TH "v9fs_fill_super" 9 "v9fs_fill_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fill_super \-  populate superblock with info
.SH SYNOPSIS
.B "void" v9fs_fill_super
.BI "(struct super_block *" sb ","
.BI "struct v9fs_session_info *" v9ses ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock
.IP "v9ses" 12
 session information
.IP "flags" 12
-- undescribed --
.TH "v9fs_get_sb" 9 "v9fs_get_sb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_get_sb \-  mount a superblock
.SH SYNOPSIS
.B "struct super_block *" v9fs_get_sb
.BI "(struct file_system_type *" fs_type ","
.BI "int " flags ","
.BI "const char *" dev_name ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "fs_type" 12
 file system type
.IP "flags" 12
 mount flags
.IP "dev_name" 12
 device name that was mounted
.IP "data" 12
 mount options
.TH "v9fs_kill_super" 9 "v9fs_kill_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_kill_super \-  Kill Superblock
.SH SYNOPSIS
.B "void" v9fs_kill_super
.BI "(struct super_block *" s ");"
.SH ARGUMENTS
.IP "s" 12
 superblock
.TH "v9fs_show_options" 9 "v9fs_show_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_show_options \-  Show mount options in /proc/mounts
.SH SYNOPSIS
.B "int" v9fs_show_options
.BI "(struct seq_file *" m ","
.BI "struct vfsmount *" mnt ");"
.SH ARGUMENTS
.IP "m" 12
 seq_file to write to
.IP "mnt" 12
 mount descriptor
.TH "unixmode2p9mode" 9 "unixmode2p9mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unixmode2p9mode \-  convert unix mode bits to plan 9
.SH SYNOPSIS
.B "int" unixmode2p9mode
.BI "(struct v9fs_session_info *" v9ses ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "v9ses" 12
 v9fs session information
.IP "mode" 12
 mode to convert
.TH "p9mode2unixmode" 9 "p9mode2unixmode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
p9mode2unixmode \-  convert plan9 mode bits to unix mode bits
.SH SYNOPSIS
.B "int" p9mode2unixmode
.BI "(struct v9fs_session_info *" v9ses ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "v9ses" 12
 v9fs session information
.IP "mode" 12
 mode to convert
.TH "v9fs_blank_mistat" 9 "v9fs_blank_mistat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_blank_mistat \-  helper function to setup a 9P stat structure
.SH SYNOPSIS
.B "void" v9fs_blank_mistat
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_stat *" mistat ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P session info (for determining extended mode)
.IP "mistat" 12
 structure to initialize
.TH "v9fs_mistat2unix" 9 "v9fs_mistat2unix" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_mistat2unix \-  convert mistat to unix stat
.SH SYNOPSIS
.B "void" v9fs_mistat2unix
.BI "(struct v9fs_stat *" mistat ","
.BI "struct stat *" buf ","
.BI "struct super_block *" sb ");"
.SH ARGUMENTS
.IP "mistat" 12
 Plan 9 metadata (mistat) structure
.IP "buf" 12
 unix metadata (stat) structure to populate
.IP "sb" 12
 superblock
.TH "v9fs_get_inode" 9 "v9fs_get_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_get_inode \-  helper function to setup an inode
.SH SYNOPSIS
.B "struct inode *" v9fs_get_inode
.BI "(struct super_block *" sb ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock
.IP "mode" 12
 mode to setup inode with
.TH "v9fs_create" 9 "v9fs_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_create \-  helper function to create files and directories
.SH SYNOPSIS
.B "int" v9fs_create
.BI "(struct inode *" dir ","
.BI "struct dentry *" file_dentry ","
.BI "unsigned int " perm ","
.BI "unsigned int " open_mode ");"
.SH ARGUMENTS
.IP "dir" 12
 directory inode file is being created in
.IP "file_dentry" 12
 dentry file is being created in
.IP "perm" 12
 permissions file is being created with
.IP "open_mode" 12
 resulting open mode for file
.TH "v9fs_remove" 9 "v9fs_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_remove \-  helper function to remove files and directories
.SH SYNOPSIS
.B "int" v9fs_remove
.BI "(struct inode *" dir ","
.BI "struct dentry *" file ","
.BI "int " rmdir ");"
.SH ARGUMENTS
.IP "dir" 12
 directory inode that is being deleted
.IP "file" 12
  dentry that is being deleted
.IP "rmdir" 12
 removing a directory
.TH "v9fs_vfs_create" 9 "v9fs_vfs_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_create \-  VFS hook to create files
.SH SYNOPSIS
.B "int" v9fs_vfs_create
.BI "(struct inode *" inode ","
.BI "struct dentry *" dentry ","
.BI "int " perm ","
.BI "struct nameidata *" nd ");"
.SH ARGUMENTS
.IP "inode" 12
 directory inode that is being deleted
.IP "dentry" 12
  dentry that is being deleted
.IP "perm" 12
 create permissions
.IP "nd" 12
 path information
.TH "v9fs_vfs_mkdir" 9 "v9fs_vfs_mkdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_mkdir \-  VFS mkdir hook to create a directory
.SH SYNOPSIS
.B "int" v9fs_vfs_mkdir
.BI "(struct inode *" inode ","
.BI "struct dentry *" dentry ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "inode" 12
  inode that is being unlinked
.IP "dentry" 12
 dentry that is being unlinked
.IP "mode" 12
 mode for new directory
.TH "v9fs_vfs_lookup" 9 "v9fs_vfs_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_lookup \-  VFS lookup hook to "walk" to a new inode
.SH SYNOPSIS
.B "struct dentry *" v9fs_vfs_lookup
.BI "(struct inode *" dir ","
.BI "struct dentry *" dentry ","
.BI "struct nameidata *" nameidata ");"
.SH ARGUMENTS
.IP "dir" 12
  inode that is being walked from
.IP "dentry" 12
 dentry that is being walked to?
.IP "nameidata" 12
 path data
.TH "v9fs_vfs_unlink" 9 "v9fs_vfs_unlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_unlink \-  VFS unlink hook to delete an inode
.SH SYNOPSIS
.B "int" v9fs_vfs_unlink
.BI "(struct inode *" i ","
.BI "struct dentry *" d ");"
.SH ARGUMENTS
.IP "i" 12
  inode that is being unlinked
.IP "d" 12
 dentry that is being unlinked
.TH "v9fs_vfs_rmdir" 9 "v9fs_vfs_rmdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_rmdir \-  VFS unlink hook to delete a directory
.SH SYNOPSIS
.B "int" v9fs_vfs_rmdir
.BI "(struct inode *" i ","
.BI "struct dentry *" d ");"
.SH ARGUMENTS
.IP "i" 12
  inode that is being unlinked
.IP "d" 12
 dentry that is being unlinked
.TH "v9fs_vfs_rename" 9 "v9fs_vfs_rename" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_rename \-  VFS hook to rename an inode
.SH SYNOPSIS
.B "int" v9fs_vfs_rename
.BI "(struct inode *" old_dir ","
.BI "struct dentry *" old_dentry ","
.BI "struct inode *" new_dir ","
.BI "struct dentry *" new_dentry ");"
.SH ARGUMENTS
.IP "old_dir" 12
  old dir inode
.IP "old_dentry" 12
 old dentry
.IP "new_dir" 12
 new dir inode
.IP "new_dentry" 12
 new dentry
.TH "v9fs_vfs_getattr" 9 "v9fs_vfs_getattr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_getattr \-  retreive file metadata
.SH SYNOPSIS
.B "int" v9fs_vfs_getattr
.BI "(struct vfsmount *" mnt ","
.BI "struct dentry *" dentry ","
.BI "struct kstat *" stat ");"
.SH ARGUMENTS
.IP "mnt" 12
-- undescribed --
.IP "dentry" 12
-- undescribed --
.IP "stat" 12
-- undescribed --
.SH "DESCRIPTION"
\fImnt\fP - mount information
\fIdentry\fP - file to get attributes on
\fIstat\fP - metadata structure to populate
.TH "v9fs_vfs_setattr" 9 "v9fs_vfs_setattr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_setattr \-  set file metadata
.SH SYNOPSIS
.B "int" v9fs_vfs_setattr
.BI "(struct dentry *" dentry ","
.BI "struct iattr *" iattr ");"
.SH ARGUMENTS
.IP "dentry" 12
 file whose metadata to set
.IP "iattr" 12
 metadata assignment structure
.TH "v9fs_mistat2inode" 9 "v9fs_mistat2inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_mistat2inode \-  populate an inode structure with mistat info
.SH SYNOPSIS
.B "void" v9fs_mistat2inode
.BI "(struct v9fs_stat *" mistat ","
.BI "struct inode *" inode ","
.BI "struct super_block *" sb ");"
.SH ARGUMENTS
.IP "mistat" 12
 Plan 9 metadata (mistat) structure
.IP "inode" 12
 inode to populate
.IP "sb" 12
 superblock of filesystem
.TH "v9fs_qid2ino" 9 "v9fs_qid2ino" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_qid2ino \-  convert qid into inode number
.SH SYNOPSIS
.B "ino_t" v9fs_qid2ino
.BI "(struct v9fs_qid *" qid ");"
.SH ARGUMENTS
.IP "qid" 12
 qid to hash
.SH "BUG"
 potential for inode number collisions?
.TH "v9fs_vfs_symlink" 9 "v9fs_vfs_symlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_symlink \-  helper function to create symlinks
.SH SYNOPSIS
.B "int" v9fs_vfs_symlink
.BI "(struct inode *" dir ","
.BI "struct dentry *" dentry ","
.BI "const char *" symname ");"
.SH ARGUMENTS
.IP "dir" 12
 directory inode containing symlink
.IP "dentry" 12
 dentry for symlink
.IP "symname" 12
 symlink data
.SH "DESCRIPTION"
See 9P2000.u RFC for more information
.TH "v9fs_readlink" 9 "v9fs_readlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_readlink \-  read a symlink's location (internal version)
.SH SYNOPSIS
.B "int" v9fs_readlink
.BI "(struct dentry *" dentry ","
.BI "char *" buffer ","
.BI "int " buflen ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry for symlink
.IP "buffer" 12
 buffer to load symlink location into
.IP "buflen" 12
 length of buffer
.TH "v9fs_vfs_readlink" 9 "v9fs_vfs_readlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_readlink \-  read a symlink's location
.SH SYNOPSIS
.B "int" v9fs_vfs_readlink
.BI "(struct dentry *" dentry ","
.BI "char __user *" buffer ","
.BI "int " buflen ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry for symlink
.IP "buffer" 12
-- undescribed --
.IP "buflen" 12
 length of buffer
.TH "v9fs_vfs_follow_link" 9 "v9fs_vfs_follow_link" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_follow_link \-  follow a symlink path
.SH SYNOPSIS
.B "void *" v9fs_vfs_follow_link
.BI "(struct dentry *" dentry ","
.BI "struct nameidata *" nd ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry for symlink
.IP "nd" 12
 nameidata
.TH "v9fs_vfs_put_link" 9 "v9fs_vfs_put_link" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_put_link \-  release a symlink path
.SH SYNOPSIS
.B "void" v9fs_vfs_put_link
.BI "(struct dentry *" dentry ","
.BI "struct nameidata *" nd ","
.BI "void *" p ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry for symlink
.IP "nd" 12
 nameidata
.IP "p" 12
-- undescribed --
.TH "v9fs_vfs_link" 9 "v9fs_vfs_link" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_link \-  create a hardlink
.SH SYNOPSIS
.B "int" v9fs_vfs_link
.BI "(struct dentry *" old_dentry ","
.BI "struct inode *" dir ","
.BI "struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "old_dentry" 12
 dentry for file to link to
.IP "dir" 12
 inode destination for new link
.IP "dentry" 12
 dentry for link
.TH "v9fs_vfs_mknod" 9 "v9fs_vfs_mknod" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_vfs_mknod \-  create a special file
.SH SYNOPSIS
.B "int" v9fs_vfs_mknod
.BI "(struct inode *" dir ","
.BI "struct dentry *" dentry ","
.BI "int " mode ","
.BI "dev_t " rdev ");"
.SH ARGUMENTS
.IP "dir" 12
 inode destination for new link
.IP "dentry" 12
 dentry for file
.IP "mode" 12
 mode for creation
.IP "rdev" 12
-- undescribed --
.TH "v9fs_sock_recv" 9 "v9fs_sock_recv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_sock_recv \-  receive from a socket
.SH SYNOPSIS
.B "int" v9fs_sock_recv
.BI "(struct v9fs_transport *" trans ","
.BI "void *" v ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "trans" 12
-- undescribed --
.IP "v" 12
 buffer to receive data into
.IP "len" 12
 size of receive buffer
.TH "v9fs_sock_send" 9 "v9fs_sock_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_sock_send \-  send to a socket
.SH SYNOPSIS
.B "int" v9fs_sock_send
.BI "(struct v9fs_transport *" trans ","
.BI "void *" v ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "trans" 12
-- undescribed --
.IP "v" 12
 buffer to send data from
.IP "len" 12
 size of send buffer
.TH "v9fs_tcp_init" 9 "v9fs_tcp_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_tcp_init \-  initialize TCP socket
.SH SYNOPSIS
.B "int" v9fs_tcp_init
.BI "(struct v9fs_session_info *" v9ses ","
.BI "const char *" addr ","
.BI "char *" data ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session information
.IP "addr" 12
 address of server to mount
.IP "data" 12
 mount options
.TH "v9fs_unix_init" 9 "v9fs_unix_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_unix_init \-  initialize UNIX domain socket
.SH SYNOPSIS
.B "int" v9fs_unix_init
.BI "(struct v9fs_session_info *" v9ses ","
.BI "const char *" dev_name ","
.BI "char *" data ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session information
.IP "dev_name" 12
 path to named pipe
.IP "data" 12
 mount options
.TH "v9fs_sock_close" 9 "v9fs_sock_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_sock_close \-  shutdown socket
.SH SYNOPSIS
.B "void" v9fs_sock_close
.BI "(struct v9fs_transport *" trans ");"
.SH ARGUMENTS
.IP "trans" 12
 private socket structure
.TH "dprintcond" 9 "dprintcond" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dprintcond \-  print condition of session info
.SH SYNOPSIS
.B "int" dprintcond
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_rpcreq *" req ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "req" 12
 RPC request structure
.TH "xread" 9 "xread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xread \-  force read of a certain number of bytes
.SH SYNOPSIS
.B "int" xread
.BI "(struct v9fs_session_info *" v9ses ","
.BI "void *" ptr ","
.BI "unsigned long " sz ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "ptr" 12
 pointer to buffer
.IP "sz" 12
 number of bytes to read
.SH "DESCRIPTION"
Chuck Cranor CS-533 project1
.TH "read_message" 9 "read_message" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_message \-  read a full 9P2000 fcall packet
.SH SYNOPSIS
.B "int" read_message
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_fcall *" rcall ","
.BI "int " rcalllen ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "rcall" 12
 fcall structure to read into
.IP "rcalllen" 12
 size of fcall buffer
.TH "v9fs_recv" 9 "v9fs_recv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_recv \-  receive an RPC response for a particular tag
.SH SYNOPSIS
.B "int" v9fs_recv
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_rpcreq *" req ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "req" 12
 RPC request structure
.TH "v9fs_send" 9 "v9fs_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_send \-  send a 9P request
.SH SYNOPSIS
.B "int" v9fs_send
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_rpcreq *" req ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "req" 12
 RPC request to send
.TH "v9fs_mux_rpc" 9 "v9fs_mux_rpc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_mux_rpc \-  send a request, receive a response
.SH SYNOPSIS
.B "long" v9fs_mux_rpc
.BI "(struct v9fs_session_info *" v9ses ","
.BI "struct v9fs_fcall *" tcall ","
.BI "struct v9fs_fcall **" rcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "tcall" 12
 fcall to send
.IP "rcall" 12
 buffer to place response into
.TH "v9fs_mux_cancel_requests" 9 "v9fs_mux_cancel_requests" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_mux_cancel_requests \-  cancels all pending requests
.SH SYNOPSIS
.B "void" v9fs_mux_cancel_requests
.BI "(struct v9fs_session_info *" v9ses ","
.BI "int " err ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "err" 12
 error code to return to the requests
.SH "DESCRIPTION"
.TH "v9fs_recvproc" 9 "v9fs_recvproc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_recvproc \-  kproc to handle demultiplexing responses
.SH SYNOPSIS
.B "int" v9fs_recvproc
.BI "(void *" data ");"
.SH ARGUMENTS
.IP "data" 12
 session info structure
.TH "v9fs_mux_init" 9 "v9fs_mux_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_mux_init \-  initialize multiplexer (spawn kproc)
.SH SYNOPSIS
.B "int" v9fs_mux_init
.BI "(struct v9fs_session_info *" v9ses ","
.BI "const char *" dev_name ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session info structure
.IP "dev_name" 12
 mount device information (to create unique kproc)
.TH "v9fs_dentry_validate" 9 "v9fs_dentry_validate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_dentry_validate \-  VFS dcache hook to validate cache
.SH SYNOPSIS
.B "int" v9fs_dentry_validate
.BI "(struct dentry *" dentry ","
.BI "struct nameidata *" nd ");"
.SH ARGUMENTS
.IP "dentry" 12
  dentry that is being validated
.IP "nd" 12
 path data
.SH "DESCRIPTION"
dcache really shouldn't be used for 9P2000 as at all due to
potential attached semantics to directory traversal (walk).
.SH "FUTURE"
 look into how to use dcache to allow multi-stage
walks in Plan 9 &amp; potential for better dcache operation which
would remain valid for Plan 9 semantics.  Older versions
had validation via stat for those interested.  However, since
stat has the same approximate overhead as walk there really
is no difference.  The only improvement would be from a
time-decay cache like NFS has and that undermines the
synchronous nature of 9P2000.
.TH "v9fs_dentry_release" 9 "v9fs_dentry_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_dentry_release \-  called when dentry is going to be freed
.SH SYNOPSIS
.B "void" v9fs_dentry_release
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
  dentry that is being release
.TH "v9fs_fid_insert" 9 "v9fs_fid_insert" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fid_insert \-  add a fid to a dentry
.SH SYNOPSIS
.B "int" v9fs_fid_insert
.BI "(struct v9fs_fid *" fid ","
.BI "struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "fid" 12
 fid to add
.IP "dentry" 12
 dentry that it is being added to
.TH "v9fs_fid_create" 9 "v9fs_fid_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fid_create \-  allocate a FID structure
.SH SYNOPSIS
.B "struct v9fs_fid *" v9fs_fid_create
.BI "(struct dentry *" dentry ","
.BI "struct v9fs_session_info *" v9ses ","
.BI "int " fid ","
.BI "int " create ");"
.SH ARGUMENTS
.IP "dentry" 12
-- undescribed --
.IP "v9ses" 12
-- undescribed --
.IP "fid" 12
-- undescribed --
.IP "create" 12
-- undescribed --
.SH "DESCRIPTION"
\fIdentry\fP - dentry to link newly created fid to
.TH "v9fs_fid_destroy" 9 "v9fs_fid_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fid_destroy \-  deallocate a FID structure
.SH SYNOPSIS
.B "void" v9fs_fid_destroy
.BI "(struct v9fs_fid *" fid ");"
.SH ARGUMENTS
.IP "fid" 12
 fid to destroy
.TH "v9fs_fid_walk_up" 9 "v9fs_fid_walk_up" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fid_walk_up \-  walks from the process current directory
.SH SYNOPSIS
.B "struct v9fs_fid *" v9fs_fid_walk_up
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
-- undescribed --
.SH "DESCRIPTION"
up to the specified dentry.
.TH "v9fs_fid_lookup" 9 "v9fs_fid_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_fid_lookup \-  retrieve the right fid from a  particular dentry
.SH SYNOPSIS
.B "struct v9fs_fid *" v9fs_fid_lookup
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry to look for fid in
.SH "DESCRIPTION"
search list of fids associated with a dentry for a fid with a matching
thread id or uid.  If that fails, look up the dentry's parents to see if you
can find a matching fid.
.TH "v9fs_t_version" 9 "v9fs_t_version" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_version \-  negotiate protocol parameters with sever
.SH SYNOPSIS
.B "int" v9fs_t_version
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " msize ","
.BI "char *" version ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "msize" 12
 requested max size packet
.IP "version" 12
 requested version.extension string
.IP "fcall" 12
 pointer to response fcall pointer
.TH "v9fs_t_attach" 9 "v9fs_t_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_attach \-  mount the server
.SH SYNOPSIS
.B "int" v9fs_t_attach
.BI "(struct v9fs_session_info *" v9ses ","
.BI "char *" uname ","
.BI "char *" aname ","
.BI "u32 " fid ","
.BI "u32 " afid ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "uname" 12
 user name doing the attach
.IP "aname" 12
 remote name being attached to
.IP "fid" 12
 mount fid to attatch to root node
.IP "afid" 12
 authentication fid (in this case result key)
.IP "fcall" 12
 pointer to response fcall pointer
.TH "v9fs_t_clunk" 9 "v9fs_t_clunk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_clunk \-  release a fid (finish a transaction)
.SH SYNOPSIS
.B "int" v9fs_t_clunk
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid to release
.IP "fcall" 12
 pointer to response fcall pointer
.TH "v9fs_t_flush" 9 "v9fs_t_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_flush \-  flush a pending transaction
.SH SYNOPSIS
.B "int" v9fs_t_flush
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u16 " tag ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "tag" 12
 tid to release
.TH "v9fs_t_stat" 9 "v9fs_t_stat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_stat \-  read a file's meta-data
.SH SYNOPSIS
.B "int" v9fs_t_stat
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid pointing to file or directory to get info about
.IP "fcall" 12
 pointer to response fcall
.TH "v9fs_t_wstat" 9 "v9fs_t_wstat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_wstat \-  write a file's meta-data
.SH SYNOPSIS
.B "int" v9fs_t_wstat
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "struct v9fs_stat *" stat ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid pointing to file or directory to write info about
.IP "stat" 12
 metadata
.IP "fcall" 12
 pointer to response fcall
.TH "v9fs_t_walk" 9 "v9fs_t_walk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_walk \-  walk a fid to a new file or directory
.SH SYNOPSIS
.B "int" v9fs_t_walk
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "u32 " newfid ","
.BI "char *" name ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid to walk
.IP "newfid" 12
 new fid (for clone operations)
.IP "name" 12
 path to walk fid to
.IP "fcall" 12
 pointer to response fcall
.TH "v9fs_t_open" 9 "v9fs_t_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_open \-  open a file
.SH SYNOPSIS
.B "int" v9fs_t_open
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "u8 " mode ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
-- undescribed --
.IP "fid" 12
-- undescribed --
.IP "mode" 12
-- undescribed --
.IP "fcall" 12
-- undescribed --
.SH "DESCRIPTION"

\fIv9ses\fP - 9P2000 session information
\fIfid\fP - fid to open
\fImode\fP - mode to open file (R, RW, etc)
\fIfcall\fP - pointer to response fcall
.TH "v9fs_t_remove" 9 "v9fs_t_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_remove \-  remove a file or directory
.SH SYNOPSIS
.B "int" v9fs_t_remove
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid to remove
.IP "fcall" 12
 pointer to response fcall
.TH "v9fs_t_create" 9 "v9fs_t_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_create \-  create a file or directory
.SH SYNOPSIS
.B "int" v9fs_t_create
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "char *" name ","
.BI "u32 " perm ","
.BI "u8 " mode ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid to create
.IP "name" 12
 name of the file or directory to create
.IP "perm" 12
 permissions to create with
.IP "mode" 12
 mode to open file (R, RW, etc)
.IP "fcall" 12
 pointer to response fcall
.TH "v9fs_t_read" 9 "v9fs_t_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_read \-  read data
.SH SYNOPSIS
.B "int" v9fs_t_read
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "u64 " offset ","
.BI "u32 " count ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid to read from
.IP "offset" 12
 offset to start read at
.IP "count" 12
 how many bytes to read
.IP "fcall" 12
 pointer to response fcall (with data)
.TH "v9fs_t_write" 9 "v9fs_t_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_t_write \-  write data
.SH SYNOPSIS
.B "int" v9fs_t_write
.BI "(struct v9fs_session_info *" v9ses ","
.BI "u32 " fid ","
.BI "u64 " offset ","
.BI "u32 " count ","
.BI "void *" data ","
.BI "struct v9fs_fcall **" fcall ");"
.SH ARGUMENTS
.IP "v9ses" 12
 9P2000 session information
.IP "fid" 12
 fid to write to
.IP "offset" 12
 offset to start write at
.IP "count" 12
 how many bytes to write
.IP "data" 12
-- undescribed --
.IP "fcall" 12
 pointer to response fcall
.TH "dt_type" 9 "dt_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dt_type \-  return file type
.SH SYNOPSIS
.B "int" dt_type
.BI "(struct v9fs_stat *" mistat ");"
.SH ARGUMENTS
.IP "mistat" 12
 mistat structure
.TH "v9fs_dir_readdir" 9 "v9fs_dir_readdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_dir_readdir \-  read a directory
.SH SYNOPSIS
.B "int" v9fs_dir_readdir
.BI "(struct file *" filp ","
.BI "void *" dirent ","
.BI "filldir_t " filldir ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "dirent" 12
 directory structure ???
.IP "filldir" 12
 function to populate directory structure ???
.TH "v9fs_dir_release" 9 "v9fs_dir_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_dir_release \-  close a directory
.SH SYNOPSIS
.B "int" v9fs_dir_release
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of the directory
.IP "filp" 12
 file pointer to a directory
.TH "v9fs_error_init" 9 "v9fs_error_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_error_init \-  preload
.SH SYNOPSIS
.B "int" v9fs_error_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "v9fs_errstr2errno" 9 "v9fs_errstr2errno" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_errstr2errno \-  convert error string to error number
.SH SYNOPSIS
.B "int" v9fs_errstr2errno
.BI "(char *" errstr ");"
.SH ARGUMENTS
.IP "errstr" 12
 error string
.TH "v9fs_file_open" 9 "v9fs_file_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_file_open \-  open a file (or directory)
.SH SYNOPSIS
.B "int" v9fs_file_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to be opened
.IP "file" 12
 file being opened
.TH "v9fs_file_lock" 9 "v9fs_file_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_file_lock \-  lock a file (or directory)
.SH SYNOPSIS
.B "int" v9fs_file_lock
.BI "(struct file *" filp ","
.BI "int " cmd ","
.BI "struct file_lock *" fl ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "fl" 12
-- undescribed --
.SH "DESCRIPTION"
XXX - this looks like a local only lock, we should extend into 9P
by using open exclusive
.TH "v9fs_file_read" 9 "v9fs_file_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_file_read \-  read from a file
.SH SYNOPSIS
.B "ssize_t" v9fs_file_read
.BI "(struct file *" filp ","
.BI "char __user *" data ","
.BI "size_t " count ","
.BI "loff_t *" offset ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "data" 12
 data buffer to read data into
.IP "count" 12
 size of buffer
.IP "offset" 12
 offset at which to read data
.TH "v9fs_file_write" 9 "v9fs_file_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_file_write \-  write to a file
.SH SYNOPSIS
.B "ssize_t" v9fs_file_write
.BI "(struct file *" filp ","
.BI "const char __user *" data ","
.BI "size_t " count ","
.BI "loff_t *" offset ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "data" 12
 data buffer to write data from
.IP "count" 12
 size of buffer
.IP "offset" 12
 offset at which to write data
.TH "v9fs_parse_options" 9 "v9fs_parse_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_parse_options \-  parse mount options into session structure
.SH SYNOPSIS
.B "void" v9fs_parse_options
.BI "(char *" options ","
.BI "struct v9fs_session_info *" v9ses ");"
.SH ARGUMENTS
.IP "options" 12
 options string passed from mount
.IP "v9ses" 12
 existing v9fs session information
.TH "v9fs_inode2v9ses" 9 "v9fs_inode2v9ses" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_inode2v9ses \-  safely extract v9fs session info from super block
.SH SYNOPSIS
.B "struct v9fs_session_info *" v9fs_inode2v9ses
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to extract information from
.SH "DESCRIPTION"
Paranoid function to extract v9ses information from superblock,
if anything is missing it will report an error.
.TH "v9fs_get_idpool" 9 "v9fs_get_idpool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_get_idpool \-  allocate numeric id from pool
.SH SYNOPSIS
.B "int" v9fs_get_idpool
.BI "(struct v9fs_idpool *" p ");"
.SH ARGUMENTS
.IP "p" 12
-- undescribed --
.SH "DESCRIPTION"
\fIp\fP - pool to allocate from

XXX - This seems to be an awful generic function, should it be in idr.c with
the lock included in struct idr?
.TH "v9fs_put_idpool" 9 "v9fs_put_idpool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_put_idpool \-  release numeric id from pool
.SH SYNOPSIS
.B "void" v9fs_put_idpool
.BI "(int " id ","
.BI "struct v9fs_idpool *" p ");"
.SH ARGUMENTS
.IP "id" 12
-- undescribed --
.IP "p" 12
-- undescribed --
.SH "DESCRIPTION"
\fIp\fP - pool to allocate from

XXX - This seems to be an awful generic function, should it be in idr.c with
the lock included in struct idr?
.TH "v9fs_session_init" 9 "v9fs_session_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_session_init \-  initialize session
.SH SYNOPSIS
.B "int" v9fs_session_init
.BI "(struct v9fs_session_info *" v9ses ","
.BI "const char *" dev_name ","
.BI "char *" data ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session information structure
.IP "dev_name" 12
 device being mounted
.IP "data" 12
 options
.TH "v9fs_session_close" 9 "v9fs_session_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_session_close \-  shutdown a session
.SH SYNOPSIS
.B "void" v9fs_session_close
.BI "(struct v9fs_session_info *" v9ses ");"
.SH ARGUMENTS
.IP "v9ses" 12
 session information structure
.TH "v9fs_session_cancel" 9 "v9fs_session_cancel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
v9fs_session_cancel \-  mark transport as disconnected
.SH SYNOPSIS
.B "void" v9fs_session_cancel
.BI "(struct v9fs_session_info *" v9ses ");"
.SH ARGUMENTS
.IP "v9ses" 12
-- undescribed --
.SH "DESCRIPTION"
and cancel all pending requests.
.TH "init_v9fs" 9 "init_v9fs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_v9fs \-  Initialize module
.SH SYNOPSIS
.B "int __init" init_v9fs
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "exit_v9fs" 9 "exit_v9fs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
exit_v9fs \-  shutdown module
.SH SYNOPSIS
.B "void __exit" exit_v9fs
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "reiserfs_find_actor" 9 "reiserfs_find_actor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
reiserfs_find_actor \-  "find actor" reiserfs supplies to iget5_locked().
.SH SYNOPSIS
.B "int" reiserfs_find_actor
.BI "(struct inode *" inode ","
.BI "void *" opaque ");"
.SH ARGUMENTS
.IP "inode" 12
    inode from hash table to check
.IP "opaque" 12
   "cookie" passed to \fBiget5_locked\fP. This is &amp;reiserfs_iget_args.
.SH "DESCRIPTION"
This function is called by \fBiget5_locked\fP to distinguish reiserfs inodes
having the same inode numbers. Such inodes can only exist due to some
error condition. One of them should be bad. Inodes with identical
inode numbers (objectids) are distinguished by parent directory ids.
.SH "DESCRIPTION"
This function is called by \fBiget5_locked\fP to distinguish reiserfs inodes
having the same inode numbers. Such inodes can only exist due to some
error condition. One of them should be bad. Inodes with identical
inode numbers (objectids) are distinguished by parent directory ids.
.TH "old_item_num" 9 "old_item_num" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
old_item_num \- 
.SH SYNOPSIS
.B "int" old_item_num
.BI "(int " new_num ","
.BI "int " affected_item_num ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "new_num" 12
-- undescribed --
.IP "affected_item_num" 12
-- undescribed --
.IP "mode" 12
-- undescribed --
.SH "DESCRIPTION"
* old_entry_num
* set_entry_sizes
* create_virtual_node
* check_left
* check_right
* directory_part_size
* get_num_ver
* set_parameters
* is_leaf_removable
* are_leaves_removable
* get_empty_nodes
* get_lfree
* get_rfree
* is_left_neighbor_in_cache
* decrement_key
* get_far_parent
* get_parents
* can_node_be_removed
* ip_check_balance
* dc_check_balance_internal
* dc_check_balance_leaf
* dc_check_balance
* check_balance
* get_direct_parent
* get_neighbors
* fix_nodes
* 
* 
.TH "efi_crc32" 9 "efi_crc32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
efi_crc32 \-  EFI version of crc32 function
.SH SYNOPSIS
.B "u32" efi_crc32
.BI "(const void *" buf ","
.BI "unsigned long " len ");"
.SH ARGUMENTS
.IP "buf" 12
 buffer to calculate crc32 of
\fIlen\fP - length of buf
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
 Returns EFI-style CRC32 value for \fIbuf\fP

This function uses the little endian Ethernet polynomial
but seeds the function with ~0, and xor's with ~0 at the end.
Note, the EFI Specification, v1.02, has a reference to
Dr. Dobbs Journal, May 1994 (actually it's in May 1992).
.TH "last_lba" 9 "last_lba" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
last_lba \- 
.SH SYNOPSIS
.B "u64" last_lba
.BI "(struct block_device *" bdev ");"
.SH ARGUMENTS
.IP "bdev" 12
 block device
.SH "DESCRIPTION"
 Returns last LBA value on success, 0 on error.
This is stored (by sd and ide-geometry) in
the part[0] entry for this disk, and is the number of
physical sectors available on the disk.
.TH "is_pmbr_valid" 9 "is_pmbr_valid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_pmbr_valid \- 
.SH SYNOPSIS
.B "int" is_pmbr_valid
.BI "(legacy_mbr *" mbr ","
.BI "u64 " lastlba ");"
.SH ARGUMENTS
.IP "mbr" 12
 pointer to a legacy mbr structure
.IP "lastlba" 12
 last_lba for the whole device
.SH "DESCRIPTION"
 Returns 1 if PMBR is valid, 0 otherwise.
.SH "VALIDITY DEPENDS ON TWO THINGS"
1) MSDOS signature is in the last two bytes of the MBR
2) One partition of type 0xEE is found
.TH "read_lba" 9 "read_lba" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_lba \- 
.SH SYNOPSIS
.B "size_t" read_lba
.BI "(struct block_device *" bdev ","
.BI "u64 " lba ","
.BI "u8 *" buffer ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "bdev" 12
-- undescribed --
.IP "lba" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
  Reads \fIcount\fP bytes from \fIbdev\fP into \fIbuffer\fP.
Returns number of bytes read on success, 0 on error.
.SH "DESCRIPTION"
  Reads \fIcount\fP bytes from \fIbdev\fP into \fIbuffer\fP.
Returns number of bytes read on success, 0 on error.
.TH "alloc_read_gpt_entries" 9 "alloc_read_gpt_entries" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_read_gpt_entries \- 
.SH SYNOPSIS
.B "gpt_entry *" alloc_read_gpt_entries
.BI "(struct block_device *" bdev ","
.BI "gpt_header *" gpt ");"
.SH ARGUMENTS
.IP "bdev" 12
-- undescribed --
.IP "gpt" 12
-- undescribed --
.SH "DESCRIPTION"
 Returns ptes on success,  NULL on error.
Allocates space for PTEs based on information found in \fIgpt\fP.
.SH "DESCRIPTION"
 Returns ptes on success,  NULL on error.
Allocates space for PTEs based on information found in \fIgpt\fP.
.SH "NOTES"
 remember to free pte when you're done!
.TH "alloc_read_gpt_header" 9 "alloc_read_gpt_header" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_read_gpt_header \- 
.SH SYNOPSIS
.B "gpt_header *" alloc_read_gpt_header
.BI "(struct block_device *" bdev ","
.BI "u64 " lba ");"
.SH ARGUMENTS
.IP "bdev" 12
-- undescribed --
.IP "lba" 12
-- undescribed --
.SH "DESCRIPTION"
 returns GPT header on success, NULL on error.   Allocates
and fills a GPT header starting at @ from \fIbdev\fP.
.SH "DESCRIPTION"
 returns GPT header on success, NULL on error.   Allocates
and fills a GPT header starting at @ from \fIbdev\fP.
.SH "NOTE"
 remember to free gpt when finished with it.
.TH "is_gpt_valid" 9 "is_gpt_valid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_gpt_valid \-  tests one GPT header and PTEs for validity
.SH SYNOPSIS
.B "int" is_gpt_valid
.BI "(struct block_device *" bdev ","
.BI "u64 " lba ","
.BI "gpt_header **" gpt ","
.BI "gpt_entry **" ptes ");"
.SH ARGUMENTS
.IP "bdev" 12
-- undescribed --
.IP "lba" 12
-- undescribed --
.IP "gpt" 12
-- undescribed --
.IP "ptes" 12
-- undescribed --
.SH "DESCRIPTION"
 returns 1 if valid,  0 on error.
If valid, returns pointers to newly allocated GPT header and PTEs.
.SH "DESCRIPTION"
 returns 1 if valid,  0 on error.
If valid, returns pointers to newly allocated GPT header and PTEs.
.TH "is_pte_valid" 9 "is_pte_valid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_pte_valid \-  tests one PTE for validity
.SH SYNOPSIS
.B "int" is_pte_valid
.BI "(const gpt_entry *" pte ","
.BI "const u64 " lastlba ");"
.SH ARGUMENTS
.IP "pte" 12
-- undescribed --
.IP "lastlba" 12
-- undescribed --
.SH "DESCRIPTION"
 returns 1 if valid,  0 on error.
.SH "DESCRIPTION"
 returns 1 if valid,  0 on error.
.TH "compare_gpts" 9 "compare_gpts" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
compare_gpts \-  Search disk for valid GPT headers and PTEs
.SH SYNOPSIS
.B "void" compare_gpts
.BI "(gpt_header *" pgpt ","
.BI "gpt_header *" agpt ","
.BI "u64 " lastlba ");"
.SH ARGUMENTS
.IP "pgpt" 12
-- undescribed --
.IP "agpt" 12
-- undescribed --
.IP "lastlba" 12
-- undescribed --
.SH "DESCRIPTION"
 Returns nothing.  Sanity checks pgpt and agpt fields
and prints warnings on discrepancies.
.SH "DESCRIPTION"
 Returns nothing.  Sanity checks pgpt and agpt fields
and prints warnings on discrepancies.
.TH "find_valid_gpt" 9 "find_valid_gpt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_valid_gpt \-  Search disk for valid GPT headers and PTEs
.SH SYNOPSIS
.B "int" find_valid_gpt
.BI "(struct block_device *" bdev ","
.BI "gpt_header **" gpt ","
.BI "gpt_entry **" ptes ");"
.SH ARGUMENTS
.IP "bdev" 12
-- undescribed --
.IP "gpt" 12
-- undescribed --
.IP "ptes" 12
-- undescribed --
.SH "DESCRIPTION"
 Returns 1 if valid, 0 on error.
If valid, returns pointers to newly allocated GPT header and PTEs.
Validity depends on PMBR being valid (or being overridden by the
'gpt' kernel command line option) and finding either the Primary
GPT header and PTEs valid, or the Alternate GPT header and PTEs
valid.  If the Primary GPT header is not valid, the Alternate GPT header
is not checked unless the 'gpt' kernel command line option is passed.
This protects against devices which misreport their size, and forces
the user to decide to use the Alternate GPT.
.SH "DESCRIPTION"
 Returns 1 if valid, 0 on error.
If valid, returns pointers to newly allocated GPT header and PTEs.
Validity depends on PMBR being valid (or being overridden by the
'gpt' kernel command line option) and finding either the Primary
GPT header and PTEs valid, or the Alternate GPT header and PTEs
valid.  If the Primary GPT header is not valid, the Alternate GPT header
is not checked unless the 'gpt' kernel command line option is passed.
This protects against devices which misreport their size, and forces
the user to decide to use the Alternate GPT.
.TH "efi_partition" 9 "efi_partition" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
efi_partition \- 
.SH SYNOPSIS
.B "int" efi_partition
.BI "(struct parsed_partitions *" state ","
.BI "struct block_device *" bdev ");"
.SH ARGUMENTS
.IP "state" 12
-- undescribed --
.IP "bdev" 12
-- undescribed --
.SH "DESCRIPTION"
 called from check.c, if the disk contains GPT
partitions, sets up partition entries in the kernel.

If the first block on the disk is a legacy MBR,
it will get handled by \fBmsdos_partition\fP.
If it's a Protective MBR, we'll handle it here.

We do not create a Linux partition for GPT, but
only for the actual data partitions.
.SH "DESCRIPTION"
 called from check.c, if the disk contains GPT
partitions, sets up partition entries in the kernel.

If the first block on the disk is a legacy MBR,
it will get handled by \fBmsdos_partition\fP.
If it's a Protective MBR, we'll handle it here.

We do not create a Linux partition for GPT, but
only for the actual data partitions.
.SH "RETURNS"
-1 if unable to read the partition table
0 if this isn't our partition table
1 if successful
.TH "befs_read_datastream" 9 "befs_read_datastream" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_read_datastream \-  get buffer_head containing data, starting from pos.
.SH SYNOPSIS
.B "struct buffer_head *" befs_read_datastream
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ","
.BI "befs_off_t " pos ","
.BI "uint *" off ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "ds" 12
 datastrem to find data with
.IP "pos" 12
 start of data
.IP "off" 12
 offset of data in buffer_head-&gt;b_data
.SH "DESCRIPTION"
Returns pointer to buffer_head containing data starting with offset \fIoff\fP,
if you don't need to know offset just set \fIoff\fP = NULL.
.TH "befs_read_lsymlink" 9 "befs_read_lsymlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_read_lsymlink \-  read long symlink from datastream.
.SH SYNOPSIS
.B "size_t" befs_read_lsymlink
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ","
.BI "void *" buff ","
.BI "befs_off_t " len ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock 
.IP "ds" 12
 Datastrem to read from
.IP "buff" 12
-- undescribed --
.IP "len" 12
 Length of the long symlink in bytes
.SH "DESCRIPTION"
Returns the number of bytes read
.TH "befs_count_blocks" 9 "befs_count_blocks" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_count_blocks \-  blocks used by a file
.SH SYNOPSIS
.B "befs_blocknr_t" befs_count_blocks
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "ds" 12
 Datastream of the file
.SH "DESCRIPTION"
Counts the number of fs blocks that the file represented by
inode occupies on the filesystem, counting both regular file
data and filesystem metadata (and eventually attribute data
when we support attributes)
.TH "befs_bt_read_super" 9 "befs_bt_read_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_bt_read_super \-  read in btree superblock convert to cpu byteorder
.SH SYNOPSIS
.B "int" befs_bt_read_super
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ","
.BI "befs_btree_super *" sup ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "ds" 12
 Datastream to read from
.IP "sup" 12
 Buffer in which to place the btree superblock
.SH "DESCRIPTION"
Calls befs_read_datastream to read in the btree superblock and
makes sure it is in cpu byteorder, byteswapping if necessary.

On success, returns BEFS_OK and *\fIsup\fP contains the btree superblock,
in cpu byte order.

On failure, BEFS_ERR is returned.
.TH "befs_bt_read_node" 9 "befs_bt_read_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_bt_read_node \-  read in btree node and convert to cpu byteorder
.SH SYNOPSIS
.B "int" befs_bt_read_node
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ","
.BI "befs_btree_node *" node ","
.BI "befs_off_t " node_off ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "ds" 12
 Datastream to read from
.IP "node" 12
 Buffer in which to place the btree node
.IP "node_off" 12
 Starting offset (in bytes) of the node in \fIds\fP
.SH "DESCRIPTION"
Calls befs_read_datastream to read in the indicated btree node and
makes sure its header fields are in cpu byteorder, byteswapping if
necessary.
.SH "NOTE"
 node-&gt;bh must be NULL when this function called first
time. Don't forget brelse(node-&gt;bh) after last call.

On success, returns BEFS_OK and *\fInode\fP contains the btree node that
starts at \fInode_off\fP, with the node-&gt;head fields in cpu byte order.

On failure, BEFS_ERR is returned.
.TH "befs_btree_find" 9 "befs_btree_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_btree_find \-  Find a key in a befs B+tree
.SH SYNOPSIS
.B "int" befs_btree_find
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ","
.BI "const char *" key ","
.BI "befs_off_t *" value ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "ds" 12
 Datastream containing btree
.IP "key" 12
 Key string to lookup in btree
.IP "value" 12
 Value stored with \fIkey\fP
.SH "DESCRIPTION"
On sucess, returns BEFS_OK and sets *\fIvalue\fP to the value stored
with \fIkey\fP (usually the disk block number of an inode).

On failure, returns BEFS_ERR or BEFS_BT_NOT_FOUND.
.SH "ALGORITHM"
 
Read the superblock and rootnode of the b+tree.
Drill down through the interior nodes using \fBbefs_find_key\fP.
Once at the correct leaf node, use \fBbefs_find_key\fP again to get the
actuall value stored with the key.
.TH "befs_find_key" 9 "befs_find_key" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_find_key \-  Search for a key within a node
.SH SYNOPSIS
.B "int" befs_find_key
.BI "(struct super_block *" sb ","
.BI "befs_btree_node *" node ","
.BI "const char *" findkey ","
.BI "befs_off_t *" value ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "node" 12
 Node to find the key within
.IP "findkey" 12
-- undescribed --
.IP "value" 12
 If key is found, the value stored with the key is put here
.SH "DESCRIPTION"
finds exact match if one exists, and returns BEFS_BT_MATCH
If no exact match, finds first key in node that is greater
(alphabetically) than the search key and returns BEFS_BT_PARMATCH
(for partial match, I guess). Can you think of something better to
call it?

If no key was a match or greater than the search key, return
BEFS_BT_NOT_FOUND.

Use binary search instead of a linear.
.TH "befs_btree_read" 9 "befs_btree_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_btree_read \-  Traverse leafnodes of a btree
.SH SYNOPSIS
.B "int" befs_btree_read
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ","
.BI "loff_t " key_no ","
.BI "size_t " bufsize ","
.BI "char *" keybuf ","
.BI "size_t *" keysize ","
.BI "befs_off_t *" value ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "ds" 12
 Datastream containing btree
.IP "key_no" 12
 Key number (alphabetical order) of key to read
.IP "bufsize" 12
 Size of the buffer to return key in
.IP "keybuf" 12
 Pointer to a buffer to put the key in
.IP "keysize" 12
 Length of the returned key
.IP "value" 12
 Value stored with the returned key
.SH "HERES HOW IT WORKS"
 Key_no is the index of the key/value pair to 
return in keybuf/value.
Bufsize is the size of keybuf (BEFS_NAME_LEN+1 is a good size). Keysize is 
the number of charecters in the key (just a convenience).
.SH "ALGORITHM"
Get the first leafnode of the tree. See if the requested key is in that
node. If not, follow the node-&gt;right link to the next leafnode. Repeat 
until the (key_no)th key is found or the tree is out of keys.
.TH "befs_btree_seekleaf" 9 "befs_btree_seekleaf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_btree_seekleaf \-  Find the first leafnode in the btree
.SH SYNOPSIS
.B "int" befs_btree_seekleaf
.BI "(struct super_block *" sb ","
.BI "befs_data_stream *" ds ","
.BI "befs_btree_super *" bt_super ","
.BI "befs_btree_node *" this_node ","
.BI "befs_off_t *" node_off ");"
.SH ARGUMENTS
.IP "sb" 12
 Filesystem superblock
.IP "ds" 12
 Datastream containing btree
.IP "bt_super" 12
 Pointer to the superblock of the btree
.IP "this_node" 12
 Buffer to return the leafnode in
.IP "node_off" 12
 Pointer to offset of current node within datastream. Modified
by the function.
.SH "DESCRIPTION"

Helper function for btree traverse. Moves the current position to the 
start of the first leaf node.

Also checks for an empty tree. If there are no keys, returns BEFS_BT_EMPTY.
.TH "befs_leafnode" 9 "befs_leafnode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_leafnode \-  Determine if the btree node is a leaf node or an 
.SH SYNOPSIS
.B "int" befs_leafnode
.BI "(befs_btree_node *" node ");"
.SH ARGUMENTS
.IP "node" 12
 Pointer to node structure to test
.SH "DESCRIPTION"
Return 1 if leaf, 0 if interior
.SH "DESCRIPTION"
Return 1 if leaf, 0 if interior
.TH "befs_bt_keylen_index" 9 "befs_bt_keylen_index" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_bt_keylen_index \-  Finds start of keylen index in a node
.SH SYNOPSIS
.B "u16 *" befs_bt_keylen_index
.BI "(befs_btree_node *" node ");"
.SH ARGUMENTS
.IP "node" 12
 Pointer to the node structure to find the keylen index within
.SH "DESCRIPTION"
Returns a pointer to the start of the key length index array
of the B+tree node *\fInode\fP

"The length of all the keys in the node is added to the size of the
header and then rounded up to a multiple of four to get the beginning
of the key length index" (p.88, practical filesystem design).

Except that rounding up to 8 works, and rounding up to 4 doesn't.
.TH "befs_bt_valarray" 9 "befs_bt_valarray" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_bt_valarray \-  Finds the start of value array in a node
.SH SYNOPSIS
.B "befs_off_t *" befs_bt_valarray
.BI "(befs_btree_node *" node ");"
.SH ARGUMENTS
.IP "node" 12
 Pointer to the node structure to find the value array within
.SH "DESCRIPTION"
Returns a pointer to the start of the value array
of the node pointed to by the node header
.TH "befs_bt_keydata" 9 "befs_bt_keydata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_bt_keydata \-  Finds start of keydata array in a node
.SH SYNOPSIS
.B "char *" befs_bt_keydata
.BI "(befs_btree_node *" node ");"
.SH ARGUMENTS
.IP "node" 12
 Pointer to the node structure to find the keydata array within
.SH "DESCRIPTION"
Returns a pointer to the start of the keydata array
of the node pointed to by the node header 
.TH "befs_bt_get_key" 9 "befs_bt_get_key" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_bt_get_key \-  returns a pointer to the start of a key
.SH SYNOPSIS
.B "char *" befs_bt_get_key
.BI "(struct super_block *" sb ","
.BI "befs_btree_node *" node ","
.BI "int " index ","
.BI "u16 *" keylen ");"
.SH ARGUMENTS
.IP "sb" 12
 filesystem superblock
.IP "node" 12
 node in which to look for the key
.IP "index" 12
 the index of the key to get
.IP "keylen" 12
 modified to be the length of the key at \fIindex\fP
.SH "DESCRIPTION"
Returns a valid pointer into \fInode\fP on success.
Returns NULL on failure (bad input) and sets *\fIkeylen\fP = 0
.TH "befs_compare_strings" 9 "befs_compare_strings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_compare_strings \-  compare two strings
.SH SYNOPSIS
.B "int" befs_compare_strings
.BI "(const void *" key1 ","
.BI "int " keylen1 ","
.BI "const void *" key2 ","
.BI "int " keylen2 ");"
.SH ARGUMENTS
.IP "key1" 12
 pointer to the first key to be compared 
.IP "keylen1" 12
 length in bytes of key1
.IP "key2" 12
 pointer to the second key to be compared
.IP "keylen2" 12
-- undescribed --
.SH "DESCRIPTION"
Returns 0 if \fIkey1\fP and \fIkey2\fP are equal.
Returns &gt;0 if \fIkey1\fP is greater.
Returns &lt;0 if \fIkey2\fP is greater..
.TH "befs_load_sb" 9 "befs_load_sb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
befs_load_sb \- - Read from disk and properly byteswap all the fields
.SH SYNOPSIS
.B "int" befs_load_sb
.BI "(struct super_block *" sb ","
.BI "befs_super_block *" disk_sb ");"
.SH ARGUMENTS
.IP "sb" 12
-- undescribed --
.IP "disk_sb" 12
-- undescribed --
.SH "DESCRIPTION"
of the befs superblock
.TH "journal_init_dev" 9 "journal_init_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_init_dev \-  creates an initialises a journal structure
.SH SYNOPSIS
.B "journal_t *" journal_init_dev
.BI "(struct block_device *" bdev ","
.BI "struct block_device *" fs_dev ","
.BI "int " start ","
.BI "int " len ","
.BI "int " blocksize ");"
.SH ARGUMENTS
.IP "bdev" 12
 Block device on which to create the journal
.IP "fs_dev" 12
 Device which hold journalled filesystem for this journal.
.IP "start" 12
 Block nr Start of journal.
.IP "len" 12
  Lenght of the journal in blocks.
.IP "blocksize" 12
 blocksize of journalling device
.SH "DESCRIPTION"
journal_init_dev creates a journal which maps a fixed contiguous
range of blocks on an arbitrary block device.
.TH "journal_init_inode" 9 "journal_init_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_init_inode \-  creates a journal which maps to a inode.
.SH SYNOPSIS
.B "journal_t *" journal_init_inode
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 An inode to create the journal in
.SH "DESCRIPTION"
journal_init_inode creates a journal which maps an on-disk inode as
the journal.  The inode must exist already, must support \fBbmap\fP and
must have all data blocks preallocated.
.TH "journal_create" 9 "journal_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_create \-  Initialise the new journal file
.SH SYNOPSIS
.B "int" journal_create
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to create. This structure must have been initialised
.SH "DESCRIPTION"
Given a journal_t structure which tells us which disk blocks we can
use, create a new journal superblock and initialise all of the
journal fields from scratch.  
.TH "journal_update_superblock" 9 "journal_update_superblock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_update_superblock \-  Update journal sb on disk.
.SH SYNOPSIS
.B "void" journal_update_superblock
.BI "(journal_t *" journal ","
.BI "int " wait ");"
.SH ARGUMENTS
.IP "journal" 12
 The journal to update.
.IP "wait" 12
 Set to '0' if you don't want to wait for IO completion.
.SH "DESCRIPTION"
Update a journal's dynamic superblock fields and write it to disk,
optionally waiting for the IO to complete.
.TH "journal_load" 9 "journal_load" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_load \-  Read journal from disk.
.SH SYNOPSIS
.B "int" journal_load
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to act on.
.SH "DESCRIPTION"
Given a journal_t structure which tells us which disk blocks contain
a journal, read the journal from disk to initialise the in-memory
structures.
.TH "journal_destroy" 9 "journal_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_destroy \-  Release a journal_t structure.
.SH SYNOPSIS
.B "void" journal_destroy
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to act on.
.SH "DESCRIPTION"
Release a journal_t structure once it is no longer in use by the
journaled object.
.TH "journal_check_used_features" 9 "journal_check_used_features" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_check_used_features \-  Check if features specified are used.
.SH SYNOPSIS
.B "int" journal_check_used_features
.BI "(journal_t *" journal ","
.BI "unsigned long " compat ","
.BI "unsigned long " ro ","
.BI "unsigned long " incompat ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to check.
.IP "compat" 12
 bitmask of compatible features
.IP "ro" 12
 bitmask of features that force read-only mount
.IP "incompat" 12
 bitmask of incompatible features
.SH "DESCRIPTION"
Check whether the journal uses all of a given set of
features.  Return true (non-zero) if it does. 
.TH "journal_check_available_features" 9 "journal_check_available_features" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_check_available_features \-  Check feature set in journalling layer
.SH SYNOPSIS
.B "int" journal_check_available_features
.BI "(journal_t *" journal ","
.BI "unsigned long " compat ","
.BI "unsigned long " ro ","
.BI "unsigned long " incompat ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to check.
.IP "compat" 12
 bitmask of compatible features
.IP "ro" 12
 bitmask of features that force read-only mount
.IP "incompat" 12
 bitmask of incompatible features
.SH "DESCRIPTION"
Check whether the journaling code supports the use of
all of a given set of features on this journal.  Return true
.TH "journal_set_features" 9 "journal_set_features" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_set_features \-  Mark a given journal feature in the superblock
.SH SYNOPSIS
.B "int" journal_set_features
.BI "(journal_t *" journal ","
.BI "unsigned long " compat ","
.BI "unsigned long " ro ","
.BI "unsigned long " incompat ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to act on.
.IP "compat" 12
 bitmask of compatible features
.IP "ro" 12
 bitmask of features that force read-only mount
.IP "incompat" 12
 bitmask of incompatible features
.SH "DESCRIPTION"
Mark a given journal feature as present on the
superblock.  Returns true if the requested features could be set. 
.TH "journal_update_format" 9 "journal_update_format" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_update_format \-  Update on-disk journal structure.
.SH SYNOPSIS
.B "int" journal_update_format
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to act on.
.SH "DESCRIPTION"
Given an initialised but unloaded journal struct, poke about in the
on-disk structure to update it to the most recent supported version.
.TH "journal_flush" 9 "journal_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_flush \-  Flush journal
.SH SYNOPSIS
.B "int" journal_flush
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to act on.
.SH "DESCRIPTION"
Flush all data for a given journal to disk and empty the journal.
Filesystems can use this when remounting readonly to ensure that
recovery does not need to happen on remount.
.TH "journal_wipe" 9 "journal_wipe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_wipe \-  Wipe journal contents
.SH SYNOPSIS
.B "int" journal_wipe
.BI "(journal_t *" journal ","
.BI "int " write ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to act on.
.IP "write" 12
 flag (see below)
.SH "DESCRIPTION"
Wipe out all of the contents of a journal, safely.  This will produce
a warning if the journal contains any valid recovery information.
Must be called between journal_init_*() and \fBjournal_load\fP.

If 'write' is non-zero, then we wipe out the journal on disk; otherwise
we merely suppress recovery.
.TH "journal_abort" 9 "journal_abort" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_abort \-  Shutdown the journal immediately.
.SH SYNOPSIS
.B "void" journal_abort
.BI "(journal_t *" journal ","
.BI "int " errno ");"
.SH ARGUMENTS
.IP "journal" 12
 the journal to shutdown.
.IP "errno" 12
   an error number to record in the journal indicating
the reason for the shutdown.
.SH "DESCRIPTION"
Perform a complete, immediate shutdown of the ENTIRE
journal (not of a single transaction).  This operation cannot be
undone without closing and reopening the journal.

The journal_abort function is intended to support higher level error
recovery mechanisms such as the ext2/ext3 remount-readonly error
mode.

Journal abort has very specific semantics.  Any existing dirty,
unjournaled buffers in the main filesystem will still be written to
disk by bdflush, but the journaling mechanism will be suspended
immediately and no further transaction commits will be honoured.

Any dirty, journaled buffers will be written back to disk without
hitting the journal.  Atomicity cannot be guaranteed on an aborted
filesystem, but we _do_ attempt to leave as much data as possible
behind for fsck to use for cleanup.

Any attempt to get a new transaction handle on a journal which is in
ABORT state will just result in an -EROFS error return.  A
journal_stop on an existing handle will return -EIO if we have
entered abort state during the update.

Recursive transactions are not disturbed by journal abort until the
final journal_stop, which will receive the -EIO error.

Finally, the journal_abort call allows the caller to supply an errno
which will be recorded (if possible) in the journal superblock.  This
allows a client to record failure conditions in the middle of a
transaction without having to complete the transaction to record the
failure to disk.  ext3_error, for example, now uses this
functionality.

Errors which originate from within the journaling layer will NOT
supply an errno; a null errno implies that absolutely no further
writes are done to the journal (unless there are any already in
progress).
.TH "journal_errno" 9 "journal_errno" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_errno \-  returns the journal's error state.
.SH SYNOPSIS
.B "int" journal_errno
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 journal to examine.
.SH "DESCRIPTION"
This is the errno numbet set with \fBjournal_abort\fP, the last
time the journal was mounted - if the journal was stopped
without calling abort this will be 0.

If the journal has been aborted on this mount time -EROFS will
be returned.
.TH "journal_clear_err" 9 "journal_clear_err" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_clear_err \-  clears the journal's error state
.SH SYNOPSIS
.B "int" journal_clear_err
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 journal to act on.
.SH "DESCRIPTION"
An error must be cleared or Acked to take a FS out of readonly
mode.
.TH "journal_ack_err" 9 "journal_ack_err" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_ack_err \-  Ack journal err.
.SH SYNOPSIS
.B "void" journal_ack_err
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 journal to act on.
.SH "DESCRIPTION"
An error must be cleared or Acked to take a FS out of readonly
mode.
.TH "journal_recover" 9 "journal_recover" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_recover \-  recovers a on-disk journal
.SH SYNOPSIS
.B "int" journal_recover
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 the journal to recover
.SH "DESCRIPTION"
The primary function for recovering the log contents when mounting a
journaled device.  

Recovery is done in three passes.  In the first pass, we look for the
end of the log.  In the second, we assemble the list of revoke
blocks.  In the third and final pass, we replay any un-revoked blocks
in the log.  
.TH "journal_skip_recovery" 9 "journal_skip_recovery" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_skip_recovery \-  Start journal and wipe exiting records 
.SH SYNOPSIS
.B "int" journal_skip_recovery
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
 journal to startup
.SH "DESCRIPTION"
Locate any valid recovery information from the journal and set up the
journal structures in memory to ignore it (presumably because the
caller has evidence that it is out of date).  
This function does'nt appear to be exorted..

We perform one pass over the journal to allow us to tell the user how
much recovery information is being erased, and to let us initialise
the journal transaction sequence numbers to the next unused ID. 
.TH "journal_start" 9 "journal_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_start \-  Obtain a new handle.  
.SH SYNOPSIS
.B "handle_t *" journal_start
.BI "(journal_t *" journal ","
.BI "int " nblocks ");"
.SH ARGUMENTS
.IP "journal" 12
 Journal to start transaction on.
.IP "nblocks" 12
 number of block buffer we might modify
.SH "DESCRIPTION"
We make sure that the transaction can guarantee at least nblocks of
modified buffers in the log.  We block until the log can guarantee
that much space.  

This function is visible to journal users (like ext3fs), so is not
called with the journal already locked.

Return a pointer to a newly allocated handle, or NULL on failure
.TH "journal_extend" 9 "journal_extend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_extend \-  extend buffer credits.
.SH SYNOPSIS
.B "int" journal_extend
.BI "(handle_t *" handle ","
.BI "int " nblocks ");"
.SH ARGUMENTS
.IP "handle" 12
  handle to 'extend'
.IP "nblocks" 12
 nr blocks to try to extend by.
.SH "DESCRIPTION"
Some transactions, such as large extends and truncates, can be done
atomically all at once or in several stages.  The operation requests
a credit for a number of buffer modications in advance, but can
extend its credit if it needs more.  

journal_extend tries to give the running handle more buffer credits.
It does not guarantee that allocation - this is a best-effort only.
The calling process MUST be able to deal cleanly with a failure to
extend here.

Return 0 on success, non-zero on failure.

return code &lt; 0 implies an error
return code &gt; 0 implies normal transaction-full status.
.TH "journal_restart" 9 "journal_restart" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_restart \-  restart a handle .
.SH SYNOPSIS
.B "int" journal_restart
.BI "(handle_t *" handle ","
.BI "int " nblocks ");"
.SH ARGUMENTS
.IP "handle" 12
  handle to restart
.IP "nblocks" 12
 nr credits requested
.SH "DESCRIPTION"
Restart a handle for a multi-transaction filesystem
operation.

If the \fBjournal_extend\fP call above fails to grant new buffer credits
to a running handle, a call to journal_restart will commit the
handle's transaction so far and reattach the handle to a new
transaction capabable of guaranteeing the requested number of
credits.
.TH "journal_lock_updates" 9 "journal_lock_updates" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_lock_updates \-  establish a transaction barrier.
.SH SYNOPSIS
.B "void" journal_lock_updates
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
  Journal to establish a barrier on.
.SH "DESCRIPTION"
This locks out any further updates from being started, and blocks
until all existing updates have completed, returning only once the
journal is in a quiescent state with no updates running.

The journal lock should not be held on entry.
.TH "journal_unlock_updates" 9 "journal_unlock_updates" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_unlock_updates \-  release barrier
.SH SYNOPSIS
.B "void" journal_unlock_updates
.BI "(journal_t *" journal ");"
.SH ARGUMENTS
.IP "journal" 12
  Journal to release the barrier on.
.SH "DESCRIPTION"
Release a transaction barrier obtained with \fBjournal_lock_updates\fP.

Should be called without the journal lock held.
.TH "journal_get_write_access" 9 "journal_get_write_access" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_get_write_access \-  notify intent to modify a buffer for metadata (not data) update.
.SH SYNOPSIS
.B "int" journal_get_write_access
.BI "(handle_t *" handle ","
.BI "struct buffer_head *" bh ");"
.SH ARGUMENTS
.IP "handle" 12
 transaction to add buffer modifications to
.IP "bh" 12
     bh to be used for metadata writes
.SH "DESCRIPTION"
Returns an error code or 0 on success.

In full data journalling mode the buffer may be of type BJ_AsyncData,
because we're \fBwrite\fPing a buffer which is also part of a shared mapping.
.TH "journal_get_create_access" 9 "journal_get_create_access" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_get_create_access \-  notify intent to use newly created bh
.SH SYNOPSIS
.B "int" journal_get_create_access
.BI "(handle_t *" handle ","
.BI "struct buffer_head *" bh ");"
.SH ARGUMENTS
.IP "handle" 12
 transaction to new buffer to
.IP "bh" 12
 new buffer.
.SH "DESCRIPTION"
Call this if you create a new bh.
.TH "journal_get_undo_access" 9 "journal_get_undo_access" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_get_undo_access \-   Notify intent to modify metadata with
.SH SYNOPSIS
.B "int" journal_get_undo_access
.BI "(handle_t *" handle ","
.BI "struct buffer_head *" bh ");"
.SH ARGUMENTS
.IP "handle" 12
 transaction
.IP "bh" 12
 buffer to undo
.SH "DESCRIPTION"
Sometimes there is a need to distinguish between metadata which has
been committed to disk and that which has not.  The ext3fs code uses
this for freeing and allocating space, we have to make sure that we
do not reuse freed space until the deallocation has been committed,
since if we overwrote that space we would make the delete
un-rewindable in case of a crash.

To deal with that, journal_get_undo_access requests write access to a
buffer for parts of non-rewindable operations such as delete
operations on the bitmaps.  The journaling code must keep a copy of
the buffer's contents prior to the undo_access call until such time
as we know that the buffer has definitely been committed to disk.

We never need to know which transaction the committed data is part
of, buffers touched here are guaranteed to be dirtied later and so
will be committed to a new transaction in due course, at which point
we can discard the old committed data pointer.

Returns error number or 0 on success.
.SH "DESCRIPTION"
Sometimes there is a need to distinguish between metadata which has
been committed to disk and that which has not.  The ext3fs code uses
this for freeing and allocating space, we have to make sure that we
do not reuse freed space until the deallocation has been committed,
since if we overwrote that space we would make the delete
un-rewindable in case of a crash.

To deal with that, journal_get_undo_access requests write access to a
buffer for parts of non-rewindable operations such as delete
operations on the bitmaps.  The journaling code must keep a copy of
the buffer's contents prior to the undo_access call until such time
as we know that the buffer has definitely been committed to disk.

We never need to know which transaction the committed data is part
of, buffers touched here are guaranteed to be dirtied later and so
will be committed to a new transaction in due course, at which point
we can discard the old committed data pointer.

Returns error number or 0 on success.
.TH "journal_dirty_data" 9 "journal_dirty_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_dirty_data \-   mark a buffer as containing dirty data which
.SH SYNOPSIS
.B "int" journal_dirty_data
.BI "(handle_t *" handle ","
.BI "struct buffer_head *" bh ");"
.SH ARGUMENTS
.IP "handle" 12
 transaction
.IP "bh" 12
 bufferhead to mark
.SH "DESCRIPTION"
The buffer is placed on the transaction's data list and is marked as
belonging to the transaction.

Returns error number or 0 on success.

\fBjournal_dirty_data\fP can be called via page_launder-&gt;ext3_writepage
by kswapd.
.SH "DESCRIPTION"
The buffer is placed on the transaction's data list and is marked as
belonging to the transaction.

Returns error number or 0 on success.

\fBjournal_dirty_data\fP can be called via page_launder-&gt;ext3_writepage
by kswapd.
.TH "journal_dirty_metadata" 9 "journal_dirty_metadata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_dirty_metadata \-   mark a buffer as containing dirty metadata
.SH SYNOPSIS
.B "int" journal_dirty_metadata
.BI "(handle_t *" handle ","
.BI "struct buffer_head *" bh ");"
.SH ARGUMENTS
.IP "handle" 12
 transaction to add buffer to.
.IP "bh" 12
 buffer to mark 
.SH "DESCRIPTION"
mark dirty metadata which needs to be journaled as part of the current
transaction.

The buffer is placed on the transaction's metadata list and is marked
as belonging to the transaction.  

Returns error number or 0 on success.  

Special care needs to be taken if the buffer already belongs to the
current committing transaction (in which case we should have frozen
data present for that commit).  In that case, we don't relink the
.SH "BUFFER"
 that only gets done when the old transaction finally
completes its commit.
.TH "journal_forget" 9 "journal_forget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_forget \-  bforget() for potentially-journaled buffers.
.SH SYNOPSIS
.B "int" journal_forget
.BI "(handle_t *" handle ","
.BI "struct buffer_head *" bh ");"
.SH ARGUMENTS
.IP "handle" 12
 transaction handle
.IP "bh" 12
     bh to 'forget'
.SH "DESCRIPTION"
We can only do the bforget if there are no commits pending against the
buffer.  If the buffer is dirty in the current running transaction we
can safely unlink it. 

bh may not be a journalled buffer at all - it may be a non-JBD
buffer which came off the hashtable.  Check for this.

Decrements bh-&gt;b_count by one.

Allow this call even if the handle has aborted --- it may be part of
the caller's cleanup after an abort.
.TH "journal_stop" 9 "journal_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_stop \-  complete a transaction
.SH SYNOPSIS
.B "int" journal_stop
.BI "(handle_t *" handle ");"
.SH ARGUMENTS
.IP "handle" 12
 tranaction to complete.
.SH "DESCRIPTION"
All done for a particular handle.

There is not much action needed here.  We just return any remaining
buffer credits to the transaction and remove the handle.  The only
complication is that we need to start a commit operation if the
filesystem is marked for synchronous update.

journal_stop itself will not usually return an error, but it may
do so in unusual circumstances.  In particular, expect it to 
return -EIO if a journal_abort has been executed since the
transaction began.
.TH "journal_try_to_free_buffers" 9 "journal_try_to_free_buffers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_try_to_free_buffers \-  try to free page buffers.
.SH SYNOPSIS
.B "int" journal_try_to_free_buffers
.BI "(journal_t *" journal ","
.BI "struct page *" page ","
.BI "int " unused_gfp_mask ");"
.SH ARGUMENTS
.IP "journal" 12
 journal for operation
.IP "page" 12
 to try and free
.IP "unused_gfp_mask" 12
 unused
.SH "DESCRIPTION"

For all the buffers on this page,
if they are fully written out ordered data, move them onto BUF_CLEAN
so \fBtry_to_free_buffers\fP can reap them.

This function returns non-zero if we wish \fBtry_to_free_buffers\fP
to be called. We do this if the page is releasable by \fBtry_to_free_buffers\fP.
We also do it if the page has locked or dirty buffers and the caller wants
us to perform sync or async writeout.

This complicates JBD locking somewhat.  We aren't protected by the
BKL here.  We wish to remove the buffer from its committing or
running transaction's -&gt;t_datalist via __journal_unfile_buffer.

This may *change* the value of transaction_t-&gt;t_datalist, so anyone
who looks at t_datalist needs to lock against this function.

Even worse, someone may be doing a journal_dirty_data on this
buffer.  So we need to lock against that.  \fBjournal_dirty_data\fP
will come out of the lock with the buffer dirty, which makes it
ineligible for release here.

Who else is affected by this?  hmm...  Really the only contender
is \fBdo_get_write_access\fP - it could be looking at the buffer while
\fBjournal_try_to_free_buffer\fP is changing its state.  But that
cannot happen because we never reallocate freed data as metadata
while the data is part of a transaction.  Yes?
.TH "journal_invalidatepage" 9 "journal_invalidatepage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
journal_invalidatepage \- 
.SH SYNOPSIS
.B "int" journal_invalidatepage
.BI "(journal_t *" journal ","
.BI "struct page *" page ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "journal" 12
 journal to use for flush... 
.IP "page" 12
    page to flush
.IP "offset" 12
  length of page to invalidate.
.SH "DESCRIPTION"
Reap page buffers containing data after offset in page.

Return non-zero if the page's buffers were successfully reaped.
.TH "may_umount_tree" 9 "may_umount_tree" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
may_umount_tree \-  check if a mount tree is busy
.SH SYNOPSIS
.B "int" may_umount_tree
.BI "(struct vfsmount *" mnt ");"
.SH ARGUMENTS
.IP "mnt" 12
 root of mount tree
.SH "DESCRIPTION"
This is called to check if a tree of mounts has any
open files, pwds, chroots or sub mounts that are
busy.
.TH "may_umount" 9 "may_umount" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
may_umount \-  check if a mount point is busy
.SH SYNOPSIS
.B "int" may_umount
.BI "(struct vfsmount *" mnt ");"
.SH ARGUMENTS
.IP "mnt" 12
 root of mount
.SH "DESCRIPTION"
This is called to check if a mount point has any
open files, pwds, chroots or sub mounts. If the
mount has sub mounts this will return busy
regardless of whether the sub mounts are busy.

Doesn't take quota and stuff into account. IOW, in some cases it will
give false negatives. The main reason why it's here is that we need
a non-destructive way to look for easily umountable filesystems.
.TH "seq_open" 9 "seq_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
seq_open \- 	initialize sequential file
.SH SYNOPSIS
.B "int" seq_open
.BI "(struct file *" file ","
.BI "struct seq_operations *" op ");"
.SH ARGUMENTS
.IP "file" 12
 file we initialize
.IP "op" 12
 method table describing the sequence
.SH "DESCRIPTION"
\fBseq_open\fP sets \fIfile\fP, associating it with a sequence described
by \fIop\fP.  \fIop\fP-&gt;\fBstart\fP sets the iterator up and returns the first
element of sequence. \fIop\fP-&gt;\fBstop\fP shuts it down.  \fIop\fP-&gt;\fBnext\fP
returns the next element of sequence.  \fIop\fP-&gt;\fBshow\fP prints element
into the buffer.  In case of error -&gt;\fBstart\fP and -&gt;\fBnext\fP return
ERR_PTR(error).  In the end of sequence they return NULL. -&gt;\fBshow\fP
returns 0 in case of success and negative number in case of error.
.TH "seq_read" 9 "seq_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
seq_read \- 	-\\\gt;read() method for sequential files.
.SH SYNOPSIS
.B "ssize_t" seq_read
.BI "(struct file *" file ","
.BI "char __user *" buf ","
.BI "size_t " size ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
 the file to read from
.IP "buf" 12
 the buffer to read to
.IP "size" 12
 the maximum number of bytes to read
.IP "ppos" 12
 the current position in the file
.SH "DESCRIPTION"
Ready-made -&gt;f_op-&gt;\fBread\fP
.TH "seq_lseek" 9 "seq_lseek" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
seq_lseek \- 	-\\\gt;llseek() method for sequential files.
.SH SYNOPSIS
.B "loff_t" seq_lseek
.BI "(struct file *" file ","
.BI "loff_t " offset ","
.BI "int " origin ");"
.SH ARGUMENTS
.IP "file" 12
 the file in question
.IP "offset" 12
 new position
.IP "origin" 12
 0 for absolute, 1 for relative position
.SH "DESCRIPTION"
Ready-made -&gt;f_op-&gt;\fBllseek\fP
.TH "seq_release" 9 "seq_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
seq_release \- 	free the structures associated with sequential file.
.SH SYNOPSIS
.B "int" seq_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 file-&gt;f_dentry-&gt;d_inode
.IP "file" 12
 file in question
.SH "DESCRIPTION"
Frees the structures associated with sequential file; can be used
as -&gt;f_op-&gt;\fBrelease\fP if you don't have private data to destroy.
.TH "seq_escape" 9 "seq_escape" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
seq_escape \- 	print string into buffer, escaping some characters
.SH SYNOPSIS
.B "int" seq_escape
.BI "(struct seq_file *" m ","
.BI "const char *" s ","
.BI "const char *" esc ");"
.SH ARGUMENTS
.IP "m" 12
	target buffer
.IP "s" 12
	string
.IP "esc" 12
	set of characters that need escaping
.SH "DESCRIPTION"
Puts string into buffer, replacing each occurrence of character from
\fIesc\fP with usual octal escape.  Returns 0 in case of success, -1 - in
case of overflow.
.TH "posix_lock_file" 9 "posix_lock_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
posix_lock_file \-  Apply a POSIX-style lock to a file
.SH SYNOPSIS
.B "int" posix_lock_file
.BI "(struct file *" filp ","
.BI "struct file_lock *" fl ");"
.SH ARGUMENTS
.IP "filp" 12
 The file to apply the lock to
.IP "fl" 12
 The lock to be applied
.SH "DESCRIPTION"
Add a POSIX style lock to a file.
We merge adjacent &amp; overlapping locks whenever possible.
POSIX locks are sorted by owner task, then by starting address
.TH "posix_lock_file_wait" 9 "posix_lock_file_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
posix_lock_file_wait \-  Apply a POSIX-style lock to a file
.SH SYNOPSIS
.B "int" posix_lock_file_wait
.BI "(struct file *" filp ","
.BI "struct file_lock *" fl ");"
.SH ARGUMENTS
.IP "filp" 12
 The file to apply the lock to
.IP "fl" 12
 The lock to be applied
.SH "DESCRIPTION"
Add a POSIX style lock to a file.
We merge adjacent &amp; overlapping locks whenever possible.
POSIX locks are sorted by owner task, then by starting address
.TH "locks_mandatory_locked" 9 "locks_mandatory_locked" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
locks_mandatory_locked \-  Check for an active lock
.SH SYNOPSIS
.B "int" locks_mandatory_locked
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 the file to check
.SH "DESCRIPTION"
Searches the inode's list of locks to find any POSIX locks which conflict.
This function is called from \fBlocks_verify_locked\fP only.
.TH "locks_mandatory_area" 9 "locks_mandatory_area" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
locks_mandatory_area \-  Check for a conflicting lock
.SH SYNOPSIS
.B "int" locks_mandatory_area
.BI "(int " read_write ","
.BI "struct inode *" inode ","
.BI "struct file *" filp ","
.BI "loff_t " offset ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "read_write" 12
 FLOCK_VERIFY_WRITE for exclusive access, FLOCK_VERIFY_READ
for shared
.IP "inode" 12
      the file to check
.IP "filp" 12
       how the file was opened (if it was)
.IP "offset" 12
     start of area to check
.IP "count" 12
      length of area to check
.SH "DESCRIPTION"
Searches the inode's list of locks to find any POSIX locks which conflict.
This function is called from \fBrw_verify_area\fP and
\fBlocks_verify_truncate\fP.
.TH "__break_lease" 9 "__break_lease" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__break_lease \- 	revoke all outstanding leases on file
.SH SYNOPSIS
.B "int" __break_lease
.BI "(struct inode *" inode ","
.BI "unsigned int " mode ");"
.SH ARGUMENTS
.IP "inode" 12
 the inode of the file to return
.IP "mode" 12
 the open mode (read or write)
.SH "DESCRIPTION"
break_lease (inlined for speed) has checked there already
is a lease on this file.  Leases are broken on a call to \fBopen\fP
or \fBtruncate\fP.  This function can sleep unless you
specified O_NONBLOCK to your \fBopen\fP.
.TH "lease_get_mtime" 9 "lease_get_mtime" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lease_get_mtime \- 
.SH SYNOPSIS
.B "void" lease_get_mtime
.BI "(struct inode *" inode ","
.BI "struct timespec *" time ");"
.SH ARGUMENTS
.IP "inode" 12
 the inode
.IP "time" 12
  pointer to a timespec which will contain the last modified time
.SH "DESCRIPTION"
This is to force NFS clients to flush their caches for files with
exclusive leases.  The justification is that if someone has an
exclusive lease, then they could be modifiying it.
.TH "fcntl_getlease" 9 "fcntl_getlease" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fcntl_getlease \-  Enquire what lease is currently active
.SH SYNOPSIS
.B "int" fcntl_getlease
.BI "(struct file *" filp ");"
.SH ARGUMENTS
.IP "filp" 12
 the file
.SH "DESCRIPTION"
The value returned by this function will be one of
(if no lease break is pending):

F_RDLCK to indicate a shared lease is held.

F_WRLCK to indicate an exclusive lease is held.

F_UNLCK to indicate no lease is held.

(if a lease break is pending):

F_RDLCK to indicate an exclusive lease needs to be
changed to a shared lease (or removed).

F_UNLCK to indicate the lease needs to be removed.
.SH "XXX"
 sfr &amp; willy disagree over whether F_INPROGRESS
should be returned to userspace.
.TH "__setlease" 9 "__setlease" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__setlease \- 	sets a lease on an open file
.SH SYNOPSIS
.B "int" __setlease
.BI "(struct file *" filp ","
.BI "long " arg ","
.BI "struct file_lock **" flp ");"
.SH ARGUMENTS
.IP "filp" 12
 file pointer
.IP "arg" 12
 type of lease to obtain
.IP "flp" 12
 input - file_lock to use, output - file_lock inserted
.SH "DESCRIPTION"
The (input) flp-&gt;fl_lmops-&gt;fl_break function is required
by \fBbreak_lease\fP.

Called with kernel lock held.
.TH "fcntl_setlease" 9 "fcntl_setlease" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fcntl_setlease \- 	sets a lease on an open file
.SH SYNOPSIS
.B "int" fcntl_setlease
.BI "(unsigned int " fd ","
.BI "struct file *" filp ","
.BI "long " arg ");"
.SH ARGUMENTS
.IP "fd" 12
 open file descriptor
.IP "filp" 12
 file pointer
.IP "arg" 12
 type of lease to obtain
.SH "DESCRIPTION"
Call this fcntl to establish a lease on the file.
Note that you also need to call F_SETSIG to
receive a signal when the lease is broken.
.TH "flock_lock_file_wait" 9 "flock_lock_file_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
flock_lock_file_wait \-  Apply a FLOCK-style lock to a file
.SH SYNOPSIS
.B "int" flock_lock_file_wait
.BI "(struct file *" filp ","
.BI "struct file_lock *" fl ");"
.SH ARGUMENTS
.IP "filp" 12
 The file to apply the lock to
.IP "fl" 12
 The lock to be applied
.SH "DESCRIPTION"
Add a FLOCK style lock to a file.
.TH "sys_flock" 9 "sys_flock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_flock \-  flock() system call.
.SH SYNOPSIS
.B "long" sys_flock
.BI "(unsigned int " fd ","
.BI "unsigned int " cmd ");"
.SH ARGUMENTS
.IP "fd" 12
 the file descriptor to lock.
.IP "cmd" 12
 the type of lock to apply.
.SH "DESCRIPTION"
Apply a FL_FLOCK style lock to an open file descriptor.
The \fIcmd\fP can be one of

LOCK_SH -- a shared lock.

LOCK_EX -- an exclusive lock.

LOCK_UN -- remove an existing lock.

LOCK_MAND -- a `mandatory' flock.  This exists to emulate Windows Share Modes.

LOCK_MAND can be combined with LOCK_READ or LOCK_WRITE to allow other
processes read and write access respectively.
.TH "posix_block_lock" 9 "posix_block_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
posix_block_lock \-  blocks waiting for a file lock
.SH SYNOPSIS
.B "void" posix_block_lock
.BI "(struct file_lock *" blocker ","
.BI "struct file_lock *" waiter ");"
.SH ARGUMENTS
.IP "blocker" 12
 the lock which is blocking
.IP "waiter" 12
 the lock which conflicts and has to wait
.SH "DESCRIPTION"
lockd needs to block waiting for locks.
.TH "posix_unblock_lock" 9 "posix_unblock_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
posix_unblock_lock \-  stop waiting for a file lock
.SH SYNOPSIS
.B "void" posix_unblock_lock
.BI "(struct file *" filp ","
.BI "struct file_lock *" waiter ");"
.SH ARGUMENTS
.IP "filp" 12
   how the file was opened
.IP "waiter" 12
 the lock which was waiting
.SH "DESCRIPTION"
lockd needs to block waiting for locks.
.TH "get_locks_status" 9 "get_locks_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_locks_status \- 	reports lock usage in /proc/locks
.SH SYNOPSIS
.B "int" get_locks_status
.BI "(char *" buffer ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " length ");"
.SH ARGUMENTS
.IP "buffer" 12
 address in userspace to write into
.IP "start" 12
 ?
.IP "offset" 12
 how far we are through the buffer
.IP "length" 12
 how much to read
.TH "lock_may_read" 9 "lock_may_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lock_may_read \-  checks that the region is free of locks
.SH SYNOPSIS
.B "int" lock_may_read
.BI "(struct inode *" inode ","
.BI "loff_t " start ","
.BI "unsigned long " len ");"
.SH ARGUMENTS
.IP "inode" 12
 the inode that is being read
.IP "start" 12
 the first byte to read
.IP "len" 12
 the number of bytes to read
.SH "DESCRIPTION"
Emulates Windows locking requirements.  Whole-file
mandatory locks (share modes) can prohibit a read and
byte-range POSIX locks can prohibit a read if they overlap.

N.B. this function is only ever called
from knfsd and ownership of locks is never checked.
.TH "lock_may_write" 9 "lock_may_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lock_may_write \-  checks that the region is free of locks
.SH SYNOPSIS
.B "int" lock_may_write
.BI "(struct inode *" inode ","
.BI "loff_t " start ","
.BI "unsigned long " len ");"
.SH ARGUMENTS
.IP "inode" 12
 the inode that is being written
.IP "start" 12
 the first byte to write
.IP "len" 12
 the number of bytes to write
.SH "DESCRIPTION"
Emulates Windows locking requirements.  Whole-file
mandatory locks (share modes) can prohibit a write and
byte-range POSIX locks can prohibit a write if they overlap.

N.B. this function is only ever called
from knfsd and ownership of locks is never checked.
.TH "devfs_get" 9 "devfs_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_get \-  Get a reference to a devfs entry.
.SH SYNOPSIS
.B "struct devfs_entry *" devfs_get
.BI "(struct devfs_entry *" de ");"
.SH ARGUMENTS
.IP "de" 12
  The devfs entry.
.TH "devfs_put" 9 "devfs_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_put \-  Put (release) a reference to a devfs entry.
.SH SYNOPSIS
.B "void" devfs_put
.BI "(devfs_handle_t " de ");"
.SH ARGUMENTS
.IP "de" 12
  The handle to the devfs entry.
.TH "_devfs_search_dir" 9 "_devfs_search_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_search_dir \-  Search for a devfs entry in a directory.
.SH SYNOPSIS
.B "struct devfs_entry *" _devfs_search_dir
.BI "(struct devfs_entry *" dir ","
.BI "const char *" name ","
.BI "unsigned int " namelen ");"
.SH ARGUMENTS
.IP "dir" 12
  The directory to search.
.IP "name" 12
  The name of the entry to search for.
.IP "namelen" 12
  The number of characters in \fIname\fP.
.SH "DESCRIPTION"
Search for a devfs entry in a directory and returns a pointer to the entry
on success, else NULL. The directory must be locked already.
An implicit \fBdevfs_get\fP is performed on the returned entry.
.TH "_devfs_alloc_entry" 9 "_devfs_alloc_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_alloc_entry \-  Allocate a devfs entry.
.SH SYNOPSIS
.B "struct devfs_entry *" _devfs_alloc_entry
.BI "(const char *" name ","
.BI "unsigned int " namelen ","
.BI "umode_t " mode ");"
.SH ARGUMENTS
.IP "name" 12
     the name of the entry
.IP "namelen" 12
  the number of characters in \fIname\fP
.IP "mode" 12
     the mode for the entry
.SH "DESCRIPTION"
Allocate a devfs entry and returns a pointer to the entry on success, else
NULL.
.TH "_devfs_append_entry" 9 "_devfs_append_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_append_entry \-  Append a devfs entry to a directory's child list.
.SH SYNOPSIS
.B "int" _devfs_append_entry
.BI "(devfs_handle_t " dir ","
.BI "devfs_handle_t " de ","
.BI "devfs_handle_t *" old_de ");"
.SH ARGUMENTS
.IP "dir" 12
  The directory to add to.
.IP "de" 12
  The devfs entry to append.
.IP "old_de" 12
 If an existing entry exists, it will be written here. This may
be NULL. An implicit \fBdevfs_get\fP is performed on this entry.
.SH "DESCRIPTION"
Append a devfs entry to a directory's list of children, checking first to
see if an entry of the same name exists. The directory will be locked.
The value 0 is returned on success, else a negative error code.
On failure, an implicit \fBdevfs_put\fP is performed on de.
.TH "_devfs_get_root_entry" 9 "_devfs_get_root_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_get_root_entry \-  Get the root devfs entry.
.SH SYNOPSIS
.B "struct devfs_entry *" _devfs_get_root_entry
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns the root devfs entry on success, else NULL.

TODO it must be called asynchronously due to the fact
that devfs is initialized relatively late. Proper way
is to remove module_init from init_devfs_fs and manually
call it early enough during system init
.TH "_devfs_descend" 9 "_devfs_descend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_descend \-  Descend down a tree using the next component name.
.SH SYNOPSIS
.B "struct devfs_entry *" _devfs_descend
.BI "(struct devfs_entry *" dir ","
.BI "const char *" name ","
.BI "int " namelen ","
.BI "int *" next_pos ");"
.SH ARGUMENTS
.IP "dir" 12
  The directory to search.
.IP "name" 12
  The component name to search for.
.IP "namelen" 12
  The length of name.
.IP "next_pos" 12
  The position of the next '/' or '\0' is written here.
.SH "DESCRIPTION"
Descend into a directory, searching for a component. This function forms
the core of a tree-walking algorithm. The directory will be locked.
The devfs entry corresponding to the component is returned. If there is
no matching entry, NULL is returned.
An implicit \fBdevfs_get\fP is performed on the returned entry.
.TH "_devfs_find_entry" 9 "_devfs_find_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_find_entry \-  Find a devfs entry.
.SH SYNOPSIS
.B "struct devfs_entry *" _devfs_find_entry
.BI "(devfs_handle_t " dir ","
.BI "const char *" name ","
.BI "int " traverse_symlink ");"
.SH ARGUMENTS
.IP "dir" 12
 The handle to the parent devfs directory entry. If this is NULL the
name is relative to the root of the devfs.
.IP "name" 12
 The name of the entry. This may be NULL.
.IP "traverse_symlink" 12
 If TRUE then symbolic links are traversed.
.SH "DESCRIPTION"
Returns the devfs_entry pointer on success, else NULL. An implicit
\fBdevfs_get\fP is performed.
.TH "free_dentry" 9 "free_dentry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_dentry \-  Free the dentry for a device entry and invalidate inode.
.SH SYNOPSIS
.B "void" free_dentry
.BI "(struct devfs_entry *" de ");"
.SH ARGUMENTS
.IP "de" 12
 The entry.
.SH "DESCRIPTION"
This must only be called after the entry has been unhooked from its
parent directory.
.TH "is_devfsd_or_child" 9 "is_devfsd_or_child" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_devfsd_or_child \-  Test if the current process is devfsd or one of its children.
.SH SYNOPSIS
.B "int" is_devfsd_or_child
.BI "(struct fs_info *" fs_info ");"
.SH ARGUMENTS
.IP "fs_info" 12
 The filesystem information.
.SH "DESCRIPTION"
Returns TRUE if devfsd or child, else FALSE.
.TH "devfsd_queue_empty" 9 "devfsd_queue_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfsd_queue_empty \-  Test if devfsd has work pending in its event queue.
.SH SYNOPSIS
.B "int" devfsd_queue_empty
.BI "(struct fs_info *" fs_info ");"
.SH ARGUMENTS
.IP "fs_info" 12
 The filesystem information.
.SH "DESCRIPTION"
Returns TRUE if the queue is empty, else FALSE.
.TH "wait_for_devfsd_finished" 9 "wait_for_devfsd_finished" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_for_devfsd_finished \-  Wait for devfsd to finish processing its event queue.
.SH SYNOPSIS
.B "int" wait_for_devfsd_finished
.BI "(struct fs_info *" fs_info ");"
.SH ARGUMENTS
.IP "fs_info" 12
 The filesystem information.
.SH "DESCRIPTION"
Returns TRUE if no more waiting will be required, else FALSE.
.TH "devfsd_notify_de" 9 "devfsd_notify_de" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfsd_notify_de \-  Notify the devfsd daemon of a change.
.SH SYNOPSIS
.B "int" devfsd_notify_de
.BI "(struct devfs_entry *" de ","
.BI "unsigned short " type ","
.BI "umode_t " mode ","
.BI "uid_t " uid ","
.BI "gid_t " gid ","
.BI "struct fs_info *" fs_info ");"
.SH ARGUMENTS
.IP "de" 12
 The devfs entry that has changed. This and all parent entries will
have their reference counts incremented if the event was queued.
.IP "type" 12
 The type of change.
.IP "mode" 12
 The mode of the entry.
.IP "uid" 12
 The user ID.
.IP "gid" 12
 The group ID.
.IP "fs_info" 12
 The filesystem info.
.SH "DESCRIPTION"
Returns TRUE if an event was queued and devfsd woken up, else FALSE.
.TH "devfsd_notify" 9 "devfsd_notify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfsd_notify \-  Notify the devfsd daemon of a change.
.SH SYNOPSIS
.B "void" devfsd_notify
.BI "(struct devfs_entry *" de ","
.BI "unsigned short " type ");"
.SH ARGUMENTS
.IP "de" 12
 The devfs entry that has changed.
.IP "type" 12
 The type of change event.
.TH "_devfs_unhook" 9 "_devfs_unhook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_unhook \-  Unhook a device entry from its parents list
.SH SYNOPSIS
.B "int" _devfs_unhook
.BI "(struct devfs_entry *" de ");"
.SH ARGUMENTS
.IP "de" 12
 The entry to unhook.
.SH "DESCRIPTION"
Returns TRUE if the entry was unhooked, else FALSE if it was
previously unhooked.
The caller must have a write lock on the parent directory.
.TH "_devfs_unregister" 9 "_devfs_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_unregister \-  Unregister a device entry from its parent.
.SH SYNOPSIS
.B "void" _devfs_unregister
.BI "(struct devfs_entry *" dir ","
.BI "struct devfs_entry *" de ");"
.SH ARGUMENTS
.IP "dir" 12
 The parent directory.
.IP "de" 12
 The entry to unregister.
.SH "DESCRIPTION"
The caller must have a write lock on the parent directory, which is
unlocked by this function.
.TH "devfs_mk_symlink" 9 "devfs_mk_symlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_mk_symlink \- 
.SH SYNOPSIS
.B "int" devfs_mk_symlink
.BI "(const char *" from ","
.BI "const char *" to ");"
.SH ARGUMENTS
.IP "from" 12
 The name of the entry.
.IP "to" 12
 Name of the destination
.SH "DESCRIPTION"
Returns 0 on success, else a negative error code is returned.
.TH "devfs_mk_dir" 9 "devfs_mk_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_mk_dir \-  Create a directory in the devfs namespace.
.SH SYNOPSIS
.B "int" devfs_mk_dir
.BI "(const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "fmt" 12
 The name of the entry.
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Use of this function is optional. The \fBdevfs_register\fP function
will automatically create intermediate directories as needed. This function
is provided for efficiency reasons, as it provides a handle to a directory.
On failure NULL is returned.
.SH "DESCRIPTION"
Use of this function is optional. The \fBdevfs_register\fP function
will automatically create intermediate directories as needed. This function
is provided for efficiency reasons, as it provides a handle to a directory.
On failure NULL is returned.
.TH "devfs_generate_path" 9 "devfs_generate_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_generate_path \-  Generate a pathname for an entry, relative to the devfs root.
.SH SYNOPSIS
.B "int" devfs_generate_path
.BI "(devfs_handle_t " de ","
.BI "char *" path ","
.BI "int " buflen ");"
.SH ARGUMENTS
.IP "de" 12
 The devfs entry.
.IP "path" 12
 The buffer to write the pathname to. The pathname and '\0'
terminator will be written at the end of the buffer.
.IP "buflen" 12
 The length of the buffer.
.SH "DESCRIPTION"
Returns the offset in the buffer where the pathname starts on success,
else a negative error code.
.TH "devfs_setup" 9 "devfs_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_setup \-  Process kernel boot options.
.SH SYNOPSIS
.B "int __init" devfs_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
 The boot options after the "devfs=".
.TH "try_modload" 9 "try_modload" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
try_modload \-  Notify devfsd of an inode lookup by a non-devfsd process.
.SH SYNOPSIS
.B "int" try_modload
.BI "(struct devfs_entry *" parent ","
.BI "struct fs_info *" fs_info ","
.BI "const char *" name ","
.BI "unsigned " namelen ","
.BI "struct devfs_entry *" buf ");"
.SH ARGUMENTS
.IP "parent" 12
 The parent devfs entry.
.IP "fs_info" 12
 The filesystem info.
.IP "name" 12
 The device name.
.IP "namelen" 12
 The number of characters in \fIname\fP.
.IP "buf" 12
 A working area that will be used. This must not go out of scope
until devfsd is idle again.
.SH "DESCRIPTION"
Returns 0 on success (event was queued), else a negative error code.
.TH "_devfs_get_vfs_inode" 9 "_devfs_get_vfs_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
_devfs_get_vfs_inode \-  Get a VFS inode.
.SH SYNOPSIS
.B "struct inode *" _devfs_get_vfs_inode
.BI "(struct super_block *" sb ","
.BI "struct devfs_entry *" de ","
.BI "struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "sb" 12
 The super block.
.IP "de" 12
 The devfs inode.
.IP "dentry" 12
 The dentry to register with the devfs inode.
.SH "DESCRIPTION"
Returns the inode on success, else NULL. An implicit \fBdevfs_get\fP is
performed if the inode is created.
.TH "devfs_d_release" 9 "devfs_d_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_d_release \-  Callback for when a dentry is freed.
.SH SYNOPSIS
.B "void" devfs_d_release
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 The dentry.
.TH "devfs_d_iput" 9 "devfs_d_iput" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_d_iput \-  Callback for when a dentry loses its inode.
.SH SYNOPSIS
.B "void" devfs_d_iput
.BI "(struct dentry *" dentry ","
.BI "struct inode *" inode ");"
.SH ARGUMENTS
.IP "dentry" 12
 The dentry.
.IP "inode" 12
	The inode.
.TH "devfs_d_delete" 9 "devfs_d_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
devfs_d_delete \-  Callback for when all files for a dentry are closed.
.SH SYNOPSIS
.B "int" devfs_d_delete
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 The dentry.
.TH "vxfs_read_olt" 9 "vxfs_read_olt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_read_olt \-  read olt
.SH SYNOPSIS
.B "int" vxfs_read_olt
.BI "(struct super_block *" sbp ","
.BI "u_long " bsize ");"
.SH ARGUMENTS
.IP "sbp" 12
	superblock of the filesystem
.IP "bsize" 12
	blocksize of the filesystem
.SH "DESCRIPTION"
vxfs_read_olt reads the olt of the filesystem described by \fIsbp\fP
into main memory and does some basic setup.
.SH "RETURNS"
Zero on success, else a negative error code.
.TH "vxfs_find_entry" 9 "vxfs_find_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_find_entry \-  find a mathing directory entry for a dentry
.SH SYNOPSIS
.B "struct vxfs_direct *" vxfs_find_entry
.BI "(struct inode *" ip ","
.BI "struct dentry *" dp ","
.BI "struct page **" ppp ");"
.SH ARGUMENTS
.IP "ip" 12
		directory inode
.IP "dp" 12
		dentry for which we want to find a direct
.IP "ppp" 12
	gets filled with the page the return value sits in
.SH "DESCRIPTION"
vxfs_find_entry finds a &amp;struct vxfs_direct for the VFS directory
cache entry \fIdp\fP.  \fIppp\fP will be filled with the page the return
value resides in.
.SH "RETURNS"
The wanted direct on success, else a NULL pointer.
.TH "vxfs_inode_by_name" 9 "vxfs_inode_by_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_inode_by_name \-  find inode number for dentry
.SH SYNOPSIS
.B "ino_t" vxfs_inode_by_name
.BI "(struct inode *" dip ","
.BI "struct dentry *" dp ");"
.SH ARGUMENTS
.IP "dip" 12
	directory to search in
.IP "dp" 12
		dentry we seach for
.SH "DESCRIPTION"
vxfs_inode_by_name finds out the inode number of
the path component described by \fIdp\fP in \fIdip\fP.
.SH "RETURNS"
The wanted inode number on success, else Zero.
.TH "vxfs_lookup" 9 "vxfs_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_lookup \-  lookup pathname component
.SH SYNOPSIS
.B "struct dentry *" vxfs_lookup
.BI "(struct inode *" dip ","
.BI "struct dentry *" dp ","
.BI "struct nameidata *" nd ");"
.SH ARGUMENTS
.IP "dip" 12
	dir in which we lookup
.IP "dp" 12
		dentry we lookup
.IP "nd" 12
		lookup nameidata
.SH "DESCRIPTION"
vxfs_lookup tries to lookup the pathname component described
by \fIdp\fP in \fIdip\fP.
.SH "RETURNS"
A NULL-pointer on success, else an negative error code encoded
in the return pointer.
.TH "vxfs_readdir" 9 "vxfs_readdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_readdir \-  read a directory
.SH SYNOPSIS
.B "int" vxfs_readdir
.BI "(struct file *" fp ","
.BI "void *" retp ","
.BI "filldir_t " filler ");"
.SH ARGUMENTS
.IP "fp" 12
		the directory to read
.IP "retp" 12
	return buffer
.IP "filler" 12
	filldir callback
.SH "DESCRIPTION"
vxfs_readdir fills \fIretp\fP with directory entries from \fIfp\fP
using the VFS supplied callback \fIfiller\fP.
.SH "RETURNS"
Zero.
.TH "vxfs_bmap_ext4" 9 "vxfs_bmap_ext4" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_bmap_ext4 \-  do bmap for ext4 extents
.SH SYNOPSIS
.B "daddr_t" vxfs_bmap_ext4
.BI "(struct inode *" ip ","
.BI "long " bn ");"
.SH ARGUMENTS
.IP "ip" 12
		pointer to the inode we do bmap for
.IP "bn" 12
-- undescribed --
.SH "DESCRIPTION"
vxfs_bmap_ext4 performs the bmap operation for inodes with
ext4-style extents (which are much like the traditional UNIX
inode organisation).
.SH "RETURNS"
The physical block number on success, else Zero.
.TH "vxfs_bmap_indir" 9 "vxfs_bmap_indir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_bmap_indir \-  recursion for vxfs_bmap_typed
.SH SYNOPSIS
.B "daddr_t" vxfs_bmap_indir
.BI "(struct inode *" ip ","
.BI "long " indir ","
.BI "int " size ","
.BI "long " block ");"
.SH ARGUMENTS
.IP "ip" 12
		pointer to the inode we do bmap for
.IP "indir" 12
	indirect block we start reading at
.IP "size" 12
	size of the typed area to search
.IP "block" 12
	partially result from further searches
.SH "DESCRIPTION"
vxfs_bmap_indir reads a &amp;struct vxfs_typed at \fIindir\fP
and performs the type-defined action.
.SH "RETURN VALUE"
The physical block number on success, else Zero.
.SH "NOTE"
Kernelstack is rare.  Unrecurse?
.TH "vxfs_bmap_typed" 9 "vxfs_bmap_typed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_bmap_typed \-  bmap for typed extents
.SH SYNOPSIS
.B "daddr_t" vxfs_bmap_typed
.BI "(struct inode *" ip ","
.BI "long " iblock ");"
.SH ARGUMENTS
.IP "ip" 12
		pointer to the inode we do bmap for
.IP "iblock" 12
	logical block
.SH "DESCRIPTION"
Performs the bmap operation for typed extents.
.SH "RETURN VALUE"
The physical block number on success, else Zero.
.TH "vxfs_bmap1" 9 "vxfs_bmap1" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_bmap1 \-  vxfs-internal bmap operation
.SH SYNOPSIS
.B "daddr_t" vxfs_bmap1
.BI "(struct inode *" ip ","
.BI "long " iblock ");"
.SH ARGUMENTS
.IP "ip" 12
			pointer to the inode we do bmap for
.IP "iblock" 12
		logical block
.SH "DESCRIPTION"
vxfs_bmap1 perfoms a logical to physical block mapping
for vxfs-internal purposes.
.SH "RETURN VALUE"
The physical block number on success, else Zero.
.TH "vxfs_immed_follow_link" 9 "vxfs_immed_follow_link" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_immed_follow_link \-  follow immed symlink
.SH SYNOPSIS
.B "void *" vxfs_immed_follow_link
.BI "(struct dentry *" dp ","
.BI "struct nameidata *" np ");"
.SH ARGUMENTS
.IP "dp" 12
		dentry for the link
.IP "np" 12
		pathname lookup data for the current path walk
.SH "DESCRIPTION"
vxfs_immed_follow_link restarts the pathname lookup with
the data obtained from \fIdp\fP.
.SH "RETURNS"
Zero on success, else a negative error code.
.TH "vxfs_immed_readpage" 9 "vxfs_immed_readpage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_immed_readpage \-  read part of an immed inode into pagecache
.SH SYNOPSIS
.B "int" vxfs_immed_readpage
.BI "(struct file *" fp ","
.BI "struct page *" pp ");"
.SH ARGUMENTS
.IP "fp" 12
-- undescribed --
.IP "pp" 12
-- undescribed --
.SH "DESCRIPTION"
vxfs_immed_readpage reads a part of the immed area of the
file that hosts \fIpp\fP into the pagecache.
.SH "RETURNS"
Zero on success, else a negative error code.
.SH "LOCKING STATUS"
\fIpage\fP is locked and will be unlocked.
.TH "vxfs_blkiget" 9 "vxfs_blkiget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_blkiget \-  find inode based on extent #
.SH SYNOPSIS
.B "struct vxfs_inode_info *" vxfs_blkiget
.BI "(struct super_block *" sbp ","
.BI "u_long " extent ","
.BI "ino_t " ino ");"
.SH ARGUMENTS
.IP "sbp" 12
	superblock of the filesystem we search in
.IP "extent" 12
	number of the extent to search
.IP "ino" 12
	inode number to search
.SH "DESCRIPTION"
vxfs_blkiget searches inode \fIino\fP in the filesystem described by
\fIsbp\fP in the extent \fIextent\fP.
Returns the matching VxFS inode on success, else a NULL pointer.
.SH "NOTE"
While __vxfs_iget uses the pagecache vxfs_blkiget uses the
buffercache.  This function should not be used outside the
\fBread_super\fP method, otherwise the data may be incoherent.
.TH "__vxfs_iget" 9 "__vxfs_iget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__vxfs_iget \-  generic find inode facility
.SH SYNOPSIS
.B "struct vxfs_inode_info *" __vxfs_iget
.BI "(ino_t " ino ","
.BI "struct inode *" ilistp ");"
.SH ARGUMENTS
.IP "ino" 12
		inode number
.IP "ilistp" 12
		inode list
.SH "DESCRIPTION"
Search the for inode number \fIino\fP in the filesystem
described by \fIsbp\fP.  Use the specified inode table (\fIilistp\fP).
Returns the matching VxFS inode on success, else a NULL pointer.
.TH "vxfs_stiget" 9 "vxfs_stiget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_stiget \-  find inode using the structural inode list
.SH SYNOPSIS
.B "struct vxfs_inode_info *" vxfs_stiget
.BI "(struct super_block *" sbp ","
.BI "ino_t " ino ");"
.SH ARGUMENTS
.IP "sbp" 12
	VFS superblock
.IP "ino" 12
	inode #
.SH "DESCRIPTION"
Find inode \fIino\fP in the filesystem described by \fIsbp\fP using
the structural inode list.
Returns the matching VxFS inode on success, else a NULL pointer.
.TH "vxfs_transmod" 9 "vxfs_transmod" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_transmod \-  mode for a VxFS inode
.SH SYNOPSIS
.B "mode_t" vxfs_transmod
.BI "(struct vxfs_inode_info *" vip ");"
.SH ARGUMENTS
.IP "vip" 12
	VxFS inode
.SH "DESCRIPTION"
vxfs_transmod returns a Linux mode_t for a given
VxFS inode structure.
.TH "vxfs_iinit" 9 "vxfs_iinit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_iinit \-  helper to fill inode fields
.SH SYNOPSIS
.B "void" vxfs_iinit
.BI "(struct inode *" ip ","
.BI "struct vxfs_inode_info *" vip ");"
.SH ARGUMENTS
.IP "ip" 12
		VFS inode
.IP "vip" 12
	VxFS inode
.SH "DESCRIPTION"
vxfs_instino is a helper function to fill in all relevant
fields in \fIip\fP from \fIvip\fP.
.TH "vxfs_get_fake_inode" 9 "vxfs_get_fake_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_get_fake_inode \-  get fake inode structure
.SH SYNOPSIS
.B "struct inode *" vxfs_get_fake_inode
.BI "(struct super_block *" sbp ","
.BI "struct vxfs_inode_info *" vip ");"
.SH ARGUMENTS
.IP "sbp" 12
		filesystem superblock
.IP "vip" 12
		fspriv inode
.SH "DESCRIPTION"
vxfs_fake_inode gets a fake inode (not in the inode hash) for a
superblock, vxfs_inode pair.
Returns the filled VFS inode.
.TH "vxfs_put_fake_inode" 9 "vxfs_put_fake_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_put_fake_inode \-  free faked inode
.SH SYNOPSIS
.B "void" vxfs_put_fake_inode
.BI "(struct inode *" ip ");"
.SH ARGUMENTS
.IP "ip" 12
-- undescribed --
.SH "IP"
			VFS inode
.SH "DESCRIPTION"
vxfs_put_fake_inode frees all data asssociated with \fIip\fP.
.TH "vxfs_read_inode" 9 "vxfs_read_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_read_inode \-  fill in inode information
.SH SYNOPSIS
.B "void" vxfs_read_inode
.BI "(struct inode *" ip ");"
.SH ARGUMENTS
.IP "ip" 12
		inode pointer to fill
.SH "DESCRIPTION"
vxfs_read_inode reads the disk inode for \fIip\fP and fills
in all relevant fields in \fIip\fP.
.TH "vxfs_clear_inode" 9 "vxfs_clear_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_clear_inode \-  remove inode from main memory
.SH SYNOPSIS
.B "void" vxfs_clear_inode
.BI "(struct inode *" ip ");"
.SH ARGUMENTS
.IP "ip" 12
		inode to discard.
.SH "DESCRIPTION"
\fBvxfs_clear_inode\fP is called on the final iput and frees the private
inode area.
.TH "vxfs_put_super" 9 "vxfs_put_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_put_super \-  free superblock resources
.SH SYNOPSIS
.B "void" vxfs_put_super
.BI "(struct super_block *" sbp ");"
.SH ARGUMENTS
.IP "sbp" 12
	VFS superblock.
.SH "DESCRIPTION"
vxfs_put_super frees all resources allocated for \fIsbp\fP
after the last instance of the filesystem is unmounted.
.TH "vxfs_statfs" 9 "vxfs_statfs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_statfs \-  get filesystem information
.SH SYNOPSIS
.B "int" vxfs_statfs
.BI "(struct super_block *" sbp ","
.BI "struct kstatfs *" bufp ");"
.SH ARGUMENTS
.IP "sbp" 12
	VFS superblock
.IP "bufp" 12
	output buffer
.SH "DESCRIPTION"
vxfs_statfs fills the statfs buffer \fIbufp\fP with information
about the filesystem described by \fIsbp\fP.
.SH "RETURNS"
Zero.
.SH "LOCKING"
No locks held.
.SH "NOTES"
This is everything but complete...
.TH "vxfs_fill_super" 9 "vxfs_fill_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_fill_super \-  read superblock into memory and initalize filesystem
.SH SYNOPSIS
.B "int" vxfs_fill_super
.BI "(struct super_block *" sbp ","
.BI "void *" dp ","
.BI "int " silent ");"
.SH ARGUMENTS
.IP "sbp" 12
		VFS superblock (to fill)
.IP "dp" 12
			fs private mount data
.IP "silent" 12
		do not complain loudly when sth is wrong
.SH "DESCRIPTION"
We are called on the first mount of a filesystem to read the
superblock into memory and do some basic setup.
.SH "RETURNS"
The superblock on success, else NULL.
.SH "LOCKING"
We are under the bkl and \fIsbp\fP-&gt;s_lock.
.TH "vxfs_getfsh" 9 "vxfs_getfsh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_getfsh \-  read fileset header into memory
.SH SYNOPSIS
.B "struct vxfs_fsh *" vxfs_getfsh
.BI "(struct inode *" ip ","
.BI "int " which ");"
.SH ARGUMENTS
.IP "ip" 12
		the (fake) fileset header inode
.IP "which" 12
	0 for the structural, 1 for the primary fsh.
.SH "DESCRIPTION"
vxfs_getfsh reads either the structural or primary fileset header
described by \fIip\fP into memory.
.SH "RETURNS"
The fileset header structure on success, else Zero.
.TH "vxfs_read_fshead" 9 "vxfs_read_fshead" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_read_fshead \-  read the fileset headers
.SH SYNOPSIS
.B "int" vxfs_read_fshead
.BI "(struct super_block *" sbp ");"
.SH ARGUMENTS
.IP "sbp" 12
	superblock to which the fileset belongs
.SH "DESCRIPTION"
vxfs_read_fshead will fill the inode and structural inode list in \fIsb\fP.
.SH "RETURNS"
Zero on success, else a negative error code (-EINVAL).
.TH "vxfs_get_page" 9 "vxfs_get_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_get_page \-  read a page into memory.
.SH SYNOPSIS
.B "struct page *" vxfs_get_page
.BI "(struct address_space *" mapping ","
.BI "u_long " n ");"
.SH ARGUMENTS
.IP "mapping" 12
-- undescribed --
.IP "n" 12
		page number
.SH "DESCRIPTION"
vxfs_get_page reads the \fIn\fP th page of \fIip\fP into the pagecache.
.SH "RETURNS"
The wanted page on success, else a NULL pointer.
.TH "vxfs_bread" 9 "vxfs_bread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_bread \-  read buffer for a give inode,block tuple
.SH SYNOPSIS
.B "struct buffer_head *" vxfs_bread
.BI "(struct inode *" ip ","
.BI "int " block ");"
.SH ARGUMENTS
.IP "ip" 12
		inode
.IP "block" 12
	logical block
.SH "DESCRIPTION"
The vxfs_bread function reads block no \fIblock\fP  of
\fIip\fP into the buffercache.
.SH "RETURNS"
The resulting &amp;struct buffer_head.
.TH "vxfs_getblk" 9 "vxfs_getblk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_getblk \-  locate buffer for given inode,block tuple 
.SH SYNOPSIS
.B "int" vxfs_getblk
.BI "(struct inode *" ip ","
.BI "sector_t " iblock ","
.BI "struct buffer_head *" bp ","
.BI "int " create ");"
.SH ARGUMENTS
.IP "ip" 12
		inode
.IP "iblock" 12
	logical block
.IP "bp" 12
		buffer skeleton
.IP "create" 12
	TRUE if blocks may be newly allocated.
.SH "DESCRIPTION"
The vxfs_get_block function fills \fIbp\fP with the right physical
block and device number to perform a lowlevel read/write on
it.
.SH "RETURNS"
Zero on success, else a negativ error code (-EIO).
.TH "vxfs_readpage" 9 "vxfs_readpage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_readpage \-  read one page synchronously into the pagecache
.SH SYNOPSIS
.B "int" vxfs_readpage
.BI "(struct file *" file ","
.BI "struct page *" page ");"
.SH ARGUMENTS
.IP "file" 12
	file context (unused)
.IP "page" 12
	page frame to fill in.
.SH "DESCRIPTION"
The vxfs_readpage routine reads \fIpage\fP synchronously into the
pagecache.
.SH "RETURNS"
Zero on success, else a negative error code.
.SH "LOCKING STATUS"
\fIpage\fP is locked and will be unlocked.
.TH "vxfs_bmap" 9 "vxfs_bmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vxfs_bmap \-  perform logical to physical block mapping
.SH SYNOPSIS
.B "sector_t" vxfs_bmap
.BI "(struct address_space *" mapping ","
.BI "sector_t " block ");"
.SH ARGUMENTS
.IP "mapping" 12
	logical to physical mapping to use
.IP "block" 12
	logical block (relative to \fImapping\fP).
.SH "DESCRIPTION"
Vxfs_bmap find out the corresponding phsical block to the
\fImapping\fP, \fIblock\fP pair.
.SH "RETURNS"
Physical block number on success, else Zero.
.SH "LOCKING STATUS"
We are under the bkl.
.TH "proc_pid_unhash" 9 "proc_pid_unhash" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_pid_unhash \-   Unhash /proc/@pid entry from the dcache.
.SH SYNOPSIS
.B "struct dentry *" proc_pid_unhash
.BI "(struct task_struct *" p ");"
.SH ARGUMENTS
.IP "p" 12
 task that should be flushed.
.SH "DESCRIPTION"
Drops the /proc/\fIpid\fP dcache entry from the hash chains.

Dropping /proc/\fIpid\fP entries and detach_pid must be synchroneous,
otherwise e.g. /proc/\fIpid\fP/exe might point to the wrong executable,
if the pid value is immediately reused. This is enforced by
- caller must acquire spin_lock(p-&gt;proc_lock)
- must be called before \fBdetach_pid\fP
- proc_pid_lookup acquires proc_lock, and checks that
the target is not dead by looking at the attach count
of PIDTYPE_PID.
.TH "proc_pid_flush" 9 "proc_pid_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_pid_flush \-  recover memory used by stale /proc/@pid/x entries
.SH SYNOPSIS
.B "void" proc_pid_flush
.BI "(struct dentry *" proc_dentry ");"
.SH ARGUMENTS
.IP "proc_dentry" 12
 directoy to prune.
.SH "DESCRIPTION"
Shrink the /proc directory that was used by the just killed thread.
.TH "lookup_bdev" 9 "lookup_bdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lookup_bdev \-  lookup a struct block_device by name
.SH SYNOPSIS
.B "struct block_device *" lookup_bdev
.BI "(const char *" path ");"
.SH ARGUMENTS
.IP "path" 12
	special file representing the block device
.SH "DESCRIPTION"
Get a reference to the blockdevice at \fIpath\fP in the current
namespace if possible and return it.  Return ERR_PTR(error)
otherwise.
.SH "DESCRIPTION"
Get a reference to the blockdevice at \fIpath\fP in the current
namespace if possible and return it.  Return ERR_PTR(error)
otherwise.
.TH "open_bdev_excl" 9 "open_bdev_excl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
open_bdev_excl \-   open a block device by name and set it up for use
.SH SYNOPSIS
.B "struct block_device *" open_bdev_excl
.BI "(const char *" path ","
.BI "int " flags ","
.BI "void *" holder ");"
.SH ARGUMENTS
.IP "path" 12
	special file representing the block device
.IP "flags" 12
	MS_RDONLY for opening read-only
.IP "holder" 12
	owner for exclusion
.SH "DESCRIPTION"
Open the blockdevice described by the special file at \fIpath\fP, claim it
for the \fIholder\fP.
.SH "DESCRIPTION"
Open the blockdevice described by the special file at \fIpath\fP, claim it
for the \fIholder\fP.
.TH "close_bdev_excl" 9 "close_bdev_excl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
close_bdev_excl \-   release a blockdevice openen by open_bdev_excl()
.SH SYNOPSIS
.B "void" close_bdev_excl
.BI "(struct block_device *" bdev ");"
.SH ARGUMENTS
.IP "bdev" 12
	blockdevice to close
.SH "DESCRIPTION"
This is the counterpart to \fBopen_bdev_excl\fP.
.SH "DESCRIPTION"
This is the counterpart to \fBopen_bdev_excl\fP.
.TH "debugfs_create_file" 9 "debugfs_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
debugfs_create_file \-  create a file in the debugfs filesystem
.SH SYNOPSIS
.B "struct dentry *" debugfs_create_file
.BI "(const char *" name ","
.BI "mode_t " mode ","
.BI "struct dentry *" parent ","
.BI "void *" data ","
.BI "struct file_operations *" fops ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the file to create.
.IP "mode" 12
 the permission that the file should have
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
file will be created in the root of the debugfs filesystem.
.IP "data" 12
 a pointer to something that the caller will want to get to later
on.  The inode.u.generic_ip pointer will point to this value on
the \fBopen\fP call.
.IP "fops" 12
 a pointer to a struct file_operations that should be used for
this file.
.SH "DESCRIPTION"
This is the basic "create a file" function for debugfs.  It allows for a
wide range of flexibility in createing a file, or a directory (if you
want to create a directory, the \fBdebugfs_create_dir\fP function is
recommended to be used instead.)

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This is the basic "create a file" function for debugfs.  It allows for a
wide range of flexibility in createing a file, or a directory (if you
want to create a directory, the \fBdebugfs_create_dir\fP function is
recommended to be used instead.)

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "debugfs_create_dir" 9 "debugfs_create_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
debugfs_create_dir \-  create a directory in the debugfs filesystem
.SH SYNOPSIS
.B "struct dentry *" debugfs_create_dir
.BI "(const char *" name ","
.BI "struct dentry *" parent ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the directory to
create.
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
directory will be created in the root of the debugfs filesystem.
.SH "DESCRIPTION"
This function creates a directory in debugfs with the given name.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This function creates a directory in debugfs with the given name.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "debugfs_remove" 9 "debugfs_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
debugfs_remove \-  removes a file or directory from the debugfs filesystem
.SH SYNOPSIS
.B "void" debugfs_remove
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 a pointer to a the dentry of the file or directory to be
removed.
.SH "DESCRIPTION"
This function removes a file or directory in debugfs that was previously
created with a call to another debugfs function (like
\fBdebufs_create_file\fP or variants thereof.)

This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.
.SH "DESCRIPTION"
This function removes a file or directory in debugfs that was previously
created with a call to another debugfs function (like
\fBdebufs_create_file\fP or variants thereof.)

This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.
.TH "debugfs_create_u8" 9 "debugfs_create_u8" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
debugfs_create_u8 \-  create a file in the debugfs filesystem that is used to read and write a unsigned 8 bit value.
.SH SYNOPSIS
.B "struct dentry *" debugfs_create_u8
.BI "(const char *" name ","
.BI "mode_t " mode ","
.BI "struct dentry *" parent ","
.BI "u8 *" value ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the file to create.
.IP "mode" 12
 the permission that the file should have
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
file will be created in the root of the debugfs filesystem.
.IP "value" 12
 a pointer to the variable that the file should read to and write
from.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "debugfs_create_u16" 9 "debugfs_create_u16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
debugfs_create_u16 \-  create a file in the debugfs filesystem that is used to read and write a unsigned 8 bit value.
.SH SYNOPSIS
.B "struct dentry *" debugfs_create_u16
.BI "(const char *" name ","
.BI "mode_t " mode ","
.BI "struct dentry *" parent ","
.BI "u16 *" value ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the file to create.
.IP "mode" 12
 the permission that the file should have
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
file will be created in the root of the debugfs filesystem.
.IP "value" 12
 a pointer to the variable that the file should read to and write
from.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "debugfs_create_u32" 9 "debugfs_create_u32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
debugfs_create_u32 \-  create a file in the debugfs filesystem that is used to read and write a unsigned 8 bit value.
.SH SYNOPSIS
.B "struct dentry *" debugfs_create_u32
.BI "(const char *" name ","
.BI "mode_t " mode ","
.BI "struct dentry *" parent ","
.BI "u32 *" value ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the file to create.
.IP "mode" 12
 the permission that the file should have
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
file will be created in the root of the debugfs filesystem.
.IP "value" 12
 a pointer to the variable that the file should read to and write
from.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "debugfs_create_bool" 9 "debugfs_create_bool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
debugfs_create_bool \-  create a file in the debugfs filesystem that is used to read and write a boolean value.
.SH SYNOPSIS
.B "struct dentry *" debugfs_create_bool
.BI "(const char *" name ","
.BI "mode_t " mode ","
.BI "struct dentry *" parent ","
.BI "u32 *" value ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the file to create.
.IP "mode" 12
 the permission that the file should have
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
file will be created in the root of the debugfs filesystem.
.IP "value" 12
 a pointer to the variable that the file should read to and write
from.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This function creates a file in debugfs with the given name that
contains the value of the variable \fIvalue\fP.  If the \fImode\fP variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBdebugfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If debugfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "find_exported_dentry" 9 "find_exported_dentry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_exported_dentry \-  helper routine to implement export_operations-\\\gt;decode_fh
.SH SYNOPSIS
.B "struct dentry *" find_exported_dentry
.BI "(struct super_block *" sb ","
.BI "void *" obj ","
.BI "void *" parent ","
.BI "int (*" acceptable ") (void *context, struct dentry *de),"
.BI "void *" context ");"
.SH ARGUMENTS
.IP "sb" 12
		The &amp;super_block identifying the filesystem
.IP "obj" 12
	An opaque identifier of the object to be found - passed to
get_inode
.IP "parent" 12
	An optional opqaue identifier of the parent of the object.
.IP "acceptable" 12
	A function used to test possible &amp;dentries to see if they are
acceptable
.IP "context" 12
	A parameter to \fIacceptable\fP so that it knows on what basis to
judge.
.SH "DESCRIPTION"
find_exported_dentry is the central helper routine to enable file systems
to provide the \fBdecode_fh\fP export_operation.  It's main task is to take
an &amp;inode, find or create an appropriate &amp;dentry structure, and possibly
splice this into the dcache in the correct place.

The \fBdecode_fh\fP operation provided by the filesystem should call
\fBfind_exported_dentry\fP with the same parameters that it received except
that instead of the file handle fragment, pointers to opaque identifiers
for the object and optionally its parent are passed.  The default decode_fh
routine passes one pointer to the start of the filehandle fragment, and
one 8 bytes into the fragment.  It is expected that most filesystems will
take this approach, though the offset to the parent identifier may well be
different.

\fBfind_exported_dentry\fP will call get_dentry to get an dentry pointer from
the file system.  If any &amp;dentry in the d_alias list is acceptable, it will
be returned.  Otherwise \fBfind_exported_dentry\fP will attempt to splice a new
&amp;dentry into the dcache using \fBget_name\fP and \fBget_parent\fP to find the
appropriate place.
.TH "get_name" 9 "get_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_name \-  default export_operations-\\\gt;get_name function
.SH SYNOPSIS
.B "int" get_name
.BI "(struct dentry *" dentry ","
.BI "char *" name ","
.BI "struct dentry *" child ");"
.SH ARGUMENTS
.IP "dentry" 12
 the directory in which to find a name
.IP "name" 12
   a pointer to a NAME_MAX+1 char buffer to store the name
.IP "child" 12
  the dentry for the child directory.
.SH "DESCRIPTION"
calls readdir on the parent until it finds an entry with
the same inode number as the child, and returns that.
.TH "export_encode_fh" 9 "export_encode_fh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
export_encode_fh \-  default export_operations-\\\gt;encode_fh function
.SH SYNOPSIS
.B "int" export_encode_fh
.BI "(struct dentry *" dentry ","
.BI "__u32 *" fh ","
.BI "int *" max_len ","
.BI "int " connectable ");"
.SH ARGUMENTS
.IP "dentry" 12
  the dentry to encode
.IP "fh" 12
      where to store the file handle fragment
.IP "max_len" 12
 maximum length to store there
.IP "connectable" 12
 whether to store parent information
.SH "DESCRIPTION"
This default encode_fh function assumes that the 32 inode number
is suitable for locating an inode, and that the generation number
can be used to check that it is still valid.  It places them in the
filehandle fragment where export_decode_fh expects to find them.
.TH "export_decode_fh" 9 "export_decode_fh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
export_decode_fh \-  default export_operations-\\\gt;decode_fh function
.SH SYNOPSIS
.B "struct dentry *" export_decode_fh
.BI "(struct super_block *" sb ","
.BI "__u32 *" fh ","
.BI "int " fh_len ","
.BI "int " fileid_type ","
.BI "int (*" acceptable ") (void *context, struct dentry *de),"
.BI "void *" context ");"
.SH ARGUMENTS
.IP "sb" 12
  The superblock
.IP "fh" 12
  pointer to the file handle fragment
.IP "fh_len" 12
 length of file handle fragment
.IP "fileid_type" 12
-- undescribed --
.IP "acceptable" 12
 function for testing acceptability of dentrys
.IP "context" 12
   context for \fIacceptable\fP
.SH "DESCRIPTION"
This is the default \fBdecode_fh\fP function.
a fileid_type of 1 indicates that the filehandlefragment
just contains an object identifier understood by  get_dentry.
a fileid_type of 2 says that there is also a directory
identifier 8 bytes in to the filehandlefragement.
.TH "ext3_block_to_path" 9 "ext3_block_to_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_block_to_path \-  parse the block number into array of offsets
.SH SYNOPSIS
.B "int" ext3_block_to_path
.BI "(struct inode *" inode ","
.BI "long " i_block ","
.BI "int " offsets[4] ","
.BI "int *" boundary ");"
.SH ARGUMENTS
.IP "inode" 12
 inode in question (we are only interested in its superblock)
.IP "i_block" 12
 block number to be parsed
.IP "offsets[4]" 12
 array to store the offsets in
.IP "boundary" 12
 set this non-zero if the referred-to block is likely to be
followed (on disk) by an indirect block.
.SH "DESCRIPTION"
To store the locations of file's data ext3 uses a data structure common
for UNIX filesystems - tree of pointers anchored in the inode, with
data blocks at leaves and indirect blocks in intermediate nodes.
This function translates the block number into path in that tree -
return value is the path length and \fIoffsets\fP[n] is the offset of
pointer to (n+1)th node in the nth one. If \fIblock\fP is out of range
(negative or too large) warning is printed and zero returned.
.SH "NOTE"
 function doesn't find node addresses, so no IO is needed. All
we need to know is the capacity of indirect blocks (taken from the
inode-&gt;i_sb).
.TH "ext3_get_branch" 9 "ext3_get_branch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_get_branch \-  read the chain of indirect blocks leading to data
.SH SYNOPSIS
.B "Indirect *" ext3_get_branch
.BI "(struct inode *" inode ","
.BI "int " depth ","
.BI "int *" offsets ","
.BI "Indirect " chain[4] ","
.BI "int *" err ");"
.SH ARGUMENTS
.IP "inode" 12
 inode in question
.IP "depth" 12
 depth of the chain (1 - direct pointer, etc.)
.IP "offsets" 12
 offsets of pointers in inode/indirect blocks
.IP "chain[4]" 12
 place to store the result
.IP "err" 12
 here we store the error value
.SH "DESCRIPTION"
Function fills the array of triples &lt;key, p, bh&gt; and returns NULL
if everything went OK or the pointer to the last filled triple
(incomplete one) otherwise. Upon the return chain[i].key contains
the number of (i+1)-th block in the chain (as it is stored in memory,
i.e. little-endian 32-bit), chain[i].p contains the address of that
number (it points into struct inode for i==0 and into the bh-&gt;b_data
for i&gt;0) and chain[i].bh points to the buffer_head of i-th indirect
block for i&gt;0 and NULL for i==0. In other words, it holds the block
numbers of the chain, addresses they were taken from (and where we can
verify that chain did not change) and buffer_heads hosting these
numbers.

Function stops when it stumbles upon zero pointer (absent block)
(pointer to last triple returned, *\fIerr\fP == 0)
or when it gets an IO error reading an indirect block
(ditto, *\fIerr\fP == -EIO)
or when it notices that chain had been changed while it was reading
(ditto, *\fIerr\fP == -EAGAIN)
or when it reads all \fIdepth\fP-1 indirect blocks successfully and finds
the whole chain, all way to the data (returns NULL, *err == 0).
.TH "ext3_find_near" 9 "ext3_find_near" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_find_near \-  find a place for allocation with sufficient locality
.SH SYNOPSIS
.B "unsigned long" ext3_find_near
.BI "(struct inode *" inode ","
.BI "Indirect *" ind ");"
.SH ARGUMENTS
.IP "inode" 12
 owner
.IP "ind" 12
 descriptor of indirect block.
.SH "DESCRIPTION"
This function returns the prefered place for block allocation.
It is used when heuristic for sequential allocation fails.
.SH "RULES ARE"
+ if there is a block to the left of our position - allocate near it.
+ if pointer will live in indirect block - allocate near that block.
+ if pointer will live in inode - allocate in the same
cylinder group. 

In the latter case we colour the starting block by the callers PID to
prevent it from clashing with concurrent allocations for a different inode
in the same block group.   The PID is used here so that functionally related
files will be close-by on-disk.

Caller must make sure that \fIind\fP is valid and will stay that way.
.TH "ext3_find_goal" 9 "ext3_find_goal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_find_goal \-  find a prefered place for allocation.
.SH SYNOPSIS
.B "unsigned long" ext3_find_goal
.BI "(struct inode *" inode ","
.BI "long " block ","
.BI "Indirect " chain[4] ","
.BI "Indirect *" partial ");"
.SH ARGUMENTS
.IP "inode" 12
 owner
.IP "block" 12
  block we want
.IP "chain[4]" 12
  chain of indirect blocks
.IP "partial" 12
 pointer to the last triple within a chain
.SH "DESCRIPTION"
Normally this function find the prefered place for block allocation,
stores it in *\fIgoal\fP and returns zero.
.TH "ext3_alloc_branch" 9 "ext3_alloc_branch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_alloc_branch \-  allocate and set up a chain of blocks.
.SH SYNOPSIS
.B "int" ext3_alloc_branch
.BI "(handle_t *" handle ","
.BI "struct inode *" inode ","
.BI "int " num ","
.BI "unsigned long " goal ","
.BI "int *" offsets ","
.BI "Indirect *" branch ");"
.SH ARGUMENTS
.IP "handle" 12
-- undescribed --
.IP "inode" 12
 owner
.IP "num" 12
 depth of the chain (number of blocks to allocate)
.IP "goal" 12
-- undescribed --
.IP "offsets" 12
 offsets (in the blocks) to store the pointers to next.
.IP "branch" 12
 place to store the chain in.
.SH "DESCRIPTION"
This function allocates \fInum\fP blocks, zeroes out all but the last one,
links them into chain and (if we are synchronous) writes them to disk.
In other words, it prepares a branch that can be spliced onto the
inode. It stores the information about that chain in the branch[], in
the same format as \fBext3_get_branch\fP would do. We are calling it after
we had read the existing part of chain and partial points to the last
triple of that (one with zero -&gt;key). Upon the exit we have the same
picture as after the successful \fBext3_get_block\fP, excpet that in one
place chain is disconnected - *branch-&gt;p is still zero (we did not
set the last link), but branch-&gt;key contains the number that should
be placed into *branch-&gt;p to fill that gap.

If allocation fails we free all blocks we've allocated (and forget
their buffer_heads) and return the error value the from failed
\fBext3_alloc_block\fP (normally -ENOSPC). Otherwise we set the chain
as described above and return 0.
.TH "ext3_splice_branch" 9 "ext3_splice_branch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_splice_branch \-  splice the allocated branch onto inode.
.SH SYNOPSIS
.B "int" ext3_splice_branch
.BI "(handle_t *" handle ","
.BI "struct inode *" inode ","
.BI "long " block ","
.BI "Indirect " chain[4] ","
.BI "Indirect *" where ","
.BI "int " num ");"
.SH ARGUMENTS
.IP "handle" 12
-- undescribed --
.IP "inode" 12
 owner
.IP "block" 12
 (logical) number of block we are adding
.IP "chain[4]" 12
 chain of indirect blocks (with a missing link - see
ext3_alloc_branch)
.IP "where" 12
 location of missing link
.IP "num" 12
   number of blocks we are adding
.SH "DESCRIPTION"
This function fills the missing link and does all housekeeping needed in
inode (-&gt;i_blocks, etc.). In case of success we end up with the full
chain to new block and return 0.
.TH "ext3_find_shared" 9 "ext3_find_shared" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_find_shared \-  find the indirect blocks for partial truncation.
.SH SYNOPSIS
.B "Indirect *" ext3_find_shared
.BI "(struct inode *" inode ","
.BI "int " depth ","
.BI "int " offsets[4] ","
.BI "Indirect " chain[4] ","
.BI "__le32 *" top ");"
.SH ARGUMENTS
.IP "inode" 12
	  inode in question
.IP "depth" 12
	  depth of the affected branch
.IP "offsets[4]" 12
 offsets of pointers in that branch (see ext3_block_to_path)
.IP "chain[4]" 12
	  place to store the pointers to partial indirect blocks
.IP "top" 12
	  place to the (detached) top of branch
.SH "DESCRIPTION"
This is a helper function used by \fBext3_truncate\fP.

When we do \fBtruncate\fP we may have to clean the ends of several
indirect blocks but leave the blocks themselves alive. Block is
partially truncated if some data below the new i_size is refered
from it (and it is on the path to the first completely truncated
data block, indeed).  We have to free the top of that path along
with everything to the right of the path. Since no allocation
past the truncation point is possible until \fBext3_truncate\fP
finishes, we may safely do the latter, but top of branch may
require special attention - pageout below the truncation point
might try to populate it.

We atomically detach the top of branch from the tree, store the
block number of its root in *\fItop\fP, pointers to buffer_heads of
partially truncated blocks - in \fIchain\fP[].bh and pointers to
their last elements that should not be removed - in
\fIchain\fP[].p. Return value is the pointer to last filled element
of \fIchain\fP.
.SH "THE WORK LEFT TO CALLER TO DO THE ACTUAL FREEING OF SUBTREES"
a) free the subtree starting from *\fItop\fP
b) free the subtrees whose roots are stored in
(\fIchain\fP[i].p+1 .. end of \fIchain\fP[i].bh-&gt;b_data)
c) free the subtrees growing from the inode past the \fIchain\fP[0].
.TH "ext3_free_data" 9 "ext3_free_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_free_data \-  free a list of data blocks
.SH SYNOPSIS
.B "void" ext3_free_data
.BI "(handle_t *" handle ","
.BI "struct inode *" inode ","
.BI "struct buffer_head *" this_bh ","
.BI "__le32 *" first ","
.BI "__le32 *" last ");"
.SH ARGUMENTS
.IP "handle" 12
	handle for this transaction
.IP "inode" 12
	inode we are dealing with
.IP "this_bh" 12
	indirect buffer_head which contains *\fIfirst\fP and *\fIlast\fP
.IP "first" 12
	array of block numbers
.IP "last" 12
	points immediately past the end of array
.SH "DESCRIPTION"
We are freeing all blocks refered from that array (numbers are stored as
little-endian 32-bit) and updating \fIinode\fP-&gt;i_blocks appropriately.

We accumulate contiguous runs of blocks to free.  Conveniently, if these
blocks are contiguous then releasing them at one time will only affect one
or two bitmap blocks (+ group descriptor(s) and superblock) and we won't
actually use a lot of journal space.

\fIthis_bh\fP will be NULL if \fIfirst\fP and \fIlast\fP point into the inode's direct
block pointers.
.TH "ext3_free_branches" 9 "ext3_free_branches" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_free_branches \-  free an array of branches
.SH SYNOPSIS
.B "void" ext3_free_branches
.BI "(handle_t *" handle ","
.BI "struct inode *" inode ","
.BI "struct buffer_head *" parent_bh ","
.BI "__le32 *" first ","
.BI "__le32 *" last ","
.BI "int " depth ");"
.SH ARGUMENTS
.IP "handle" 12
 JBD handle for this transaction
.IP "inode" 12
	inode we are dealing with
.IP "parent_bh" 12
 the buffer_head which contains *\fIfirst\fP and *\fIlast\fP
.IP "first" 12
	array of block numbers
.IP "last" 12
	pointer immediately past the end of array
.IP "depth" 12
	depth of the branches to free
.SH "DESCRIPTION"
We are freeing all blocks refered from these branches (numbers are
stored as little-endian 32-bit) and updating \fIinode\fP-&gt;i_blocks
appropriately.
.TH "find_next_reservable_window" 9 "find_next_reservable_window" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_reservable_window \- 
.SH SYNOPSIS
.B "int" find_next_reservable_window
.BI "(struct ext3_reserve_window_node *" search_head ","
.BI "struct ext3_reserve_window_node *" my_rsv ","
.BI "struct super_block *" sb ","
.BI "int " start_block ","
.BI "int " last_block ");"
.SH ARGUMENTS
.IP "search_head" 12
 the head of the searching list;
This is not necessarily the list head of the whole filesystem
.IP "my_rsv" 12
-- undescribed --
.IP "sb" 12
-- undescribed --
.IP "start_block" 12
-- undescribed --
.IP "last_block" 12
the maximum block number that our goal reservable space
could start from. This is normally the last block in this
group. The search will end when we found the start of next
possible reservable space is out of this boundary.
This could handle the cross boundary reservation window
request.
.SH "DESCRIPTION"
basically we search from the given range, rather than the whole
reservation double linked list, (start_block, last_block)
to find a free region that is of my size and has not
been reserved.
.SH "IT DOES NOT ALLOCATE THE RESERVATION WINDOW FOR NOW"
\fBalloc_new_reservation\fP will do the work later.
.SH "DESCRIPTION"
basically we search from the given range, rather than the whole
reservation double linked list, (start_block, last_block)
to find a free region that is of my size and has not
been reserved.
.SH "DESCRIPTION"
basically we search from the given range, rather than the whole
reservation double linked list, (start_block, last_block)
to find a free region that is of my size and has not
been reserved.
.TH "alloc_new_reservation" 9 "alloc_new_reservation" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_new_reservation \- -allocate a new reservation window
.SH SYNOPSIS
.B "int" alloc_new_reservation
.BI "(struct ext3_reserve_window_node *" my_rsv ","
.BI "int " goal ","
.BI "struct super_block *" sb ","
.BI "unsigned int " group ","
.BI "struct buffer_head *" bitmap_bh ");"
.SH ARGUMENTS
.IP "my_rsv" 12
-- undescribed --
.IP "goal" 12
 The goal (group-relative).  It is where the search for a
free reservable space should start from.
if we have a goal(goal &gt;0 ), then start from there,
no goal(goal = -1), we start from the first block
of the group.
.IP "sb" 12
 the super block
.IP "group" 12
 the group we are trying to allocate in
.IP "bitmap_bh" 12
 the block group block bitmap
.SH "DESCRIPTION"

To make a new reservation, we search part of the filesystem
reservation list (the list that inside the group). We try to
allocate a new reservation window near the allocation goal,
or the beginning of the group, if there is no goal.

We first find a reservable space after the goal, then from
there, we check the bitmap for the first free block after
it. If there is no free block until the end of group, then the
whole group is full, we failed. Otherwise, check if the free
block is inside the expected reservable space, if so, we
succeed.
If the first free block is outside the reservable space, then
start from the first free block, we search for next available
space, and go on.

on succeed, a new reservation will be found and inserted into the list
It contains at least one free block, and it does not overlap with other
reservation windows.
.SH "FAILED"
 we failed to find a reservation window in this group
.TH "ext3_bg_has_super" 9 "ext3_bg_has_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_bg_has_super \-  number of blocks used by the superblock in group
.SH SYNOPSIS
.B "int" ext3_bg_has_super
.BI "(struct super_block *" sb ","
.BI "int " group ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock for filesystem
.IP "group" 12
 group number to check
.SH "DESCRIPTION"
Return the number of blocks used by the superblock (primary or backup)
in this group.  Currently this will be only 0 or 1.
.TH "ext3_bg_num_gdb" 9 "ext3_bg_num_gdb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ext3_bg_num_gdb \-  number of blocks used by the group table in group
.SH SYNOPSIS
.B "unsigned long" ext3_bg_num_gdb
.BI "(struct super_block *" sb ","
.BI "int " group ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock for filesystem
.IP "group" 12
 group number to check
.SH "DESCRIPTION"
Return the number of blocks used by the group descriptor table
(primary or backup) in this group.  In the future there may be a
different number of descriptor blocks in each group.
.TH "generic_permission" 9 "generic_permission" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_permission \-   check for access rights on a Posix-like filesystem
.SH SYNOPSIS
.B "int" generic_permission
.BI "(struct inode *" inode ","
.BI "int " mask ","
.BI "int (*" check_acl ") (struct inode *inode, int mask));"
.SH ARGUMENTS
.IP "inode" 12
	inode to check access rights for
.IP "mask" 12
	right to check for (MAY_READ, MAY_WRITE, MAY_EXEC)
.IP "check_acl" 12
	optional callback to check for Posix ACLs
.SH "DESCRIPTION"
Used to check for read/write/execute permissions on a file.
We use "fsuid" for this, letting us set arbitrary permissions
for filesystem access without changing the "normal" uids which
are used for other things..
.TH "lookup_create" 9 "lookup_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lookup_create \-  lookup a dentry, creating it if it doesn't exist
.SH SYNOPSIS
.B "struct dentry *" lookup_create
.BI "(struct nameidata *" nd ","
.BI "int " is_dir ");"
.SH ARGUMENTS
.IP "nd" 12
 nameidata info
.IP "is_dir" 12
 directory flag
.SH "DESCRIPTION"
Simple function to lookup and return a dentry and create it
if it doesn't exist.  Is SMP-safe.

Returns with nd-&gt;dentry-&gt;d_inode-&gt;i_sem locked.
.TH "d_invalidate" 9 "d_invalidate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_invalidate \-  invalidate a dentry
.SH SYNOPSIS
.B "int" d_invalidate
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry to invalidate
.SH "DESCRIPTION"
Try to invalidate the dentry if it turns out to be
possible. If there are other dentries that can be
reached through this one we can't delete it and we
return -EBUSY. On success we return 0.

no dcache lock.
.TH "__d_find_alias" 9 "__d_find_alias" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__d_find_alias \-  grab a hashed alias of inode
.SH SYNOPSIS
.B "struct dentry *" __d_find_alias
.BI "(struct inode *" inode ","
.BI "int " want_discon ");"
.SH ARGUMENTS
.IP "inode" 12
 inode in question
.IP "want_discon" 12
  flag, used by d_splice_alias, to request
that only a DISCONNECTED alias be returned.
.SH "DESCRIPTION"
If inode has a hashed alias, or is a directory and has any alias,
acquire the reference to alias and return it. Otherwise return NULL.
Notice that if inode is a directory there can be only one alias and
it can be unhashed only if it has no children, or if it is the root
of a filesystem.

If the inode has a DCACHE_DISCONNECTED alias, then prefer
any other hashed alias over that one unless \fIwant_discon\fP is set,
in which case only return a DCACHE_DISCONNECTED alias.
.TH "prune_dcache" 9 "prune_dcache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
prune_dcache \-  shrink the dcache
.SH SYNOPSIS
.B "void" prune_dcache
.BI "(int " count ");"
.SH ARGUMENTS
.IP "count" 12
 number of entries to try and free
.SH "DESCRIPTION"
Shrink the dcache. This is done when we need
more memory, or simply when we need to unmount
something (at which point we need to unuse
all dentries).

This function may fail to free any resources if
all the dentries are in use.
.TH "shrink_dcache_sb" 9 "shrink_dcache_sb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shrink_dcache_sb \-  shrink dcache for a superblock
.SH SYNOPSIS
.B "void" shrink_dcache_sb
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock
.SH "DESCRIPTION"
Shrink the dcache for the specified super block. This
is used to free the dcache before unmounting a file
system
.TH "have_submounts" 9 "have_submounts" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
have_submounts \-  check for mounts over a dentry
.SH SYNOPSIS
.B "int" have_submounts
.BI "(struct dentry *" parent ");"
.SH ARGUMENTS
.IP "parent" 12
 dentry to check.
.SH "DESCRIPTION"
Return true if the parent or its subdirectories contain
a mount point
.TH "shrink_dcache_parent" 9 "shrink_dcache_parent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shrink_dcache_parent \-  prune dcache
.SH SYNOPSIS
.B "void" shrink_dcache_parent
.BI "(struct dentry *" parent ");"
.SH ARGUMENTS
.IP "parent" 12
 parent of entries to prune
.SH "DESCRIPTION"
Prune the dcache to remove unused children of the parent dentry.
.TH "shrink_dcache_anon" 9 "shrink_dcache_anon" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shrink_dcache_anon \-  further prune the cache
.SH SYNOPSIS
.B "void" shrink_dcache_anon
.BI "(struct hlist_head *" head ");"
.SH ARGUMENTS
.IP "head" 12
 head of d_hash list of dentries to prune
.SH "DESCRIPTION"
Prune the dentries that are anonymous

parsing d_hash list does not \fBhlist_for_each_rcu\fP as it
done under dcache_lock.
.TH "d_alloc" 9 "d_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_alloc \- 	allocate a dcache entry
.SH SYNOPSIS
.B "struct dentry *" d_alloc
.BI "(struct dentry *" parent ","
.BI "const struct qstr *" name ");"
.SH ARGUMENTS
.IP "parent" 12
 parent of entry to allocate
.IP "name" 12
 qstr of the name
.SH "DESCRIPTION"
Allocates a dentry. It returns NULL if there is insufficient memory
available. On a success the dentry is returned. The name passed in is
copied and the copy passed in may be reused after this call.
.TH "d_instantiate" 9 "d_instantiate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_instantiate \-  fill in inode information for a dentry
.SH SYNOPSIS
.B "void" d_instantiate
.BI "(struct dentry *" entry ","
.BI "struct inode *" inode ");"
.SH ARGUMENTS
.IP "entry" 12
 dentry to complete
.IP "inode" 12
 inode to attach to this dentry
.SH "DESCRIPTION"
Fill in inode information in the entry.

This turns negative dentries into productive full members
of society.

NOTE! This assumes that the inode count has been incremented
(or otherwise set) by the caller to indicate that it is now
in use by the dcache.
.TH "d_instantiate_unique" 9 "d_instantiate_unique" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_instantiate_unique \-  instantiate a non-aliased dentry
.SH SYNOPSIS
.B "struct dentry *" d_instantiate_unique
.BI "(struct dentry *" entry ","
.BI "struct inode *" inode ");"
.SH ARGUMENTS
.IP "entry" 12
 dentry to instantiate
.IP "inode" 12
 inode to attach to this dentry
.SH "DESCRIPTION"
Fill in inode information in the entry. On success, it returns NULL.
If an unhashed alias of "entry" already exists, then we return the
aliased dentry instead.

Note that in order to avoid conflicts with \fBrename\fP etc, the caller
had better be holding the parent directory semaphore.
.TH "d_alloc_root" 9 "d_alloc_root" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_alloc_root \-  allocate root dentry
.SH SYNOPSIS
.B "struct dentry *" d_alloc_root
.BI "(struct inode *" root_inode ");"
.SH ARGUMENTS
.IP "root_inode" 12
 inode to allocate the root for
.SH "DESCRIPTION"
Allocate a root ("/") dentry for the inode given. The inode is
instantiated and returned. NULL is returned if there is insufficient
memory or the inode passed is NULL.
.TH "d_alloc_anon" 9 "d_alloc_anon" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_alloc_anon \-  allocate an anonymous dentry
.SH SYNOPSIS
.B "struct dentry *" d_alloc_anon
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to allocate the dentry for
.SH "DESCRIPTION"
This is similar to d_alloc_root.  It is used by filesystems when
creating a dentry for a given inode, often in the process of 
mapping a filehandle to a dentry.  The returned dentry may be
anonymous, or may have a full name (if the inode was already
in the cache).  The file system may need to make further
efforts to connect this dentry into the dcache properly.

When called on a directory inode, we must ensure that
the inode only ever has one dentry.  If a dentry is
found, that is returned instead of allocating a new one.

On successful return, the reference to the inode has been transferred
to the dentry.  If NULL is returned (indicating kmalloc failure),
the reference on the inode has not been released.
.TH "d_splice_alias" 9 "d_splice_alias" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_splice_alias \-  splice a disconnected dentry into the tree if one exists
.SH SYNOPSIS
.B "struct dentry *" d_splice_alias
.BI "(struct inode *" inode ","
.BI "struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "inode" 12
  the inode which may have a disconnected dentry
.IP "dentry" 12
 a negative dentry which we want to point to the inode.
.SH "DESCRIPTION"
If inode is a directory and has a 'disconnected' dentry (i.e. IS_ROOT and
DCACHE_DISCONNECTED), then d_move that in place of the given dentry
and return it, else simply d_add the inode to the dentry and return NULL.

This is needed in the lookup routine of any filesystem that is exportable
(via knfsd) so that we can build dcache paths to directories effectively.

If a dentry was found and moved, then it is returned.  Otherwise NULL
is returned.  This matches the expected return value of -&gt;lookup.
.TH "d_lookup" 9 "d_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_lookup \-  search for a dentry
.SH SYNOPSIS
.B "struct dentry *" d_lookup
.BI "(struct dentry *" parent ","
.BI "struct qstr *" name ");"
.SH ARGUMENTS
.IP "parent" 12
 parent dentry
.IP "name" 12
 qstr of name we wish to find
.SH "DESCRIPTION"
Searches the children of the parent dentry for the name in question. If
the dentry is found its reference count is incremented and the dentry
is returned. The caller must use d_put to free the entry when it has
finished using it. NULL is returned on failure.

__d_lookup is dcache_lock free. The hash list is protected using RCU.
Memory barriers are used while updating and doing lockless traversal. 
To avoid races with d_move while rename is happening, d_lock is used.

Overflows in \fBmemcmp\fP, while d_move, are avoided by keeping the length
and name pointer in one structure pointed by d_qstr.

\fBrcu_read_lock\fP and \fBrcu_read_unlock\fP are used to disable preemption while
lookup is going on.

dentry_unused list is not updated even if lookup finds the required dentry
in there. It is updated in places such as prune_dcache, shrink_dcache_sb,
select_parent and __dget_locked. This laziness saves lookup from dcache_lock
acquisition.

\fBd_lookup\fP is protected against the concurrent renames in some unrelated
directory using the seqlockt_t rename_lock.
.TH "d_validate" 9 "d_validate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_validate \-  verify dentry provided from insecure source
.SH SYNOPSIS
.B "int" d_validate
.BI "(struct dentry *" dentry ","
.BI "struct dentry *" dparent ");"
.SH ARGUMENTS
.IP "dentry" 12
 The dentry alleged to be valid child of \fIdparent\fP
.IP "dparent" 12
 The parent dentry (known to be valid)
.SH "DESCRIPTION"
An insecure source has sent us a dentry, here we verify it and \fBdget\fP it.
This is used by ncpfs in its readdir implementation.
Zero is returned in the dentry is invalid.
.TH "d_delete" 9 "d_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_delete \-  delete a dentry
.SH SYNOPSIS
.B "void" d_delete
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 The dentry to delete
.SH "DESCRIPTION"
Turn the dentry into a negative dentry if possible, otherwise
remove it from the hash queues so it can be deleted later
.TH "d_rehash" 9 "d_rehash" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_rehash \-  add an entry back to the hash
.SH SYNOPSIS
.B "void" d_rehash
.BI "(struct dentry *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 dentry to add to the hash
.SH "DESCRIPTION"
Adds a dentry to the hash according to its name.
.TH "d_move" 9 "d_move" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
d_move \-  move a dentry
.SH SYNOPSIS
.B "void" d_move
.BI "(struct dentry *" dentry ","
.BI "struct dentry *" target ");"
.SH ARGUMENTS
.IP "dentry" 12
 entry to move
.IP "target" 12
 new dentry
.SH "DESCRIPTION"
Update the dcache to reflect the move of a file name. Negative
dcache entries should not be moved in this way.
.TH "__d_path" 9 "__d_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__d_path \-  return the path of a dentry
.SH SYNOPSIS
.B "char *" __d_path
.BI "(struct dentry *" dentry ","
.BI "struct vfsmount *" vfsmnt ","
.BI "struct dentry *" root ","
.BI "struct vfsmount *" rootmnt ","
.BI "char *" buffer ","
.BI "int " buflen ");"
.SH ARGUMENTS
.IP "dentry" 12
 dentry to report
.IP "vfsmnt" 12
 vfsmnt to which the dentry belongs
.IP "root" 12
 root dentry
.IP "rootmnt" 12
 vfsmnt to which the root dentry belongs
.IP "buffer" 12
 buffer to return value in
.IP "buflen" 12
 buffer length
.SH "DESCRIPTION"
Convert a dentry into an ASCII path name. If the entry has been deleted
the string " (deleted)" is appended. Note that this is ambiguous.

Returns the buffer or an error code if the path was too long.

"buflen" should be positive. Caller holds the dcache_lock.
.TH "is_subdir" 9 "is_subdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_subdir \-  is new dentry a subdirectory of old_dentry
.SH SYNOPSIS
.B "int" is_subdir
.BI "(struct dentry *" new_dentry ","
.BI "struct dentry *" old_dentry ");"
.SH ARGUMENTS
.IP "new_dentry" 12
 new dentry
.IP "old_dentry" 12
 old dentry
.SH "DESCRIPTION"
Returns 1 if new_dentry is a subdirectory of the parent (at any depth).
Returns 0 otherwise.
Caller must ensure that "new_dentry" is pinned before calling \fBis_subdir\fP
.TH "find_inode_number" 9 "find_inode_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_inode_number \-  check for dentry with name
.SH SYNOPSIS
.B "ino_t" find_inode_number
.BI "(struct dentry *" dir ","
.BI "struct qstr *" name ");"
.SH ARGUMENTS
.IP "dir" 12
 directory to check
.IP "name" 12
 Name to find.
.SH "DESCRIPTION"
Check whether a dentry already exists for the given name,
and return the inode number if it has an inode. Otherwise
0 is returned.

This routine is used to post-process directory listings for
filesystems using synthetic inode numbers, and is necessary
to keep \fBgetcwd\fP working.
.TH "bio_alloc_bioset" 9 "bio_alloc_bioset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_alloc_bioset \-  allocate a bio for I/O
.SH SYNOPSIS
.B "struct bio *" bio_alloc_bioset
.BI "(gfp_t " gfp_mask ","
.BI "int " nr_iovecs ","
.BI "struct bio_set *" bs ");"
.SH ARGUMENTS
.IP "gfp_mask" 12
   the GFP_ mask given to the slab allocator
.IP "nr_iovecs" 12
	number of iovecs to pre-allocate
.IP "bs" 12
		the bio_set to allocate from
.SH "DESCRIPTION"
bio_alloc_bioset will first try it's on mempool to satisfy the allocation.
If __GFP_WAIT is set then we will block on the internal pool waiting
for a &amp;struct bio to become free.

allocate bio and iovecs from the memory pools specified by the
bio_set structure.
.TH "bio_put" 9 "bio_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_put \-  release a reference to a bio
.SH SYNOPSIS
.B "void" bio_put
.BI "(struct bio *" bio ");"
.SH ARGUMENTS
.IP "bio" 12
   bio to release reference to
.SH "DESCRIPTION"
Put a reference to a &amp;struct bio, either one you have gotten with
bio_alloc or bio_get. The last put of a bio will free it.
.TH "__bio_clone" 9 "__bio_clone" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__bio_clone \- 	clone a bio
.SH SYNOPSIS
.B "void" __bio_clone
.BI "(struct bio *" bio ","
.BI "struct bio *" bio_src ");"
.SH ARGUMENTS
.IP "bio" 12
 destination bio
.IP "bio_src" 12
 bio to clone
.SH "DESCRIPTION"
Clone a &amp;bio. Caller will own the returned bio, but not
the actual data it points to. Reference count of returned
bio will be one.
.TH "bio_clone" 9 "bio_clone" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_clone \- 	clone a bio
.SH SYNOPSIS
.B "struct bio *" bio_clone
.BI "(struct bio *" bio ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "bio" 12
 bio to clone
.IP "gfp_mask" 12
 allocation priority
.SH "DESCRIPTION"
Like __bio_clone, only also allocates the returned bio
.TH "bio_get_nr_vecs" 9 "bio_get_nr_vecs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_get_nr_vecs \-  return approx number of vecs
.SH SYNOPSIS
.B "int" bio_get_nr_vecs
.BI "(struct block_device *" bdev ");"
.SH ARGUMENTS
.IP "bdev" 12
  I/O target
.SH "DESCRIPTION"
Return the approximate number of pages we can send to this target.
There's no guarantee that you will be able to fit this number of pages
into a bio, it does not account for dynamic restrictions that vary
on offset.
.TH "bio_add_page" 9 "bio_add_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_add_page \- 	attempt to add page to bio
.SH SYNOPSIS
.B "int" bio_add_page
.BI "(struct bio *" bio ","
.BI "struct page *" page ","
.BI "unsigned int " len ","
.BI "unsigned int " offset ");"
.SH ARGUMENTS
.IP "bio" 12
 destination bio
.IP "page" 12
 page to add
.IP "len" 12
 vec entry length
.IP "offset" 12
 vec entry offset
.SH "DESCRIPTION"
Attempt to add a page to the bio_vec maplist. This can fail for a
number of reasons, such as the bio being full or target block
device limitations. The target block device must allow bio's
smaller than PAGE_SIZE, so it is always possible to add a single
page to an empty bio.
.TH "bio_uncopy_user" 9 "bio_uncopy_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_uncopy_user \- 	finish previously mapped bio
.SH SYNOPSIS
.B "int" bio_uncopy_user
.BI "(struct bio *" bio ");"
.SH ARGUMENTS
.IP "bio" 12
 bio being terminated
.SH "DESCRIPTION"
Free pages allocated from \fBbio_copy_user\fP and write back data
to user space in case of a read.
.TH "bio_copy_user" 9 "bio_copy_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_copy_user \- 	copy user data to bio
.SH SYNOPSIS
.B "struct bio *" bio_copy_user
.BI "(request_queue_t *" q ","
.BI "unsigned long " uaddr ","
.BI "unsigned int " len ","
.BI "int " write_to_vm ");"
.SH ARGUMENTS
.IP "q" 12
 destination block queue
.IP "uaddr" 12
 start of user address
.IP "len" 12
 length in bytes
.IP "write_to_vm" 12
 bool indicating writing to pages or not
.SH "DESCRIPTION"
Prepares and returns a bio for indirect user io, bouncing data
to/from kernel pages as necessary. Must be paired with
call \fBbio_uncopy_user\fP on io completion.
.TH "bio_map_user" 9 "bio_map_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_map_user \- 	map user address into bio
.SH SYNOPSIS
.B "struct bio *" bio_map_user
.BI "(request_queue_t *" q ","
.BI "struct block_device *" bdev ","
.BI "unsigned long " uaddr ","
.BI "unsigned int " len ","
.BI "int " write_to_vm ");"
.SH ARGUMENTS
.IP "q" 12
 the request_queue_t for the bio
.IP "bdev" 12
 destination block device
.IP "uaddr" 12
 start of user address
.IP "len" 12
 length in bytes
.IP "write_to_vm" 12
 bool indicating writing to pages or not
.SH "DESCRIPTION"
Map the user space address into a bio suitable for io to a block
device. Returns an error pointer in case of error.
.TH "bio_map_user_iov" 9 "bio_map_user_iov" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_map_user_iov \-  map user sg_iovec table into bio
.SH SYNOPSIS
.B "struct bio *" bio_map_user_iov
.BI "(request_queue_t *" q ","
.BI "struct block_device *" bdev ","
.BI "struct sg_iovec *" iov ","
.BI "int " iov_count ","
.BI "int " write_to_vm ");"
.SH ARGUMENTS
.IP "q" 12
 the request_queue_t for the bio
.IP "bdev" 12
 destination block device
.IP "iov" 12
	the iovec.
.IP "iov_count" 12
 number of elements in the iovec
.IP "write_to_vm" 12
 bool indicating writing to pages or not
.SH "DESCRIPTION"
Map the user space address into a bio suitable for io to a block
device. Returns an error pointer in case of error.
.TH "bio_unmap_user" 9 "bio_unmap_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_unmap_user \- 	unmap a bio
.SH SYNOPSIS
.B "void" bio_unmap_user
.BI "(struct bio *" bio ");"
.SH ARGUMENTS
.IP "bio" 12
		the bio being unmapped
.SH "DESCRIPTION"
Unmap a bio previously mapped by \fBbio_map_user\fP. Must be called with
a process context.

\fBbio_unmap_user\fP may sleep.
.TH "bio_map_kern" 9 "bio_map_kern" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_map_kern \- 	map kernel address into bio
.SH SYNOPSIS
.B "struct bio *" bio_map_kern
.BI "(request_queue_t *" q ","
.BI "void *" data ","
.BI "unsigned int " len ","
.BI "unsigned int " gfp_mask ");"
.SH ARGUMENTS
.IP "q" 12
 the request_queue_t for the bio
.IP "data" 12
 pointer to buffer to map
.IP "len" 12
 length in bytes
.IP "gfp_mask" 12
 allocation flags for bio allocation
.SH "DESCRIPTION"
Map the kernel address into a bio suitable for io to a block
device. Returns an error pointer in case of error.
.TH "bio_endio" 9 "bio_endio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bio_endio \-  end I/O on a bio
.SH SYNOPSIS
.B "void" bio_endio
.BI "(struct bio *" bio ","
.BI "unsigned int " bytes_done ","
.BI "int " error ");"
.SH ARGUMENTS
.IP "bio" 12
	bio
.IP "bytes_done" 12
	number of bytes completed
.IP "error" 12
	error, if any
.SH "DESCRIPTION"
\fBbio_endio\fP will end I/O on \fIbytes_done\fP number of bytes. This may be
just a partial part of the bio, or it may be the whole bio. \fBbio_endio\fP
is the preferred way to end I/O on a bio, it takes care of decrementing
bi_size and clearing BIO_UPTODATE on error. \fIerror\fP is 0 on success, and
and one of the established -Exxxx (-EIO, for instance) error values in
case something went wrong. Noone should call \fBbi_end_io\fP directly on
a bio unless they own it and thus know that it has an end_io function.
.TH "sysfs_create_link" 9 "sysfs_create_link" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_create_link \-  create symlink between two objects.
.SH SYNOPSIS
.B "int" sysfs_create_link
.BI "(struct kobject *" kobj ","
.BI "struct kobject *" target ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "kobj" 12
	object whose directory we're creating the link in.
.IP "target" 12
	object we're pointing to.
.IP "name" 12
		name of the symlink.
.TH "sysfs_remove_link" 9 "sysfs_remove_link" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_remove_link \-  remove symlink in object's directory.
.SH SYNOPSIS
.B "void" sysfs_remove_link
.BI "(struct kobject *" kobj ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "kobj" 12
	object we're acting for.
.IP "name" 12
	name of the symlink to remove.
.TH "fill_read_buffer" 9 "fill_read_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fill_read_buffer \-  allocate and fill buffer from object.
.SH SYNOPSIS
.B "int" fill_read_buffer
.BI "(struct dentry *" dentry ","
.BI "struct sysfs_buffer *" buffer ");"
.SH ARGUMENTS
.IP "dentry" 12
	dentry pointer.
.IP "buffer" 12
	data buffer for file.
.SH "DESCRIPTION"
Allocate \fIbuffer\fP-&gt;page, if it hasn't been already, then call the
kobject's \fBshow\fP method to fill the buffer with this attribute's 
data. 
This is called only once, on the file's first read. 
.TH "flush_read_buffer" 9 "flush_read_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
flush_read_buffer \-  push buffer to userspace.
.SH SYNOPSIS
.B "int" flush_read_buffer
.BI "(struct sysfs_buffer *" buffer ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "buffer" 12
	data buffer for file.
.IP "buf" 12
		user-passed buffer.
.IP "count" 12
		number of bytes requested.
.IP "ppos" 12
		file position.
.SH "DESCRIPTION"
Copy the buffer we filled in \fBfill_read_buffer\fP to userspace.
This is done at the reader's leisure, copying and advancing 
the amount they specify each time.
This may be called continuously until the buffer is empty.
.TH "sysfs_read_file" 9 "sysfs_read_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_read_file \-  read an attribute. 
.SH SYNOPSIS
.B "ssize_t" sysfs_read_file
.BI "(struct file *" file ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
	file pointer.
.IP "buf" 12
	buffer to fill.
.IP "count" 12
	number of bytes to read.
.IP "ppos" 12
	starting offset in file.
.SH "DESCRIPTION"
Userspace wants to read an attribute file. The attribute descriptor
is in the file's -&gt;d_fsdata. The target object is in the directory's
-&gt;d_fsdata.

We call \fBfill_read_buffer\fP to allocate and fill the buffer from the
object's \fBshow\fP method exactly once (if the read is happening from
the beginning of the file). That should fill the entire buffer with
all the data the object has to offer for that attribute.
We then call \fBflush_read_buffer\fP to copy the buffer to userspace
in the increments specified.
.TH "fill_write_buffer" 9 "fill_write_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fill_write_buffer \-  copy buffer from userspace.
.SH SYNOPSIS
.B "int" fill_write_buffer
.BI "(struct sysfs_buffer *" buffer ","
.BI "const char __user *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "buffer" 12
	data buffer for file.
.IP "buf" 12
		data from user.
.IP "count" 12
		number of bytes in \fIuserbuf\fP.
.SH "DESCRIPTION"
Allocate \fIbuffer\fP-&gt;page if it hasn't been already, then
copy the user-supplied buffer into it.
.TH "flush_write_buffer" 9 "flush_write_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
flush_write_buffer \-  push buffer to kobject.
.SH SYNOPSIS
.B "int" flush_write_buffer
.BI "(struct dentry *" dentry ","
.BI "struct sysfs_buffer *" buffer ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dentry" 12
	dentry to the attribute
.IP "buffer" 12
	data buffer for file.
.IP "count" 12
		number of bytes
.SH "DESCRIPTION"
Get the correct pointers for the kobject and the attribute we're
dealing with, then call the \fBstore\fP method for the attribute, 
passing the buffer that we acquired in \fBfill_write_buffer\fP.
.TH "sysfs_write_file" 9 "sysfs_write_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_write_file \-  write an attribute.
.SH SYNOPSIS
.B "ssize_t" sysfs_write_file
.BI "(struct file *" file ","
.BI "const char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
	file pointer
.IP "buf" 12
	data to write
.IP "count" 12
	number of bytes
.IP "ppos" 12
	starting offset
.SH "DESCRIPTION"
Similar to \fBsysfs_read_file\fP, though working in the opposite direction.
We allocate and fill the data from the user in \fBfill_write_buffer\fP,
then push it to the kobject in \fBflush_write_buffer\fP.
There is no easy way for us to know if userspace is only doing a partial
write, so we don't support them. We expect the entire buffer to come
on the first write. 
.SH "HINT"
 if you're writing a value, first read the file, modify only the
the value you're changing, then write entire buffer back. 
.TH "sysfs_create_file" 9 "sysfs_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_create_file \-  create an attribute file for an object.
.SH SYNOPSIS
.B "int" sysfs_create_file
.BI "(struct kobject *" kobj ","
.BI "const struct attribute *" attr ");"
.SH ARGUMENTS
.IP "kobj" 12
	object we're creating for. 
.IP "attr" 12
	atrribute descriptor.
.TH "sysfs_update_file" 9 "sysfs_update_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_update_file \-  update the modified timestamp on an object attribute.
.SH SYNOPSIS
.B "int" sysfs_update_file
.BI "(struct kobject *" kobj ","
.BI "const struct attribute *" attr ");"
.SH ARGUMENTS
.IP "kobj" 12
 object we're acting for.
.IP "attr" 12
 attribute descriptor.
.TH "sysfs_chmod_file" 9 "sysfs_chmod_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_chmod_file \-  update the modified mode value on an object attribute.
.SH SYNOPSIS
.B "int" sysfs_chmod_file
.BI "(struct kobject *" kobj ","
.BI "struct attribute *" attr ","
.BI "mode_t " mode ");"
.SH ARGUMENTS
.IP "kobj" 12
 object we're acting for.
.IP "attr" 12
 attribute descriptor.
.IP "mode" 12
 file permissions.
.TH "sysfs_remove_file" 9 "sysfs_remove_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_remove_file \-  remove an object attribute.
.SH SYNOPSIS
.B "void" sysfs_remove_file
.BI "(struct kobject *" kobj ","
.BI "const struct attribute *" attr ");"
.SH ARGUMENTS
.IP "kobj" 12
	object we're acting for.
.IP "attr" 12
	attribute descriptor.
.SH "DESCRIPTION"
Hash the attribute name and kill the victim.
.TH "sysfs_create_bin_file" 9 "sysfs_create_bin_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_create_bin_file \-  create binary file for object.
.SH SYNOPSIS
.B "int" sysfs_create_bin_file
.BI "(struct kobject *" kobj ","
.BI "struct bin_attribute *" attr ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.IP "attr" 12
	attribute descriptor.
.TH "sysfs_remove_bin_file" 9 "sysfs_remove_bin_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_remove_bin_file \-  remove binary file for object.
.SH SYNOPSIS
.B "int" sysfs_remove_bin_file
.BI "(struct kobject *" kobj ","
.BI "struct bin_attribute *" attr ");"
.SH ARGUMENTS
.IP "kobj" 12
	object.
.IP "attr" 12
	attribute descriptor.
.TH "sysfs_create_dir" 9 "sysfs_create_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_create_dir \-  create a directory for an object.
.SH SYNOPSIS
.B "int" sysfs_create_dir
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
		object we're creating directory for. 
.TH "sysfs_remove_dir" 9 "sysfs_remove_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysfs_remove_dir \-  remove an object's directory.
.SH SYNOPSIS
.B "void" sysfs_remove_dir
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	object. 
.SH "DESCRIPTION"
The only thing special about this is that we remove any files in 
the directory before we remove the directory, and we've inlined
what used to be \fBsysfs_rmdir\fP below, instead of calling separately.
.TH "register_filesystem" 9 "register_filesystem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_filesystem \-  register a new filesystem
.SH SYNOPSIS
.B "int" register_filesystem
.BI "(struct file_system_type *" fs ");"
.SH ARGUMENTS
.IP "fs" 12
 the file system structure
.SH "DESCRIPTION"
Adds the file system passed to the list of file systems the kernel
is aware of for mount and other syscalls. Returns 0 on success,
or a negative errno code on an error.

The &amp;struct file_system_type that is passed is linked into the kernel 
structures and must not be freed until the file system has been
unregistered.
.TH "unregister_filesystem" 9 "unregister_filesystem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_filesystem \-  unregister a file system
.SH SYNOPSIS
.B "int" unregister_filesystem
.BI "(struct file_system_type *" fs ");"
.SH ARGUMENTS
.IP "fs" 12
 filesystem to unregister
.SH "DESCRIPTION"
Remove a file system that was previously successfully registered
with the kernel. An error is returned if the file system is not found.
Zero is returned on a success.

Once this function has returned the &amp;struct file_system_type structure
may be freed or reused.
.TH "clear_inode" 9 "clear_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clear_inode \-  clear an inode
.SH SYNOPSIS
.B "void" clear_inode
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to clear
.SH "DESCRIPTION"
This is called by the filesystem to tell us
that the inode is no longer useful. We just
terminate it with extreme prejudice.
.TH "invalidate_inodes" 9 "invalidate_inodes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
invalidate_inodes \-  discard the inodes on a device
.SH SYNOPSIS
.B "int" invalidate_inodes
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock
.SH "DESCRIPTION"
Discard all of the inodes for a given superblock. If the discard
fails because there are busy inodes then a non zero value is returned.
If the discard is successful all the inodes have been discarded.
.TH "new_inode" 9 "new_inode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
new_inode \-  obtain an inode
.SH SYNOPSIS
.B "struct inode *" new_inode
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock
.SH "DESCRIPTION"
Allocates a new inode for given superblock.
.TH "iunique" 9 "iunique" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iunique \-  get a unique inode number
.SH SYNOPSIS
.B "ino_t" iunique
.BI "(struct super_block *" sb ","
.BI "ino_t " max_reserved ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock
.IP "max_reserved" 12
 highest reserved inode number
.SH "DESCRIPTION"
Obtain an inode number that is unique on the system for a given
superblock. This is used by file systems that have no natural
permanent inode numbering system. An inode number is returned that
is higher than the reserved limit but unique.
.SH "BUGS"
With a large number of inodes live on the file system this function
currently becomes quite slow.
.TH "ifind" 9 "ifind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ifind \-  internal function, you want ilookup5() or iget5().
.SH SYNOPSIS
.B "struct inode *" ifind
.BI "(struct super_block *" sb ","
.BI "struct hlist_head *" head ","
.BI "int (*" test ") (struct inode *, void *),"
.BI "void *" data ","
.BI "const int " wait ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of file system to search
.IP "head" 12
       the head of the list to search
.IP "test" 12
	callback used for comparisons between inodes
.IP "data" 12
	opaque data pointer to pass to \fItest\fP
.IP "wait" 12
	if true wait for the inode to be unlocked, if false do not
.SH "DESCRIPTION"
\fBifind\fP searches for the inode specified by \fIdata\fP in the inode
cache. This is a generalized version of \fBifind_fast\fP for file systems where
the inode number is not sufficient for unique identification of an inode.

If the inode is in the cache, the inode is returned with an incremented
reference count.

Otherwise NULL is returned.

Note, \fItest\fP is called with the inode_lock held, so can't sleep.
.TH "ifind_fast" 9 "ifind_fast" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ifind_fast \-  internal function, you want ilookup() or iget().
.SH SYNOPSIS
.B "struct inode *" ifind_fast
.BI "(struct super_block *" sb ","
.BI "struct hlist_head *" head ","
.BI "unsigned long " ino ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of file system to search
.IP "head" 12
       head of the list to search
.IP "ino" 12
	inode number to search for
.SH "DESCRIPTION"
\fBifind_fast\fP searches for the inode \fIino\fP in the inode cache. This is for
file systems where the inode number is sufficient for unique identification
of an inode.

If the inode is in the cache, the inode is returned with an incremented
reference count.

Otherwise NULL is returned.
.TH "ilookup5_nowait" 9 "ilookup5_nowait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ilookup5_nowait \-  search for an inode in the inode cache
.SH SYNOPSIS
.B "struct inode *" ilookup5_nowait
.BI "(struct super_block *" sb ","
.BI "unsigned long " hashval ","
.BI "int (*" test ") (struct inode *, void *),"
.BI "void *" data ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of file system to search
.IP "hashval" 12
	hash value (usually inode number) to search for
.IP "test" 12
	callback used for comparisons between inodes
.IP "data" 12
	opaque data pointer to pass to \fItest\fP
.SH "DESCRIPTION"
\fBilookup5\fP uses \fBifind\fP to search for the inode specified by \fIhashval\fP and
\fIdata\fP in the inode cache. This is a generalized version of \fBilookup\fP for
file systems where the inode number is not sufficient for unique
identification of an inode.

If the inode is in the cache, the inode is returned with an incremented
reference count.  Note, the inode lock is not waited upon so you have to be
very careful what you do with the returned inode.  You probably should be
using \fBilookup5\fP instead.

Otherwise NULL is returned.

Note, \fItest\fP is called with the inode_lock held, so can't sleep.
.TH "ilookup5" 9 "ilookup5" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ilookup5 \-  search for an inode in the inode cache
.SH SYNOPSIS
.B "struct inode *" ilookup5
.BI "(struct super_block *" sb ","
.BI "unsigned long " hashval ","
.BI "int (*" test ") (struct inode *, void *),"
.BI "void *" data ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of file system to search
.IP "hashval" 12
	hash value (usually inode number) to search for
.IP "test" 12
	callback used for comparisons between inodes
.IP "data" 12
	opaque data pointer to pass to \fItest\fP
.SH "DESCRIPTION"
\fBilookup5\fP uses \fBifind\fP to search for the inode specified by \fIhashval\fP and
\fIdata\fP in the inode cache. This is a generalized version of \fBilookup\fP for
file systems where the inode number is not sufficient for unique
identification of an inode.

If the inode is in the cache, the inode lock is waited upon and the inode is
returned with an incremented reference count.

Otherwise NULL is returned.

Note, \fItest\fP is called with the inode_lock held, so can't sleep.
.TH "ilookup" 9 "ilookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ilookup \-  search for an inode in the inode cache
.SH SYNOPSIS
.B "struct inode *" ilookup
.BI "(struct super_block *" sb ","
.BI "unsigned long " ino ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of file system to search
.IP "ino" 12
	inode number to search for
.SH "DESCRIPTION"
\fBilookup\fP uses \fBifind_fast\fP to search for the inode \fIino\fP in the inode cache.
This is for file systems where the inode number is sufficient for unique
identification of an inode.

If the inode is in the cache, the inode is returned with an incremented
reference count.

Otherwise NULL is returned.
.TH "iget5_locked" 9 "iget5_locked" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iget5_locked \-  obtain an inode from a mounted file system
.SH SYNOPSIS
.B "struct inode *" iget5_locked
.BI "(struct super_block *" sb ","
.BI "unsigned long " hashval ","
.BI "int (*" test ") (struct inode *, void *),"
.BI "int (*" set ") (struct inode *, void *),"
.BI "void *" data ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of file system
.IP "hashval" 12
	hash value (usually inode number) to get
.IP "test" 12
	callback used for comparisons between inodes
.IP "set" 12
	callback used to initialize a new struct inode
.IP "data" 12
	opaque data pointer to pass to \fItest\fP and \fIset\fP
.SH "DESCRIPTION"
This is \fBiget\fP without the \fBread_inode\fP portion of \fBget_new_inode\fP.

\fBiget5_locked\fP uses \fBifind\fP to search for the inode specified by \fIhashval\fP
and \fIdata\fP in the inode cache and if present it is returned with an increased
reference count. This is a generalized version of \fBiget_locked\fP for file
systems where the inode number is not sufficient for unique identification
of an inode.

If the inode is not in cache, \fBget_new_inode\fP is called to allocate a new
inode and this is returned locked, hashed, and with the I_NEW flag set. The
file system gets to fill it in before unlocking it via \fBunlock_new_inode\fP.

Note both \fItest\fP and \fIset\fP are called with the inode_lock held, so can't sleep.
.TH "iget_locked" 9 "iget_locked" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iget_locked \-  obtain an inode from a mounted file system
.SH SYNOPSIS
.B "struct inode *" iget_locked
.BI "(struct super_block *" sb ","
.BI "unsigned long " ino ");"
.SH ARGUMENTS
.IP "sb" 12
		super block of file system
.IP "ino" 12
	inode number to get
.SH "DESCRIPTION"
This is \fBiget\fP without the \fBread_inode\fP portion of \fBget_new_inode_fast\fP.

\fBiget_locked\fP uses \fBifind_fast\fP to search for the inode specified by \fIino\fP in
the inode cache and if present it is returned with an increased reference
count. This is for file systems where the inode number is sufficient for
unique identification of an inode.

If the inode is not in cache, \fBget_new_inode_fast\fP is called to allocate a
new inode and this is returned locked, hashed, and with the I_NEW flag set.
The file system gets to fill it in before unlocking it via
\fBunlock_new_inode\fP.
.TH "__insert_inode_hash" 9 "__insert_inode_hash" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__insert_inode_hash \-  hash an inode
.SH SYNOPSIS
.B "void" __insert_inode_hash
.BI "(struct inode *" inode ","
.BI "unsigned long " hashval ");"
.SH ARGUMENTS
.IP "inode" 12
 unhashed inode
.IP "hashval" 12
 unsigned long value used to locate this object in the
inode_hashtable.
.SH "DESCRIPTION"
Add an inode to the inode hash for this superblock.
.TH "remove_inode_hash" 9 "remove_inode_hash" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
remove_inode_hash \-  remove an inode from the hash
.SH SYNOPSIS
.B "void" remove_inode_hash
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to unhash
.SH "DESCRIPTION"
Remove an inode from the superblock.
.TH "iput" 9 "iput" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iput \-  put an inode 
.SH SYNOPSIS
.B "void" iput
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to put
.SH "DESCRIPTION"
Puts an inode, dropping its usage count. If the inode use count hits
zero, the inode is then freed and may also be destroyed.

Consequently, \fBiput\fP can sleep.
.TH "bmap" 9 "bmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bmap \-  find a block number in a file
.SH SYNOPSIS
.B "sector_t" bmap
.BI "(struct inode *" inode ","
.BI "sector_t " block ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of file
.IP "block" 12
 block to find
.SH "DESCRIPTION"
Returns the block number on the device holding the inode that
is the disk block number for the block of the file requested.
That is, asked for block 4 of inode 1 the function will return the
disk block relative to the disk start that holds that block of the 
file.
.TH "update_atime" 9 "update_atime" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
update_atime \- 	update the access time
.SH SYNOPSIS
.B "void" update_atime
.BI "(struct inode *" inode ");"
.SH ARGUMENTS
.IP "inode" 12
 inode accessed
.SH "DESCRIPTION"
Update the accessed time on an inode and mark it for writeback.
This function automatically handles read only file systems and media,
as well as the "noatime" flag and inode specific "noatime" markers.
.TH "inode_update_time" 9 "inode_update_time" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inode_update_time \- 	update mtime and ctime time
.SH SYNOPSIS
.B "void" inode_update_time
.BI "(struct inode *" inode ","
.BI "int " ctime_too ");"
.SH ARGUMENTS
.IP "inode" 12
 inode accessed
.IP "ctime_too" 12
 update ctime too
.SH "DESCRIPTION"
Update the mtime time on an inode and mark it for writeback.
When ctime_too is specified update the ctime too.
.TH "mpage_readpages" 9 "mpage_readpages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpage_readpages \-  populate an address space with some pages, and
.SH SYNOPSIS
.B "int" mpage_readpages
.BI "(struct address_space *" mapping ","
.BI "struct list_head *" pages ","
.BI "unsigned " nr_pages ","
.BI "get_block_t " get_block ");"
.SH ARGUMENTS
.IP "mapping" 12
 the address_space
.IP "pages" 12
 The address of a list_head which contains the target pages.  These
pages have their -&gt;index populated and are otherwise uninitialised.
.IP "nr_pages" 12
 The number of pages at *\fIpages\fP
.IP "get_block" 12
 The filesystem's block mapper function.
.SH "DESCRIPTION"
This function walks the pages and the blocks within each page, building and
emitting large BIOs.

If anything unusual happens, such as:

- encountering a page which has buffers
- encountering a page which has a non-hole after a hole
- encountering a page with non-contiguous blocks

then this code just gives up and calls the buffer_head-based read function.
It does handle a page which has holes at the end - that is a common case:
the end-of-file on blocksize &lt; PAGE_CACHE_SIZE setups.
.SH "DESCRIPTION"
This function walks the pages and the blocks within each page, building and
emitting large BIOs.

If anything unusual happens, such as:

- encountering a page which has buffers
- encountering a page which has a non-hole after a hole
- encountering a page with non-contiguous blocks

then this code just gives up and calls the buffer_head-based read function.
It does handle a page which has holes at the end - that is a common case:
the end-of-file on blocksize &lt; PAGE_CACHE_SIZE setups.
.SH "DESCRIPTION"
This function walks the pages and the blocks within each page, building and
emitting large BIOs.

If anything unusual happens, such as:

- encountering a page which has buffers
- encountering a page which has a non-hole after a hole
- encountering a page with non-contiguous blocks

then this code just gives up and calls the buffer_head-based read function.
It does handle a page which has holes at the end - that is a common case:
the end-of-file on blocksize &lt; PAGE_CACHE_SIZE setups.
.SH "BH_BOUNDARY EXPLANATION"

There is a problem.  The mpage read code assembles several pages, gets all
their disk mappings, and then submits them all.  That's fine, but obtaining
the disk mappings may require I/O.  Reads of indirect blocks, for example.

So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be
.SH "SUBMITTED IN THE FOLLOWING ORDER"
12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16
because the indirect block has to be read to get the mappings of blocks
13,14,15,16.  Obviously, this impacts performance.

So what we do it to allow the filesystem's \fBget_block\fP function to set
BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block
after this one will require I/O against a block which is probably close to
this one.  So you should push what I/O you have currently accumulated.

This all causes the disk requests to be issued in the correct order.
.TH "mpage_writepages" 9 "mpage_writepages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpage_writepages \-  walk the list of dirty pages of the given
.SH SYNOPSIS
.B "int" mpage_writepages
.BI "(struct address_space *" mapping ","
.BI "struct writeback_control *" wbc ","
.BI "get_block_t " get_block ");"
.SH ARGUMENTS
.IP "mapping" 12
 address space structure to write
.IP "wbc" 12
 subtract the number of written pages from *\fIwbc\fP-&gt;nr_to_write
.IP "get_block" 12
 the filesystem's block mapper function.
If this is NULL then use a_ops-&gt;writepage.  Otherwise, go
direct-to-BIO.
.SH "DESCRIPTION"
This is a library function, which implements the \fBwritepages\fP
address_space_operation.

If a page is already under I/O, \fBgeneric_writepages\fP skips it, even
if it's dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as \fBfsync\fP.  \fBfsync\fP
and \fBmsync\fP need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.
.SH "DESCRIPTION"
This is a library function, which implements the \fBwritepages\fP
address_space_operation.

If a page is already under I/O, \fBgeneric_writepages\fP skips it, even
if it's dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as \fBfsync\fP.  \fBfsync\fP
and \fBmsync\fP need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.
.TH "jffs2_do_reserve_space" 9 "jffs2_do_reserve_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
jffs2_do_reserve_space \-  request physical space to write nodes to flash
.SH SYNOPSIS
.B "int" jffs2_do_reserve_space
.BI "(struct jffs2_sb_info *" c ","
.BI "uint32_t " minsize ","
.BI "uint32_t *" ofs ","
.BI "uint32_t *" len ");"
.SH ARGUMENTS
.IP "c" 12
 superblock info
.IP "minsize" 12
 Minimum acceptable size of allocation
.IP "ofs" 12
 Returned value of node offset
.IP "len" 12
 Returned value of allocation length
.SH "DESCRIPTION"
Requests a block of physical space on the flash. Returns zero for success
and puts 'ofs' and 'len' into the appriopriate place, or returns -ENOSPC
or other error if appropriate.

If it returns zero, \fBjffs2_reserve_space\fP also downs the per-filesystem
allocation semaphore, to prevent more than one allocation from being
active at any time. The semaphore is later released by \fBjffs2_commit_allocation\fP

\fBjffs2_reserve_space\fP may trigger garbage collection in order to make room
for the requested allocation.
.TH "jffs2_add_physical_node_ref" 9 "jffs2_add_physical_node_ref" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
jffs2_add_physical_node_ref \-  add a physical node reference to the list
.SH SYNOPSIS
.B "int" jffs2_add_physical_node_ref
.BI "(struct jffs2_sb_info *" c ","
.BI "struct jffs2_raw_node_ref *" new ");"
.SH ARGUMENTS
.IP "c" 12
 superblock info
.IP "new" 12
 new node reference to add
.SH "DESCRIPTION"
Should only be used to report nodes for which space has been allocated 
by jffs2_reserve_space.

Must be called with the alloc_sem held.
.TH "alloc_super" 9 "alloc_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_super \- 	create new superblock
.SH SYNOPSIS
.B "struct super_block *" alloc_super
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocates and initializes a new &amp;struct super_block.  \fBalloc_super\fP
returns a pointer new superblock or NULL if allocation had failed.
.TH "destroy_super" 9 "destroy_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
destroy_super \- 	frees a superblock
.SH SYNOPSIS
.B "void" destroy_super
.BI "(struct super_block *" s ");"
.SH ARGUMENTS
.IP "s" 12
 superblock to free
.SH "DESCRIPTION"
Frees a superblock.
.TH "put_super" 9 "put_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_super \- 	drop a temporary reference to superblock
.SH SYNOPSIS
.B "void" put_super
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock in question
.SH "DESCRIPTION"
Drops a temporary reference, frees superblock if there's no
references left.
.TH "deactivate_super" 9 "deactivate_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
deactivate_super \- 	drop an active reference to superblock
.SH SYNOPSIS
.B "void" deactivate_super
.BI "(struct super_block *" s ");"
.SH ARGUMENTS
.IP "s" 12
 superblock to deactivate
.SH "DESCRIPTION"
Drops an active reference to superblock, acquiring a temprory one if
there is no active references left.  In that case we lock superblock,
tell fs driver to shut it down and drop the temporary reference we
had just acquired.
.TH "grab_super" 9 "grab_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
grab_super \-  acquire an active reference
.SH SYNOPSIS
.B "int" grab_super
.BI "(struct super_block *" s ");"
.SH ARGUMENTS
.IP "s" 12
 reference we are trying to make active
.SH "DESCRIPTION"
Tries to acquire an active reference.  \fBgrab_super\fP is used when we
had just found a superblock in super_blocks or fs_type-&gt;fs_supers
and want to turn it into a full-blown active reference.  \fBgrab_super\fP
is called with sb_lock held and drops it.  Returns 1 in case of
success, 0 if we had failed (superblock contents was already dead or
dying when \fBgrab_super\fP had been called).
.TH "generic_shutdown_super" 9 "generic_shutdown_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_shutdown_super \- 	common helper for -\\\gt;kill_sb()
.SH SYNOPSIS
.B "void" generic_shutdown_super
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock to kill
.SH "DESCRIPTION"
\fBgeneric_shutdown_super\fP does all fs-independent work on superblock
shutdown.  Typical -&gt;\fBkill_sb\fP should pick all fs-specific objects
that need destruction out of superblock, call \fBgeneric_shutdown_super\fP
and release aforementioned objects.  Note: dentries and inodes _are_
taken care of and do not need specific handling.
.TH "sget" 9 "sget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sget \- 	find or create a superblock
.SH SYNOPSIS
.B "struct super_block *" sget
.BI "(struct file_system_type *" type ","
.BI "int (*" test ") (struct super_block *,void *),"
.BI "int (*" set ") (struct super_block *,void *),"
.BI "void *" data ");"
.SH ARGUMENTS
.IP "type" 12
	filesystem type superblock should belong to
.IP "test" 12
	comparison callback
.IP "set" 12
	setup callback
.IP "data" 12
	argument to each of them
.TH "get_super" 9 "get_super" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_super \-  get the superblock of a device
.SH SYNOPSIS
.B "struct super_block *" get_super
.BI "(struct block_device *" bdev ");"
.SH ARGUMENTS
.IP "bdev" 12
 device to get the superblock for
.SH "DESCRIPTION"
Scans the superblock list and finds the superblock of the file system
mounted on the device given. NULL is returned if no match is found.
.TH "mark_files_ro" 9 "mark_files_ro" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mark_files_ro \- 
.SH SYNOPSIS
.B "void" mark_files_ro
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 superblock in question
.SH "DESCRIPTION"
All files are marked read/only.  We don't care about pending
delete files so this should be used in 'force' mode only
.TH "do_remount_sb" 9 "do_remount_sb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_remount_sb \-  asks filesystem to change mount options.
.SH SYNOPSIS
.B "int" do_remount_sb
.BI "(struct super_block *" sb ","
.BI "int " flags ","
.BI "void *" data ","
.BI "int " force ");"
.SH ARGUMENTS
.IP "sb" 12
	superblock in question
.IP "flags" 12
	numeric part of options
.IP "data" 12
	the rest of options
.IP "force" 12
 whether or not to force the change
.SH "DESCRIPTION"
Alters the mount options of a mounted file system.
.TH "wp512_process_buffer" 9 "wp512_process_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wp512_process_buffer \- 
.SH SYNOPSIS
.B "void" wp512_process_buffer
.BI "(struct wp512_ctx *" wctx ");"
.SH ARGUMENTS
.IP "wctx" 12
-- undescribed --
.TH "mptfc_init" 9 "mptfc_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptfc_init \-  Register MPT adapter(s) as SCSI host(s) with
.SH SYNOPSIS
.B "int __init" mptfc_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
linux scsi mid-layer.

Returns 0 for success, non-zero for failure.
.TH "mptfc_exit" 9 "mptfc_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptfc_exit \-  Unregisters MPT adapter(s)
.SH SYNOPSIS
.B "void __exit" mptfc_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "mptscsih_add_sge" 9 "mptscsih_add_sge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_add_sge \-  Place a simple SGE at address pAddr.
.SH SYNOPSIS
.B "void" mptscsih_add_sge
.BI "(char *" pAddr ","
.BI "u32 " flagslength ","
.BI "dma_addr_t " dma_addr ");"
.SH ARGUMENTS
.IP "pAddr" 12
 virtual address for SGE
.IP "flagslength" 12
 SGE flags and data transfer length
.IP "dma_addr" 12
 Physical address
.SH "DESCRIPTION"
This routine places a MPT request frame back on the MPT adapter's
FreeQ.
.TH "mptscsih_add_chain" 9 "mptscsih_add_chain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_add_chain \-  Place a chain SGE at address pAddr.
.SH SYNOPSIS
.B "void" mptscsih_add_chain
.BI "(char *" pAddr ","
.BI "u8 " next ","
.BI "u16 " length ","
.BI "dma_addr_t " dma_addr ");"
.SH ARGUMENTS
.IP "pAddr" 12
 virtual address for SGE
.IP "next" 12
 nextChainOffset value (u32's)
.IP "length" 12
 length of next SGL segment
.IP "dma_addr" 12
 Physical address
.SH "DESCRIPTION"
This routine places a MPT request frame back on the MPT adapter's
FreeQ.
.TH "mptscsih_info" 9 "mptscsih_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_info \-  Return information about MPT adapter
.SH SYNOPSIS
.B "const char *" mptscsih_info
.BI "(struct Scsi_Host *" SChost ");"
.SH ARGUMENTS
.IP "SChost" 12
 Pointer to Scsi_Host structure
.SH "DESCRIPTION"
(linux scsi_host_template.info routine)

Returns pointer to buffer where information was written.
.TH "mptscsih_proc_info" 9 "mptscsih_proc_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_proc_info \-  Return information about MPT adapter
.SH SYNOPSIS
.B "int" mptscsih_proc_info
.BI "(struct Scsi_Host *" host ","
.BI "char *" buffer ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " length ","
.BI "int " func ");"
.SH ARGUMENTS
.IP "host" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "length" 12
-- undescribed --
.IP "func" 12
-- undescribed --
.SH "DESCRIPTION"

(linux scsi_host_template.info routine)
.SH "BUFFER"
 if write, user data; if read, buffer for user
.SH "LENGTH"
 if write, return length;
.SH "OFFSET"
 if write, 0; if read, the current offset into the buffer from
the previous read.
.SH "HOSTNO"
 scsi host number
.SH "FUNC"
   if write = 1; if read = 0
.TH "mptscsih_qcmd" 9 "mptscsih_qcmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_qcmd \-  Primary Fusion MPT SCSI initiator IO start routine.
.SH SYNOPSIS
.B "int" mptscsih_qcmd
.BI "(struct scsi_cmnd *" SCpnt ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "SCpnt" 12
 Pointer to scsi_cmnd structure
.IP "done" 12
 Pointer SCSI mid-layer IO completion function
.SH "DESCRIPTION"
(linux scsi_host_template.queuecommand routine)
This is the primary SCSI IO start routine.  Create a MPI SCSIIORequest
from a linux scsi_cmnd request and send it to the IOC.

Returns 0. (rtn value discarded by linux scsi mid-layer)
.TH "mptscsih_abort" 9 "mptscsih_abort" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_abort \-  Abort linux scsi_cmnd routine, new_eh variant
.SH SYNOPSIS
.B "int" mptscsih_abort
.BI "(struct scsi_cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 Pointer to scsi_cmnd structure, IO to be aborted
.SH "DESCRIPTION"
(linux scsi_host_template.eh_abort_handler routine)

Returns SUCCESS or FAILED.
.TH "mptscsih_dev_reset" 9 "mptscsih_dev_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_dev_reset \-  Perform a SCSI TARGET_RESET!  new_eh variant
.SH SYNOPSIS
.B "int" mptscsih_dev_reset
.BI "(struct scsi_cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 Pointer to scsi_cmnd structure, IO which reset is due to
.SH "DESCRIPTION"
(linux scsi_host_template.eh_dev_reset_handler routine)

Returns SUCCESS or FAILED.
.TH "mptscsih_bus_reset" 9 "mptscsih_bus_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_bus_reset \-  Perform a SCSI BUS_RESET!	new_eh variant
.SH SYNOPSIS
.B "int" mptscsih_bus_reset
.BI "(struct scsi_cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 Pointer to scsi_cmnd structure, IO which reset is due to
.SH "DESCRIPTION"
(linux scsi_host_template.eh_bus_reset_handler routine)

Returns SUCCESS or FAILED.
.TH "mptscsih_host_reset" 9 "mptscsih_host_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_host_reset \-  Perform a SCSI host adapter RESET!
.SH SYNOPSIS
.B "int" mptscsih_host_reset
.BI "(struct scsi_cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 Pointer to scsi_cmnd structure, IO which reset is due to
.SH "DESCRIPTION"
(linux scsi_host_template.eh_host_reset_handler routine)

Returns SUCCESS or FAILED.
.SH "DESCRIPTION"
(linux scsi_host_template.eh_host_reset_handler routine)

Returns SUCCESS or FAILED.
.TH "mptscsih_tm_pending_wait" 9 "mptscsih_tm_pending_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_tm_pending_wait \-  wait for pending task management request to
.SH SYNOPSIS
.B "int" mptscsih_tm_pending_wait
.BI "(MPT_SCSI_HOST *" hd ");"
.SH ARGUMENTS
.IP "hd" 12
 Pointer to MPT host structure.
.SH "DESCRIPTION"
Returns {SUCCESS,FAILED}.
.SH "DESCRIPTION"
Returns {SUCCESS,FAILED}.
.TH "mptscsih_tm_wait_for_completion" 9 "mptscsih_tm_wait_for_completion" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_tm_wait_for_completion \-  wait for completion of TM task
.SH SYNOPSIS
.B "int" mptscsih_tm_wait_for_completion
.BI "(MPT_SCSI_HOST *" hd ","
.BI "ulong " timeout ");"
.SH ARGUMENTS
.IP "hd" 12
 Pointer to MPT host structure.
.IP "timeout" 12
-- undescribed --
.SH "DESCRIPTION"
Returns {SUCCESS,FAILED}.
.TH "mptscsih_taskmgmt_complete" 9 "mptscsih_taskmgmt_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_taskmgmt_complete \-  Registered with Fusion MPT base driver
.SH SYNOPSIS
.B "int" mptscsih_taskmgmt_complete
.BI "(MPT_ADAPTER *" ioc ","
.BI "MPT_FRAME_HDR *" mf ","
.BI "MPT_FRAME_HDR *" mr ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT_ADAPTER structure
.IP "mf" 12
 Pointer to SCSI task mgmt request frame
.IP "mr" 12
 Pointer to SCSI task mgmt reply frame
.SH "DESCRIPTION"
This routine is called from mptbase.c::\fBmpt_interrupt\fP at the completion
of any SCSI task management request.
This routine is registered with the MPT (base) driver at driver
load/init time via the \fBmpt_register\fP API call.

Returns 1 indicating alloc'd request frame ptr should be freed.
.TH "mptscsih_do_cmd" 9 "mptscsih_do_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_do_cmd \-  Do internal command.
.SH SYNOPSIS
.B "int" mptscsih_do_cmd
.BI "(MPT_SCSI_HOST *" hd ","
.BI "INTERNAL_CMD *" io ");"
.SH ARGUMENTS
.IP "hd" 12
 MPT_SCSI_HOST pointer
.IP "io" 12
 INTERNAL_CMD pointer.
.SH "DESCRIPTION"
Issue the specified internally generated command and do command
specific cleanup. For bus scan / DV only.
.SH "NOTES"
 If command is Inquiry and status is good,
initialize a target structure, save the data
.SH "REMARK"
 Single threaded access only.
.SH "RETURN"
&lt; 0 if an illegal command or no resources

0 if good

&gt; 0 if command complete but some type of completion error.
.TH "mptscsih_synchronize_cache" 9 "mptscsih_synchronize_cache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_synchronize_cache \-  Send SYNCHRONIZE_CACHE to all disks.
.SH SYNOPSIS
.B "int" mptscsih_synchronize_cache
.BI "(MPT_SCSI_HOST *" hd ","
.BI "int " portnum ");"
.SH ARGUMENTS
.IP "hd" 12
 Pointer to MPT_SCSI_HOST structure
.IP "portnum" 12
 IOC port number
.SH "DESCRIPTION"
Uses the ISR, but with special processing.
MUST be single-threaded.
.SH "RETURN"
 0 on completion
.TH "mptscsih_domainValidation" 9 "mptscsih_domainValidation" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_domainValidation \-  Top level handler for domain validation.
.SH SYNOPSIS
.B "void" mptscsih_domainValidation
.BI "(void *" arg ");"
.SH ARGUMENTS
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
Uses the ISR, but with special processing.
Called from schedule, should not be in interrupt mode.
While thread alive, do dv for all devices needing dv
.SH "RETURN"
 None.
.TH "mptscsih_doDv" 9 "mptscsih_doDv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptscsih_doDv \-  Perform domain validation to a target.
.SH SYNOPSIS
.B "int" mptscsih_doDv
.BI "(MPT_SCSI_HOST *" hd ","
.BI "int " bus_number ","
.BI "int " id ");"
.SH ARGUMENTS
.IP "hd" 12
 Pointer to MPT_SCSI_HOST structure.
.IP "bus_number" 12
-- undescribed --
.IP "id" 12
-- undescribed --
.SH "DESCRIPTION"
Uses the ISR, but with special processing.
MUST be single-threaded.
Test will exit if target is at async &amp; narrow.
.SH "RETURN"
 None.
.TH "mpt_register" 9 "mpt_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_register \-  Register protocol-specific main callback handler.
.SH SYNOPSIS
.B "int" mpt_register
.BI "(MPT_CALLBACK " cbfunc ","
.BI "MPT_DRIVER_CLASS " dclass ");"
.SH ARGUMENTS
.IP "cbfunc" 12
 callback function pointer
.IP "dclass" 12
 Protocol driver's class (MPT_DRIVER_CLASS enum value)
.SH "DESCRIPTION"
This routine is called by a protocol-specific driver (SCSI host,
LAN, SCSI target) to register it's reply callback routine.  Each
protocol-specific driver must do this before it will be able to
use any IOC resources, such as obtaining request frames.
.SH "NOTES"
 The SCSI protocol driver currently calls this routine thrice
in order to register separate callbacks; one for "normal" SCSI IO;
one for MptScsiTaskMgmt requests; one for Scan/DV requests.

Returns a positive integer valued "handle" in the
range (and S.O.D. order) {N,...,7,6,5,...,1} if successful.
Any non-positive return value (including zero!) should be considered
an error by the caller.
.TH "mpt_deregister" 9 "mpt_deregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_deregister \-  Deregister a protocol drivers resources.
.SH SYNOPSIS
.B "void" mpt_deregister
.BI "(int " cb_idx ");"
.SH ARGUMENTS
.IP "cb_idx" 12
 previously registered callback handle
.SH "DESCRIPTION"
Each protocol-specific driver should call this routine when it's
module is unloaded.
.TH "mpt_event_register" 9 "mpt_event_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_event_register \-  Register protocol-specific event callback
.SH SYNOPSIS
.B "int" mpt_event_register
.BI "(int " cb_idx ","
.BI "MPT_EVHANDLER " ev_cbfunc ");"
.SH ARGUMENTS
.IP "cb_idx" 12
 previously registered (via mpt_register) callback handle
.IP "ev_cbfunc" 12
 callback function
.SH "DESCRIPTION"
This routine can be called by one or more protocol-specific drivers
if/when they choose to be notified of MPT events.

Returns 0 for success.
.SH "DESCRIPTION"
This routine can be called by one or more protocol-specific drivers
if/when they choose to be notified of MPT events.

Returns 0 for success.
.TH "mpt_event_deregister" 9 "mpt_event_deregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_event_deregister \-  Deregister protocol-specific event callback
.SH SYNOPSIS
.B "void" mpt_event_deregister
.BI "(int " cb_idx ");"
.SH ARGUMENTS
.IP "cb_idx" 12
 previously registered callback handle
.SH "DESCRIPTION"
Each protocol-specific driver should call this routine
when it does not (or can no longer) handle events,
or when it's module is unloaded.
.SH "DESCRIPTION"
Each protocol-specific driver should call this routine
when it does not (or can no longer) handle events,
or when it's module is unloaded.
.TH "mpt_reset_register" 9 "mpt_reset_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_reset_register \-  Register protocol-specific IOC reset handler.
.SH SYNOPSIS
.B "int" mpt_reset_register
.BI "(int " cb_idx ","
.BI "MPT_RESETHANDLER " reset_func ");"
.SH ARGUMENTS
.IP "cb_idx" 12
 previously registered (via mpt_register) callback handle
.IP "reset_func" 12
 reset function
.SH "DESCRIPTION"
This routine can be called by one or more protocol-specific drivers
if/when they choose to be notified of IOC resets.

Returns 0 for success.
.TH "mpt_reset_deregister" 9 "mpt_reset_deregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_reset_deregister \-  Deregister protocol-specific IOC reset handler.
.SH SYNOPSIS
.B "void" mpt_reset_deregister
.BI "(int " cb_idx ");"
.SH ARGUMENTS
.IP "cb_idx" 12
 previously registered callback handle
.SH "DESCRIPTION"
Each protocol-specific driver should call this routine
when it does not (or can no longer) handle IOC reset handling,
or when it's module is unloaded.
.TH "mpt_device_driver_register" 9 "mpt_device_driver_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_device_driver_register \-  Register device driver hooks
.SH SYNOPSIS
.B "int" mpt_device_driver_register
.BI "(struct mpt_pci_driver *" dd_cbfunc ","
.BI "int " cb_idx ");"
.SH ARGUMENTS
.IP "dd_cbfunc" 12
-- undescribed --
.IP "cb_idx" 12
-- undescribed --
.TH "mpt_device_driver_deregister" 9 "mpt_device_driver_deregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_device_driver_deregister \-  DeRegister device driver hooks
.SH SYNOPSIS
.B "void" mpt_device_driver_deregister
.BI "(int " cb_idx ");"
.SH ARGUMENTS
.IP "cb_idx" 12
-- undescribed --
.TH "mpt_get_msg_frame" 9 "mpt_get_msg_frame" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_get_msg_frame \-  Obtain a MPT request frame from the pool (of 1024)
.SH SYNOPSIS
.B "MPT_FRAME_HDR*" mpt_get_msg_frame
.BI "(int " handle ","
.BI "MPT_ADAPTER *" ioc ");"
.SH ARGUMENTS
.IP "handle" 12
 Handle of registered MPT protocol driver
.IP "ioc" 12
 Pointer to MPT adapter structure
.SH "DESCRIPTION"
Returns pointer to a MPT request frame or NULL if none are available
or IOC is not active.
.SH "DESCRIPTION"
Returns pointer to a MPT request frame or NULL if none are available
or IOC is not active.
.TH "mpt_put_msg_frame" 9 "mpt_put_msg_frame" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_put_msg_frame \-  Send a protocol specific MPT request frame
.SH SYNOPSIS
.B "void" mpt_put_msg_frame
.BI "(int " handle ","
.BI "MPT_ADAPTER *" ioc ","
.BI "MPT_FRAME_HDR *" mf ");"
.SH ARGUMENTS
.IP "handle" 12
 Handle of registered MPT protocol driver
.IP "ioc" 12
 Pointer to MPT adapter structure
.IP "mf" 12
 Pointer to MPT request frame
.SH "DESCRIPTION"
This routine posts a MPT request frame to the request post FIFO of a
specific MPT adapter.
.SH "DESCRIPTION"
This routine posts a MPT request frame to the request post FIFO of a
specific MPT adapter.
.TH "mpt_free_msg_frame" 9 "mpt_free_msg_frame" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_free_msg_frame \-  Place MPT request frame back on FreeQ.
.SH SYNOPSIS
.B "void" mpt_free_msg_frame
.BI "(MPT_ADAPTER *" ioc ","
.BI "MPT_FRAME_HDR *" mf ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT adapter structure
.IP "mf" 12
 Pointer to MPT request frame
.SH "DESCRIPTION"
This routine places a MPT request frame back on the MPT adapter's
FreeQ.
.TH "mpt_add_sge" 9 "mpt_add_sge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_add_sge \-  Place a simple SGE at address pAddr.
.SH SYNOPSIS
.B "void" mpt_add_sge
.BI "(char *" pAddr ","
.BI "u32 " flagslength ","
.BI "dma_addr_t " dma_addr ");"
.SH ARGUMENTS
.IP "pAddr" 12
 virtual address for SGE
.IP "flagslength" 12
 SGE flags and data transfer length
.IP "dma_addr" 12
 Physical address
.SH "DESCRIPTION"
This routine places a MPT request frame back on the MPT adapter's
FreeQ.
.TH "mpt_send_handshake_request" 9 "mpt_send_handshake_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_send_handshake_request \-  Send MPT request via doorbell
.SH SYNOPSIS
.B "int" mpt_send_handshake_request
.BI "(int " handle ","
.BI "MPT_ADAPTER *" ioc ","
.BI "int " reqBytes ","
.BI "u32 *" req ","
.BI "int " sleepFlag ");"
.SH ARGUMENTS
.IP "handle" 12
 Handle of registered MPT protocol driver
.IP "ioc" 12
 Pointer to MPT adapter structure
.IP "reqBytes" 12
 Size of the request in bytes
.IP "req" 12
 Pointer to MPT request frame
.IP "sleepFlag" 12
 Use schedule if CAN_SLEEP else use udelay.
.SH "DESCRIPTION"
This routine is used exclusively to send MptScsiTaskMgmt
requests since they are required to be sent via doorbell handshake.
.SH "DESCRIPTION"
This routine is used exclusively to send MptScsiTaskMgmt
requests since they are required to be sent via doorbell handshake.
.SH "NOTE"
 It is the callers responsibility to byte-swap fields in the
request which are greater than 1 byte in size.

Returns 0 for success, non-zero for failure.
.TH "mpt_host_page_access_control" 9 "mpt_host_page_access_control" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_host_page_access_control \-  provides mechanism for the host
.SH SYNOPSIS
.B "int" mpt_host_page_access_control
.BI "(MPT_ADAPTER *" ioc ","
.BI "u8 " access_control_value ","
.BI "int " sleepFlag ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT adapter structure
.IP "access_control_value" 12
 define bits below
.IP "sleepFlag" 12
-- undescribed --
.SH "DESCRIPTION"
Access Control Value - bits[15:12]
0h Reserved
1h Enable Access { MPI_DB_HPBAC_ENABLE_ACCESS }
2h Disable Access { MPI_DB_HPBAC_DISABLE_ACCESS }
3h Free Buffer { MPI_DB_HPBAC_FREE_BUFFER }

Returns 0 for success, non-zero for failure.
.SH "DESCRIPTION"
Access Control Value - bits[15:12]
0h Reserved
1h Enable Access { MPI_DB_HPBAC_ENABLE_ACCESS }
2h Disable Access { MPI_DB_HPBAC_DISABLE_ACCESS }
3h Free Buffer { MPI_DB_HPBAC_FREE_BUFFER }

Returns 0 for success, non-zero for failure.
.TH "mpt_host_page_alloc" 9 "mpt_host_page_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_host_page_alloc \-  allocate system memory for the fw
.SH SYNOPSIS
.B "int" mpt_host_page_alloc
.BI "(MPT_ADAPTER *" ioc ","
.BI "pIOCInit_t " ioc_init ");"
.SH ARGUMENTS
.IP "ioc" 12
-- undescribed --
.IP "ioc_init" 12
-- undescribed --
.SH "DESCRIPTION"
If we already allocated memory in past, then resend the same pointer.
ioc@: Pointer to pointer to IOC adapter
ioc_init@: Pointer to ioc init config page

Returns 0 for success, non-zero for failure.
.TH "mpt_verify_adapter" 9 "mpt_verify_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_verify_adapter \-  Given a unique IOC identifier, set pointer to
.SH SYNOPSIS
.B "int" mpt_verify_adapter
.BI "(int " iocid ","
.BI "MPT_ADAPTER **" iocpp ");"
.SH ARGUMENTS
.IP "iocid" 12
 IOC unique identifier (integer)
.IP "iocpp" 12
 Pointer to pointer to IOC adapter
.SH "DESCRIPTION"
Returns iocid and sets iocpp.
.SH "DESCRIPTION"
Returns iocid and sets iocpp.
.TH "mpt_handshake_req_reply_wait" 9 "mpt_handshake_req_reply_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_handshake_req_reply_wait \-  Send MPT request to and receive reply
.SH SYNOPSIS
.B "int" mpt_handshake_req_reply_wait
.BI "(MPT_ADAPTER *" ioc ","
.BI "int " reqBytes ","
.BI "u32 *" req ","
.BI "int " replyBytes ","
.BI "u16 *" u16reply ","
.BI "int " maxwait ","
.BI "int " sleepFlag ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT_ADAPTER structure
.IP "reqBytes" 12
 Size of the request in bytes
.IP "req" 12
 Pointer to MPT request frame
.IP "replyBytes" 12
 Expected size of the reply in bytes
.IP "u16reply" 12
 Pointer to area where reply should be written
.IP "maxwait" 12
 Max wait time for a reply (in seconds)
.IP "sleepFlag" 12
 Specifies whether the process can sleep
.SH "DESCRIPTION"
from IOC via doorbell handshake method.
.SH "NOTES"
 It is the callers responsibility to byte-swap fields in the
request which are greater than 1 byte in size.  It is also the
callers responsibility to byte-swap response fields which are
greater than 1 byte in size.

Returns 0 for success, non-zero for failure.
.TH "mpt_findImVolumes" 9 "mpt_findImVolumes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_findImVolumes \-  Identify IDs of hidden disks and RAID Volumes
.SH SYNOPSIS
.B "int" mpt_findImVolumes
.BI "(MPT_ADAPTER *" ioc ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to a Adapter Strucutre
.SH "RETURN"
0 on success
-EFAULT if read of config page header fails or data pointer not NULL
-ENOMEM if pci_alloc failed
.TH "SendEventAck" 9 "SendEventAck" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
SendEventAck \-  Send EventAck request to MPT adapter.
.SH SYNOPSIS
.B "int" SendEventAck
.BI "(MPT_ADAPTER *" ioc ","
.BI "EventNotificationReply_t *" evnp ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT_ADAPTER structure
.IP "evnp" 12
 Pointer to original EventNotification request
.TH "mpt_config" 9 "mpt_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_config \-  Generic function to issue config message
.SH SYNOPSIS
.B "int" mpt_config
.BI "(MPT_ADAPTER *" ioc ","
.BI "CONFIGPARMS *" pCfg ");"
.SH ARGUMENTS
.IP "ioc" 12
-- undescribed --
.IP "pCfg" 12
-- undescribed --
.SH "DESCRIPTION"
\fIioc\fP - Pointer to an adapter structure
\fIcfg\fP - Pointer to a configuration structure. Struct contains
action, page address, direction, physical address
and pointer to a configuration page header
Page header is updated.

Returns 0 for success
-EPERM if not allowed due to ISR context
-EAGAIN if no msg frames currently available
-EFAULT for non-successful reply or no reply (timeout)
.TH "mpt_toolbox" 9 "mpt_toolbox" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_toolbox \-  Generic function to issue toolbox message
.SH SYNOPSIS
.B "int" mpt_toolbox
.BI "(MPT_ADAPTER *" ioc ","
.BI "CONFIGPARMS *" pCfg ");"
.SH ARGUMENTS
.IP "ioc" 12
-- undescribed --
.IP "pCfg" 12
-- undescribed --
.SH "DESCRIPTION"
\fIioc\fP - Pointer to an adapter structure
\fIcfg\fP - Pointer to a toolbox structure. Struct contains
action, page address, direction, physical address
and pointer to a configuration page header
Page header is updated.

Returns 0 for success
-EPERM if not allowed due to ISR context
-EAGAIN if no msg frames currently available
-EFAULT for non-successful reply or no reply (timeout)
.TH "mpt_print_ioc_summary" 9 "mpt_print_ioc_summary" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_print_ioc_summary \-  Write ASCII summary of IOC to a buffer.
.SH SYNOPSIS
.B "void" mpt_print_ioc_summary
.BI "(MPT_ADAPTER *" ioc ","
.BI "char *" buffer ","
.BI "int *" size ","
.BI "int " len ","
.BI "int " showlan ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT_ADAPTER structure
.IP "buffer" 12
 Pointer to buffer where IOC summary info should be written
.IP "size" 12
 Pointer to number of bytes we wrote (set by this routine)
.IP "len" 12
 Offset at which to start writing in buffer
.IP "showlan" 12
 Display LAN stuff?
.SH "DESCRIPTION"
This routine writes (english readable) ASCII text, which represents
a summary of IOC information, to a buffer.
.TH "mpt_HardResetHandler" 9 "mpt_HardResetHandler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mpt_HardResetHandler \-  Generic reset handler, issue SCSI Task
.SH SYNOPSIS
.B "int" mpt_HardResetHandler
.BI "(MPT_ADAPTER *" ioc ","
.BI "int " sleepFlag ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT_ADAPTER structure
.IP "sleepFlag" 12
 Indicates if sleep or schedule must be called.
.SH "DESCRIPTION"
Management call based on input arg values.  If TaskMgmt fails,
return associated SCSI request.
.SH "REMARK"
 A return of -1 is a FATAL error case, as it means a
FW reload/initialization failed.

Returns 0 for SUCCESS or -1 if FAILED.
.SH "REMARK"
 A return of -1 is a FATAL error case, as it means a
FW reload/initialization failed.

Returns 0 for SUCCESS or -1 if FAILED.
.TH "mptspi_init" 9 "mptspi_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptspi_init \-  Register MPT adapter(s) as SCSI host(s) with
.SH SYNOPSIS
.B "int __init" mptspi_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
linux scsi mid-layer.

Returns 0 for success, non-zero for failure.
.TH "mptspi_exit" 9 "mptspi_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptspi_exit \-  Unregisters MPT adapter(s)
.SH SYNOPSIS
.B "void __exit" mptspi_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "lan_reply" 9 "lan_reply" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lan_reply \-  Handle all data sent from the hardware.
.SH SYNOPSIS
.B "int" lan_reply
.BI "(MPT_ADAPTER *" ioc ","
.BI "MPT_FRAME_HDR *" mf ","
.BI "MPT_FRAME_HDR *" reply ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT_ADAPTER structure
.IP "mf" 12
 Pointer to original MPT request frame (NULL if TurboReply)
.IP "reply" 12
 Pointer to MPT reply frame
.SH "DESCRIPTION"
Returns 1 indicating original alloc'd request frame ptr
should be freed, or 0 if it shouldn't.
.TH "mptctl_syscall_down" 9 "mptctl_syscall_down" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mptctl_syscall_down \-  Down the MPT adapter syscall semaphore.
.SH SYNOPSIS
.B "int" mptctl_syscall_down
.BI "(MPT_ADAPTER *" ioc ","
.BI "int " nonblock ");"
.SH ARGUMENTS
.IP "ioc" 12
 Pointer to MPT adapter
.IP "nonblock" 12
 boolean, non-zero if O_NONBLOCK is set
.SH "DESCRIPTION"
All of the ioctl commands can potentially sleep, which is illegal
with a spinlock held, thus we perform mutual exclusion here.

Returns negative errno on error, or zero for success.
.TH "i2o_block_device_free" 9 "i2o_block_device_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_device_free \-  free the memory of the I2O Block device
.SH SYNOPSIS
.B "void" i2o_block_device_free
.BI "(struct i2o_block_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O Block device, which should be cleaned up
.SH "DESCRIPTION"
Frees the request queue, gendisk and the i2o_block_device structure.
.TH "i2o_block_remove" 9 "i2o_block_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_remove \-  remove the I2O Block device from the system again
.SH SYNOPSIS
.B "int" i2o_block_remove
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O Block device which should be removed
.SH "DESCRIPTION"
Remove gendisk from system and free all allocated memory.

Always returns 0.
.TH "i2o_block_device_flush" 9 "i2o_block_device_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_device_flush \-  Flush all dirty data of I2O device dev
.SH SYNOPSIS
.B "int" i2o_block_device_flush
.BI "(struct i2o_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should be flushed
.SH "DESCRIPTION"
Flushes all dirty data on device dev.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_issue_flush" 9 "i2o_block_issue_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_issue_flush \-  device-flush interface for block-layer
.SH SYNOPSIS
.B "int" i2o_block_issue_flush
.BI "(request_queue_t *" queue ","
.BI "struct gendisk *" disk ","
.BI "sector_t *" error_sector ");"
.SH ARGUMENTS
.IP "queue" 12
 the request queue of the device which should be flushed
.IP "disk" 12
 gendisk
.IP "error_sector" 12
 error offset
.SH "DESCRIPTION"
Helper function to provide flush functionality to block-layer.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_device_mount" 9 "i2o_block_device_mount" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_device_mount \-  Mount (load) the media of device dev
.SH SYNOPSIS
.B "int" i2o_block_device_mount
.BI "(struct i2o_device *" dev ","
.BI "u32 " media_id ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should receive the mount request
.IP "media_id" 12
 Media Identifier
.SH "DESCRIPTION"
Load a media into drive. Identifier should be set to -1, because the
spec does not support any other value.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_device_lock" 9 "i2o_block_device_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_device_lock \-  Locks the media of device dev
.SH SYNOPSIS
.B "int" i2o_block_device_lock
.BI "(struct i2o_device *" dev ","
.BI "u32 " media_id ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should receive the lock request
.IP "media_id" 12
 Media Identifier
.SH "DESCRIPTION"
Lock media of device dev to prevent removal. The media identifier
should be set to -1, because the spec does not support any other value.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_device_unlock" 9 "i2o_block_device_unlock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_device_unlock \-  Unlocks the media of device dev
.SH SYNOPSIS
.B "int" i2o_block_device_unlock
.BI "(struct i2o_device *" dev ","
.BI "u32 " media_id ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should receive the unlocked request
.IP "media_id" 12
 Media Identifier
.SH "DESCRIPTION"
Unlocks the media in device dev. The media identifier should be set to
-1, because the spec does not support any other value.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_device_power" 9 "i2o_block_device_power" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_device_power \-  Power management for device dev
.SH SYNOPSIS
.B "int" i2o_block_device_power
.BI "(struct i2o_block_device *" dev ","
.BI "u8 " op ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should receive the power management request
.IP "op" 12
-- undescribed --
.SH "DESCRIPTION"
Send a power management request to the device dev.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_request_alloc" 9 "i2o_block_request_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_request_alloc \-  Allocate an I2O block request struct
.SH SYNOPSIS
.B "struct i2o_block_request *" i2o_block_request_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocates an I2O block request struct and initialize the list.

Returns a i2o_block_request pointer on success or negative error code
on failure.
.TH "i2o_block_request_free" 9 "i2o_block_request_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_request_free \-  Frees a I2O block request
.SH SYNOPSIS
.B "void" i2o_block_request_free
.BI "(struct i2o_block_request *" ireq ");"
.SH ARGUMENTS
.IP "ireq" 12
 I2O block request which should be freed
.SH "DESCRIPTION"
Fres the allocated memory (give it back to the request mempool).
.TH "i2o_block_sglist_alloc" 9 "i2o_block_sglist_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_sglist_alloc \-  Allocate the SG list and map it
.SH SYNOPSIS
.B "int" i2o_block_sglist_alloc
.BI "(struct i2o_controller *" c ","
.BI "struct i2o_block_request *" ireq ","
.BI "u32 __iomem **" mptr ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller to which the request belongs
.IP "ireq" 12
 I2O block request
.IP "mptr" 12
-- undescribed --
.SH "DESCRIPTION"
Builds the SG list and map it to be accessable by the controller.

Returns 0 on failure or 1 on success.
.TH "i2o_block_sglist_free" 9 "i2o_block_sglist_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_sglist_free \-  Frees the SG list
.SH SYNOPSIS
.B "void" i2o_block_sglist_free
.BI "(struct i2o_block_request *" ireq ");"
.SH ARGUMENTS
.IP "ireq" 12
 I2O block request from which the SG should be freed
.SH "DESCRIPTION"
Frees the SG list from the I2O block request.
.TH "i2o_block_prep_req_fn" 9 "i2o_block_prep_req_fn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_prep_req_fn \-  Allocates I2O block device specific struct
.SH SYNOPSIS
.B "int" i2o_block_prep_req_fn
.BI "(struct request_queue *" q ","
.BI "struct request *" req ");"
.SH ARGUMENTS
.IP "q" 12
 request queue for the request
.IP "req" 12
 the request to prepare
.SH "DESCRIPTION"
Allocate the necessary i2o_block_request struct and connect it to
the request. This is needed that we not loose the SG list later on.

Returns BLKPREP_OK on success or BLKPREP_DEFER on failure.
.TH "i2o_block_delayed_request_fn" 9 "i2o_block_delayed_request_fn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_delayed_request_fn \-  delayed request queue function
.SH SYNOPSIS
.B "void" i2o_block_delayed_request_fn
.BI "(void *" delayed_request ");"
.SH ARGUMENTS
.IP "delayed_request" 12
-- undescribed --
.SH "DELAYED_REQUEST"
 the delayed request with the queue to start

If the request queue is stopped for a disk, and there is no open
request, a new event is created, which calls this function to start
the queue after I2O_BLOCK_REQUEST_TIME. Otherwise the queue will never
be started again.
.TH "i2o_block_end_request" 9 "i2o_block_end_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_end_request \-  Post-processing of completed commands
.SH SYNOPSIS
.B "void" i2o_block_end_request
.BI "(struct request *" req ","
.BI "int " uptodate ","
.BI "int " nr_bytes ");"
.SH ARGUMENTS
.IP "req" 12
 request which should be completed
.IP "uptodate" 12
 1 for success, 0 for I/O error, &lt; 0 for specific error
.IP "nr_bytes" 12
 number of bytes to complete
.SH "DESCRIPTION"
Mark the request as complete. The lock must not be held when entering.
.TH "i2o_block_reply" 9 "i2o_block_reply" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_reply \-  Block OSM reply handler.
.SH SYNOPSIS
.B "int" i2o_block_reply
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ","
.BI "struct i2o_message *" msg ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller from which the message arrives
.IP "m" 12
 message id of reply
.IP "msg" 12
-- undescribed --
.SH "QMSG"
 the actuall I2O message reply

This function gets all the message replies.
.TH "i2o_block_open" 9 "i2o_block_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_open \-  Open the block device
.SH SYNOPSIS
.B "int" i2o_block_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.SH "DESCRIPTION"

Power up the device, mount and lock the media. This function is called,
if the block device is opened for access.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_release" 9 "i2o_block_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_release \-  Release the I2O block device
.SH SYNOPSIS
.B "int" i2o_block_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.SH "DESCRIPTION"

Unlock and unmount the media, and power down the device. Gets called if
the block device is closed.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_ioctl" 9 "i2o_block_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_ioctl \-  Issue device specific ioctl calls.
.SH SYNOPSIS
.B "int" i2o_block_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.IP "cmd" 12
 ioctl command
.IP "arg" 12
 arg
.SH "DESCRIPTION"
Handles ioctl request for the block device.

Return 0 on success or negative error on failure.
.TH "i2o_block_media_changed" 9 "i2o_block_media_changed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_media_changed \-  Have we seen a media change?
.SH SYNOPSIS
.B "int" i2o_block_media_changed
.BI "(struct gendisk *" disk ");"
.SH ARGUMENTS
.IP "disk" 12
 gendisk which should be verified
.SH "DESCRIPTION"
Verifies if the media has changed.

Returns 1 if the media was changed or 0 otherwise.
.TH "i2o_block_transfer" 9 "i2o_block_transfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_transfer \-  Transfer a request to/from the I2O controller
.SH SYNOPSIS
.B "int" i2o_block_transfer
.BI "(struct request *" req ");"
.SH ARGUMENTS
.IP "req" 12
 the request which should be transfered
.SH "DESCRIPTION"
This function converts the request into a I2O message. The necessary
DMA buffers are allocated and after everything is setup post the message
to the I2O controller. No cleanup is done by this function. It is done
on the interrupt side when the reply arrives.

Return 0 on success or negative error code on failure.
.TH "i2o_block_request_fn" 9 "i2o_block_request_fn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_request_fn \-  request queue handling function
.SH SYNOPSIS
.B "void" i2o_block_request_fn
.BI "(struct request_queue *" q ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.SH "Q"
 request queue from which the request could be fetched

Takes the next request from the queue, transfers it and if no error
occurs dequeue it from the queue. On arrival of the reply the message
will be processed further. If an error occurs requeue the request.
.TH "i2o_block_device_alloc" 9 "i2o_block_device_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_device_alloc \-  Allocate memory for a I2O Block device
.SH SYNOPSIS
.B "struct i2o_block_device *" i2o_block_device_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate memory for the i2o_block_device struct, gendisk and request
queue and initialize them as far as no additional information is needed.

Returns a pointer to the allocated I2O Block device on succes or a
negative error code on failure.
.TH "i2o_block_probe" 9 "i2o_block_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_probe \-  verify if dev is a I2O Block device and install it
.SH SYNOPSIS
.B "int" i2o_block_probe
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to verify if it is a I2O Block device
.SH "DESCRIPTION"
We only verify if the user_tid of the device is 0xfff and then install
the device. Otherwise it is used by some other device (e. g. RAID).

Returns 0 on success or negative error code on failure.
.TH "i2o_block_init" 9 "i2o_block_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_init \-  Block OSM initialization function
.SH SYNOPSIS
.B "int __init" i2o_block_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate the slab and mempool for request structs, registers i2o_block
block device and finally register the Block OSM in the I2O core.

Returns 0 on success or negative error code on failure.
.TH "i2o_block_exit" 9 "i2o_block_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_block_exit \-  Block OSM exit function
.SH SYNOPSIS
.B "void __exit" i2o_block_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters Block OSM from I2O core, unregisters i2o_block block device
and frees the mempool and slab.
.TH "i2o_get_class_name" 9 "i2o_get_class_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_get_class_name \-  	do i2o class name lookup
.SH SYNOPSIS
.B "const char *" i2o_get_class_name
.BI "(int " class ");"
.SH ARGUMENTS
.IP "class" 12
 class number
.SH "DESCRIPTION"
Return a descriptive string for an i2o class
.TH "i2o_proc_create_entries" 9 "i2o_proc_create_entries" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_create_entries \-  Creates proc dir entries
.SH SYNOPSIS
.B "int" i2o_proc_create_entries
.BI "(struct proc_dir_entry *" dir ","
.BI "i2o_proc_entry *" i2o_pe ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "dir" 12
 proc dir entry under which the entries should be placed
.IP "i2o_pe" 12
 pointer to the entries which should be added
.IP "data" 12
 pointer to I2O controller or device
.SH "DESCRIPTION"
Create proc dir entries for a I2O controller or I2O device.

Returns 0 on success or negative error code on failure.
.TH "i2o_proc_subdir_remove" 9 "i2o_proc_subdir_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_subdir_remove \-  Remove child entries from a proc entry
.SH SYNOPSIS
.B "void" i2o_proc_subdir_remove
.BI "(struct proc_dir_entry *" dir ");"
.SH ARGUMENTS
.IP "dir" 12
 proc dir entry from which the childs should be removed
.SH "DESCRIPTION"
Iterate over each i2o proc entry under dir and remove it. If the child
also has entries, remove them too.
.TH "i2o_proc_device_add" 9 "i2o_proc_device_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_device_add \-  Add an I2O device to the proc dir
.SH SYNOPSIS
.B "void" i2o_proc_device_add
.BI "(struct proc_dir_entry *" dir ","
.BI "struct i2o_device *" dev ");"
.SH ARGUMENTS
.IP "dir" 12
 proc dir entry to which the device should be added
.IP "dev" 12
 I2O device which should be added
.SH "DESCRIPTION"
Add an I2O device to the proc dir entry dir and create the entries for
the device depending on the class of the I2O device.
.TH "i2o_proc_iop_add" 9 "i2o_proc_iop_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_iop_add \-  Add an I2O controller to the i2o proc tree
.SH SYNOPSIS
.B "int" i2o_proc_iop_add
.BI "(struct proc_dir_entry *" dir ","
.BI "struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "dir" 12
 parent proc dir entry
.IP "c" 12
 I2O controller which should be added
.SH "DESCRIPTION"
Add the entries to the parent proc dir entry. Also each device is added
to the controllers proc dir entry.

Returns 0 on success or negative error code on failure.
.TH "i2o_proc_iop_remove" 9 "i2o_proc_iop_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_iop_remove \-  Removes an I2O controller from the i2o proc tree
.SH SYNOPSIS
.B "void" i2o_proc_iop_remove
.BI "(struct proc_dir_entry *" dir ","
.BI "struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "dir" 12
 parent proc dir entry
.IP "c" 12
 I2O controller which should be removed
.SH "DESCRIPTION"
Iterate over each i2o proc entry and search controller c. If it is found
remove it from the tree.
.TH "i2o_proc_fs_create" 9 "i2o_proc_fs_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_fs_create \-  Create the i2o proc fs.
.SH SYNOPSIS
.B "int __init" i2o_proc_fs_create
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Iterate over each I2O controller and create the entries for it.

Returns 0 on success or negative error code on failure.
.TH "i2o_proc_fs_destroy" 9 "i2o_proc_fs_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_fs_destroy \-  Cleanup the all i2o proc entries
.SH SYNOPSIS
.B "int __exit" i2o_proc_fs_destroy
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Iterate over each I2O controller and remove the entries for it.

Returns 0 on success or negative error code on failure.
.TH "i2o_proc_init" 9 "i2o_proc_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_init \-  Init function for procfs
.SH SYNOPSIS
.B "int __init" i2o_proc_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Registers Proc OSM and creates procfs entries.

Returns 0 on success or negative error code on failure.
.TH "i2o_proc_exit" 9 "i2o_proc_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_proc_exit \-  Exit function for procfs
.SH SYNOPSIS
.B "void __exit" i2o_proc_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters Proc OSM and removes procfs entries.
.TH "i2o_msg_nop" 9 "i2o_msg_nop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_nop \-  Returns a message which is not used
.SH SYNOPSIS
.B "void" i2o_msg_nop
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller from which the message was created
.IP "m" 12
 message which should be returned
.SH "DESCRIPTION"
If you fetch a message via i2o_msg_get, and can't use it, you must
return the message with this function. Otherwise the message frame
is lost.
.TH "i2o_msg_get_wait" 9 "i2o_msg_get_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_get_wait \-  obtain an I2O message from the IOP
.SH SYNOPSIS
.B "u32" i2o_msg_get_wait
.BI "(struct i2o_controller *" c ","
.BI "struct i2o_message __iomem **" msg ","
.BI "int " wait ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.IP "msg" 12
 pointer to a I2O message pointer
.IP "wait" 12
 how long to wait until timeout
.SH "DESCRIPTION"
This function waits up to wait seconds for a message slot to be
available.

On a success the message is returned and the pointer to the message is
set in msg. The returned message is the physical page frame offset
address from the read port (see the i2o spec). If no message is
available returns I2O_QUEUE_EMPTY and msg is leaved untouched.
.TH "i2o_cntxt_list_add" 9 "i2o_cntxt_list_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_cntxt_list_add \-  Append a pointer to context list and return a id
.SH SYNOPSIS
.B "u32" i2o_cntxt_list_add
.BI "(struct i2o_controller *" c ","
.BI "void *" ptr ");"
.SH ARGUMENTS
.IP "c" 12
 controller to which the context list belong
.IP "ptr" 12
 pointer to add to the context list
.SH "DESCRIPTION"
Because the context field in I2O is only 32-bit large, on 64-bit the
pointer is to large to fit in the context field. The i2o_cntxt_list
functions therefore map pointers to context fields.

Returns context id &gt; 0 on success or 0 on failure.
.TH "i2o_cntxt_list_remove" 9 "i2o_cntxt_list_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_cntxt_list_remove \-  Remove a pointer from the context list
.SH SYNOPSIS
.B "u32" i2o_cntxt_list_remove
.BI "(struct i2o_controller *" c ","
.BI "void *" ptr ");"
.SH ARGUMENTS
.IP "c" 12
 controller to which the context list belong
.IP "ptr" 12
 pointer which should be removed from the context list
.SH "DESCRIPTION"
Removes a previously added pointer from the context list and returns
the matching context id.

Returns context id on succes or 0 on failure.
.TH "i2o_cntxt_list_get" 9 "i2o_cntxt_list_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_cntxt_list_get \-  Get a pointer from the context list and remove it
.SH SYNOPSIS
.B "void *" i2o_cntxt_list_get
.BI "(struct i2o_controller *" c ","
.BI "u32 " context ");"
.SH ARGUMENTS
.IP "c" 12
 controller to which the context list belong
.IP "context" 12
 context id to which the pointer belong
.SH "DESCRIPTION"
Returns pointer to the matching context id on success or NULL on
failure.
.TH "i2o_cntxt_list_get_ptr" 9 "i2o_cntxt_list_get_ptr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_cntxt_list_get_ptr \-  Get a context id from the context list
.SH SYNOPSIS
.B "u32" i2o_cntxt_list_get_ptr
.BI "(struct i2o_controller *" c ","
.BI "void *" ptr ");"
.SH ARGUMENTS
.IP "c" 12
 controller to which the context list belong
.IP "ptr" 12
 pointer to which the context id should be fetched
.SH "DESCRIPTION"
Returns context id which matches to the pointer on succes or 0 on
failure.
.TH "i2o_find_iop" 9 "i2o_find_iop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_find_iop \-  Find an I2O controller by id
.SH SYNOPSIS
.B "struct i2o_controller *" i2o_find_iop
.BI "(int " unit ");"
.SH ARGUMENTS
.IP "unit" 12
 unit number of the I2O controller to search for
.SH "DESCRIPTION"
Lookup the I2O controller on the controller list.

Returns pointer to the I2O controller on success or NULL if not found.
.TH "i2o_iop_find_device" 9 "i2o_iop_find_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_find_device \-  Find a I2O device on an I2O controller
.SH SYNOPSIS
.B "struct i2o_device *" i2o_iop_find_device
.BI "(struct i2o_controller *" c ","
.BI "u16 " tid ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller where the I2O device hangs on
.IP "tid" 12
 TID of the I2O device to search for
.SH "DESCRIPTION"
Searches the devices of the I2O controller for a device with TID tid and
returns it.

Returns a pointer to the I2O device if found, otherwise NULL.
.TH "i2o_iop_quiesce" 9 "i2o_iop_quiesce" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_quiesce \-  quiesce controller
.SH SYNOPSIS
.B "int" i2o_iop_quiesce
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.SH "DESCRIPTION"
Quiesce an IOP. Causes IOP to make external operation quiescent
(i2o 'READY' state). Internal operation of the IOP continues normally.

Returns 0 on success or negative error code on failure.
.TH "i2o_iop_enable" 9 "i2o_iop_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_enable \-  move controller from ready to OPERATIONAL
.SH SYNOPSIS
.B "int" i2o_iop_enable
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
Enable IOP. This allows the IOP to resume external operations and
reverses the effect of a quiesce. Returns zero or an error code if
an error occurs.
.TH "i2o_iop_quiesce_all" 9 "i2o_iop_quiesce_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_quiesce_all \-  Quiesce all I2O controllers on the system
.SH SYNOPSIS
.B "void" i2o_iop_quiesce_all
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Quiesce all I2O controllers which are connected to the system.
.TH "i2o_iop_enable_all" 9 "i2o_iop_enable_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_enable_all \-  Enables all controllers on the system
.SH SYNOPSIS
.B "void" i2o_iop_enable_all
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Enables all I2O controllers which are connected to the system.
.TH "i2o_iop_clear" 9 "i2o_iop_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_clear \-  Bring I2O controller into HOLD state
.SH SYNOPSIS
.B "int" i2o_iop_clear
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.SH "DESCRIPTION"
Clear an IOP to HOLD state, ie. terminate external operations, clear all
input queues and prepare for a system restart. IOP's internal operation
continues normally and the outbound queue is alive. The IOP is not
expected to rebuild its LCT.

Returns 0 on success or negative error code on failure.
.TH "i2o_iop_init_outbound_queue" 9 "i2o_iop_init_outbound_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_init_outbound_queue \-  setup the outbound message queue
.SH SYNOPSIS
.B "int" i2o_iop_init_outbound_queue
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
Clear and (re)initialize IOP's outbound queue and post the message
frames to the IOP.

Returns 0 on success or a negative errno code on failure.
.TH "i2o_iop_reset" 9 "i2o_iop_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_reset \-  reset an I2O controller
.SH SYNOPSIS
.B "int" i2o_iop_reset
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 controller to reset
.SH "DESCRIPTION"
Reset the IOP into INIT state and wait until IOP gets into RESET state.
Terminate all external operations, clear IOP's inbound and outbound
queues, terminate all DDMs, and reload the IOP's operating environment
and all local DDMs. The IOP rebuilds its LCT.
.TH "i2o_iop_activate" 9 "i2o_iop_activate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_activate \-  Bring controller up to HOLD
.SH SYNOPSIS
.B "int" i2o_iop_activate
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.SH "DESCRIPTION"
This function brings an I2O controller into HOLD state. The adapter
is reset if necessary and then the queues and resource table are read.

Returns 0 on success or negative error code on failure.
.TH "i2o_iop_systab_set" 9 "i2o_iop_systab_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_systab_set \-  Set the I2O System Table of the specified IOP
.SH SYNOPSIS
.B "int" i2o_iop_systab_set
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller to which the system table should be send
.SH "DESCRIPTION"
Before the systab could be set \fBi2o_systab_build\fP must be called.

Returns 0 on success or negative error code on failure.
.TH "i2o_iop_online" 9 "i2o_iop_online" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_online \-  Bring a controller online into OPERATIONAL state.
.SH SYNOPSIS
.B "int" i2o_iop_online
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
Send the system table and enable the I2O controller.

Returns 0 on success or negativer error code on failure.
.TH "i2o_iop_remove" 9 "i2o_iop_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_remove \-  Remove the I2O controller from the I2O core
.SH SYNOPSIS
.B "void" i2o_iop_remove
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
Remove the I2O controller from the I2O core. If devices are attached to
the controller remove these also and finally reset the controller.
.TH "i2o_systab_build" 9 "i2o_systab_build" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_systab_build \-  Build system table
.SH SYNOPSIS
.B "int" i2o_systab_build
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

The system table contains information about all the IOPs in the system
(duh) and is used by the Executives on the IOPs to establish peer2peer
connections. We're not supporting peer2peer at the moment, but this
will be needed down the road for things like lan2lan forwarding.

Returns 0 on success or negative error code on failure.
.TH "i2o_parse_hrt" 9 "i2o_parse_hrt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_parse_hrt \-  Parse the hardware resource table.
.SH SYNOPSIS
.B "int" i2o_parse_hrt
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
We don't do anything with it except dumping it (in debug mode).

Returns 0.
.TH "i2o_status_get" 9 "i2o_status_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_status_get \-  Get the status block from the I2O controller
.SH SYNOPSIS
.B "int" i2o_status_get
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
Issue a status query on the controller. This updates the attached
status block. The status block could then be accessed through
c-&gt;status_block.

Returns 0 on sucess or negative error code on failure.
.TH "i2o_iop_free" 9 "i2o_iop_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_free \-  Free the i2o_controller struct
.SH SYNOPSIS
.B "void" i2o_iop_free
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller to free
.TH "i2o_iop_release" 9 "i2o_iop_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_release \-  release the memory for a I2O controller
.SH SYNOPSIS
.B "void" i2o_iop_release
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O controller which should be released
.SH "DESCRIPTION"
Release the allocated memory. This function is called if refcount of
device reaches 0 automatically.
.TH "i2o_iop_alloc" 9 "i2o_iop_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_alloc \-  Allocate and initialize a i2o_controller struct
.SH SYNOPSIS
.B "struct i2o_controller *" i2o_iop_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate the necessary memory for a i2o_controller struct and
initialize the lists.

Returns a pointer to the I2O controller or a negative error code on
failure.
.TH "i2o_iop_add" 9 "i2o_iop_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_add \-  Initialize the I2O controller and add him to the I2O core
.SH SYNOPSIS
.B "int" i2o_iop_add
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.SH "DESCRIPTION"
Initialize the I2O controller and if no error occurs add him to the I2O
core.

Returns 0 on success or negative error code on failure.
.TH "i2o_event_register" 9 "i2o_event_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_event_register \-  Turn on/off event notification for a I2O device
.SH SYNOPSIS
.B "int" i2o_event_register
.BI "(struct i2o_device *" dev ","
.BI "struct i2o_driver *" drv ","
.BI "int " tcntxt ","
.BI "u32 " evt_mask ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should receive the event registration request
.IP "drv" 12
 driver which want to get notified
.IP "tcntxt" 12
 transaction context to use with this notifier
.IP "evt_mask" 12
 mask of events
.SH "DESCRIPTION"
Create and posts an event registration message to the task. No reply
is waited for, or expected. If you do not want further notifications,
call the i2o_event_register again with a evt_mask of 0.

Returns 0 on success or -ETIMEDOUT if no message could be fetched for
sending the request.
.TH "i2o_iop_init" 9 "i2o_iop_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_init \-  I2O main initialization function
.SH SYNOPSIS
.B "int __init" i2o_iop_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initialize the I2O drivers (OSM) functions, register the Executive OSM,
initialize the I2O PCI part and finally initialize I2O device stuff.

Returns 0 on success or negative error code on failure.
.TH "i2o_iop_exit" 9 "i2o_iop_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_iop_exit \-  I2O main exit function
.SH SYNOPSIS
.B "void __exit" i2o_iop_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Removes I2O controllers from PCI subsystem and shut down OSMs.
.TH "i2o_exec_wait_alloc" 9 "i2o_exec_wait_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_wait_alloc \-  Allocate a i2o_exec_wait struct an initialize it
.SH SYNOPSIS
.B "struct i2o_exec_wait *" i2o_exec_wait_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate the i2o_exec_wait struct and initialize the wait.

Returns i2o_exec_wait pointer on success or negative error code on
failure.
.TH "i2o_exec_wait_free" 9 "i2o_exec_wait_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_wait_free \-  Free a i2o_exec_wait struct
.SH SYNOPSIS
.B "void" i2o_exec_wait_free
.BI "(struct i2o_exec_wait *" wait ");"
.SH ARGUMENTS
.IP "wait" 12
-- undescribed --
.TH "i2o_msg_post_wait_mem" 9 "i2o_msg_post_wait_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_post_wait_mem \-  Post and wait a message with DMA buffers
.SH SYNOPSIS
.B "int" i2o_msg_post_wait_mem
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ","
.BI "unsigned long " timeout ","
.BI "struct i2o_dma *" dma ");"
.SH ARGUMENTS
.IP "c" 12
 controller
.IP "m" 12
 message to post
.IP "timeout" 12
 time in seconds to wait
.IP "dma" 12
 i2o_dma struct of the DMA buffer to free on failure
.SH "DESCRIPTION"
This API allows an OSM to post a message and then be told whether or
not the system received a successful reply. If the message times out
then the value '-ETIMEDOUT' is returned. This is a special case. In
this situation the message may (should) complete at an indefinite time
in the future. When it completes it will use the memory buffer
attached to the request. If -ETIMEDOUT is returned then the memory
buffer must not be freed. Instead the event completion will free them
for you. In all other cases the buffer are your problem.

Returns 0 on success, negative error code on timeout or positive error
code from reply.
.TH "i2o_msg_post_wait_complete" 9 "i2o_msg_post_wait_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_msg_post_wait_complete \-  Reply to a i2o_msg_post request from IOP
.SH SYNOPSIS
.B "int" i2o_msg_post_wait_complete
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ","
.BI "struct i2o_message *" msg ","
.BI "u32 " context ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller which answers
.IP "m" 12
 message id
.IP "msg" 12
 pointer to the I2O reply message
.IP "context" 12
 transaction context of request
.SH "DESCRIPTION"
This function is called in interrupt context only. If the reply reached
before the timeout, the i2o_exec_wait struct is filled with the message
and the task will be waked up. The task is now responsible for returning
the message m back to the controller! If the message reaches us after
the timeout clean up the i2o_exec_wait struct (including allocated
DMA buffer).

Return 0 on success and if the message m should not be given back to the
I2O controller, or &gt;0 on success and if the message should be given back
afterwords. Returns negative error code on failure. In this case the
message must also be given back to the controller.
.TH "i2o_exec_show_vendor_id" 9 "i2o_exec_show_vendor_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_show_vendor_id \-  Displays Vendor ID of controller
.SH SYNOPSIS
.B "ssize_t" i2o_exec_show_vendor_id
.BI "(struct device *" d ","
.BI "struct device_attribute *" attr ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "d" 12
 device of which the Vendor ID should be displayed
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 buffer into which the Vendor ID should be printed
.SH "DESCRIPTION"
Returns number of bytes printed into buffer.
.TH "i2o_exec_show_product_id" 9 "i2o_exec_show_product_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_show_product_id \-  Displays Product ID of controller
.SH SYNOPSIS
.B "ssize_t" i2o_exec_show_product_id
.BI "(struct device *" d ","
.BI "struct device_attribute *" attr ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "d" 12
 device of which the Product ID should be displayed
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 buffer into which the Product ID should be printed
.SH "DESCRIPTION"
Returns number of bytes printed into buffer.
.TH "i2o_exec_probe" 9 "i2o_exec_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_probe \-  Called if a new I2O device (executive class) appears
.SH SYNOPSIS
.B "int" i2o_exec_probe
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should be probed
.SH "DESCRIPTION"
Registers event notification for every event from Executive device. The
return is always 0, because we want all devices of class Executive.

Returns 0 on success.
.TH "i2o_exec_remove" 9 "i2o_exec_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_remove \-  Called on I2O device removal
.SH SYNOPSIS
.B "int" i2o_exec_remove
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which was removed
.SH "DESCRIPTION"
Unregisters event notification from Executive I2O device.

Returns 0 on success.
.TH "i2o_exec_lct_modified" 9 "i2o_exec_lct_modified" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_lct_modified \-  Called on LCT NOTIFY reply
.SH SYNOPSIS
.B "void" i2o_exec_lct_modified
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller on which the LCT has modified
.SH "DESCRIPTION"
This function handles asynchronus LCT NOTIFY replies. It parses the
new LCT and if the buffer for the LCT was to small sends a LCT NOTIFY
again, otherwise send LCT NOTIFY to get informed on next LCT change.
.TH "i2o_exec_reply" 9 "i2o_exec_reply" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_reply \-   I2O Executive reply handler
.SH SYNOPSIS
.B "int" i2o_exec_reply
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ","
.BI "struct i2o_message *" msg ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller from which the reply comes
.IP "m" 12
 message id
.IP "msg" 12
 pointer to the I2O reply message
.SH "DESCRIPTION"
This function is always called from interrupt context. If a POST WAIT
reply was received, pass it to the complete function. If a LCT NOTIFY
reply was received, a new event is created to handle the update.

Returns 0 on success and if the reply should not be flushed or &gt; 0
on success and if the reply should be flushed. Returns negative error
code on failure and if the reply should be flushed.
.TH "i2o_exec_event" 9 "i2o_exec_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_event \-  Event handling function
.SH SYNOPSIS
.B "void" i2o_exec_event
.BI "(struct i2o_event *" evt ");"
.SH ARGUMENTS
.IP "evt" 12
 Event which occurs
.SH "DESCRIPTION"
Handles events send by the Executive device. At the moment does not do
anything useful.
.TH "i2o_exec_lct_get" 9 "i2o_exec_lct_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_lct_get \-  Get the IOP's Logical Configuration Table
.SH SYNOPSIS
.B "int" i2o_exec_lct_get
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller from which the LCT should be fetched
.SH "DESCRIPTION"
Send a LCT NOTIFY request to the controller, and wait
I2O_TIMEOUT_LCT_GET seconds until arrival of response. If the LCT is
to large, retry it.

Returns 0 on success or negative error code on failure.
.TH "i2o_exec_lct_notify" 9 "i2o_exec_lct_notify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_lct_notify \-  Send a asynchronus LCT NOTIFY request
.SH SYNOPSIS
.B "int" i2o_exec_lct_notify
.BI "(struct i2o_controller *" c ","
.BI "u32 " change_ind ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller to which the request should be send
.IP "change_ind" 12
 change indicator
.SH "DESCRIPTION"
This function sends a LCT NOTIFY request to the I2O controller with
the change indicator change_ind. If the change_ind == 0 the controller
replies immediately after the request. If change_ind &gt; 0 the reply is
send after change indicator of the LCT is &gt; change_ind.
.TH "i2o_exec_init" 9 "i2o_exec_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_init \-  Registers the Exec OSM
.SH SYNOPSIS
.B "int __init" i2o_exec_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Registers the Exec OSM in the I2O core.

Returns 0 on success or negative error code on failure.
.TH "i2o_exec_exit" 9 "i2o_exec_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_exec_exit \-  Removes the Exec OSM
.SH SYNOPSIS
.B "void __exit" i2o_exec_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters the Exec OSM from the I2O core.
.TH "i2o_bus_match" 9 "i2o_bus_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_bus_match \-  Tell if a I2O device class id match the class ids of
.SH SYNOPSIS
.B "int" i2o_bus_match
.BI "(struct device *" dev ","
.BI "struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "dev" 12
 device which should be verified
.IP "drv" 12
 the driver to match against
.SH "DESCRIPTION"
Used by the bus to check if the driver wants to handle the device.

Returns 1 if the class ids of the driver match the class id of the
device, otherwise 0.
.SH "DESCRIPTION"
Used by the bus to check if the driver wants to handle the device.

Returns 1 if the class ids of the driver match the class id of the
device, otherwise 0.
.TH "i2o_driver_register" 9 "i2o_driver_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_register \-  Register a I2O driver (OSM) in the I2O core
.SH SYNOPSIS
.B "int" i2o_driver_register
.BI "(struct i2o_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 I2O driver which should be registered
.SH "DESCRIPTION"
Registers the OSM drv in the I2O core and creates an event queues if
necessary.

Returns 0 on success or negative error code on failure.
.TH "i2o_driver_unregister" 9 "i2o_driver_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_unregister \-  Unregister a I2O driver (OSM) from the I2O core
.SH SYNOPSIS
.B "void" i2o_driver_unregister
.BI "(struct i2o_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 I2O driver which should be unregistered
.SH "DESCRIPTION"
Unregisters the OSM drv from the I2O core and cleanup event queues if
necessary.
.TH "i2o_driver_dispatch" 9 "i2o_driver_dispatch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_dispatch \-  dispatch an I2O reply message
.SH SYNOPSIS
.B "int" i2o_driver_dispatch
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller of the message
.IP "m" 12
 I2O message number
.SH "DESCRIPTION"
The reply is delivered to the driver from which the original message
was. This function is only called from interrupt context.

Returns 0 on success and the message should not be flushed. Returns &gt; 0
on success and if the message should be flushed afterwords. Returns
negative error code on failure (the message will be flushed too).
.TH "i2o_driver_notify_controller_add_all" 9 "i2o_driver_notify_controller_add_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_controller_add_all \-  Send notify of added controller
.SH SYNOPSIS
.B "void" i2o_driver_notify_controller_add_all
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
-- undescribed --
.SH "DESCRIPTION"
to all I2O drivers

Send notifications to all registered drivers that a new controller was
added.
.TH "i2o_driver_notify_controller_remove_all" 9 "i2o_driver_notify_controller_remove_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_controller_remove_all \-  Send notify of removed
.SH SYNOPSIS
.B "void" i2o_driver_notify_controller_remove_all
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
-- undescribed --
.SH "DESCRIPTION"
controller to all I2O drivers

Send notifications to all registered drivers that a controller was
removed.
.TH "i2o_driver_notify_device_add_all" 9 "i2o_driver_notify_device_add_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_device_add_all \-  Send notify of added device to all
.SH SYNOPSIS
.B "void" i2o_driver_notify_device_add_all
.BI "(struct i2o_device *" i2o_dev ");"
.SH ARGUMENTS
.IP "i2o_dev" 12
-- undescribed --
.SH "DESCRIPTION"
I2O drivers

Send notifications to all registered drivers that a device was added.
.TH "i2o_driver_notify_device_remove_all" 9 "i2o_driver_notify_device_remove_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_notify_device_remove_all \-  Send notify of removed device to
.SH SYNOPSIS
.B "void" i2o_driver_notify_device_remove_all
.BI "(struct i2o_device *" i2o_dev ");"
.SH ARGUMENTS
.IP "i2o_dev" 12
-- undescribed --
.SH "DESCRIPTION"
all I2O drivers

Send notifications to all registered drivers that a device was removed.
.TH "i2o_driver_init" 9 "i2o_driver_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_init \-  initialize I2O drivers (OSMs)
.SH SYNOPSIS
.B "int __init" i2o_driver_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Registers the I2O bus and allocate memory for the array of OSMs.

Returns 0 on success or negative error code on failure.
.TH "i2o_driver_exit" 9 "i2o_driver_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_driver_exit \-  clean up I2O drivers (OSMs)
.SH SYNOPSIS
.B "void __exit" i2o_driver_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters the I2O bus and free driver array.
.TH "i2o_bus_scan" 9 "i2o_bus_scan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_bus_scan \-  Scan the bus for new devices
.SH SYNOPSIS
.B "int" i2o_bus_scan
.BI "(struct i2o_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device of the bus, which should be scanned
.SH "DESCRIPTION"
Scans the bus dev for new / removed devices. After the scan a new LCT
will be fetched automatically.

Returns 0 on success or negative error code on failure.
.TH "i2o_bus_store_scan" 9 "i2o_bus_store_scan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_bus_store_scan \-  Scan the I2O Bus Adapter
.SH SYNOPSIS
.B "ssize_t" i2o_bus_store_scan
.BI "(struct device *" d ","
.BI "struct device_attribute *" attr ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "d" 12
 device which should be scanned
.IP "attr" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
Returns count.
.TH "i2o_bus_probe" 9 "i2o_bus_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_bus_probe \-  verify if dev is a I2O Bus Adapter device and install it
.SH SYNOPSIS
.B "int" i2o_bus_probe
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to verify if it is a I2O Bus Adapter device
.SH "DESCRIPTION"
Because we want all Bus Adapters always return 0.

Returns 0.
.TH "i2o_bus_remove" 9 "i2o_bus_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_bus_remove \-  remove the I2O Bus Adapter device from the system again
.SH SYNOPSIS
.B "int" i2o_bus_remove
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O Bus Adapter device which should be removed
.SH "DESCRIPTION"
Always returns 0.
.TH "i2o_bus_init" 9 "i2o_bus_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_bus_init \-  Bus Adapter OSM initialization function
.SH SYNOPSIS
.B "int __init" i2o_bus_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Only register the Bus Adapter OSM in the I2O core.

Returns 0 on success or negative error code on failure.
.TH "i2o_bus_exit" 9 "i2o_bus_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_bus_exit \-  Bus Adapter OSM exit function
.SH SYNOPSIS
.B "void __exit" i2o_bus_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters Bus Adapter OSM from I2O core.
.TH "i2o_scsi_get_host" 9 "i2o_scsi_get_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_get_host \-  Get an I2O SCSI host
.SH SYNOPSIS
.B "struct i2o_scsi_host *" i2o_scsi_get_host
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller to for which to get the SCSI host
.SH "DESCRIPTION"
If the I2O controller already exists as SCSI host, the SCSI host
is returned, otherwise the I2O controller is added to the SCSI
core.

Returns pointer to the I2O SCSI host on success or NULL on failure.
.TH "i2o_scsi_remove" 9 "i2o_scsi_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_remove \-  Remove I2O device from SCSI core
.SH SYNOPSIS
.B "int" i2o_scsi_remove
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device which should be removed
.SH "DESCRIPTION"
Removes the I2O device from the SCSI core again.

Returns 0 on success.
.TH "i2o_scsi_probe" 9 "i2o_scsi_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_probe \-  verify if dev is a I2O SCSI device and install it
.SH SYNOPSIS
.B "int" i2o_scsi_probe
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to verify if it is a I2O SCSI device
.SH "DESCRIPTION"
Retrieve channel, id and lun for I2O device. If everthing goes well
register the I2O device as SCSI device on the I2O SCSI controller.

Returns 0 on success or negative error code on failure.
.TH "i2o_scsi_reply" 9 "i2o_scsi_reply" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_reply \-  SCSI OSM message reply handler
.SH SYNOPSIS
.B "int" i2o_scsi_reply
.BI "(struct i2o_controller *" c ","
.BI "u32 " m ","
.BI "struct i2o_message *" msg ");"
.SH ARGUMENTS
.IP "c" 12
 controller issuing the reply
.IP "m" 12
 message id for flushing
.IP "msg" 12
 the message from the controller
.SH "DESCRIPTION"
Process reply messages (interrupts in normal scsi controller think).
We can get a variety of messages to process. The normal path is
scsi command completions. We must also deal with IOP failures,
the reply to a bus reset and the reply to a LUN query.

Returns 0 on success and if the reply should not be flushed or &gt; 0
on success and if the reply should be flushed. Returns negative error
code on failure and if the reply should be flushed.
.TH "i2o_scsi_notify_device_add" 9 "i2o_scsi_notify_device_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_notify_device_add \-  Retrieve notifications of added devices
.SH SYNOPSIS
.B "void" i2o_scsi_notify_device_add
.BI "(struct i2o_device *" i2o_dev ");"
.SH ARGUMENTS
.IP "i2o_dev" 12
 the I2O device which was added
.SH "DESCRIPTION"
If a I2O device is added we catch the notification, because I2O classes
other then SCSI peripheral will not be received through
\fBi2o_scsi_probe\fP.
.TH "i2o_scsi_notify_device_remove" 9 "i2o_scsi_notify_device_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_notify_device_remove \-  Retrieve notifications of removed
.SH SYNOPSIS
.B "void" i2o_scsi_notify_device_remove
.BI "(struct i2o_device *" i2o_dev ");"
.SH ARGUMENTS
.IP "i2o_dev" 12
 the I2O device which was removed
.SH "DESCRIPTION"
If a I2O device is removed, we catch the notification to remove the
corresponding SCSI device.
.SH "DESCRIPTION"
If a I2O device is removed, we catch the notification to remove the
corresponding SCSI device.
.TH "i2o_scsi_notify_controller_add" 9 "i2o_scsi_notify_controller_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_notify_controller_add \-  Retrieve notifications of added
.SH SYNOPSIS
.B "void" i2o_scsi_notify_controller_add
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 the controller which was added
.SH "DESCRIPTION"
If a I2O controller is added, we catch the notification to add a
corresponding Scsi_Host.
.SH "DESCRIPTION"
If a I2O controller is added, we catch the notification to add a
corresponding Scsi_Host.
.TH "i2o_scsi_notify_controller_remove" 9 "i2o_scsi_notify_controller_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_notify_controller_remove \-  Retrieve notifications of removed
.SH SYNOPSIS
.B "void" i2o_scsi_notify_controller_remove
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 the controller which was removed
.SH "DESCRIPTION"
If a I2O controller is removed, we catch the notification to remove the
corresponding Scsi_Host.
.SH "DESCRIPTION"
If a I2O controller is removed, we catch the notification to remove the
corresponding Scsi_Host.
.TH "i2o_scsi_queuecommand" 9 "i2o_scsi_queuecommand" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_queuecommand \-  queue a SCSI command
.SH SYNOPSIS
.B "int" i2o_scsi_queuecommand
.BI "(struct scsi_cmnd *" SCpnt ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "SCpnt" 12
 scsi command pointer
.IP "done" 12
 callback for completion
.SH "DESCRIPTION"
Issue a scsi command asynchronously. Return 0 on success or 1 if
we hit an error (normally message queue congestion). The only
minor complication here is that I2O deals with the device addressing
so we have to map the bus/dev/lun back to an I2O handle as well
as faking absent devices ourself.
.SH "LOCKS"
 takes the controller lock on error path only
.TH "i2o_scsi_abort" 9 "i2o_scsi_abort" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_abort \-  abort a running command
.SH SYNOPSIS
.B "int" i2o_scsi_abort
.BI "(struct scsi_cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 command to abort
.SH "DESCRIPTION"
Ask the I2O controller to abort a command. This is an asynchrnous
process and our callback handler will see the command complete with an
aborted message if it succeeds.

Returns 0 if the command is successfully aborted or negative error code
on failure.
.TH "i2o_scsi_bios_param" 9 "i2o_scsi_bios_param" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_bios_param \- 	Invent disk geometry
.SH SYNOPSIS
.B "int" i2o_scsi_bios_param
.BI "(struct scsi_device *" sdev ","
.BI "struct block_device *" dev ","
.BI "sector_t " capacity ","
.BI "int *" ip ");"
.SH ARGUMENTS
.IP "sdev" 12
 scsi device
.IP "dev" 12
 block layer device
.IP "capacity" 12
 size in sectors
.IP "ip" 12
 geometry array
.SH "DESCRIPTION"
This is anyones guess quite frankly. We use the same rules everyone
else appears to and hope. It seems to work.
.TH "i2o_scsi_init" 9 "i2o_scsi_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_init \-  SCSI OSM initialization function
.SH SYNOPSIS
.B "int __init" i2o_scsi_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Register SCSI OSM into I2O core.

Returns 0 on success or negative error code on failure.
.TH "i2o_scsi_exit" 9 "i2o_scsi_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_scsi_exit \-  SCSI OSM exit function
.SH SYNOPSIS
.B "void __exit" i2o_scsi_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters SCSI OSM from I2O core.
.TH "i2o_device_issue_claim" 9 "i2o_device_issue_claim" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_issue_claim \-  claim or release a device
.SH SYNOPSIS
.B "int" i2o_device_issue_claim
.BI "(struct i2o_device *" dev ","
.BI "u32 " cmd ","
.BI "u32 " type ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device to claim or release
.IP "cmd" 12
 claim or release command
.IP "type" 12
 type of claim
.SH "DESCRIPTION"
Issue I2O UTIL_CLAIM or UTIL_RELEASE messages. The message to be sent
is set by cmd. dev is the I2O device which should be claim or
released and the type is the claim type (see the I2O spec).

Returs 0 on success or negative error code on failure.
.TH "i2o_device_claim" 9 "i2o_device_claim" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_claim \-  claim a device for use by an OSM
.SH SYNOPSIS
.B "int" i2o_device_claim
.BI "(struct i2o_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device to claim
.SH "DESCRIPTION"
Do the leg work to assign a device to a given OSM. If the claim succeed
the owner of the rimary. If the attempt fails a negative errno code
is returned. On success zero is returned.
.TH "i2o_device_claim_release" 9 "i2o_device_claim_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_claim_release \-  release a device that the OSM is using
.SH SYNOPSIS
.B "int" i2o_device_claim_release
.BI "(struct i2o_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to release
.SH "DESCRIPTION"
Drop a claim by an OSM on a given I2O device.

AC - some devices seem to want to refuse an unclaim until they have
finished internal processing. It makes sense since you don't want a
new device to go reconfiguring the entire system until you are done.
Thus we are prepared to wait briefly.

Returns 0 on success or negative error code on failure.
.TH "i2o_device_release" 9 "i2o_device_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_release \-  release the memory for a I2O device
.SH SYNOPSIS
.B "void" i2o_device_release
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 I2O device which should be released
.SH "DESCRIPTION"
Release the allocated memory. This function is called if refcount of
device reaches 0 automatically.
.TH "i2o_device_class_release" 9 "i2o_device_class_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_class_release \-  Remove I2O device attributes
.SH SYNOPSIS
.B "void" i2o_device_class_release
.BI "(struct class_device *" cd ");"
.SH ARGUMENTS
.IP "cd" 12
 I2O class device which is added to the I2O device class
.SH "DESCRIPTION"
Removes attributes from the I2O device again. Also search each device
on the controller for I2O devices which refert to this device as parent
or user and remove this links also.
.TH "i2o_device_alloc" 9 "i2o_device_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_alloc \-  Allocate a I2O device and initialize it
.SH SYNOPSIS
.B "struct i2o_device *" i2o_device_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate the memory for a I2O device and initialize locks and lists

Returns the allocated I2O device or a negative error code if the device
could not be allocated.
.TH "i2o_device_add" 9 "i2o_device_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_add \-  allocate a new I2O device and add it to the IOP
.SH SYNOPSIS
.B "struct i2o_device *" i2o_device_add
.BI "(struct i2o_controller *" c ","
.BI "i2o_lct_entry *" entry ");"
.SH ARGUMENTS
.IP "c" 12
-- undescribed --
.IP "entry" 12
 LCT entry of the I2O device
.SH "DESCRIPTION"
Allocate a new I2O device and initialize it with the LCT entry. The
device is appended to the device list of the controller.

Returns a pointer to the I2O device on success or negative error code
on failure.
.TH "i2o_device_remove" 9 "i2o_device_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_remove \-  remove an I2O device from the I2O core
.SH SYNOPSIS
.B "void" i2o_device_remove
.BI "(struct i2o_device *" i2o_dev ");"
.SH ARGUMENTS
.IP "i2o_dev" 12
-- undescribed --
.SH "DESCRIPTION"
Is used on I2O controller removal or LCT modification, when the device
is removed from the system. Note that the device could still hang
around until the refcount reaches 0.
.TH "i2o_device_parse_lct" 9 "i2o_device_parse_lct" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_parse_lct \-  Parse a previously fetched LCT and create devices
.SH SYNOPSIS
.B "int" i2o_device_parse_lct
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller from which the LCT should be parsed.
.SH "DESCRIPTION"
The Logical Configuration Table tells us what we can talk to on the
board. For every entry we create an I2O device, which is registered in
the I2O core.

Returns 0 on success or negative error code on failure.
.TH "i2o_device_class_show_class_id" 9 "i2o_device_class_show_class_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_class_show_class_id \-  Displays class id of I2O device
.SH SYNOPSIS
.B "ssize_t" i2o_device_class_show_class_id
.BI "(struct class_device *" cd ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "cd" 12
 class device of which the class id should be displayed
.IP "buf" 12
 buffer into which the class id should be printed
.SH "DESCRIPTION"
Returns the number of bytes which are printed into the buffer.
.TH "i2o_device_class_show_tid" 9 "i2o_device_class_show_tid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_class_show_tid \-  Displays TID of I2O device
.SH SYNOPSIS
.B "ssize_t" i2o_device_class_show_tid
.BI "(struct class_device *" cd ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "cd" 12
 class device of which the TID should be displayed
.IP "buf" 12
 buffer into which the class id should be printed
.SH "DESCRIPTION"
Returns the number of bytes which are printed into the buffer.
.TH "i2o_device_class_add" 9 "i2o_device_class_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_class_add \-  Adds attributes to the I2O device
.SH SYNOPSIS
.B "int" i2o_device_class_add
.BI "(struct class_device *" cd ");"
.SH ARGUMENTS
.IP "cd" 12
 I2O class device which is added to the I2O device class
.SH "DESCRIPTION"
This function get called when a I2O device is added to the class. It
creates the attributes for each device and creates user/parent symlink
if necessary.

Returns 0 on success or negative error code on failure.
.TH "i2o_device_init" 9 "i2o_device_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_init \-  Initialize I2O devices
.SH SYNOPSIS
.B "int" i2o_device_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Registers the I2O device class.

Returns 0 on success or negative error code on failure.
.TH "i2o_device_exit" 9 "i2o_device_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_device_exit \-  I2O devices exit function
.SH SYNOPSIS
.B "void" i2o_device_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters the I2O device class.
.TH "i2o_config_init" 9 "i2o_config_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_config_init \-  Configuration OSM initialization function
.SH SYNOPSIS
.B "int __init" i2o_config_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Registers Configuration OSM in the I2O core and if old ioctl's are
compiled in initialize them.

Returns 0 on success or negative error code on failure.
.TH "i2o_config_exit" 9 "i2o_config_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_config_exit \-  Configuration OSM exit function
.SH SYNOPSIS
.B "void" i2o_config_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

If old ioctl's are compiled in exit remove them and unregisters
Configuration OSM from I2O core.
.TH "i2o_pci_free" 9 "i2o_pci_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_free \-  Frees the DMA memory for the I2O controller
.SH SYNOPSIS
.B "void" i2o_pci_free
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller to free
.SH "DESCRIPTION"
Remove all allocated DMA memory and unmap memory IO regions. If MTRR
is enabled, also remove it again.
.TH "i2o_pci_alloc" 9 "i2o_pci_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_alloc \-  Allocate DMA memory, map IO memory for I2O controller
.SH SYNOPSIS
.B "int __devinit" i2o_pci_alloc
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
Allocate DMA memory for a PCI (or in theory AGP) I2O controller. All
IO mappings are also done here. If MTRR is enabled, also do add memory
regions here.

Returns 0 on success or negative error code on failure.
.TH "i2o_pci_interrupt" 9 "i2o_pci_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_interrupt \-  Interrupt handler for I2O controller
.SH SYNOPSIS
.B "irqreturn_t" i2o_pci_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" r ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt line
.IP "dev_id" 12
 pointer to the I2O controller
.IP "r" 12
 pointer to registers
.SH "DESCRIPTION"
Handle an interrupt from a PCI based I2O controller. This turns out
to be rather simple. We keep the controller pointer in the cookie.
.TH "i2o_pci_irq_enable" 9 "i2o_pci_irq_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_irq_enable \-  Allocate interrupt for I2O controller
.SH SYNOPSIS
.B "int" i2o_pci_irq_enable
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
-- undescribed --
.SH "DESCRIPTION"

Allocate an interrupt for the I2O controller, and activate interrupts
on the I2O controller.

Returns 0 on success or negative error code on failure.
.TH "i2o_pci_irq_disable" 9 "i2o_pci_irq_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_irq_disable \-  Free interrupt for I2O controller
.SH SYNOPSIS
.B "void" i2o_pci_irq_disable
.BI "(struct i2o_controller *" c ");"
.SH ARGUMENTS
.IP "c" 12
 I2O controller
.SH "DESCRIPTION"
Disable interrupts in I2O controller and then free interrupt.
.TH "i2o_pci_probe" 9 "i2o_pci_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_probe \-  Probe the PCI device for an I2O controller
.SH SYNOPSIS
.B "int __devinit" i2o_pci_probe
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.IP "id" 12
 id which matched with the PCI device id table
.SH "DESCRIPTION"
Probe the PCI device for any device which is a memory of the
Intelligent, I2O class or an Adaptec Zero Channel Controller. We
attempt to set up each such device and register it with the core.

Returns 0 on success or negative error code on failure.
.TH "i2o_pci_remove" 9 "i2o_pci_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_remove \-  Removes a I2O controller from the system
.SH SYNOPSIS
.B "void __devexit" i2o_pci_remove
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.SH "PDEV"
 I2O controller which should be removed

Reset the I2O controller, disable interrupts and remove all allocated
resources.
.TH "i2o_pci_init" 9 "i2o_pci_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_init \-  registers I2O PCI driver in PCI subsystem
.SH SYNOPSIS
.B "int __init" i2o_pci_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns &gt; 0 on success or negative error code on failure.
.TH "i2o_pci_exit" 9 "i2o_pci_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i2o_pci_exit \-  unregisters I2O PCI driver from PCI subsystem
.SH SYNOPSIS
.B "void __exit" i2o_pci_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "pnp_add_card_id" 9 "pnp_add_card_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_add_card_id \-  adds an EISA id to the specified card
.SH SYNOPSIS
.B "int" pnp_add_card_id
.BI "(struct pnp_id *" id ","
.BI "struct pnp_card *" card ");"
.SH ARGUMENTS
.IP "id" 12
 pointer to a pnp_id structure
.IP "card" 12
 pointer to the desired card
.TH "pnp_add_card" 9 "pnp_add_card" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_add_card \-  adds a PnP card to the PnP Layer
.SH SYNOPSIS
.B "int" pnp_add_card
.BI "(struct pnp_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 pointer to the card to add
.TH "pnp_remove_card" 9 "pnp_remove_card" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_remove_card \-  removes a PnP card from the PnP Layer
.SH SYNOPSIS
.B "void" pnp_remove_card
.BI "(struct pnp_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 pointer to the card to remove
.TH "pnp_add_card_device" 9 "pnp_add_card_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_add_card_device \-  adds a device to the specified card
.SH SYNOPSIS
.B "int" pnp_add_card_device
.BI "(struct pnp_card *" card ","
.BI "struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "card" 12
 pointer to the card to add to
.IP "dev" 12
 pointer to the device to add
.TH "pnp_remove_card_device" 9 "pnp_remove_card_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_remove_card_device \-  removes a device from the specified card
.SH SYNOPSIS
.B "void" pnp_remove_card_device
.BI "(struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the device to remove
.TH "pnp_request_card_device" 9 "pnp_request_card_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_request_card_device \-  Searches for a PnP device under the specified card
.SH SYNOPSIS
.B "struct pnp_dev *" pnp_request_card_device
.BI "(struct pnp_card_link *" clink ","
.BI "const char *" id ","
.BI "struct pnp_dev *" from ");"
.SH ARGUMENTS
.IP "clink" 12
 pointer to the card link, cannot be NULL
.IP "id" 12
 pointer to a PnP ID structure that explains the rules for finding the device
.IP "from" 12
 Starting place to search from. If NULL it will start from the begining.
.TH "pnp_release_card_device" 9 "pnp_release_card_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_release_card_device \-  call this when the driver no longer needs the device
.SH SYNOPSIS
.B "void" pnp_release_card_device
.BI "(struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the PnP device stucture
.TH "pnp_register_card_driver" 9 "pnp_register_card_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_register_card_driver \-  registers a PnP card driver with the PnP Layer
.SH SYNOPSIS
.B "int" pnp_register_card_driver
.BI "(struct pnp_card_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to the driver to register
.TH "pnp_unregister_card_driver" 9 "pnp_unregister_card_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_unregister_card_driver \-  unregisters a PnP card driver from the PnP Layer
.SH SYNOPSIS
.B "void" pnp_unregister_card_driver
.BI "(struct pnp_card_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to the driver to unregister
.TH "pnp_register_protocol" 9 "pnp_register_protocol" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_register_protocol \-  adds a pnp protocol to the pnp layer
.SH SYNOPSIS
.B "int" pnp_register_protocol
.BI "(struct pnp_protocol *" protocol ");"
.SH ARGUMENTS
.IP "protocol" 12
 pointer to the corresponding pnp_protocol structure
.SH "EX PROTOCOLS"
 ISAPNP, PNPBIOS, etc
.TH "pnp_unregister_protocol" 9 "pnp_unregister_protocol" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_unregister_protocol \-  removes a pnp protocol from the pnp layer
.SH SYNOPSIS
.B "void" pnp_unregister_protocol
.BI "(struct pnp_protocol *" protocol ");"
.SH ARGUMENTS
.IP "protocol" 12
 pointer to the corresponding pnp_protocol structure
.TH "pnp_remove_device" 9 "pnp_remove_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_remove_device \-  removes a pnp device from the pnp layer
.SH SYNOPSIS
.B "void" pnp_remove_device
.BI "(struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to dev to add
.SH "DESCRIPTION"
this function will free all mem used by dev
.TH "pnp_add_id" 9 "pnp_add_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_add_id \-  adds an EISA id to the specified device
.SH SYNOPSIS
.B "int" pnp_add_id
.BI "(struct pnp_id *" id ","
.BI "struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "id" 12
 pointer to a pnp_id structure
.IP "dev" 12
 pointer to the desired device
.TH "fs_initcall" 9 "fs_initcall" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fs_initcall \- 
.SH SYNOPSIS
.B "" fs_initcall
.BI "(" pnp_system_init ");"
.SH ARGUMENTS
.IP "pnp_system_init" 12
.SH "DESCRIPTION"
but before PCI assign resources for uninitialized PCI devices
.TH "pnp_is_active" 9 "pnp_is_active" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_is_active \-  Determines if a device is active based on its current resources
.SH SYNOPSIS
.B "int" pnp_is_active
.BI "(struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the desired PnP device
.TH "pnp_init_resource_table" 9 "pnp_init_resource_table" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_init_resource_table \-  Resets a resource table to default values.
.SH SYNOPSIS
.B "void" pnp_init_resource_table
.BI "(struct pnp_resource_table *" table ");"
.SH ARGUMENTS
.IP "table" 12
 pointer to the desired resource table
.TH "pnp_clean_resource_table" 9 "pnp_clean_resource_table" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_clean_resource_table \-  clears resources that were not manually set
.SH SYNOPSIS
.B "void" pnp_clean_resource_table
.BI "(struct pnp_resource_table *" res ");"
.SH ARGUMENTS
.IP "res" 12
 the resources to clean
.TH "pnp_assign_resources" 9 "pnp_assign_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_assign_resources \-  assigns resources to the device based on the specified dependent number
.SH SYNOPSIS
.B "int" pnp_assign_resources
.BI "(struct pnp_dev *" dev ","
.BI "int " depnum ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the desired device
.IP "depnum" 12
 the dependent function number
.SH "DESCRIPTION"
Only set depnum to 0 if the device does not have dependent options.
.TH "pnp_manual_config_dev" 9 "pnp_manual_config_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_manual_config_dev \-  Disables Auto Config and Manually sets the resource table
.SH SYNOPSIS
.B "int" pnp_manual_config_dev
.BI "(struct pnp_dev *" dev ","
.BI "struct pnp_resource_table *" res ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the desired device
.IP "res" 12
 pointer to the new resource config
.IP "mode" 12
 0 or PNP_CONFIG_FORCE
.SH "DESCRIPTION"
This function can be used by drivers that want to manually set thier resources.
.TH "pnp_auto_config_dev" 9 "pnp_auto_config_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_auto_config_dev \-  automatically assigns resources to a device
.SH SYNOPSIS
.B "int" pnp_auto_config_dev
.BI "(struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the desired device
.TH "pnp_activate_dev" 9 "pnp_activate_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_activate_dev \-  activates a PnP device for use
.SH SYNOPSIS
.B "int" pnp_activate_dev
.BI "(struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the desired device
.SH "DESCRIPTION"
does not validate or set resources so be careful.
.TH "pnp_disable_dev" 9 "pnp_disable_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_disable_dev \-  disables device
.SH SYNOPSIS
.B "int" pnp_disable_dev
.BI "(struct pnp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the desired device
.SH "DESCRIPTION"
inform the correct pnp protocol so that resources can be used by other devices
.TH "pnp_resource_change" 9 "pnp_resource_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pnp_resource_change \-  change one resource
.SH SYNOPSIS
.B "void" pnp_resource_change
.BI "(struct resource *" resource ","
.BI "unsigned long " start ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "resource" 12
 pointer to resource to be changed
.IP "start" 12
 start of region
.IP "size" 12
 size of region
.TH "hpsb_set_packet_complete_task" 9 "hpsb_set_packet_complete_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpsb_set_packet_complete_task \-  set the task that runs when a packet
.SH SYNOPSIS
.B "void" hpsb_set_packet_complete_task
.BI "(struct hpsb_packet *" packet ","
.BI "void (*" routine ") (void *),"
.BI "void *" data ");"
.SH ARGUMENTS
.IP "packet" 12
 the packet whose completion we want the task added to
.IP "routine" 12
 function to call
.IP "data" 12
 data (if any) to pass to the above function
.SH "DESCRIPTION"
completes. You cannot call this more than once on a single packet
before it is sent.
.TH "hpsb_alloc_packet" 9 "hpsb_alloc_packet" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpsb_alloc_packet \-  allocate new packet structure
.SH SYNOPSIS
.B "struct hpsb_packet *" hpsb_alloc_packet
.BI "(size_t " data_size ");"
.SH ARGUMENTS
.IP "data_size" 12
 size of the data block to be allocated
.SH "DESCRIPTION"
This function allocates, initializes and returns a new &amp;struct hpsb_packet.
It can be used in interrupt context.  A header block is always included, its
size is big enough to contain all possible 1394 headers.  The data block is
only allocated when \fIdata_size\fP is not zero.

For packets for which responses will be received the \fIdata_size\fP has to be big
enough to contain the response's data block since no further allocation
occurs at response matching time.

The packet's generation value will be set to the current generation number
for ease of use.  Remember to overwrite it with your own recorded generation
number if you can not be sure that your code will not race with a bus reset.
.SH "RETURN VALUE"
 A pointer to a &amp;struct hpsb_packet or NULL on allocation
failure.
.TH "hpsb_free_packet" 9 "hpsb_free_packet" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpsb_free_packet \-  free packet and data associated with it
.SH SYNOPSIS
.B "void" hpsb_free_packet
.BI "(struct hpsb_packet *" packet ");"
.SH ARGUMENTS
.IP "packet" 12
 packet to free (is NULL safe)
.SH "DESCRIPTION"
This function will free packet-&gt;data and finally the packet itself.
.TH "hpsb_send_phy_config" 9 "hpsb_send_phy_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpsb_send_phy_config \-  transmit a PHY configuration packet on the bus
.SH SYNOPSIS
.B "int" hpsb_send_phy_config
.BI "(struct hpsb_host *" host ","
.BI "int " rootid ","
.BI "int " gapcnt ");"
.SH ARGUMENTS
.IP "host" 12
 host that PHY config packet gets sent through
.IP "rootid" 12
 root whose force_root bit should get set (-1 = don't set force_root)
.IP "gapcnt" 12
 gap count value to set (-1 = don't set gap count)
.SH "DESCRIPTION"
This function sends a PHY config packet on the bus through the specified host.
.SH "RETURN VALUE"
 0 for success or error number otherwise.
.TH "hpsb_send_packet" 9 "hpsb_send_packet" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpsb_send_packet \-  transmit a packet on the bus
.SH SYNOPSIS
.B "int" hpsb_send_packet
.BI "(struct hpsb_packet *" packet ");"
.SH ARGUMENTS
.IP "packet" 12
 packet to send
.SH "DESCRIPTION"
The packet is sent through the host specified in the packet-&gt;host field.
Before sending, the packet's transmit speed is automatically determined
using the local speed map when it is an async, non-broadcast packet.

Possibilities for failure are that host is either not initialized, in bus
reset, the packet's generation number doesn't match the current generation
number or the host reports a transmit error.
.SH "RETURN VALUE"
 0 on success, negative errno on failure.
.TH "DECLARE_MUTEX" 9 "DECLARE_MUTEX" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
DECLARE_MUTEX \-  allocate a new host controller.
.SH SYNOPSIS
.B "" DECLARE_MUTEX
.BI "(" host_num_alloc ");"
.SH ARGUMENTS
.IP "host_num_alloc" 12
.SH "DESCRIPTION"
Allocate a &amp;hpsb_host and initialize the general subsystem specific
fields.  If the driver needs to store per host data, as drivers
usually do, the amount of memory required can be specified by the
\fIextra\fP parameter.  Once allocated, the driver should initialize the
driver specific parts, enable the controller and make it available
to the general subsystem using \fBhpsb_add_host\fP.
.SH "RETURN VALUE"
 a pointer to the &amp;hpsb_host if succesful, NULL if
no memory was available.
.TH "hpsb_get_tlabel" 9 "hpsb_get_tlabel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpsb_get_tlabel \-  allocate a transaction label
.SH SYNOPSIS
.B "int" hpsb_get_tlabel
.BI "(struct hpsb_packet *" packet ");"
.SH ARGUMENTS
.IP "packet" 12
 the packet who's tlabel/tpool we set
.SH "DESCRIPTION"
Every asynchronous transaction on the 1394 bus needs a transaction
label to match the response to the request.  This label has to be
different from any other transaction label in an outstanding request to
the same node to make matching possible without ambiguity.

There are 64 different tlabels, so an allocated tlabel has to be freed
with \fBhpsb_free_tlabel\fP after the transaction is complete (unless it's
reused again for the same target node).
.SH "RETURN VALUE"
 Zero on success, otherwise non-zero. A non-zero return
generally means there are no available tlabels. If this is called out
of interrupt or atomic context, then it will sleep until can return a
tlabel.
.TH "hpsb_free_tlabel" 9 "hpsb_free_tlabel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpsb_free_tlabel \-  free an allocated transaction label
.SH SYNOPSIS
.B "void" hpsb_free_tlabel
.BI "(struct hpsb_packet *" packet ");"
.SH ARGUMENTS
.IP "packet" 12
 packet whos tlabel/tpool needs to be cleared
.SH "DESCRIPTION"
Frees the transaction label allocated with \fBhpsb_get_tlabel\fP.  The
tlabel has to be freed after the transaction is complete (i.e. response
was received for a split transaction or packet was sent for a unified
transaction).

A tlabel must not be freed twice.
.TH "snt_poll_getc" 9 "snt_poll_getc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snt_poll_getc \-  Get a character from the console in polling mode
.SH SYNOPSIS
.B "int" snt_poll_getc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "snt_poll_input_pending" 9 "snt_poll_input_pending" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snt_poll_input_pending \-  Check if any input is waiting - polling mode.
.SH SYNOPSIS
.B "int" snt_poll_input_pending
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "snt_intr_getc" 9 "snt_intr_getc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snt_intr_getc \-  Get a character from the console, interrupt mode
.SH SYNOPSIS
.B "int" snt_intr_getc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "snt_intr_input_pending" 9 "snt_intr_input_pending" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snt_intr_input_pending \-  Check if input is pending, interrupt mode
.SH SYNOPSIS
.B "int" snt_intr_input_pending
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "snt_hw_puts_raw" 9 "snt_hw_puts_raw" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snt_hw_puts_raw \-  Send raw string to the console, polled or interrupt mode
.SH SYNOPSIS
.B "int" snt_hw_puts_raw
.BI "(const char *" s ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "s" 12
 String
.IP "len" 12
 Length
.TH "snt_hw_puts_buffered" 9 "snt_hw_puts_buffered" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snt_hw_puts_buffered \-  Send string to console, polled or interrupt mode
.SH SYNOPSIS
.B "int" snt_hw_puts_buffered
.BI "(const char *" s ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "s" 12
 String
.IP "len" 12
 Length
.TH "snp_type" 9 "snp_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_type \-  What type of console are we?
.SH SYNOPSIS
.B "const char *" snp_type
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate with (we ignore since we only have one port)
.TH "snp_tx_empty" 9 "snp_tx_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_tx_empty \-  Is the transmitter empty?  We pretend we're always empty
.SH SYNOPSIS
.B "unsigned int" snp_tx_empty
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on (we ignore since we only have one port)
.TH "snp_stop_tx" 9 "snp_stop_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_stop_tx \-  stop the transmitter - no-op for us
.SH SYNOPSIS
.B "void" snp_stop_tx
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operat eon - we ignore - no-op function
.TH "snp_release_port" 9 "snp_release_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_release_port \-  Free i/o and resources for port - no-op for us
.SH SYNOPSIS
.B "void" snp_release_port
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on - we ignore - no-op function
.TH "snp_enable_ms" 9 "snp_enable_ms" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_enable_ms \-  Force modem status interrupts on - no-op for us
.SH SYNOPSIS
.B "void" snp_enable_ms
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on - we ignore - no-op function
.TH "snp_shutdown" 9 "snp_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_shutdown \-  shut down the port - free irq and disable - no-op for us
.SH SYNOPSIS
.B "void" snp_shutdown
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to shut down - we ignore
.TH "snp_set_mctrl" 9 "snp_set_mctrl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_set_mctrl \-  set control lines (dtr, rts, etc) - no-op for our console
.SH SYNOPSIS
.B "void" snp_set_mctrl
.BI "(struct uart_port *" port ","
.BI "unsigned int " mctrl ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on - we ignore
.IP "mctrl" 12
 Lines to set/unset - we ignore
.TH "snp_get_mctrl" 9 "snp_get_mctrl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_get_mctrl \-  get contorl line info, we just return a static value
.SH SYNOPSIS
.B "unsigned int" snp_get_mctrl
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 port to operate on - we only have one port so we ignore this
.TH "snp_stop_rx" 9 "snp_stop_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_stop_rx \-  Stop the receiver - we ignor ethis
.SH SYNOPSIS
.B "void" snp_stop_rx
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on - we ignore
.TH "snp_start_tx" 9 "snp_start_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_start_tx \-  Start transmitter
.SH SYNOPSIS
.B "void" snp_start_tx
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on
.TH "snp_break_ctl" 9 "snp_break_ctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_break_ctl \-  handle breaks - ignored by us
.SH SYNOPSIS
.B "void" snp_break_ctl
.BI "(struct uart_port *" port ","
.BI "int " break_state ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on
.IP "break_state" 12
 Break state
.TH "snp_startup" 9 "snp_startup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_startup \-  Start up the serial port - always return 0 (We're always on)
.SH SYNOPSIS
.B "int" snp_startup
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on
.TH "snp_set_termios" 9 "snp_set_termios" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_set_termios \-  set termios stuff - we ignore these
.SH SYNOPSIS
.B "void" snp_set_termios
.BI "(struct uart_port *" port ","
.BI "struct termios *" termios ","
.BI "struct termios *" old ");"
.SH ARGUMENTS
.IP "port" 12
 port to operate on
.IP "termios" 12
 Old
.IP "old" 12
-- undescribed --
.TH "snp_request_port" 9 "snp_request_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_request_port \-  allocate resources for port - ignored by us
.SH SYNOPSIS
.B "int" snp_request_port
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 port to operate on
.TH "snp_config_port" 9 "snp_config_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snp_config_port \-  allocate resources, set up - we ignore,  we're always on
.SH SYNOPSIS
.B "void" snp_config_port
.BI "(struct uart_port *" port ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on
.IP "flags" 12
 flags used for port setup
.TH "sn_debug_printf" 9 "sn_debug_printf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_debug_printf \-  close to hardware debugging printf
.SH SYNOPSIS
.B "int" sn_debug_printf
.BI "(const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "fmt" 12
 printf format
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
This is as "close to the metal" as we can get, used when the driver
itself may be broken.
.TH "sn_receive_chars" 9 "sn_receive_chars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_receive_chars \-  Grab characters, pass them to tty layer
.SH SYNOPSIS
.B "void" sn_receive_chars
.BI "(struct sn_cons_port *" port ","
.BI "struct pt_regs *" regs ","
.BI "unsigned long " flags ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on
.IP "regs" 12
 Saved registers (needed by uart_handle_sysrq_char)
.IP "flags" 12
 irq flags
.SH "NOTE"
 If we're not registered with the serial core infrastructure yet,
we don't try to send characters to it...
.TH "sn_transmit_chars" 9 "sn_transmit_chars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_transmit_chars \-  grab characters from serial core, send off
.SH SYNOPSIS
.B "void" sn_transmit_chars
.BI "(struct sn_cons_port *" port ","
.BI "int " raw ");"
.SH ARGUMENTS
.IP "port" 12
 Port to operate on
.IP "raw" 12
 Transmit raw or buffered
.SH "NOTE"
 If we're early, before we're registered with serial core, the
writes are going through sn_sal_console_write because that's how
register_console has been set up.  We currently could have asynch
polls calling this function due to sn_sal_switch_to_asynch but we can
ignore them until we register with the serial core stuffs.
.TH "sn_sal_interrupt" 9 "sn_sal_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_interrupt \-  Handle console interrupts
.SH SYNOPSIS
.B "irqreturn_t" sn_sal_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 irq #, useful for debug statements
.IP "dev_id" 12
 our pointer to our port (sn_cons_port which contains the uart port)
.IP "regs" 12
 Saved registers, used by sn_receive_chars for uart_handle_sysrq_char
.TH "sn_sal_connect_interrupt" 9 "sn_sal_connect_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_connect_interrupt \-  Request interrupt, handled by sn_sal_interrupt
.SH SYNOPSIS
.B "int" sn_sal_connect_interrupt
.BI "(struct sn_cons_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Our sn_cons_port (which contains the uart port)
.SH "DESCRIPTION"
returns the console irq if interrupt is successfully registered, else 0
.TH "sn_sal_timer_poll" 9 "sn_sal_timer_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_timer_poll \-  this function handles polled console mode
.SH SYNOPSIS
.B "void" sn_sal_timer_poll
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 A pointer to our sn_cons_port (which contains the uart port)
.SH "DESCRIPTION"
data is the pointer that init_timer will store for us.  This function is
associated with init_timer to see if there is any console traffic.
Obviously not used in interrupt mode
.TH "sn_sal_switch_to_asynch" 9 "sn_sal_switch_to_asynch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_switch_to_asynch \-  Switch to async mode (as opposed to synch)
.SH SYNOPSIS
.B "void __init" sn_sal_switch_to_asynch
.BI "(struct sn_cons_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Our sn_cons_port (which contains the uart port)
.SH "DESCRIPTION"
So this is used by sn_sal_serial_console_init (early on, before we're
registered with serial core).  It's also used by sn_sal_module_init
right after we've registered with serial core.  The later only happens
if we didn't already come through here via sn_sal_serial_console_init.
.TH "sn_sal_switch_to_interrupts" 9 "sn_sal_switch_to_interrupts" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_switch_to_interrupts \-  Switch to interrupt driven mode
.SH SYNOPSIS
.B "void __init" sn_sal_switch_to_interrupts
.BI "(struct sn_cons_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Our sn_cons_port (which contains the uart port)
.SH "DESCRIPTION"
In sn_sal_module_init, after we're registered with serial core and
the port is added, this function is called to switch us to interrupt
mode.  We were previously in asynch/polling mode (using init_timer).

We attempt to switch to interrupt mode here by calling
sn_sal_connect_interrupt.  If that works out, we enable receive interrupts.
.TH "sn_sal_module_init" 9 "sn_sal_module_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_module_init \-  When the kernel loads us, get us rolling w/ serial core
.SH SYNOPSIS
.B "int __init" sn_sal_module_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Before this is called, we've been printing kernel messages in a special
early mode not making use of the serial core infrastructure.  When our
driver is loaded for real, we register the driver and port with serial
core and try to enable interrupt driven mode.
.TH "sn_sal_module_exit" 9 "sn_sal_module_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_module_exit \-  When we're unloaded, remove the driver/port
.SH SYNOPSIS
.B "void __exit" sn_sal_module_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "puts_raw_fixed" 9 "puts_raw_fixed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
puts_raw_fixed \-  sn_sal_console_write helper for adding \r's as required
.SH SYNOPSIS
.B "void" puts_raw_fixed
.BI "(int (*" puts_raw ") (const char *s, int len),"
.BI "const char *" s ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "puts_raw" 12
 puts function to do the writing
.IP "s" 12
 input string
.IP "count" 12
 length
.SH "DESCRIPTION"
We need a \r ahead of every \n for direct writes through
ia64_sn_console_putb (what sal_puts_raw below actually does).
.TH "sn_sal_console_write" 9 "sn_sal_console_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_console_write \-  Print statements before serial core available
.SH SYNOPSIS
.B "void" sn_sal_console_write
.BI "(struct console *" co ","
.BI "const char *" s ","
.BI "unsigned " count ");"
.SH ARGUMENTS
.IP "co" 12
-- undescribed --
.IP "s" 12
 String to send
.IP "count" 12
 length
.SH "DESCRIPTION"
This is referenced in the console struct.  It is used for early
console printing before we register with serial core and for things
such as kdb.  The console_lock must be held when we get here.

This function has some code for trying to print output even if the lock
is held.  We try to cover the case where a lock holder could have died.
We don't use this special case code if we're not registered with serial
core yet.  After we're registered with serial core, the only time this
function would be used is for high level kernel output like magic sys req,
kdb, and printk's.
.TH "sn_sal_console_setup" 9 "sn_sal_console_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_console_setup \-  Set up console for early printing
.SH SYNOPSIS
.B "int __init" sn_sal_console_setup
.BI "(struct console *" co ","
.BI "char *" options ");"
.SH ARGUMENTS
.IP "co" 12
 Console to work with
.IP "options" 12
 Options to set
.SH "DESCRIPTION"
Altix console doesn't do anything with baud rates, etc, anyway.

This isn't required since not providing the setup function in the
console struct is ok.  However, other patches like KDB plop something
here so providing it is easier.
.TH "sn_sal_console_write_early" 9 "sn_sal_console_write_early" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_console_write_early \-  simple early output routine
.SH SYNOPSIS
.B "void __init" sn_sal_console_write_early
.BI "(struct console *" co ","
.BI "const char *" s ","
.BI "unsigned " count ");"
.SH ARGUMENTS
.IP "co" 12
-- undescribed --
.IP "s" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
\fIco\fP - console struct
\fIs\fP - string to print
\fIcount\fP - count

Simple function to provide early output, before even
sn_sal_serial_console_init is called.  Referenced in the
console struct registerd in sn_serial_console_early_setup.
.TH "sn_serial_console_early_setup" 9 "sn_serial_console_early_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_serial_console_early_setup \-  Sets up early console output support
.SH SYNOPSIS
.B "int __init" sn_serial_console_early_setup
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Register a console early on...  This is for output before even
sn_sal_serial_cosnole_init is called.  This function is called from
setup.c.  This allows us to do really early polled writes. When
sn_sal_serial_console_init is called, this console is unregistered
and a new one registered.
.TH "sn_sal_serial_console_init" 9 "sn_sal_serial_console_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_sal_serial_console_init \-  Early console output - set up for register
.SH SYNOPSIS
.B "int __init" sn_sal_serial_console_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function is called when regular console init happens.  Because we
support even earlier console output with sn_serial_console_early_setup
(called from setup.c directly), this function unregisters the really
early console.
.SH "NOTE"
 Even if setup.c doesn't register sal_console_early, unregistering
it here doesn't hurt anything.
.TH "uart_update_timeout" 9 "uart_update_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_update_timeout \-  update per-port FIFO timeout.
.SH SYNOPSIS
.B "void" uart_update_timeout
.BI "(struct uart_port *" port ","
.BI "unsigned int " cflag ","
.BI "unsigned int " baud ");"
.SH ARGUMENTS
.IP "port" 12
  uart_port structure describing the port
.IP "cflag" 12
 termios cflag value
.IP "baud" 12
  speed of the port
.SH "DESCRIPTION"
Set the port FIFO timeout value.  The \fIcflag\fP value should
reflect the actual hardware settings.
.TH "uart_get_baud_rate" 9 "uart_get_baud_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_get_baud_rate \-  return baud rate for a particular port
.SH SYNOPSIS
.B "unsigned int" uart_get_baud_rate
.BI "(struct uart_port *" port ","
.BI "struct termios *" termios ","
.BI "struct termios *" old ","
.BI "unsigned int " min ","
.BI "unsigned int " max ");"
.SH ARGUMENTS
.IP "port" 12
 uart_port structure describing the port in question.
.IP "termios" 12
 desired termios settings.
.IP "old" 12
 old termios (or NULL)
.IP "min" 12
 minimum acceptable baud rate
.IP "max" 12
 maximum acceptable baud rate
.SH "DESCRIPTION"
Decode the termios structure into a numeric baud rate,
taking account of the magic 38400 baud rate (with spd_*
flags), and mapping the B0 rate to 9600 baud.

If the new baud rate is invalid, try the old termios setting.
If it's still invalid, we try 9600 baud.

Update the \fItermios\fP structure to reflect the baud rate
we're actually going to be using.
.TH "uart_get_divisor" 9 "uart_get_divisor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_get_divisor \-  return uart clock divisor
.SH SYNOPSIS
.B "unsigned int" uart_get_divisor
.BI "(struct uart_port *" port ","
.BI "unsigned int " baud ");"
.SH ARGUMENTS
.IP "port" 12
 uart_port structure describing the port.
.IP "baud" 12
 desired baud rate
.SH "DESCRIPTION"
Calculate the uart clock divisor for the port.
.TH "uart_parse_options" 9 "uart_parse_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_parse_options \-  Parse serial port baud/parity/bits/flow contro.
.SH SYNOPSIS
.B "void __init" uart_parse_options
.BI "(char *" options ","
.BI "int *" baud ","
.BI "int *" parity ","
.BI "int *" bits ","
.BI "int *" flow ");"
.SH ARGUMENTS
.IP "options" 12
 pointer to option string
.IP "baud" 12
 pointer to an 'int' variable for the baud rate.
.IP "parity" 12
 pointer to an 'int' variable for the parity.
.IP "bits" 12
 pointer to an 'int' variable for the number of data bits.
.IP "flow" 12
 pointer to an 'int' variable for the flow control character.
.SH "DESCRIPTION"
uart_parse_options decodes a string containing the serial console
options.  The format of the string is &lt;baud&gt;&lt;parity&gt;&lt;bits&gt;&lt;flow&gt;,
.SH "EG"
 115200n8r
.TH "uart_set_options" 9 "uart_set_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_set_options \-  setup the serial console parameters
.SH SYNOPSIS
.B "int __init" uart_set_options
.BI "(struct uart_port *" port ","
.BI "struct console *" co ","
.BI "int " baud ","
.BI "int " parity ","
.BI "int " bits ","
.BI "int " flow ");"
.SH ARGUMENTS
.IP "port" 12
 pointer to the serial ports uart_port structure
.IP "co" 12
 console pointer
.IP "baud" 12
 baud rate
.IP "parity" 12
 parity character - 'n' (none), 'o' (odd), 'e' (even)
.IP "bits" 12
 number of data bits
.IP "flow" 12
 flow control character - 'r' (rts)
.TH "uart_register_driver" 9 "uart_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_register_driver \-  register a driver with the uart core layer
.SH SYNOPSIS
.B "int" uart_register_driver
.BI "(struct uart_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 low level driver structure
.SH "DESCRIPTION"
Register a uart driver with the core driver.  We in turn register
with the tty layer, and initialise the core driver per-port state.

We have a proc file in /proc/tty/driver which is named after the
normal driver.

drv-&gt;port should be NULL, and the per-port structures should be
registered using uart_add_one_port after this call has succeeded.
.TH "uart_unregister_driver" 9 "uart_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_unregister_driver \-  remove a driver from the uart core layer
.SH SYNOPSIS
.B "void" uart_unregister_driver
.BI "(struct uart_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 low level driver structure
.SH "DESCRIPTION"
Remove all references to a driver from the core driver.  The low
level driver must have removed all its ports via the
\fBuart_remove_one_port\fP if it registered them with \fBuart_add_one_port\fP.
(ie, drv-&gt;port == NULL)
.TH "uart_add_one_port" 9 "uart_add_one_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_add_one_port \-  attach a driver-defined port structure
.SH SYNOPSIS
.B "int" uart_add_one_port
.BI "(struct uart_driver *" drv ","
.BI "struct uart_port *" port ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to the uart low level driver structure for this port
.IP "port" 12
 uart port structure to use for this port.
.SH "DESCRIPTION"
This allows the driver to register its own uart_port structure
with the core driver.  The main purpose is to allow the low
level uart drivers to expand uart_port, rather than having yet
more levels of structures.
.TH "uart_remove_one_port" 9 "uart_remove_one_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
uart_remove_one_port \-  detach a driver defined port structure
.SH SYNOPSIS
.B "int" uart_remove_one_port
.BI "(struct uart_driver *" drv ","
.BI "struct uart_port *" port ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to the uart low level driver structure for this port
.IP "port" 12
 uart port structure for this port
.SH "DESCRIPTION"
This unhooks (and hangs up) the specified port structure from the
core driver.  No further calls will be made to the low-level code
for this port.
.TH "m32r_sio_suspend_port" 9 "m32r_sio_suspend_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
m32r_sio_suspend_port \-  suspend one serial port
.SH SYNOPSIS
.B "void" m32r_sio_suspend_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
 serial line number
.SH "DESCRIPTION"
Suspend one serial port.
.TH "m32r_sio_resume_port" 9 "m32r_sio_resume_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
m32r_sio_resume_port \-  resume one serial port
.SH SYNOPSIS
.B "void" m32r_sio_resume_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
 serial line number
.SH "DESCRIPTION"
Resume one serial port.
.TH "serial_txx9_suspend_port" 9 "serial_txx9_suspend_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial_txx9_suspend_port \-  suspend one serial port
.SH SYNOPSIS
.B "void" serial_txx9_suspend_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
  serial line number
.SH "DESCRIPTION"
Suspend one serial port.
.TH "serial_txx9_resume_port" 9 "serial_txx9_resume_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial_txx9_resume_port \-  resume one serial port
.SH SYNOPSIS
.B "void" serial_txx9_resume_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
  serial line number
.SH "DESCRIPTION"
Resume one serial port.
.TH "serial_txx9_register_port" 9 "serial_txx9_register_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial_txx9_register_port \-  register a serial port
.SH SYNOPSIS
.B "int __devinit" serial_txx9_register_port
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 serial port template
.SH "DESCRIPTION"
Configure the serial port specified by the request.

The port is then probed and if necessary the IRQ is autodetected
If this fails an error is returned.

On success the port is ready to use and the line number is returned.
.TH "serial_txx9_unregister_port" 9 "serial_txx9_unregister_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial_txx9_unregister_port \-  remove a txx9 serial port at runtime
.SH SYNOPSIS
.B "void __devexit" serial_txx9_unregister_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
 serial line number
.SH "DESCRIPTION"
Remove one serial port.  This may not be called from interrupt
context.  We hand the port back to the our control.
.TH "serial8250_suspend_port" 9 "serial8250_suspend_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial8250_suspend_port \-  suspend one serial port
.SH SYNOPSIS
.B "void" serial8250_suspend_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
  serial line number
.SH "DESCRIPTION"
Suspend one serial port.
.TH "serial8250_resume_port" 9 "serial8250_resume_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial8250_resume_port \-  resume one serial port
.SH SYNOPSIS
.B "void" serial8250_resume_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
  serial line number
.SH "DESCRIPTION"
Resume one serial port.
.TH "serial8250_register_port" 9 "serial8250_register_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial8250_register_port \-  register a serial port
.SH SYNOPSIS
.B "int" serial8250_register_port
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 serial port template
.SH "DESCRIPTION"
Configure the serial port specified by the request. If the
port exists and is in use, it is hung up and unregistered
first.

The port is then probed and if necessary the IRQ is autodetected
If this fails an error is returned.

On success the port is ready to use and the line number is returned.
.TH "serial8250_unregister_port" 9 "serial8250_unregister_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial8250_unregister_port \-  remove a 16x50 serial port at runtime
.SH SYNOPSIS
.B "void" serial8250_unregister_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
 serial line number
.SH "DESCRIPTION"
Remove one serial port.  This may not be called from interrupt
context.  We hand the port back to the our control.
.TH "mux_tx_empty" 9 "mux_tx_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_tx_empty \-  Check if the transmitter fifo is empty.
.SH SYNOPSIS
.B "unsigned int" mux_tx_empty
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
This function test if the transmitter fifo for the port
described by 'port' is empty.  If it is empty, this function
should return TIOCSER_TEMT, otherwise return 0.
.TH "mux_set_mctrl" 9 "mux_set_mctrl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_set_mctrl \-  Set the current state of the modem control inputs.
.SH SYNOPSIS
.B "void" mux_set_mctrl
.BI "(struct uart_port *" port ","
.BI "unsigned int " mctrl ");"
.SH ARGUMENTS
.IP "port" 12
-- undescribed --
.IP "mctrl" 12
 Modem control bits.
.SH "DESCRIPTION"
The Serial MUX does not support CTS, DCD or DSR so this function
is ignored.
.TH "mux_get_mctrl" 9 "mux_get_mctrl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_get_mctrl \-  Returns the current state of modem control inputs.
.SH SYNOPSIS
.B "unsigned int" mux_get_mctrl
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
The Serial MUX does not support CTS, DCD or DSR so these lines are
treated as permanently active.
.TH "mux_stop_tx" 9 "mux_stop_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_stop_tx \-  Stop transmitting characters.
.SH SYNOPSIS
.B "void" mux_stop_tx
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
The Serial MUX does not support this function.
.TH "mux_start_tx" 9 "mux_start_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_start_tx \-  Start transmitting characters.
.SH SYNOPSIS
.B "void" mux_start_tx
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
The Serial Mux does not support this function.
.TH "mux_stop_rx" 9 "mux_stop_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_stop_rx \-  Stop receiving characters.
.SH SYNOPSIS
.B "void" mux_stop_rx
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
The Serial Mux does not support this function.
.TH "mux_enable_ms" 9 "mux_enable_ms" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_enable_ms \-  Enable modum status interrupts.
.SH SYNOPSIS
.B "void" mux_enable_ms
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
The Serial Mux does not support this function.
.TH "mux_break_ctl" 9 "mux_break_ctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_break_ctl \-  Control the transmitssion of a break signal.
.SH SYNOPSIS
.B "void" mux_break_ctl
.BI "(struct uart_port *" port ","
.BI "int " break_state ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.IP "break_state" 12
 Raise/Lower the break signal.
.SH "DESCRIPTION"
The Serial Mux does not support this function.
.TH "mux_write" 9 "mux_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_write \-  Write chars to the mux fifo.
.SH SYNOPSIS
.B "void" mux_write
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
This function writes all the data from the uart buffer to
the mux fifo.
.TH "mux_read" 9 "mux_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_read \-  Read chars from the mux fifo.
.SH SYNOPSIS
.B "void" mux_read
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
This reads all available data from the mux's fifo and pushes
the data to the tty layer.
.TH "mux_startup" 9 "mux_startup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_startup \-  Initialize the port.
.SH SYNOPSIS
.B "int" mux_startup
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
Grab any resources needed for this port and start the
mux timer.
.TH "mux_shutdown" 9 "mux_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_shutdown \-  Disable the port.
.SH SYNOPSIS
.B "void" mux_shutdown
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
Release any resources needed for the port.
.TH "mux_set_termios" 9 "mux_set_termios" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_set_termios \-  Chane port parameters.
.SH SYNOPSIS
.B "void" mux_set_termios
.BI "(struct uart_port *" port ","
.BI "struct termios *" termios ","
.BI "struct termios *" old ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.IP "termios" 12
 new termios settings.
.IP "old" 12
 old termios settings.
.SH "DESCRIPTION"
The Serial Mux does not support this function.
.TH "mux_type" 9 "mux_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_type \-  Describe the port.
.SH SYNOPSIS
.B "const char *" mux_type
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
Return a pointer to a string constant describing the
specified port.
.TH "mux_release_port" 9 "mux_release_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_release_port \-  Release memory and IO regions.
.SH SYNOPSIS
.B "void" mux_release_port
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
Release any memory and IO region resources currently in use by
the port.
.TH "mux_request_port" 9 "mux_request_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_request_port \-  Request memory and IO regions.
.SH SYNOPSIS
.B "int" mux_request_port
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.SH "DESCRIPTION"
Request any memory and IO region resources required by the port.
If any fail, no resources should be registered when this function
returns, and it should return -EBUSY on failure.
.TH "mux_config_port" 9 "mux_config_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_config_port \-  Perform port autoconfiguration.
.SH SYNOPSIS
.B "void" mux_config_port
.BI "(struct uart_port *" port ","
.BI "int " type ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.IP "type" 12
 Bitmask of required configurations.
.SH "DESCRIPTION"
Perform any autoconfiguration steps for the port.  This functino is
called if the UPF_BOOT_AUTOCONF flag is specified for the port.
[Note: This is required for now because of a bug in the Serial core.
rmk has already submitted a patch to linus, should be available for
2.5.47.]
.TH "mux_verify_port" 9 "mux_verify_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_verify_port \-  Verify the port information.
.SH SYNOPSIS
.B "int" mux_verify_port
.BI "(struct uart_port *" port ","
.BI "struct serial_struct *" ser ");"
.SH ARGUMENTS
.IP "port" 12
 Ptr to the uart_port.
.IP "ser" 12
 Ptr to the serial information.
.SH "DESCRIPTION"
Verify the new serial port information contained within serinfo is
suitable for this port type.
.TH "mux_poll" 9 "mux_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_poll \-  Mux poll function.
.SH SYNOPSIS
.B "void" mux_poll
.BI "(unsigned long " unused ");"
.SH ARGUMENTS
.IP "unused" 12
 Unused variable
.SH "DESCRIPTION"
This function periodically polls the Serial MUX to check for new data.
.TH "mux_probe" 9 "mux_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_probe \-  Determine if the Serial Mux should claim this device.
.SH SYNOPSIS
.B "int __init" mux_probe
.BI "(struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The parisc device.
.SH "DESCRIPTION"
Deterimine if the Serial Mux should claim this chip (return 0)
or not (return 1).
.TH "mux_init" 9 "mux_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_init \-  Serial MUX initalization procedure.
.SH SYNOPSIS
.B "int __init" mux_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Register the Serial MUX driver.
.TH "mux_exit" 9 "mux_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mux_exit \-  Serial MUX cleanup procedure.
.SH SYNOPSIS
.B "void __exit" mux_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregister the Serial MUX driver from the tty layer.
.TH "serial8250_suspend_port" 9 "serial8250_suspend_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial8250_suspend_port \-  suspend one serial port
.SH SYNOPSIS
.B "void" serial8250_suspend_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
  serial line number
.SH "DESCRIPTION"
Suspend one serial port.
.TH "serial8250_resume_port" 9 "serial8250_resume_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
serial8250_resume_port \-  resume one serial port
.SH SYNOPSIS
.B "void" serial8250_resume_port
.BI "(int " line ");"
.SH ARGUMENTS
.IP "line" 12
  serial line number
.SH "DESCRIPTION"
Resume one serial port.
.TH "write_ireg" 9 "write_ireg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_ireg \-  write the interrupt regs
.SH SYNOPSIS
.B "void" write_ireg
.BI "(struct ioc4_soft *" ioc4_soft ","
.BI "uint32_t " val ","
.BI "int " which ","
.BI "int " type ");"
.SH ARGUMENTS
.IP "ioc4_soft" 12
 ptr to soft struct for this port
.IP "val" 12
 value to write
.IP "which" 12
 which register
.IP "type" 12
 which ireg set
.TH "set_baud" 9 "set_baud" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_baud \-  Baud rate setting code
.SH SYNOPSIS
.B "int" set_baud
.BI "(struct ioc4_port *" port ","
.BI "int " baud ");"
.SH ARGUMENTS
.IP "port" 12
 port to set
.IP "baud" 12
 baud rate to use
.TH "get_ioc4_port" 9 "get_ioc4_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_ioc4_port \-  given a uart port, return the control structure
.SH SYNOPSIS
.B "struct ioc4_port *" get_ioc4_port
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "port_init" 9 "port_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
port_init \-  Initialize the sio and ioc4 hardware for a given port
.SH SYNOPSIS
.B "int inline" port_init
.BI "(struct ioc4_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 port to initialize
.SH "DESCRIPTION"
called per port from attach...
.TH "handle_dma_error_intr" 9 "handle_dma_error_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
handle_dma_error_intr \-  service any pending DMA error interrupts for the
.SH SYNOPSIS
.B "void" handle_dma_error_intr
.BI "(void *" arg ","
.BI "uint32_t " other_ir ");"
.SH ARGUMENTS
.IP "arg" 12
 handler arg
.IP "other_ir" 12
 ioc4regs
.SH "DESCRIPTION"
given port - 2nd level called via sd_intr
.TH "intr_connect" 9 "intr_connect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
intr_connect \-  interrupt connect function
.SH SYNOPSIS
.B "void" intr_connect
.BI "(struct ioc4_soft *" soft ","
.BI "int " type ","
.BI "uint32_t " intrbits ","
.BI "ioc4_intr_func_f *" intr ","
.BI "void *" info ");"
.SH ARGUMENTS
.IP "soft" 12
 soft struct for this card
.IP "type" 12
 interrupt type
.IP "intrbits" 12
 bit pattern to set
.IP "intr" 12
 handler function
.IP "info" 12
 handler arg
.TH "ioc4_intr" 9 "ioc4_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_intr \-  Top level IOC4 interrupt handler.
.SH SYNOPSIS
.B "irqreturn_t" ioc4_intr
.BI "(int " irq ","
.BI "void *" arg ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 irq value
.IP "arg" 12
 handler arg
.IP "regs" 12
 registers
.TH "ioc4_attach_local" 9 "ioc4_attach_local" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_attach_local \-  Device initialization.
.SH SYNOPSIS
.B "int inline" ioc4_attach_local
.BI "(struct ioc4_driver_data *" idd ");"
.SH ARGUMENTS
.IP "idd" 12
 Master module data for this IOC4
.SH "DESCRIPTION"
Called at *\fB_attach\fP time for each
IOC4 with serial ports in the system.
.TH "enable_intrs" 9 "enable_intrs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_intrs \-  enable interrupts
.SH SYNOPSIS
.B "void" enable_intrs
.BI "(struct ioc4_port *" port ","
.BI "uint32_t " mask ");"
.SH ARGUMENTS
.IP "port" 12
 port to enable
.IP "mask" 12
 mask to use
.TH "local_open" 9 "local_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
local_open \-  local open a port
.SH SYNOPSIS
.B "int" local_open
.BI "(struct ioc4_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 port to open
.TH "set_rx_timeout" 9 "set_rx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_rx_timeout \-  Set rx timeout and threshold values.
.SH SYNOPSIS
.B "int" set_rx_timeout
.BI "(struct ioc4_port *" port ","
.BI "int " timeout ");"
.SH ARGUMENTS
.IP "port" 12
 port to use
.IP "timeout" 12
 timeout value in ticks
.TH "config_port" 9 "config_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
config_port \-  config the hardware
.SH SYNOPSIS
.B "int" config_port
.BI "(struct ioc4_port *" port ","
.BI "int " baud ","
.BI "int " byte_size ","
.BI "int " stop_bits ","
.BI "int " parenb ","
.BI "int " parodd ");"
.SH ARGUMENTS
.IP "port" 12
 port to config
.IP "baud" 12
 baud rate for the port
.IP "byte_size" 12
 data size
.IP "stop_bits" 12
 number of stop bits
.IP "parenb" 12
 parity enable ?
.IP "parodd" 12
 odd parity ?
.TH "do_write" 9 "do_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_write \-  Write bytes to the port.  Returns the number of bytes
.SH SYNOPSIS
.B "int" do_write
.BI "(struct ioc4_port *" port ","
.BI "char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "port" 12
 port to use
.IP "buf" 12
 the stuff to write
.IP "len" 12
 how many bytes in 'buf'
.SH "DESCRIPTION"
actually written. Called from transmit_chars
.TH "disable_intrs" 9 "disable_intrs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_intrs \-  disable interrupts
.SH SYNOPSIS
.B "void" disable_intrs
.BI "(struct ioc4_port *" port ","
.BI "uint32_t " mask ");"
.SH ARGUMENTS
.IP "port" 12
 port to enable
.IP "mask" 12
 mask to use
.TH "set_notification" 9 "set_notification" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_notification \-  Modify event notification
.SH SYNOPSIS
.B "int" set_notification
.BI "(struct ioc4_port *" port ","
.BI "int " mask ","
.BI "int " set_on ");"
.SH ARGUMENTS
.IP "port" 12
 port to use
.IP "mask" 12
 events mask
.IP "set_on" 12
 set ?
.TH "set_mcr" 9 "set_mcr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_mcr \-  set the master control reg
.SH SYNOPSIS
.B "int" set_mcr
.BI "(struct uart_port *" the_port ","
.BI "int " set ","
.BI "int " mask1 ","
.BI "int " mask2 ");"
.SH ARGUMENTS
.IP "the_port" 12
 port to use
.IP "set" 12
 set ?
.IP "mask1" 12
 mcr mask
.IP "mask2" 12
 shadow mask
.TH "ioc4_set_proto" 9 "ioc4_set_proto" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_set_proto \-  set the protocol for the port
.SH SYNOPSIS
.B "int" ioc4_set_proto
.BI "(struct ioc4_port *" port ","
.BI "enum sio_proto " proto ");"
.SH ARGUMENTS
.IP "port" 12
 port to use
.IP "proto" 12
 protocol to use
.TH "transmit_chars" 9 "transmit_chars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transmit_chars \-  upper level write, called with ip_lock
.SH SYNOPSIS
.B "void" transmit_chars
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
 port to write
.TH "ioc4_change_speed" 9 "ioc4_change_speed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_change_speed \-  change the speed of the port
.SH SYNOPSIS
.B "void" ioc4_change_speed
.BI "(struct uart_port *" the_port ","
.BI "struct termios *" new_termios ","
.BI "struct termios *" old_termios ");"
.SH ARGUMENTS
.IP "the_port" 12
 port to change
.IP "new_termios" 12
 new termios settings
.IP "old_termios" 12
 old termios settings
.TH "ic4_startup_local" 9 "ic4_startup_local" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_startup_local \-  Start up the serial port - returns \\\gt;= 0 if no errors
.SH SYNOPSIS
.B "int" ic4_startup_local
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
 Port to operate on
.TH "handle_intr" 9 "handle_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
handle_intr \-  service any interrupts for the given port - 2nd level
.SH SYNOPSIS
.B "void" handle_intr
.BI "(void *" arg ","
.BI "uint32_t " sio_ir ");"
.SH ARGUMENTS
.IP "arg" 12
 handler arg
.IP "sio_ir" 12
 ioc4regs
.SH "DESCRIPTION"
called via sd_intr
.TH "do_read" 9 "do_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_read \-  Read in bytes from the port.  Return the number of bytes
.SH SYNOPSIS
.B "int" do_read
.BI "(struct uart_port *" the_port ","
.BI "unsigned char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "the_port" 12
 port to use
.IP "buf" 12
 place to put the stuff we read
.IP "len" 12
 how big 'buf' is
.SH "DESCRIPTION"
actually read.
.TH "receive_chars" 9 "receive_chars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
receive_chars \-  upper level read. Called with ip_lock.
.SH SYNOPSIS
.B "void" receive_chars
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
 port to read from
.TH "ic4_type" 9 "ic4_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_type \-  What type of console are we?
.SH SYNOPSIS
.B "const char *" ic4_type
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "ic4_tx_empty" 9 "ic4_tx_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_tx_empty \-  Is the transmitter empty?  We pretend we're always empty
.SH SYNOPSIS
.B "unsigned int" ic4_tx_empty
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "ic4_stop_tx" 9 "ic4_stop_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_stop_tx \-  stop the transmitter
.SH SYNOPSIS
.B "void" ic4_stop_tx
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "null_void_function" 9 "null_void_function" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
null_void_function \- 
.SH SYNOPSIS
.B "void" null_void_function
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "ic4_shutdown" 9 "ic4_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_shutdown \-  shut down the port - free irq and disable
.SH SYNOPSIS
.B "void" ic4_shutdown
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "ic4_set_mctrl" 9 "ic4_set_mctrl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_set_mctrl \-  set control lines (dtr, rts, etc)
.SH SYNOPSIS
.B "void" ic4_set_mctrl
.BI "(struct uart_port *" the_port ","
.BI "unsigned int " mctrl ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.IP "mctrl" 12
 Lines to set/unset
.TH "ic4_get_mctrl" 9 "ic4_get_mctrl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_get_mctrl \-  get control line info
.SH SYNOPSIS
.B "unsigned int" ic4_get_mctrl
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "ic4_start_tx" 9 "ic4_start_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_start_tx \-  Start transmitter, flush any output
.SH SYNOPSIS
.B "void" ic4_start_tx
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "ic4_break_ctl" 9 "ic4_break_ctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_break_ctl \-  handle breaks
.SH SYNOPSIS
.B "void" ic4_break_ctl
.BI "(struct uart_port *" the_port ","
.BI "int " break_state ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.IP "break_state" 12
 Break state
.TH "ic4_startup" 9 "ic4_startup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_startup \-  Start up the serial port - always return 0 (We're always on)
.SH SYNOPSIS
.B "int" ic4_startup
.BI "(struct uart_port *" the_port ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.TH "ic4_set_termios" 9 "ic4_set_termios" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_set_termios \-  set termios stuff
.SH SYNOPSIS
.B "void" ic4_set_termios
.BI "(struct uart_port *" the_port ","
.BI "struct termios *" termios ","
.BI "struct termios *" old_termios ");"
.SH ARGUMENTS
.IP "the_port" 12
-- undescribed --
.IP "termios" 12
 Old
.IP "old_termios" 12
-- undescribed --
.TH "ic4_request_port" 9 "ic4_request_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ic4_request_port \-  allocate resources for port - no op....
.SH SYNOPSIS
.B "int" ic4_request_port
.BI "(struct uart_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 port to operate on
.TH "ioc4_serial_core_attach" 9 "ioc4_serial_core_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_serial_core_attach \-  register with serial core
.SH SYNOPSIS
.B "int" ioc4_serial_core_attach
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 handle for this card
.SH "DESCRIPTION"
This is done during pci probing
.TH "ioc4_serial_attach_one" 9 "ioc4_serial_attach_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_serial_attach_one \-  register attach function
.SH SYNOPSIS
.B "int" ioc4_serial_attach_one
.BI "(struct ioc4_driver_data *" idd ");"
.SH ARGUMENTS
.IP "idd" 12
 Master module data for this IOC4
.SH "DESCRIPTION"
called per card found from IOC4 master module.
.TH "ioc4_serial_remove_one" 9 "ioc4_serial_remove_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_serial_remove_one \-  detach function
.SH SYNOPSIS
.B "int" ioc4_serial_remove_one
.BI "(struct ioc4_driver_data *" idd ");"
.SH ARGUMENTS
.IP "idd" 12
 IOC4 master module data for this IOC4
.SH "DESCRIPTION"
.TH "ioc4_serial_init" 9 "ioc4_serial_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioc4_serial_init \-  module init
.SH SYNOPSIS
.B "int" ioc4_serial_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "ccio_alloc_range" 9 "ccio_alloc_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_alloc_range \-  Allocate pages in the ioc's resource map.
.SH SYNOPSIS
.B "int" ccio_alloc_range
.BI "(struct ioc *" ioc ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "ioc" 12
 The I/O Controller.
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
This function searches the resource map of the ioc to locate a range
of available pages for the requested size.
.TH "ccio_free_range" 9 "ccio_free_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_free_range \-  Free pages from the ioc's resource map.
.SH SYNOPSIS
.B "void" ccio_free_range
.BI "(struct ioc *" ioc ","
.BI "dma_addr_t " iova ","
.BI "unsigned long " pages_mapped ");"
.SH ARGUMENTS
.IP "ioc" 12
 The I/O Controller.
.IP "iova" 12
 The I/O Virtual Address.
.IP "pages_mapped" 12
 The requested number of pages to be freed from the
I/O Pdir.
.SH "DESCRIPTION"
This function frees the resouces allocated for the iova.
.TH "ccio_io_pdir_entry" 9 "ccio_io_pdir_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_io_pdir_entry \-  Initialize an I/O Pdir.
.SH SYNOPSIS
.B "void CCIO_INLINE" ccio_io_pdir_entry
.BI "(u64 *" pdir_ptr ","
.BI "space_t " sid ","
.BI "unsigned long " vba ","
.BI "unsigned long " hints ");"
.SH ARGUMENTS
.IP "pdir_ptr" 12
 A pointer into I/O Pdir.
.IP "sid" 12
 The Space Identifier.
.IP "vba" 12
 The virtual address.
.IP "hints" 12
 The DMA Hint.
.SH "DESCRIPTION"
Given a virtual address (vba, arg2) and space id, (sid, arg1),
load the I/O PDIR entry pointed to by pdir_ptr (arg0). Each IO Pdir
entry consists of 8 bytes as shown below (MSB == bit 0):
.SH "WORD 0"
+------+----------------+-----------------------------------------------+
| Phys | Virtual Index  |               Phys                            |
| 0:3  |     0:11       |               4:19                            |
|4 bits|   12 bits      |              16 bits                          |
+------+----------------+-----------------------------------------------+
.SH "WORD 1"
+-----------------------+-----------------------------------------------+
|      Phys    |  Rsvd  | Prefetch |Update |Rsvd  |Lock  |Safe  |Valid  |
|     20:39    |        | Enable   |Enable |      |Enable|DMA   |       |
|    20 bits   | 5 bits | 1 bit    |1 bit  |2 bits|1 bit |1 bit |1 bit  |
+-----------------------+-----------------------------------------------+

The virtual index field is filled with the results of the LCI
(Load Coherence Index) instruction.  The 8 bits used for the virtual
.SH "INDEX ARE BITS 12"
19 of the value returned by LCI.
.TH "ccio_clear_io_tlb" 9 "ccio_clear_io_tlb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_clear_io_tlb \-  Remove stale entries from the I/O TLB.
.SH SYNOPSIS
.B "CCIO_INLINE void" ccio_clear_io_tlb
.BI "(struct ioc *" ioc ","
.BI "dma_addr_t " iovp ","
.BI "size_t " byte_cnt ");"
.SH ARGUMENTS
.IP "ioc" 12
 The I/O Controller.
.IP "iovp" 12
 The I/O Virtual Page.
.IP "byte_cnt" 12
 The requested number of bytes to be freed from the I/O Pdir.
.SH "DESCRIPTION"
Purge invalid I/O PDIR entries from the I/O TLB.
.SH "FIXME"
 Can we change the byte_cnt to pages_mapped?
.TH "ccio_mark_invalid" 9 "ccio_mark_invalid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_mark_invalid \-  Mark the I/O Pdir entries invalid.
.SH SYNOPSIS
.B "CCIO_INLINE void" ccio_mark_invalid
.BI "(struct ioc *" ioc ","
.BI "dma_addr_t " iova ","
.BI "size_t " byte_cnt ");"
.SH ARGUMENTS
.IP "ioc" 12
 The I/O Controller.
.IP "iova" 12
 The I/O Virtual Address.
.IP "byte_cnt" 12
 The requested number of bytes to be freed from the I/O Pdir.
.SH "DESCRIPTION"
Mark the I/O Pdir entries invalid and blow away the corresponding I/O
TLB entries.
.SH "FIXME"
 Can we change byte_cnt to pages_mapped?
.SH "FIXME"
 Can we change byte_cnt to pages_mapped?
.SH "FIXME"
 Can we change byte_cnt to pages_mapped?
.TH "ccio_dma_supported" 9 "ccio_dma_supported" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_dma_supported \-  Verify the IOMMU supports the DMA address range.
.SH SYNOPSIS
.B "int" ccio_dma_supported
.BI "(struct device *" dev ","
.BI "u64 " mask ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device.
.IP "mask" 12
 A bit mask describing the DMA address range of the device.
.SH "DESCRIPTION"
This function implements the pci_dma_supported function.
.TH "ccio_map_single" 9 "ccio_map_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_map_single \-  Map an address range into the IOMMU.
.SH SYNOPSIS
.B "dma_addr_t" ccio_map_single
.BI "(struct device *" dev ","
.BI "void *" addr ","
.BI "size_t " size ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device.
.IP "addr" 12
 The start address of the DMA region.
.IP "size" 12
 The length of the DMA region.
.IP "direction" 12
 The direction of the DMA transaction (to/from device).
.SH "DESCRIPTION"
This function implements the pci_map_single function.
.TH "ccio_unmap_single" 9 "ccio_unmap_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_unmap_single \-  Unmap an address range from the IOMMU.
.SH SYNOPSIS
.B "void" ccio_unmap_single
.BI "(struct device *" dev ","
.BI "dma_addr_t " iova ","
.BI "size_t " size ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device.
.IP "iova" 12
-- undescribed --
.IP "size" 12
 The length of the DMA region.
.IP "direction" 12
 The direction of the DMA transaction (to/from device).
.SH "DESCRIPTION"
This function implements the pci_unmap_single function.
.TH "ccio_alloc_consistent" 9 "ccio_alloc_consistent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_alloc_consistent \-  Allocate a consistent DMA mapping.
.SH SYNOPSIS
.B "void *" ccio_alloc_consistent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "dma_addr_t *" dma_handle ","
.BI "int " flag ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device.
.IP "size" 12
 The length of the DMA region.
.IP "dma_handle" 12
 The DMA address handed back to the device (not the cpu).
.IP "flag" 12
-- undescribed --
.SH "DESCRIPTION"
This function implements the pci_alloc_consistent function.
.TH "ccio_free_consistent" 9 "ccio_free_consistent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_free_consistent \-  Free a consistent DMA mapping.
.SH SYNOPSIS
.B "void" ccio_free_consistent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "void *" cpu_addr ","
.BI "dma_addr_t " dma_handle ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device.
.IP "size" 12
 The length of the DMA region.
.IP "cpu_addr" 12
 The cpu address returned from the ccio_alloc_consistent.
.IP "dma_handle" 12
 The device address returned from the ccio_alloc_consistent.
.SH "DESCRIPTION"
This function implements the pci_free_consistent function.
.TH "ccio_map_sg" 9 "ccio_map_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_map_sg \-  Map the scatter/gather list into the IOMMU.
.SH SYNOPSIS
.B "int" ccio_map_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sglist ","
.BI "int " nents ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device.
.IP "sglist" 12
 The scatter/gather list to be mapped in the IOMMU.
.IP "nents" 12
 The number of entries in the scatter/gather list.
.IP "direction" 12
 The direction of the DMA transaction (to/from device).
.SH "DESCRIPTION"
This function implements the pci_map_sg function.
.TH "ccio_unmap_sg" 9 "ccio_unmap_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_unmap_sg \-  Unmap the scatter/gather list from the IOMMU.
.SH SYNOPSIS
.B "void" ccio_unmap_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sglist ","
.BI "int " nents ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device.
.IP "sglist" 12
 The scatter/gather list to be unmapped from the IOMMU.
.IP "nents" 12
 The number of entries in the scatter/gather list.
.IP "direction" 12
 The direction of the DMA transaction (to/from device).
.SH "DESCRIPTION"
This function implements the pci_unmap_sg function.
.TH "ccio_find_ioc" 9 "ccio_find_ioc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_find_ioc \-  Find the ioc in the ioc_list
.SH SYNOPSIS
.B "struct ioc *" ccio_find_ioc
.BI "(int " hw_path ");"
.SH ARGUMENTS
.IP "hw_path" 12
 The hardware path of the ioc.
.SH "DESCRIPTION"
This function searches the ioc_list for an ioc that matches
the provide hardware path.
.TH "ccio_get_iommu" 9 "ccio_get_iommu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_get_iommu \-  Find the iommu which controls this device
.SH SYNOPSIS
.B "void *" ccio_get_iommu
.BI "(const struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The parisc device.
.SH "DESCRIPTION"
This function searches through the registered IOMMU's and returns
the appropriate IOMMU for the device based on its hardware path.
.TH "ccio_ioc_init" 9 "ccio_ioc_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_ioc_init \-  Initalize the I/O Controller
.SH SYNOPSIS
.B "void" ccio_ioc_init
.BI "(struct ioc *" ioc ");"
.SH ARGUMENTS
.IP "ioc" 12
 The I/O Controller.
.SH "DESCRIPTION"
Initalize the I/O Controller which includes setting up the
I/O Page Directory, the resource map, and initalizing the
U2/Uturn chip into virtual mode.
.TH "ccio_probe" 9 "ccio_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_probe \-  Determine if ccio should claim this device.
.SH SYNOPSIS
.B "int" ccio_probe
.BI "(struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The device which has been found
.SH "DESCRIPTION"
Determine if ccio should claim this chip (return 0) or not (return 1).
If so, initialize the chip and tell other partners in crime they
have work to do.
.TH "ccio_init" 9 "ccio_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ccio_init \-  ccio initalization procedure.
.SH SYNOPSIS
.B "void __init" ccio_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Register this driver.
.TH "sba_dump_ranges" 9 "sba_dump_ranges" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dump_ranges \-  debugging only - print ranges assigned to this IOA
.SH SYNOPSIS
.B "void" sba_dump_ranges
.BI "(void __iomem *" hpa ");"
.SH ARGUMENTS
.IP "hpa" 12
 base address of the sba
.SH "DESCRIPTION"
Print the MMIO and IO Port address ranges forwarded by an Astro/Ike/RIO
IO Adapter (aka Bus Converter).
.TH "sba_dump_tlb" 9 "sba_dump_tlb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dump_tlb \-  debugging only - print IOMMU operating parameters
.SH SYNOPSIS
.B "void" sba_dump_tlb
.BI "(void __iomem *" hpa ");"
.SH ARGUMENTS
.IP "hpa" 12
 base address of the IOMMU
.SH "DESCRIPTION"
Print the size/location of the IO MMU PDIR.
.TH "sba_dump_pdir_entry" 9 "sba_dump_pdir_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dump_pdir_entry \-  debugging only - print one IOMMU PDIR entry
.SH SYNOPSIS
.B "void" sba_dump_pdir_entry
.BI "(struct ioc *" ioc ","
.BI "char *" msg ","
.BI "uint " pide ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "msg" 12
 text to print ont the output line.
.IP "pide" 12
 pdir index.
.SH "DESCRIPTION"
Print one entry of the IO MMU PDIR in human readable form.
.TH "sba_check_pdir" 9 "sba_check_pdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_check_pdir \-  debugging only - consistency checker
.SH SYNOPSIS
.B "int" sba_check_pdir
.BI "(struct ioc *" ioc ","
.BI "char *" msg ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "msg" 12
 text to print ont the output line.
.SH "DESCRIPTION"
Verify the resource map and pdir state is consistent
.TH "sba_dump_sg" 9 "sba_dump_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dump_sg \-  debugging only - print Scatter-Gather list
.SH SYNOPSIS
.B "void" sba_dump_sg
.BI "(struct ioc *" ioc ","
.BI "struct scatterlist *" startsg ","
.BI "int " nents ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "startsg" 12
 head of the SG list
.IP "nents" 12
 number of entries in SG list
.SH "DESCRIPTION"
print the SG list so we can verify it's correct by hand.
.TH "sba_search_bitmap" 9 "sba_search_bitmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_search_bitmap \-  find free space in IO PDIR resource bitmap
.SH SYNOPSIS
.B "SBA_INLINE unsigned long" sba_search_bitmap
.BI "(struct ioc *" ioc ","
.BI "unsigned long " bits_wanted ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "bits_wanted" 12
 number of entries we need.
.SH "DESCRIPTION"
Find consecutive free bits in resource bitmap.
Each bit represents one entry in the IO Pdir.
.SH "COOL PERF OPTIMIZATION"
 search for log2(size) bits at a time.
.TH "sba_alloc_range" 9 "sba_alloc_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_alloc_range \-  find free bits and mark them in IO PDIR resource bitmap
.SH SYNOPSIS
.B "int" sba_alloc_range
.BI "(struct ioc *" ioc ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "size" 12
 number of bytes to create a mapping for
.SH "DESCRIPTION"
Given a size, find consecutive unmarked and then mark those bits in the
resource bit map.
.TH "sba_free_range" 9 "sba_free_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_free_range \-  unmark bits in IO PDIR resource bitmap
.SH SYNOPSIS
.B "SBA_INLINE void" sba_free_range
.BI "(struct ioc *" ioc ","
.BI "dma_addr_t " iova ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "iova" 12
 IO virtual address which was previously allocated.
.IP "size" 12
 number of bytes to create a mapping for
.SH "DESCRIPTION"
clear bits in the ioc's resource map
.TH "sba_io_pdir_entry" 9 "sba_io_pdir_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_io_pdir_entry \-  fill in one IO PDIR entry
.SH SYNOPSIS
.B "void SBA_INLINE" sba_io_pdir_entry
.BI "(u64 *" pdir_ptr ","
.BI "space_t " sid ","
.BI "unsigned long " vba ","
.BI "unsigned long " hint ");"
.SH ARGUMENTS
.IP "pdir_ptr" 12
  pointer to IO PDIR entry
.IP "sid" 12
 process Space ID - currently only support KERNEL_SPACE
.IP "vba" 12
 Virtual CPU address of buffer to map
.IP "hint" 12
 DMA hint set to use for this mapping
.SH "DESCRIPTION"
SBA Mapping Routine

Given a virtual address (vba, arg2) and space id, (sid, arg1)
\fBsba_io_pdir_entry\fP loads the I/O PDIR entry pointed to by
pdir_ptr (arg0). 
Using the bass-ackwards HP bit numbering, Each IO Pdir entry
for Astro/Ike looks like:


0                    19                                 51   55       63
+-+---------------------+----------------------------------+----+--------+
|V|        U            |            PPN[43:12]            | U  |   VI   |
+-+---------------------+----------------------------------+----+--------+

Pluto is basically identical, supports fewer physical address bits:

0                       23                              51   55       63
+-+------------------------+-------------------------------+----+--------+
|V|        U               |         PPN[39:12]            | U  |   VI   |
+-+------------------------+-------------------------------+----+--------+

V  == Valid Bit  (Most Significant Bit is bit 0)
U  == Unused
PPN == Physical Page Number
VI  == Virtual Index (aka Coherent Index)

LPA instruction output is put into PPN field.
LCI (Load Coherence Index) instruction provides the "VI" bits.

We pre-swap the bytes since PCX-W is Big Endian and the
IOMMU uses little endian for the pdir.
.TH "sba_mark_invalid" 9 "sba_mark_invalid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_mark_invalid \-  invalidate one or more IO PDIR entries
.SH SYNOPSIS
.B "SBA_INLINE void" sba_mark_invalid
.BI "(struct ioc *" ioc ","
.BI "dma_addr_t " iova ","
.BI "size_t " byte_cnt ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "iova" 12
  IO Virtual Address mapped earlier
.IP "byte_cnt" 12
  number of bytes this mapping covers.
.SH "DESCRIPTION"
Marking the IO PDIR entry(ies) as Invalid and invalidate
corresponding IO TLB entry. The Ike PCOM (Purge Command Register)
is to purge stale entries in the IO TLB when unmapping entries.

The PCOM register supports purging of multiple pages, with a minium
of 1 page and a maximum of 2GB. Hardware requires the address be
aligned to the size of the range being purged. The size of the range
must be a power of 2. The "Cool perf optimization" in the
allocation routine helps keep that true.
.TH "sba_dma_supported" 9 "sba_dma_supported" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dma_supported \-  PCI driver can query DMA support
.SH SYNOPSIS
.B "int" sba_dma_supported
.BI "(struct device *" dev ","
.BI "u64 " mask ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking
.IP "mask" 12
  number of address bits this PCI device can handle
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_map_single" 9 "sba_map_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_map_single \-  map one buffer and return IOVA for DMA
.SH SYNOPSIS
.B "dma_addr_t" sba_map_single
.BI "(struct device *" dev ","
.BI "void *" addr ","
.BI "size_t " size ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "addr" 12
  driver buffer to map.
.IP "size" 12
  number of bytes to map in driver buffer.
.IP "direction" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_unmap_single" 9 "sba_unmap_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_unmap_single \-  unmap one IOVA and free resources
.SH SYNOPSIS
.B "void" sba_unmap_single
.BI "(struct device *" dev ","
.BI "dma_addr_t " iova ","
.BI "size_t " size ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "iova" 12
  IOVA of driver buffer previously mapped.
.IP "size" 12
  number of bytes mapped in driver buffer.
.IP "direction" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_alloc_consistent" 9 "sba_alloc_consistent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_alloc_consistent \-  allocate/map shared mem for DMA
.SH SYNOPSIS
.B "void *" sba_alloc_consistent
.BI "(struct device *" hwdev ","
.BI "size_t " size ","
.BI "dma_addr_t *" dma_handle ","
.BI "int " gfp ");"
.SH ARGUMENTS
.IP "hwdev" 12
 instance of PCI owned by the driver that's asking.
.IP "size" 12
  number of bytes mapped in driver buffer.
.IP "dma_handle" 12
  IOVA of new buffer.
.IP "gfp" 12
-- undescribed --
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_free_consistent" 9 "sba_free_consistent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_free_consistent \-  free/unmap shared mem for DMA
.SH SYNOPSIS
.B "void" sba_free_consistent
.BI "(struct device *" hwdev ","
.BI "size_t " size ","
.BI "void *" vaddr ","
.BI "dma_addr_t " dma_handle ");"
.SH ARGUMENTS
.IP "hwdev" 12
 instance of PCI owned by the driver that's asking.
.IP "size" 12
  number of bytes mapped in driver buffer.
.IP "vaddr" 12
  virtual address IOVA of "consistent" buffer.
.IP "dma_handle" 12
-- undescribed --
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_map_sg" 9 "sba_map_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_map_sg \-  map Scatter/Gather list
.SH SYNOPSIS
.B "int" sba_map_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sglist ","
.BI "int " nents ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "sglist" 12
  array of buffer/length pairs
.IP "nents" 12
  number of entries in list
.IP "direction" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_unmap_sg" 9 "sba_unmap_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_unmap_sg \-  unmap Scatter/Gather list
.SH SYNOPSIS
.B "void" sba_unmap_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sglist ","
.BI "int " nents ","
.BI "enum dma_data_direction " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "sglist" 12
  array of buffer/length pairs
.IP "nents" 12
  number of entries in list
.IP "direction" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_get_iommu" 9 "sba_get_iommu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_get_iommu \-  Assign the iommu pointer for the pci bus controller.
.SH SYNOPSIS
.B "void *" sba_get_iommu
.BI "(struct parisc_device *" pci_hba ");"
.SH ARGUMENTS
.IP "pci_hba" 12
-- undescribed --
.SH "DESCRIPTION"
Returns the appropriate IOMMU data for the given parisc PCI controller.
This is cached and used later for PCI DMA Mapping.
.TH "sba_directed_lmmio" 9 "sba_directed_lmmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_directed_lmmio \-  return first directed LMMIO range routed to rope
.SH SYNOPSIS
.B "void" sba_directed_lmmio
.BI "(struct parisc_device *" pci_hba ","
.BI "struct resource *" r ");"
.SH ARGUMENTS
.IP "pci_hba" 12
-- undescribed --
.IP "r" 12
 resource PCI host controller wants start/end fields assigned.
.SH "DESCRIPTION"
For the given parisc PCI controller, determine if any direct ranges
are routed down the corresponding rope.
.TH "sba_distributed_lmmio" 9 "sba_distributed_lmmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_distributed_lmmio \-  return portion of distributed LMMIO range
.SH SYNOPSIS
.B "void" sba_distributed_lmmio
.BI "(struct parisc_device *" pci_hba ","
.BI "struct resource *" r ");"
.SH ARGUMENTS
.IP "pci_hba" 12
-- undescribed --
.IP "r" 12
 resource PCI host controller wants start/end fields assigned.
.SH "DESCRIPTION"
For the given parisc PCI controller, return portion of distributed LMMIO
range. The distributed LMMIO is always present and it's just a question
of the base address and size of the range.
.TH "hppb_probe" 9 "hppb_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hppb_probe \-  Determine if the hppb driver should claim this device.
.SH SYNOPSIS
.B "int" hppb_probe
.BI "(struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The device which has been found
.SH "DESCRIPTION"
Determine if hppb driver should claim this chip (return 0) or not 
(return 1). If so, initialize the chip and tell other partners in crime 
they have work to do.
.TH "hppb_init" 9 "hppb_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hppb_init \-  HP-PB bus initalization procedure.
.SH SYNOPSIS
.B "void __init" hppb_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Register this driver.   
.TH "iommu_fill_pdir" 9 "iommu_fill_pdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iommu_fill_pdir \-  Insert coalesced scatter/gather chunks into the I/O Pdir.
.SH SYNOPSIS
.B "unsigned int" iommu_fill_pdir
.BI "(struct ioc *" ioc ","
.BI "struct scatterlist *" startsg ","
.BI "int " nents ","
.BI "unsigned long " hint ","
.BI "void (*" iommu_io_pdir_entry ") (u64 *, space_t, unsigned long, 					    unsigned long));"
.SH ARGUMENTS
.IP "ioc" 12
 The I/O Controller.
.IP "startsg" 12
 The scatter/gather list of coalesced chunks.
.IP "nents" 12
 The number of entries in the scatter/gather list.
.IP "hint" 12
 The DMA Hint.
.IP "iommu_io_pdir_entry" 12
-- undescribed --
.SH "DESCRIPTION"
This function inserts the coalesced scatter/gather list chunks into the
I/O Controller's I/O Pdir.
.TH "pdcspath_fetch" 9 "pdcspath_fetch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_fetch \-  This function populates the path entry structs.
.SH SYNOPSIS
.B "int" pdcspath_fetch
.BI "(struct pdcspath_entry *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 A pointer to an allocated pdcspath_entry.
.SH "DESCRIPTION"
The general idea is that you don't read from the Stable Storage every time
you access the files provided by the facilites. We store a copy of the
content of the stable storage WRT various paths in these structs. We read
these structs when reading the files, and we will write to these structs when
writing to the files, and only then write them back to the Stable Storage.
.TH "pdcspath_store" 9 "pdcspath_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_store \-  This function writes a path to stable storage.
.SH SYNOPSIS
.B "int" pdcspath_store
.BI "(struct pdcspath_entry *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 A pointer to an allocated pdcspath_entry.
.SH "IT CAN BE USED IN TWO WAYS"
 either by passing it a preset devpath struct
containing an already computed hardware path, or by passing it a device
pointer, from which it'll find out the corresponding hardware path.
For now we do not handle the case where there's an error in writing to the
Stable Storage area, so you'd better not mess up the data :P
.TH "pdcspath_hwpath_read" 9 "pdcspath_hwpath_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_hwpath_read \-  This function handles hardware path pretty printing.
.SH SYNOPSIS
.B "ssize_t" pdcspath_hwpath_read
.BI "(struct pdcspath_entry *" entry ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "entry" 12
 An allocated and populated pdscpath_entry struct.
.IP "buf" 12
 The output buffer to write to.
.SH "DESCRIPTION"
We will call this function to format the output of the hwpath attribute file.
.TH "pdcspath_hwpath_write" 9 "pdcspath_hwpath_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_hwpath_write \-  This function handles hardware path modifying.
.SH SYNOPSIS
.B "ssize_t" pdcspath_hwpath_write
.BI "(struct pdcspath_entry *" entry ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "entry" 12
 An allocated and populated pdscpath_entry struct.
.IP "buf" 12
 The input buffer to read from.
.IP "count" 12
 The number of bytes to be read.
.SH "DESCRIPTION"
We will call this function to change the current hardware path.
Hardware paths are to be given '/'-delimited, without brackets.
We take care to make sure that the provided path actually maps to an existing
device, BUT nothing would prevent some foolish user to set the path to some
PCI bridge or even a CPU...
A better work around would be to make sure we are at the end of a device tree
for instance, but it would be IMHO beyond the simple scope of that driver.
The aim is to provide a facility. Data correctness is left to userland.
.TH "pdcspath_layer_read" 9 "pdcspath_layer_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_layer_read \-  Extended layer (eg. SCSI ids) pretty printing.
.SH SYNOPSIS
.B "ssize_t" pdcspath_layer_read
.BI "(struct pdcspath_entry *" entry ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "entry" 12
 An allocated and populated pdscpath_entry struct.
.IP "buf" 12
 The output buffer to write to.
.SH "DESCRIPTION"
We will call this function to format the output of the layer attribute file.
.TH "pdcspath_layer_write" 9 "pdcspath_layer_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_layer_write \-  This function handles extended layer modifying.
.SH SYNOPSIS
.B "ssize_t" pdcspath_layer_write
.BI "(struct pdcspath_entry *" entry ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "entry" 12
 An allocated and populated pdscpath_entry struct.
.IP "buf" 12
 The input buffer to read from.
.IP "count" 12
 The number of bytes to be read.
.SH "DESCRIPTION"
We will call this function to change the current layer value.
Layers are to be given '.'-delimited, without brackets.
XXX beware we are far less checky WRT input data provided than for hwpath.
Potential harm can be done, since there's no way to check the validity of
the layer fields.
.TH "pdcspath_attr_show" 9 "pdcspath_attr_show" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_attr_show \-  Generic read function call wrapper.
.SH SYNOPSIS
.B "ssize_t" pdcspath_attr_show
.BI "(struct kobject *" kobj ","
.BI "struct attribute *" attr ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "kobj" 12
 The kobject to get info from.
.IP "attr" 12
 The attribute looked upon.
.IP "buf" 12
 The output buffer.
.TH "pdcspath_attr_store" 9 "pdcspath_attr_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcspath_attr_store \-  Generic write function call wrapper.
.SH SYNOPSIS
.B "ssize_t" pdcspath_attr_store
.BI "(struct kobject *" kobj ","
.BI "struct attribute *" attr ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "kobj" 12
 The kobject to write info to.
.IP "attr" 12
 The attribute to be modified.
.IP "buf" 12
 The input buffer.
.IP "count" 12
 The size of the buffer.
.TH "pdcs_info_read" 9 "pdcs_info_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcs_info_read \-  Pretty printing of the remaining useful data.
.SH SYNOPSIS
.B "ssize_t" pdcs_info_read
.BI "(struct subsystem *" entry ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "entry" 12
 An allocated and populated subsytem struct. We don't use it tho.
.IP "buf" 12
 The output buffer to write to.
.SH "DESCRIPTION"
We will call this function to format the output of the 'info' attribute file.
Please refer to PDC Procedures documentation, section PDC_STABLE to get a
better insight of what we're doing here.
.TH "pdcs_info_write" 9 "pdcs_info_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcs_info_write \-  This function handles boot flag modifying.
.SH SYNOPSIS
.B "ssize_t" pdcs_info_write
.BI "(struct subsystem *" entry ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "entry" 12
 An allocated and populated subsytem struct. We don't use it tho.
.IP "buf" 12
 The input buffer to read from.
.IP "count" 12
 The number of bytes to be read.
.SH "DESCRIPTION"
We will call this function to change the current boot flags.
.SH "WE EXPECT A PRECISE SYNTAX"
\"n n\" (n == 0 or 1) to toggle respectively AutoBoot and AutoSearch

As of now there is no incentive on my side to provide more "knobs" to that
interface, since modifying the rest of the data is pretty meaningless when
the machine is running and for the expected use of that facility, such as
PALO setting up the boot disk when installing a Linux distribution...
.TH "pdcs_register_pathentries" 9 "pdcs_register_pathentries" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcs_register_pathentries \-  Prepares path entries kobjects for sysfs usage.
.SH SYNOPSIS
.B "int __init" pdcs_register_pathentries
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

It creates kobjects corresponding to each path entry with nice sysfs
links to the real device. This is where the magic takes place: when
registering the subsystem attributes during module init, each kobject hereby
created will show in the sysfs tree as a folder containing files as defined
by path_subsys_attr[].
.TH "pdcs_unregister_pathentries" 9 "pdcs_unregister_pathentries" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdcs_unregister_pathentries \-  Routine called when unregistering the module.
.SH SYNOPSIS
.B "void __exit" pdcs_unregister_pathentries
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "iosapic_load_irt" 9 "iosapic_load_irt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iosapic_load_irt \-  Fill in the interrupt routing table
.SH SYNOPSIS
.B "int __init" iosapic_load_irt
.BI "(unsigned long " cell_num ","
.BI "struct irt_entry **" irt ");"
.SH ARGUMENTS
.IP "cell_num" 12
 The cell number of the CPU we're currently executing on
.IP "irt" 12
 The address to place the new IRT at
\fIreturn\fP The number of entries found
.SH "DESCRIPTION"
The "Get PCI INT Routing Table Size" option returns the number of 
entries in the PCI interrupt routing table for the cell specified 
in the cell_number argument.  The cell number must be for a cell 
within the caller's protection domain.

The "Get PCI INT Routing Table" option returns, for the cell 
specified in the cell_number argument, the PCI interrupt routing 
table in the caller allocated memory pointed to by mem_addr.
We assume the IRT only contains entries for I/O SAPIC and
calculate the size based on the size of I/O sapic entries.

The PCI interrupt routing table entry format is derived from the
IA64 SAL Specification 2.4.   The PCI interrupt routing table defines
the routing of PCI interrupt signals between the PCI device output
"pins" and the IO SAPICs' input "lines" (including core I/O PCI
devices).  This table does NOT include information for devices/slots
behind PCI to PCI bridges. See PCI to PCI Bridge Architecture Spec.
for the architected method of routing of IRQ's behind PPB's.
.TH "DEVID" 9 "DEVID" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
DEVID \- 
.SH SYNOPSIS
.B "" DEVID
.BI "(" _vend ","
.BI "" _dev ","
.BI "" _subvend ","
.BI "" _subdev ","
.BI "" mask ","
.BI "" bits ");"
.SH ARGUMENTS
.IP "_vend" 12
.IP "_dev" 12
.IP "_subvend" 12
.IP "_subdev" 12
.IP "mask" 12
.IP "bits" 12
.SH "DESCRIPTION"
have their own test registers and more important their own little problems.
Some fixup code to make everybody happy (TM).
.TH "socket_resume" 9 "socket_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
socket_resume \- level PCMCIA socket drivers need to register with the PCCard
.SH SYNOPSIS
.B "int" socket_resume
.BI "(struct pcmcia_socket *" skt ");"
.SH ARGUMENTS
.IP "skt" 12
-- undescribed --
.SH "DESCRIPTION"
core using pcmcia_register_socket.

socket drivers are expected to use the following callbacks in their
.drv struct:
- pcmcia_socket_dev_suspend
- pcmcia_socket_dev_resume
These functions check for the appropriate struct pcmcia_soket arrays,
and pass them to the low-level functions pcmcia_{suspend,resume}_socket
.TH "pcmcia_register_socket" 9 "pcmcia_register_socket" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcmcia_register_socket \-  add a new pcmcia socket device
.SH SYNOPSIS
.B "int" pcmcia_register_socket
.BI "(struct pcmcia_socket *" socket ");"
.SH ARGUMENTS
.IP "socket" 12
-- undescribed --
.TH "pcmcia_unregister_socket" 9 "pcmcia_unregister_socket" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcmcia_unregister_socket \-  remove a pcmcia socket device
.SH SYNOPSIS
.B "void" pcmcia_unregister_socket
.BI "(struct pcmcia_socket *" socket ");"
.SH ARGUMENTS
.IP "socket" 12
-- undescribed --
.TH "shutdown_socket" 9 "shutdown_socket" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shutdown_socket \- 
.SH SYNOPSIS
.B "void" shutdown_socket
.BI "(struct pcmcia_socket *" s ");"
.SH ARGUMENTS
.IP "s" 12
-- undescribed --
.SH "DESCRIPTION"
handler when card insertion and removal events are received.
\fBsocket_setup\fP turns on socket power and resets the socket, in two stages.
\fBshutdown_socket\fP unconfigures a socket and turns off socket power.
.TH "send_event" 9 "send_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
send_event \- 
.SH SYNOPSIS
.B "int" send_event
.BI "(struct pcmcia_socket *" s ","
.BI "event_t " event ","
.BI "int " priority ");"
.SH ARGUMENTS
.IP "s" 12
-- undescribed --
.IP "event" 12
-- undescribed --
.IP "priority" 12
-- undescribed --
.SH "DESCRIPTION"
16-bit subsystem, which then calls the relevant device drivers.
\fBParse_events\fP interprets the event bits from
a card status change report.  \fBDo_shutdown\fP handles the high
priority stuff associated with a card removal.
.TH "pcmcia_load_firmware" 9 "pcmcia_load_firmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcmcia_load_firmware \-  load CIS from userspace if device-provided is broken
.SH SYNOPSIS
.B "int" pcmcia_load_firmware
.BI "(struct pcmcia_device *" dev ","
.BI "char *" filename ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "filename" 12
-- undescribed --
.SH "DESCRIPTION"
\fIdev\fP - the pcmcia device which needs a CIS override
\fIfilename\fP - requested filename in /lib/firmware/cis/

This uses the in-kernel firmware loading mechanism to use a "fake CIS" if
the one provided by the card is broken. The firmware files reside in
/lib/firmware/cis/ in userspace.
.TH "pcmcia_device_probe" 9 "pcmcia_device_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcmcia_device_probe \-  register a PCMCIA driver with the bus core
.SH SYNOPSIS
.B "int" pcmcia_device_probe
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Registers a PCMCIA driver with the PCMCIA bus core.
.TH "pcmcia_unregister_driver" 9 "pcmcia_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcmcia_unregister_driver \-  unregister a PCMCIA driver with the bus core
.SH SYNOPSIS
.B "void" pcmcia_unregister_driver
.BI "(struct pcmcia_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.TH "show_available_freqs" 9 "show_available_freqs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
show_available_freqs \-  show the current policy for the specified CPU
.SH SYNOPSIS
.B "ssize_t" show_available_freqs
.BI "(struct cpufreq_policy *" policy ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "policy" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.TH "superhyway_add_device" 9 "superhyway_add_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
superhyway_add_device \-  Add a SuperHyway module
.SH SYNOPSIS
.B "int" superhyway_add_device
.BI "(unsigned int " mod_id ","
.BI "unsigned long " base ","
.BI "unsigned long long " vcr ");"
.SH ARGUMENTS
.IP "mod_id" 12
 Module ID (taken from MODULE.VCR.MOD_ID).
.IP "base" 12
 Physical address where module is mapped.
.IP "vcr" 12
 VCR value.
.SH "DESCRIPTION"
This is responsible for adding a new SuperHyway module. This sets up a new
struct superhyway_device for the module being added. Each one of \fImod_id\fP,
\fIbase\fP, and \fIvcr\fP are registered with the new device for further use
elsewhere.

Devices are initially added in the order that they are scanned (from the
top-down of the memory map), and are assigned an ID based on the order that
they are added. Any manual addition of a module will thus get the ID after
the devices already discovered regardless of where it resides in memory.

Further work can and should be done in \fBsuperhyway_scan_bus\fP, to be sure
that any new modules are properly discovered and subsequently registered.
.TH "superhyway_register_driver" 9 "superhyway_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
superhyway_register_driver \-  Register a new SuperHyway driver
.SH SYNOPSIS
.B "int" superhyway_register_driver
.BI "(struct superhyway_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 SuperHyway driver to register.
.SH "DESCRIPTION"
This registers the passed in \fIdrv\fP. Any devices matching the id table will
automatically be populated and handed off to the driver's specified probe
routine.
.TH "superhyway_unregister_driver" 9 "superhyway_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
superhyway_unregister_driver \-  Unregister a SuperHyway driver
.SH SYNOPSIS
.B "void" superhyway_unregister_driver
.BI "(struct superhyway_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 SuperHyway driver to unregister.
.SH "DESCRIPTION"
This cleans up after \fBsuperhyway_register_driver\fP, and should be invoked in
the exit path of any module drivers.
.TH "macio_release_dev" 9 "macio_release_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_release_dev \-  free a macio device structure when all users of it are finished.
.SH SYNOPSIS
.B "void" macio_release_dev
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device that's been disconnected
.SH "DESCRIPTION"
Will be called only by the device core when all users of this macio device are
done. This currently means never as we don't hot remove any macio device yet,
though that will happen with mediabay based devices in a later implementation.
.TH "macio_resource_quirks" 9 "macio_resource_quirks" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_resource_quirks \-  tweak or skip some resources for a device
.SH SYNOPSIS
.B "int" macio_resource_quirks
.BI "(struct device_node *" np ","
.BI "struct resource *" res ","
.BI "int " index ");"
.SH ARGUMENTS
.IP "np" 12
 pointer to the device node
.IP "res" 12
 resulting resource
.IP "index" 12
 index of resource in node
.SH "DESCRIPTION"
If this routine returns non-null, then the resource is completely
skipped.
.TH "macio_add_one_device" 9 "macio_add_one_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_add_one_device \-  Add one device from OF node to the device tree
.SH SYNOPSIS
.B "struct macio_dev *" macio_add_one_device
.BI "(struct macio_chip *" chip ","
.BI "struct device *" parent ","
.BI "struct device_node *" np ","
.BI "struct macio_dev *" in_bay ","
.BI "struct resource *" parent_res ");"
.SH ARGUMENTS
.IP "chip" 12
 pointer to the macio_chip holding the device
.IP "parent" 12
-- undescribed --
.IP "np" 12
 pointer to the device node in the OF tree
.IP "in_bay" 12
 set to 1 if device is part of a media-bay
.IP "parent_res" 12
-- undescribed --
.SH "DESCRIPTION"
When media-bay is changed to hotswap drivers, this function will
be exposed to the bay driver some way...
.TH "macio_pci_add_devices" 9 "macio_pci_add_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_pci_add_devices \-  Adds sub-devices of mac-io to the device tree
.SH SYNOPSIS
.B "void" macio_pci_add_devices
.BI "(struct macio_chip *" chip ");"
.SH ARGUMENTS
.IP "chip" 12
 pointer to the macio_chip holding the devices
.SH "DESCRIPTION"
This function will do the job of extracting devices from the
Open Firmware device tree, build macio_dev structures and add
them to the Linux device tree.

For now, childs of media-bay are added now as well. This will
change rsn though.
.TH "macio_register_driver" 9 "macio_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_register_driver \-  Registers a new MacIO device driver
.SH SYNOPSIS
.B "int" macio_register_driver
.BI "(struct macio_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to the driver definition structure
.TH "macio_unregister_driver" 9 "macio_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_unregister_driver \-  Unregisters a new MacIO device driver
.SH SYNOPSIS
.B "void" macio_unregister_driver
.BI "(struct macio_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to the driver definition structure
.TH "macio_request_resource" 9 "macio_request_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_request_resource \-  Request an MMIO resource
.SH SYNOPSIS
.B "int" macio_request_resource
.BI "(struct macio_dev *" dev ","
.BI "int " resource_no ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the device holding the resource
.IP "resource_no" 12
 resource number to request
.IP "name" 12
 resource name
.SH "DESCRIPTION"
Mark  memory region number \fIresource_no\fP associated with MacIO
device \fIdev\fP as being reserved by owner \fIname\fP.  Do not access
any address inside the memory regions unless this call returns
successfully.

Returns 0 on success, or EBUSY on error.  A warning
message is also printed on failure.
.TH "macio_release_resource" 9 "macio_release_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_release_resource \-  Release an MMIO resource
.SH SYNOPSIS
.B "void" macio_release_resource
.BI "(struct macio_dev *" dev ","
.BI "int " resource_no ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the device holding the resource
.IP "resource_no" 12
 resource number to release
.TH "macio_request_resources" 9 "macio_request_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_request_resources \-  Reserve all memory resources
.SH SYNOPSIS
.B "int" macio_request_resources
.BI "(struct macio_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 MacIO device whose resources are to be reserved
.IP "name" 12
 Name to be associated with resource.
.SH "DESCRIPTION"
Mark all memory regions associated with MacIO device \fIdev\fP as
being reserved by owner \fIname\fP.  Do not access any address inside
the memory regions unless this call returns successfully.

Returns 0 on success, or EBUSY on error.  A warning
message is also printed on failure.
.TH "macio_release_resources" 9 "macio_release_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
macio_release_resources \-  Release reserved memory resources
.SH SYNOPSIS
.B "void" macio_release_resources
.BI "(struct macio_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 MacIO device whose resources were previously reserved
.TH "mca_set_adapter_procfn" 9 "mca_set_adapter_procfn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_set_adapter_procfn \-  Set the /proc callback
.SH SYNOPSIS
.B "void" mca_set_adapter_procfn
.BI "(int " slot ","
.BI "MCA_ProcFn " procfn ","
.BI "void *" proc_dev ");"
.SH ARGUMENTS
.IP "slot" 12
 slot to configure
.IP "procfn" 12
 callback function to call for /proc
.IP "proc_dev" 12
-- undescribed --
.SH "DESCRIPTION"
This sets up an information callback for /proc/mca/slot?.  The
function is called with the buffer, slot, and device pointer (or
some equally informative context information, or nothing, if you
prefer), and is expected to put useful information into the
buffer.  The adapter name, ID, and POS registers get printed
before this is called though, so don't do it again.

This should be called with a NULL \fIprocfn\fP when a module
unregisters, thus preventing kernel crashes and other such
nastiness.
.TH "mca_device_read_stored_pos" 9 "mca_device_read_stored_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_read_stored_pos \-  read POS register from stored data
.SH SYNOPSIS
.B "unsigned char" mca_device_read_stored_pos
.BI "(struct mca_device *" mca_dev ","
.BI "int " reg ");"
.SH ARGUMENTS
.IP "mca_dev" 12
 device to read from
.IP "reg" 12
  register to read from
.SH "DESCRIPTION"
Fetch a POS value that was stored at boot time by the kernel
when it scanned the MCA space. The register value is returned.
Missing or invalid registers report 0.
.TH "mca_device_read_pos" 9 "mca_device_read_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_read_pos \-  read POS register from card
.SH SYNOPSIS
.B "unsigned char" mca_device_read_pos
.BI "(struct mca_device *" mca_dev ","
.BI "int " reg ");"
.SH ARGUMENTS
.IP "mca_dev" 12
 device to read from
.IP "reg" 12
  register to read from
.SH "DESCRIPTION"
Fetch a POS value directly from the hardware to obtain the
current value. This is much slower than
mca_device_read_stored_pos and may not be invoked from
interrupt context. It handles the deep magic required for
onboard devices transparently.
.TH "mca_device_write_pos" 9 "mca_device_write_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_write_pos \-  read POS register from card
.SH SYNOPSIS
.B "void" mca_device_write_pos
.BI "(struct mca_device *" mca_dev ","
.BI "int " reg ","
.BI "unsigned char " byte ");"
.SH ARGUMENTS
.IP "mca_dev" 12
 device to write pos register to
.IP "reg" 12
  register to write to
.IP "byte" 12
 byte to write to the POS registers
.SH "DESCRIPTION"
Store a POS value directly to the hardware. You should not
normally need to use this function and should have a very good
knowledge of MCA bus before you do so. Doing this wrongly can
damage the hardware.

This function may not be used from interrupt context.
.TH "mca_device_transform_irq" 9 "mca_device_transform_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_transform_irq \-  transform the ADF obtained IRQ
.SH SYNOPSIS
.B "int" mca_device_transform_irq
.BI "(struct mca_device *" mca_dev ","
.BI "int " irq ");"
.SH ARGUMENTS
.IP "mca_dev" 12
-- undescribed --
.IP "irq" 12
 input irq from ADF
.SH "DESCRIPTION"
MCA Adapter Definition Files (ADF) contain irq, ioport, memory
etc. definitions.  In systems with more than one bus, these need
to be transformed through bus mapping functions to get the real
system global quantities.

This function transforms the interrupt number and returns the
transformed system global interrupt
.TH "mca_device_transform_ioport" 9 "mca_device_transform_ioport" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_transform_ioport \-  transform the ADF obtained I/O port
.SH SYNOPSIS
.B "int" mca_device_transform_ioport
.BI "(struct mca_device *" mca_dev ","
.BI "int " port ");"
.SH ARGUMENTS
.IP "mca_dev" 12
-- undescribed --
.IP "port" 12
-- undescribed --
.SH "DESCRIPTION"
MCA Adapter Definition Files (ADF) contain irq, ioport, memory
etc. definitions.  In systems with more than one bus, these need
to be transformed through bus mapping functions to get the real
system global quantities.

This function transforms the I/O port number and returns the
transformed system global port number.

This transformation can be assumed to be linear for port ranges.
.TH "mca_device_transform_memory" 9 "mca_device_transform_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_transform_memory \-  transform the ADF obtained memory
.SH SYNOPSIS
.B "void *" mca_device_transform_memory
.BI "(struct mca_device *" mca_dev ","
.BI "void *" mem ");"
.SH ARGUMENTS
.IP "mca_dev" 12
-- undescribed --
.IP "mem" 12
 memory region start from ADF
.SH "DESCRIPTION"
MCA Adapter Definition Files (ADF) contain irq, ioport, memory
etc. definitions.  In systems with more than one bus, these need
to be transformed through bus mapping functions to get the real
system global quantities.

This function transforms the memory region start and returns the
transformed system global memory region (physical).

This transformation can be assumed to be linear for region ranges.
.TH "mca_device_claimed" 9 "mca_device_claimed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_claimed \-  check if claimed by driver
.SH SYNOPSIS
.B "int" mca_device_claimed
.BI "(struct mca_device *" mca_dev ");"
.SH ARGUMENTS
.IP "mca_dev" 12
	device to check
.SH "DESCRIPTION"
Returns 1 if the slot has been claimed by a driver
.TH "mca_device_set_claim" 9 "mca_device_set_claim" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_set_claim \-  set the claim value of the driver
.SH SYNOPSIS
.B "void" mca_device_set_claim
.BI "(struct mca_device *" mca_dev ","
.BI "int " val ");"
.SH ARGUMENTS
.IP "mca_dev" 12
	device to set value for
.IP "val" 12
		claim value to set (1 claimed, 0 unclaimed)
.TH "mca_device_status" 9 "mca_device_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_status \-  get the status of the device
.SH SYNOPSIS
.B "enum MCA_AdapterStatus" mca_device_status
.BI "(struct mca_device *" mca_dev ");"
.SH ARGUMENTS
.IP "mca_dev" 12
-- undescribed --
.SH "RETURNS AN ENUMERATION OF THE DEVICE STATUS"

MCA_ADAPTER_NORMAL	adapter is OK.
MCA_ADAPTER_NONE	no adapter at device (should never happen).
MCA_ADAPTER_DISABLED	adapter is disabled.
MCA_ADAPTER_ERROR	adapter cannot be initialised.
.TH "mca_device_set_name" 9 "mca_device_set_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_device_set_name \-  set the name of the device
.SH SYNOPSIS
.B "void" mca_device_set_name
.BI "(struct mca_device *" mca_dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "mca_dev" 12
-- undescribed --
.IP "name" 12
		name to set
.TH "mca_find_adapter" 9 "mca_find_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_find_adapter \-  scan for adapters
.SH SYNOPSIS
.B "int" mca_find_adapter
.BI "(int " id ","
.BI "int " start ");"
.SH ARGUMENTS
.IP "id" 12
	MCA identification to search for
.IP "start" 12
	starting slot
.SH "DESCRIPTION"
Search the MCA configuration for adapters matching the 16bit
ID given. The first time it should be called with start as zero
and then further calls made passing the return value of the
previous call until MCA_NOTFOUND is returned.

Disabled adapters are not reported.
.TH "mca_find_unused_adapter" 9 "mca_find_unused_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_find_unused_adapter \-  scan for unused adapters
.SH SYNOPSIS
.B "int" mca_find_unused_adapter
.BI "(int " id ","
.BI "int " start ");"
.SH ARGUMENTS
.IP "id" 12
	MCA identification to search for
.IP "start" 12
	starting slot
.SH "DESCRIPTION"
Search the MCA configuration for adapters matching the 16bit
ID given. The first time it should be called with start as zero
and then further calls made passing the return value of the
previous call until MCA_NOTFOUND is returned.

Adapters that have been claimed by drivers and those that
are disabled are not reported. This function thus allows a driver
to scan for further cards when some may already be driven.
.TH "mca_read_stored_pos" 9 "mca_read_stored_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_read_stored_pos \-  read POS register from boot data
.SH SYNOPSIS
.B "unsigned char" mca_read_stored_pos
.BI "(int " slot ","
.BI "int " reg ");"
.SH ARGUMENTS
.IP "slot" 12
 slot number to read from
.IP "reg" 12
  register to read from
.SH "DESCRIPTION"
Fetch a POS value that was stored at boot time by the kernel
when it scanned the MCA space. The register value is returned.
Missing or invalid registers report 0.
.TH "mca_read_pos" 9 "mca_read_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_read_pos \-  read POS register from card
.SH SYNOPSIS
.B "unsigned char" mca_read_pos
.BI "(int " slot ","
.BI "int " reg ");"
.SH ARGUMENTS
.IP "slot" 12
 slot number to read from
.IP "reg" 12
  register to read from
.SH "DESCRIPTION"
Fetch a POS value directly from the hardware to obtain the
current value. This is much slower than mca_read_stored_pos and
may not be invoked from interrupt context. It handles the
deep magic required for onboard devices transparently.
.TH "mca_write_pos" 9 "mca_write_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_write_pos \-  read POS register from card
.SH SYNOPSIS
.B "void" mca_write_pos
.BI "(int " slot ","
.BI "int " reg ","
.BI "unsigned char " byte ");"
.SH ARGUMENTS
.IP "slot" 12
 slot number to read from
.IP "reg" 12
  register to read from
.IP "byte" 12
 byte to write to the POS registers
.SH "DESCRIPTION"
Store a POS value directly from the hardware. You should not
normally need to use this function and should have a very good
knowledge of MCA bus before you do so. Doing this wrongly can
damage the hardware.

This function may not be used from interrupt context.

Note that this a technically a Bad Thing, as IBM tech stuff says
you should only set POS values through their utilities.
However, some devices such as the 3c523 recommend that you write
back some data to make sure the configuration is consistent.
I'd say that IBM is right, but I like my drivers to work.

This function can't do checks to see if multiple devices end up
with the same resources, so you might see magic smoke if someone
screws up.
.TH "mca_set_adapter_name" 9 "mca_set_adapter_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_set_adapter_name \-  Set the description of the card
.SH SYNOPSIS
.B "void" mca_set_adapter_name
.BI "(int " slot ","
.BI "char *" name ");"
.SH ARGUMENTS
.IP "slot" 12
 slot to name
.IP "name" 12
 text string for the namen
.SH "DESCRIPTION"
This function sets the name reported via /proc for this
adapter slot. This is for user information only. Setting a
name deletes any previous name.
.TH "mca_is_adapter_used" 9 "mca_is_adapter_used" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_is_adapter_used \-  check if claimed by driver
.SH SYNOPSIS
.B "int" mca_is_adapter_used
.BI "(int " slot ");"
.SH ARGUMENTS
.IP "slot" 12
	slot to check
.SH "DESCRIPTION"
Returns 1 if the slot has been claimed by a driver
.TH "mca_mark_as_used" 9 "mca_mark_as_used" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_mark_as_used \-  claim an MCA device
.SH SYNOPSIS
.B "int" mca_mark_as_used
.BI "(int " slot ");"
.SH ARGUMENTS
.IP "slot" 12
	slot to claim
.SH "FIXME"
  should we make this threadsafe

Claim an MCA slot for a device driver. If the
slot is already taken the function returns 1,
if it is not taken it is claimed and 0 is
returned.
.TH "mca_mark_as_unused" 9 "mca_mark_as_unused" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_mark_as_unused \-  release an MCA device
.SH SYNOPSIS
.B "void" mca_mark_as_unused
.BI "(int " slot ");"
.SH ARGUMENTS
.IP "slot" 12
	slot to claim
.SH "DESCRIPTION"
Release the slot for other drives to use.
.TH "parport_open" 9 "parport_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_open \-  find a device by canonical device number
.SH SYNOPSIS
.B "struct pardevice *" parport_open
.BI "(int " devnum ","
.BI "const char *" name ","
.BI "int (*" pf ") (void *),"
.BI "void (*" kf ") (void *),"
.BI "void (*" irqf ") (int, void *, struct pt_regs *),"
.BI "int " flags ","
.BI "void *" handle ");"
.SH ARGUMENTS
.IP "devnum" 12
 canonical device number
.IP "name" 12
 name to associate with the device
.IP "pf" 12
 preemption callback
.IP "kf" 12
 kick callback
.IP "irqf" 12
 interrupt handler
.IP "flags" 12
 registration flags
.IP "handle" 12
 driver data
.SH "DESCRIPTION"
This function is similar to \fBparport_register_device\fP, except
that it locates a device by its number rather than by the port
it is attached to.

All parameters except for \fIdevnum\fP are the same as for
\fBparport_register_device\fP.  The return value is the same as
for \fBparport_register_device\fP.
.TH "parport_close" 9 "parport_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_close \-  close a device opened with parport_open()
.SH SYNOPSIS
.B "void" parport_close
.BI "(struct pardevice *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to close
.SH "DESCRIPTION"
This is to \fBparport_open\fP as \fBparport_unregister_device\fP is to
\fBparport_register_device\fP.
.TH "parport_device_num" 9 "parport_device_num" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_device_num \-  convert device coordinates
.SH SYNOPSIS
.B "int" parport_device_num
.BI "(int " parport ","
.BI "int " mux ","
.BI "int " daisy ");"
.SH ARGUMENTS
.IP "parport" 12
 parallel port number
.IP "mux" 12
 multiplexor port number (-1 for no multiplexor)
.IP "daisy" 12
 daisy chain address (-1 for no daisy chain address)
.SH "DESCRIPTION"
This tries to locate a device on the given parallel port,
multiplexor port and daisy chain address, and returns its
device number or -NXIO if no device with those coordinates
exists.
.TH "parport_wait_event" 9 "parport_wait_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_wait_event \-  wait for an event on a parallel port
.SH SYNOPSIS
.B "int" parport_wait_event
.BI "(struct parport *" port ","
.BI "signed long " timeout ");"
.SH ARGUMENTS
.IP "port" 12
 port to wait on
.IP "timeout" 12
 time to wait (in jiffies)
.SH "DESCRIPTION"
This function waits for up to \fItimeout\fP jiffies for an
interrupt to occur on a parallel port.  If the port timeout is
set to zero, it returns immediately.

If an interrupt occurs before the timeout period elapses, this
function returns one immediately.  If it times out, it returns
a value greater than zero.  An error code less than zero
indicates an error (most likely a pending signal), and the
calling code should finish what it's doing as soon as it can.
.TH "parport_poll_peripheral" 9 "parport_poll_peripheral" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_poll_peripheral \-  poll status lines
.SH SYNOPSIS
.B "int" parport_poll_peripheral
.BI "(struct parport *" port ","
.BI "unsigned char " mask ","
.BI "unsigned char " result ","
.BI "int " usec ");"
.SH ARGUMENTS
.IP "port" 12
 port to watch
.IP "mask" 12
 status lines to watch
.IP "result" 12
 desired values of chosen status lines
.IP "usec" 12
 timeout
.SH "DESCRIPTION"
This function busy-waits until the masked status lines have
the desired values, or until the timeout period elapses.  The
\fImask\fP and \fIresult\fP parameters are bitmasks, with the bits
defined by the constants in parport.h: PARPORT_STATUS_BUSY,
and so on.

This function does not call \fBschedule\fP; instead it busy-waits
using \fBudelay\fP.  It currently has a resolution of 5usec.

If the status lines take on the desired values before the
timeout period elapses, \fBparport_poll_peripheral\fP returns zero
immediately.  A zero return value greater than zero indicates
a timeout.  An error code (less than zero) indicates an error,
most likely a signal that arrived, and the caller should
finish what it is doing as soon as possible.
.TH "parport_wait_peripheral" 9 "parport_wait_peripheral" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_wait_peripheral \-  wait for status lines to change in 35ms
.SH SYNOPSIS
.B "int" parport_wait_peripheral
.BI "(struct parport *" port ","
.BI "unsigned char " mask ","
.BI "unsigned char " result ");"
.SH ARGUMENTS
.IP "port" 12
 port to watch
.IP "mask" 12
 status lines to watch
.IP "result" 12
 desired values of chosen status lines
.SH "DESCRIPTION"
This function waits until the masked status lines have the
desired values, or until 35ms have elapsed (see IEEE 1284-1994
page 24 to 25 for why this value in particular is hardcoded).
The \fImask\fP and \fIresult\fP parameters are bitmasks, with the bits
defined by the constants in parport.h: PARPORT_STATUS_BUSY,
and so on.

The port is polled quickly to start off with, in anticipation
of a fast response from the peripheral.  This fast polling
time is configurable (using /proc), and defaults to 500usec.
If the timeout for this port (see \fBparport_set_timeout\fP) is
zero, the fast polling time is 35ms, and this function does
not call \fBschedule\fP.

If the timeout for this port is non-zero, after the fast
polling fails it uses \fBparport_wait_event\fP to wait for up to
10ms, waking up if an interrupt occurs.
.TH "parport_negotiate" 9 "parport_negotiate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_negotiate \-  negotiate an IEEE 1284 mode
.SH SYNOPSIS
.B "int" parport_negotiate
.BI "(struct parport *" port ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "port" 12
 port to use
.IP "mode" 12
 mode to negotiate to
.SH "DESCRIPTION"
Use this to negotiate to a particular IEEE 1284 transfer mode.
The \fImode\fP parameter should be one of the constants in
parport.h starting IEEE1284_MODE_xxx.

The return value is 0 if the peripheral has accepted the
negotiation to the mode specified, -1 if the peripheral is not
IEEE 1284 compliant (or not present), or 1 if the peripheral
has rejected the negotiation.
.TH "parport_write" 9 "parport_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_write \-  write a block of data to a parallel port
.SH SYNOPSIS
.B "ssize_t" parport_write
.BI "(struct parport *" port ","
.BI "const void *" buffer ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "port" 12
 port to write to
.IP "buffer" 12
 data buffer (in kernel space)
.IP "len" 12
 number of bytes of data to transfer
.SH "DESCRIPTION"
This will write up to \fIlen\fP bytes of \fIbuffer\fP to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using \fBparport_negotiate\fP), as long as that
mode supports forward transfers (host to peripheral).

It is the caller's responsibility to ensure that the first
\fIlen\fP bytes of \fIbuffer\fP are valid.

This function returns the number of bytes transferred (if zero
or positive), or else an error code.
.TH "parport_read" 9 "parport_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_read \-  read a block of data from a parallel port
.SH SYNOPSIS
.B "ssize_t" parport_read
.BI "(struct parport *" port ","
.BI "void *" buffer ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "port" 12
 port to read from
.IP "buffer" 12
 data buffer (in kernel space)
.IP "len" 12
 number of bytes of data to transfer
.SH "DESCRIPTION"
This will read up to \fIlen\fP bytes of \fIbuffer\fP to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using \fBparport_negotiate\fP), as long as that
mode supports reverse transfers (peripheral to host).

It is the caller's responsibility to ensure that the first
\fIlen\fP bytes of \fIbuffer\fP are available to write to.

This function returns the number of bytes transferred (if zero
or positive), or else an error code.
.TH "parport_set_timeout" 9 "parport_set_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_set_timeout \-  set the inactivity timeout for a device
.SH SYNOPSIS
.B "long" parport_set_timeout
.BI "(struct pardevice *" dev ","
.BI "long " inactivity ");"
.SH ARGUMENTS
.IP "dev" 12
 device on a port
.IP "inactivity" 12
 inactivity timeout (in jiffies)
.SH "DESCRIPTION"
This sets the inactivity timeout for a particular device on a
port.  This affects functions like \fBparport_wait_peripheral\fP.
The special value 0 means not to call \fBschedule\fP while dealing
with this device.

The return value is the previous inactivity timeout.

Any callers of \fBparport_wait_event\fP for this device are woken
up.
.TH "parport_register_driver" 9 "parport_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_register_driver \-  register a parallel port device driver
.SH SYNOPSIS
.B "int" parport_register_driver
.BI "(struct parport_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 structure describing the driver
.SH "DESCRIPTION"
This can be called by a parallel port device driver in order
to receive notifications about ports being found in the
system, as well as ports no longer available.

The \fIdrv\fP structure is allocated by the caller and must not be
deallocated until after calling \fBparport_unregister_driver\fP.

The driver's \fBattach\fP function may block.  The port that
\fBattach\fP is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call \fBparport_get_port\fP to do so.  Calling
\fBparport_register_device\fP on that port will do this for you.

The driver's \fBdetach\fP function may block.  The port that
\fBdetach\fP is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call \fBparport_get_port\fP to do so.

Returns 0 on success.  Currently it always succeeds.
.TH "parport_unregister_driver" 9 "parport_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_unregister_driver \-  deregister a parallel port device driver
.SH SYNOPSIS
.B "void" parport_unregister_driver
.BI "(struct parport_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 structure describing the driver that was given to
\fBparport_register_driver\fP
.SH "DESCRIPTION"
This should be called by a parallel port device driver that
has registered itself using \fBparport_register_driver\fP when it
is about to be unloaded.

When it returns, the driver's \fBattach\fP routine will no longer
be called, and for each port that \fBattach\fP was called for, the
\fBdetach\fP routine will have been called.

All the driver's \fBattach\fP and \fBdetach\fP calls are guaranteed to have
finished by the time this function returns.
.TH "parport_get_port" 9 "parport_get_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_get_port \-  increment a port's reference count
.SH SYNOPSIS
.B "struct parport *" parport_get_port
.BI "(struct parport *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port
.SH "DESCRIPTION"
This ensure's that a struct parport pointer remains valid
until the matching \fBparport_put_port\fP call.
.TH "parport_put_port" 9 "parport_put_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_put_port \-  decrement a port's reference count
.SH SYNOPSIS
.B "void" parport_put_port
.BI "(struct parport *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port
.SH "DESCRIPTION"
This should be called once for each call to \fBparport_get_port\fP,
once the port is no longer needed.
.TH "parport_register_port" 9 "parport_register_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_register_port \-  register a parallel port
.SH SYNOPSIS
.B "struct parport *" parport_register_port
.BI "(unsigned long " base ","
.BI "int " irq ","
.BI "int " dma ","
.BI "struct parport_operations *" ops ");"
.SH ARGUMENTS
.IP "base" 12
 base I/O address
.IP "irq" 12
 IRQ line
.IP "dma" 12
 DMA channel
.IP "ops" 12
 pointer to the port driver's port operations structure
.SH "DESCRIPTION"
When a parallel port (lowlevel) driver finds a port that
should be made available to parallel port device drivers, it
should call \fBparport_register_port\fP.  The \fIbase\fP, \fIirq\fP, and
\fIdma\fP parameters are for the convenience of port drivers, and
for ports where they aren't meaningful needn't be set to
anything special.  They can be altered afterwards by adjusting
the relevant members of the parport structure that is returned
and represents the port.  They should not be tampered with
after calling parport_announce_port, however.

If there are parallel port device drivers in the system that
have registered themselves using \fBparport_register_driver\fP,
they are not told about the port at this time; that is done by
\fBparport_announce_port\fP.

The \fIops\fP structure is allocated by the caller, and must not be
deallocated before calling \fBparport_remove_port\fP.

If there is no memory to allocate a new parport structure,
this function will return NULL.
.TH "parport_announce_port" 9 "parport_announce_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_announce_port \-  tell device drivers about a parallel port
.SH SYNOPSIS
.B "void" parport_announce_port
.BI "(struct parport *" port ");"
.SH ARGUMENTS
.IP "port" 12
 parallel port to announce
.SH "DESCRIPTION"
After a port driver has registered a parallel port with
parport_register_port, and performed any necessary
initialisation or adjustments, it should call
\fBparport_announce_port\fP in order to notify all device drivers
that have called \fBparport_register_driver\fP.  Their \fBattach\fP
functions will be called, with \fIport\fP as the parameter.
.TH "parport_remove_port" 9 "parport_remove_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_remove_port \-  deregister a parallel port
.SH SYNOPSIS
.B "void" parport_remove_port
.BI "(struct parport *" port ");"
.SH ARGUMENTS
.IP "port" 12
 parallel port to deregister
.SH "DESCRIPTION"
When a parallel port driver is forcibly unloaded, or a
parallel port becomes inaccessible, the port driver must call
this function in order to deal with device drivers that still
want to use it.

The parport structure associated with the port has its
operations structure replaced with one containing 'null'
operations that return errors or just don't do anything.

Any drivers that have registered themselves using
\fBparport_register_driver\fP are notified that the port is no
longer accessible by having their \fBdetach\fP routines called
with \fIport\fP as the parameter.
.TH "parport_register_device" 9 "parport_register_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_register_device \-  register a device on a parallel port
.SH SYNOPSIS
.B "struct pardevice *" parport_register_device
.BI "(struct parport *" port ","
.BI "const char *" name ","
.BI "int (*" pf ") (void *),"
.BI "void (*" kf ") (void *),"
.BI "void (*" irq_func ") (int, void *, struct pt_regs *),"
.BI "int " flags ","
.BI "void *" handle ");"
.SH ARGUMENTS
.IP "port" 12
 port to which the device is attached
.IP "name" 12
 a name to refer to the device
.IP "pf" 12
 preemption callback
.IP "kf" 12
 kick callback (wake-up)
.IP "irq_func" 12
 interrupt handler
.IP "flags" 12
 registration flags
.IP "handle" 12
 data for callback functions
.SH "DESCRIPTION"
This function, called by parallel port device drivers,
declares that a device is connected to a port, and tells the
system all it needs to know.

The \fIname\fP is allocated by the caller and must not be
deallocated until the caller calls \fIparport_unregister_device\fP
for that device.

The preemption callback function, \fIpf\fP, is called when this
device driver has claimed access to the port but another
device driver wants to use it.  It is given \fIhandle\fP as its
parameter, and should return zero if it is willing for the
system to release the port to another driver on its behalf.
If it wants to keep control of the port it should return
non-zero, and no action will be taken.  It is good manners for
the driver to try to release the port at the earliest
opportunity after its preemption callback rejects a preemption
attempt.  Note that if a preemption callback is happy for
preemption to go ahead, there is no need to release the port;
it is done automatically.  This function may not block, as it
may be called from interrupt context.  If the device driver
does not support preemption, \fIpf\fP can be NULL.

The wake-up ("kick") callback function, \fIkf\fP, is called when
the port is available to be claimed for exclusive access; that
is, \fBparport_claim\fP is guaranteed to succeed when called from
inside the wake-up callback function.  If the driver wants to
claim the port it should do so; otherwise, it need not take
any action.  This function may not block, as it may be called
from interrupt context.  If the device driver does not want to
be explicitly invited to claim the port in this way, \fIkf\fP can
be NULL.

The interrupt handler, \fIirq_func\fP, is called when an interrupt
arrives from the parallel port.  Note that if a device driver
wants to use interrupts it should use \fBparport_enable_irq\fP,
and can also check the irq member of the parport structure
representing the port.

The parallel port (lowlevel) driver is the one that has called
\fBrequest_irq\fP and whose interrupt handler is called first.
This handler does whatever needs to be done to the hardware to
acknowledge the interrupt (for PC-style ports there is nothing
special to be done).  It then tells the IEEE 1284 code about
the interrupt, which may involve reacting to an IEEE 1284
event depending on the current IEEE 1284 phase.  After this,
it calls \fIirq_func\fP.  Needless to say, \fIirq_func\fP will be called
from interrupt context, and may not block.

The PARPORT_DEV_EXCL flag is for preventing port sharing, and
so should only be used when sharing the port with other device
drivers is impossible and would lead to incorrect behaviour.
Use it sparingly!  Normally, \fIflags\fP will be zero.

This function returns a pointer to a structure that represents
the device on the port, or NULL if there is not enough memory
to allocate space for that structure.
.TH "parport_unregister_device" 9 "parport_unregister_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_unregister_device \-  deregister a device on a parallel port
.SH SYNOPSIS
.B "void" parport_unregister_device
.BI "(struct pardevice *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to structure representing device
.SH "DESCRIPTION"
This undoes the effect of \fBparport_register_device\fP.
.TH "parport_find_number" 9 "parport_find_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_find_number \-  find a parallel port by number
.SH SYNOPSIS
.B "struct parport *" parport_find_number
.BI "(int " number ");"
.SH ARGUMENTS
.IP "number" 12
 parallel port number
.SH "DESCRIPTION"
This returns the parallel port with the specified number, or
NULL if there is none.

There is an implicit \fBparport_get_port\fP done already; to throw
away the reference to the port that \fBparport_find_number\fP
gives you, use \fBparport_put_port\fP.
.TH "parport_find_base" 9 "parport_find_base" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_find_base \-  find a parallel port by base address
.SH SYNOPSIS
.B "struct parport *" parport_find_base
.BI "(unsigned long " base ");"
.SH ARGUMENTS
.IP "base" 12
 base I/O address
.SH "DESCRIPTION"
This returns the parallel port with the specified base
address, or NULL if there is none.

There is an implicit \fBparport_get_port\fP done already; to throw
away the reference to the port that \fBparport_find_base\fP
gives you, use \fBparport_put_port\fP.
.TH "parport_claim" 9 "parport_claim" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_claim \-  claim access to a parallel port device
.SH SYNOPSIS
.B "int" parport_claim
.BI "(struct pardevice *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to structure representing a device on the port
.SH "DESCRIPTION"
This function will not block and so can be used from interrupt
context.  If \fBparport_claim\fP succeeds in claiming access to
the port it returns zero and the port is available to use.  It
may fail (returning non-zero) if the port is in use by another
driver and that driver is not willing to relinquish control of
the port.
.TH "parport_claim_or_block" 9 "parport_claim_or_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_claim_or_block \-  claim access to a parallel port device
.SH SYNOPSIS
.B "int" parport_claim_or_block
.BI "(struct pardevice *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to structure representing a device on the port
.SH "DESCRIPTION"
This behaves like \fBparport_claim\fP, but will block if necessary
to wait for the port to be free.  A return value of 1
indicates that it slept; 0 means that it succeeded without
needing to sleep.  A negative error code indicates failure.
.TH "parport_release" 9 "parport_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parport_release \-  give up access to a parallel port device
.SH SYNOPSIS
.B "void" parport_release
.BI "(struct pardevice *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to structure representing parallel port device
.SH "DESCRIPTION"
This function cannot fail, but it should not be called without
the port claimed.  Similarly, if the port is already claimed
you should not try claiming it again.
.TH "RIOAssignAT" 9 "RIOAssignAT" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
RIOAssignAT \- 
.SH SYNOPSIS
.B "int" RIOAssignAT
.BI "(" p ","
.BI "" Base ","
.BI "" virtAddr ","
.BI "" mode ");"
.SH ARGUMENTS
.IP "p" 12
.IP "Base" 12
.IP "virtAddr" 12
.IP "mode" 12
.SH "DESCRIPTION"
*
* Fill out the fields in the p-&gt;RIOHosts structure now we know we know
* we have a board present.
*
* bits &lt; 0 indicates 8 bit operation requested,
* bits &gt; 0 indicates 16 bit operation.
.TH "Kernel API" 9 "struct n_hdlc" "January 2021" "API Manual" LINUX
.SH NAME
struct n_hdlc \-  per device instance data structure
.SH SYNOPSIS
struct n_hdlc {
.br
};
.br
.SH Arguments
.SH "Description"
\fImagic\fP - magic value for structure
\fIflags\fP - miscellaneous control flags
\fItty\fP - ptr to TTY structure
\fIbackup_tty\fP - TTY to use if tty gets closed
\fItbusy\fP - reentrancy flag for tx wakeup code
\fIwoke_up\fP - FIXME: describe this field
\fItbuf\fP - currently transmitting tx buffer
\fItx_buf_list\fP - list of pending transmit frame buffers
\fIrx_buf_list\fP - list of received frame buffers
\fItx_free_buf_list\fP - list unused transmit frame buffers
\fIrx_free_buf_list\fP - list unused received frame buffers
.TH "n_hdlc_release" 9 "n_hdlc_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_release \-  release an n_hdlc per device line discipline info structure
.SH SYNOPSIS
.B "void" n_hdlc_release
.BI "(struct n_hdlc *" n_hdlc ");"
.SH ARGUMENTS
.IP "n_hdlc" 12
-- undescribed --
.SH "DESCRIPTION"
\fIn_hdlc\fP - per device line discipline info structure
.TH "n_hdlc_tty_close" 9 "n_hdlc_tty_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_close \-  line discipline close
.SH SYNOPSIS
.B "void" n_hdlc_tty_close
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP - pointer to tty info structure

Called when the line discipline is changed to something
else, the tty is closed, or the tty detects a hangup.
.TH "n_hdlc_tty_open" 9 "n_hdlc_tty_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_open \-  called when line discipline changed to n_hdlc
.SH SYNOPSIS
.B "int" n_hdlc_tty_open
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP - pointer to tty info structure

Returns 0 if success, otherwise error code
.TH "n_hdlc_send_frames" 9 "n_hdlc_send_frames" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_send_frames \-  send frames on pending send buffer list
.SH SYNOPSIS
.B "void" n_hdlc_send_frames
.BI "(struct n_hdlc *" n_hdlc ","
.BI "struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "n_hdlc" 12
-- undescribed --
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"
\fIn_hdlc\fP - pointer to ldisc instance data
\fItty\fP - pointer to tty instance data

Send frames on pending send buffer list until the driver does not accept a
frame (busy) this function is called after adding a frame to the send buffer
list and by the tty wakeup callback.
.TH "n_hdlc_tty_wakeup" 9 "n_hdlc_tty_wakeup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_wakeup \-  Callback for transmit wakeup
.SH SYNOPSIS
.B "void" n_hdlc_tty_wakeup
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP	- pointer to associated tty instance data

Called when low level device driver can accept more send data.
.TH "n_hdlc_tty_room" 9 "n_hdlc_tty_room" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_room \-  Return the amount of space left in the receiver's buffer
.SH SYNOPSIS
.B "int" n_hdlc_tty_room
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP	- pointer to associated tty instance data

Callback function from tty driver. Return the amount of space left in the
receiver's buffer to decide if remote transmitter is to be throttled.
.TH "n_hdlc_tty_receive" 9 "n_hdlc_tty_receive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_receive \-  Called by tty driver when receive data is available
.SH SYNOPSIS
.B "void" n_hdlc_tty_receive
.BI "(struct tty_struct *" tty ","
.BI "const __u8 *" data ","
.BI "char *" flags ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "flags" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP	- pointer to tty instance data
\fIdata\fP - pointer to received data
\fIflags\fP - pointer to flags for data
\fIcount\fP - count of received data in bytes

Called by tty low level driver when receive data is available. Data is
interpreted as one HDLC frame.
.TH "n_hdlc_tty_read" 9 "n_hdlc_tty_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_read \-  Called to retreive one frame of data (if available)
.SH SYNOPSIS
.B "ssize_t" n_hdlc_tty_read
.BI "(struct tty_struct *" tty ","
.BI "struct file *" file ","
.BI "__u8 __user *" buf ","
.BI "size_t " nr ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "nr" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP - pointer to tty instance data
\fIfile\fP - pointer to open file object
\fIbuf\fP - pointer to returned data buffer
\fInr\fP - size of returned data buffer

Returns the number of bytes returned or error code.
.TH "n_hdlc_tty_write" 9 "n_hdlc_tty_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_write \-  write a single frame of data to device
.SH SYNOPSIS
.B "ssize_t" n_hdlc_tty_write
.BI "(struct tty_struct *" tty ","
.BI "struct file *" file ","
.BI "const unsigned char *" data ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP	- pointer to associated tty device instance data
\fIfile\fP - pointer to file object data
\fIdata\fP - pointer to transmit data (one frame)
\fIcount\fP - size of transmit frame in bytes

Returns the number of bytes written (or error code).
.TH "n_hdlc_tty_ioctl" 9 "n_hdlc_tty_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_ioctl \-  process IOCTL system call for the tty device.
.SH SYNOPSIS
.B "int" n_hdlc_tty_ioctl
.BI "(struct tty_struct *" tty ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP - pointer to tty instance data
\fIfile\fP - pointer to open file object for device
\fIcmd\fP - IOCTL command code
\fIarg\fP - argument for IOCTL call (cmd dependent)

Returns command dependent result.
.TH "n_hdlc_tty_poll" 9 "n_hdlc_tty_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_tty_poll \-  TTY callback for poll system call
.SH SYNOPSIS
.B "unsigned int" n_hdlc_tty_poll
.BI "(struct tty_struct *" tty ","
.BI "struct file *" filp ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "wait" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP - pointer to tty instance data
\fIfilp\fP - pointer to open file object for device
\fIpoll_table\fP - wait queue for operations

Determine which operations (read/write) will not block and return info
to caller.
Returns a bit mask containing info on which ops will not block.
.TH "n_hdlc_alloc" 9 "n_hdlc_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_alloc \-  allocate an n_hdlc instance data structure
.SH SYNOPSIS
.B "struct n_hdlc *" n_hdlc_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns a pointer to newly created structure if success, otherwise NULL
.TH "n_hdlc_buf_list_init" 9 "n_hdlc_buf_list_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_buf_list_init \-  initialize specified HDLC buffer list
.SH SYNOPSIS
.B "void" n_hdlc_buf_list_init
.BI "(struct n_hdlc_buf_list *" list ");"
.SH ARGUMENTS
.IP "list" 12
-- undescribed --
.SH "DESCRIPTION"
\fIlist\fP - pointer to buffer list
.TH "n_hdlc_buf_put" 9 "n_hdlc_buf_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_buf_put \-  add specified HDLC buffer to tail of specified list
.SH SYNOPSIS
.B "void" n_hdlc_buf_put
.BI "(struct n_hdlc_buf_list *" list ","
.BI "struct n_hdlc_buf *" buf ");"
.SH ARGUMENTS
.IP "list" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"
\fIlist\fP - pointer to buffer list
\fIbuf\fP	- pointer to buffer
.TH "n_hdlc_buf_get" 9 "n_hdlc_buf_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_hdlc_buf_get \-  remove and return an HDLC buffer from list
.SH SYNOPSIS
.B "struct n_hdlc_buf*" n_hdlc_buf_get
.BI "(struct n_hdlc_buf_list *" list ");"
.SH ARGUMENTS
.IP "list" 12
-- undescribed --
.SH "DESCRIPTION"
\fIlist\fP - pointer to HDLC buffer list

Remove and return an HDLC buffer from the head of the specified HDLC buffer
list.
Returns a pointer to HDLC buffer if available, otherwise NULL.
.TH "ldisc_receive_buf" 9 "ldisc_receive_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ldisc_receive_buf \- 
.SH SYNOPSIS
.B "void" ldisc_receive_buf
.BI "(struct tty_struct *" tty ","
.BI "const __u8 *" data ","
.BI "char *" flags ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "flags" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"

The wrappers maintain line discipline references
while calling into the line discipline.

ldisc_receive_buf  - pass receive data to line discipline
.TH "hdlcdev_attach" 9 "hdlcdev_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_attach \- 
.SH SYNOPSIS
.B "int" hdlcdev_attach
.BI "(struct net_device *" dev ","
.BI "unsigned short " encoding ","
.BI "unsigned short " parity ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "encoding" 12
-- undescribed --
.IP "parity" 12
-- undescribed --
.SH "DESCRIPTION"
set encoding and frame check sequence (FCS) options

dev       pointer to network device structure
encoding  serial encoding setting
parity    FCS setting

returns 0 if success, otherwise error code
.TH "hdlcdev_xmit" 9 "hdlcdev_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_xmit \- 
.SH SYNOPSIS
.B "int" hdlcdev_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "skb" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

skb  socket buffer containing HDLC frame
dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_open" 9 "hdlcdev_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_open \- 
.SH SYNOPSIS
.B "int" hdlcdev_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
claim resources and initialize hardware

dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_close" 9 "hdlcdev_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_close \- 
.SH SYNOPSIS
.B "int" hdlcdev_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
shutdown hardware and release resources

dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_ioctl" 9 "hdlcdev_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_ioctl \- 
.SH SYNOPSIS
.B "int" hdlcdev_ioctl
.BI "(struct net_device *" dev ","
.BI "struct ifreq *" ifr ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "ifr" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.SH "DESCRIPTION"

dev  pointer to network device structure
ifr  pointer to network interface request structure
cmd  IOCTL command code

returns 0 if success, otherwise error code
.TH "hdlcdev_tx_timeout" 9 "hdlcdev_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_tx_timeout \- 
.SH SYNOPSIS
.B "void" hdlcdev_tx_timeout
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

dev  pointer to network device structure
.TH "hdlcdev_tx_done" 9 "hdlcdev_tx_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_tx_done \- 
.SH SYNOPSIS
.B "void" hdlcdev_tx_done
.BI "(SLMP_INFO *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
reenable network layer transmit if stopped

info  pointer to device instance information
.TH "hdlcdev_rx" 9 "hdlcdev_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_rx \- 
.SH SYNOPSIS
.B "void" hdlcdev_rx
.BI "(SLMP_INFO *" info ","
.BI "char *" buf ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
pass frame to network layer

info  pointer to device instance information
buf   pointer to buffer contianing frame data
size  count of data bytes in buf
.TH "hdlcdev_init" 9 "hdlcdev_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_init \- 
.SH SYNOPSIS
.B "int" hdlcdev_init
.BI "(SLMP_INFO *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
do generic HDLC initialization

info  pointer to device instance information

returns 0 if success, otherwise error code
.TH "hdlcdev_exit" 9 "hdlcdev_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_exit \- 
.SH SYNOPSIS
.B "void" hdlcdev_exit
.BI "(SLMP_INFO *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
do generic HDLC cleanup

info  pointer to device instance information
.TH "check_unthrottle" 9 "check_unthrottle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_unthrottle \- 	allow new receive data
.SH SYNOPSIS
.B "void" check_unthrottle
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"
\fItty\fP; tty device

Check whether to call the driver.unthrottle function.
We test the TTY_THROTTLED bit first so that it always
indicates the current state. The decision about whether
it is worth allowing more input has been taken by the caller.
Can sleep, may be called under the atomic_read semaphore but
this is not guaranteed.
.TH "reset_buffer_flags" 9 "reset_buffer_flags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
reset_buffer_flags \- 	reset buffer state
.SH SYNOPSIS
.B "void" reset_buffer_flags
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal to reset
.SH "DESCRIPTION"
Reset the read buffer counters, clear the flags, 
and make sure the driver is unthrottled. Called
from \fBn_tty_open\fP and \fBn_tty_flush_buffer\fP.
.TH "n_tty_flush_buffer" 9 "n_tty_flush_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_flush_buffer \- 	clean input queue
.SH SYNOPSIS
.B "void" n_tty_flush_buffer
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
	terminal device
.SH "DESCRIPTION"
Flush the input buffer. Called when the line discipline is
being closed, when the tty layer wants the buffer flushed (eg
at hangup) or when the N_TTY line discipline internally has to
clean the pending queue (for example some signals).
.SH "FIXME"
 tty-&gt;ctrl_status is not spinlocked and relies on
\fBlock_kernel\fP still.
.TH "n_tty_chars_in_buffer" 9 "n_tty_chars_in_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_chars_in_buffer \- 	report available bytes
.SH SYNOPSIS
.B "ssize_t" n_tty_chars_in_buffer
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 tty device
.SH "DESCRIPTION"
Report the number of characters buffered to be delivered to user
at this instant in time. 
.TH "is_utf8_continuation" 9 "is_utf8_continuation" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_utf8_continuation \- 	utf8 multibyte check
.SH SYNOPSIS
.B "int" is_utf8_continuation
.BI "(unsigned char " c ");"
.SH ARGUMENTS
.IP "c" 12
 byte to check
.SH "DESCRIPTION"
Returns true if the utf8 character 'c' is a multibyte continuation
character. We use this to correctly compute the on screen size
of the character when printing
.TH "is_continuation" 9 "is_continuation" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_continuation \- 	multibyte check
.SH SYNOPSIS
.B "int" is_continuation
.BI "(unsigned char " c ","
.BI "struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "c" 12
 byte to check
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"
Returns true if the utf8 character 'c' is a multibyte continuation
character and the terminal is in unicode mode.
.TH "opost" 9 "opost" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
opost \- 	output post processor
.SH SYNOPSIS
.B "int" opost
.BI "(unsigned char " c ","
.BI "struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "c" 12
 character (or partial unicode symbol)
.IP "tty" 12
 terminal device
.SH "DESCRIPTION"
Perform OPOST processing.  Returns -1 when the output device is
full and the character must be retried. Note that Linux currently
ignores TABDLY, CRDLY, VTDLY, FFDLY and NLDLY. They simply aren't
relevant in the world today. If you ever need them, add them here.

Called from both the receive and transmit sides and can be called
re-entrantly. Relies on \fBlock_kernel\fP still.
.TH "opost_block" 9 "opost_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
opost_block \- 	block postprocess
.SH SYNOPSIS
.B "ssize_t" opost_block
.BI "(struct tty_struct *" tty ","
.BI "const unsigned char *" buf ","
.BI "unsigned int " nr ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal device
.IP "buf" 12
-- undescribed --
.IP "nr" 12
 number of bytes
.SH "DESCRIPTION"
This path is used to speed up block console writes, among other
things when processing blocks of output data. It handles only
the simple cases normally found and helps to generate blocks of
symbols for the console driver and thus improve performance.

Called from write_chan under the tty layer write lock.
.TH "put_char" 9 "put_char" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_char \- 	write character to driver
.SH SYNOPSIS
.B "void" put_char
.BI "(unsigned char " c ","
.BI "struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "c" 12
 character (or part of unicode symbol)
.IP "tty" 12
 terminal device
.SH "DESCRIPTION"
Queue a byte to the driver layer for output
.TH "echo_char" 9 "echo_char" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
echo_char \- 	echo characters
.SH SYNOPSIS
.B "void" echo_char
.BI "(unsigned char " c ","
.BI "struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "c" 12
 unicode byte to echo
.IP "tty" 12
 terminal device
.SH "DESCRIPTION"
Echo user input back onto the screen. This must be called only when 
L_ECHO(tty) is true. Called from the driver receive_buf path.
.TH "eraser" 9 "eraser" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eraser \- 	handle erase function
.SH SYNOPSIS
.B "void" eraser
.BI "(unsigned char " c ","
.BI "struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "c" 12
 character input
.IP "tty" 12
 terminal device
.SH "DESCRIPTION"
Perform erase and neccessary output when an erase character is
present in the stream from the driver layer. Handles the complexities
of UTF-8 multibyte symbols.
.TH "isig" 9 "isig" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
isig \- 	handle the ISIG optio
.SH SYNOPSIS
.B "void" isig
.BI "(int " sig ","
.BI "struct tty_struct *" tty ","
.BI "int " flush ");"
.SH ARGUMENTS
.IP "sig" 12
 signal
.IP "tty" 12
 terminal
.IP "flush" 12
 force flush
.SH "DESCRIPTION"
Called when a signal is being sent due to terminal input. This
may caus terminal flushing to take place according to the termios
settings and character used. Called from the driver receive_buf
path so serialized.
.TH "n_tty_receive_break" 9 "n_tty_receive_break" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_receive_break \- 	handle break
.SH SYNOPSIS
.B "void" n_tty_receive_break
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal
.SH "DESCRIPTION"
An RS232 break event has been hit in the incoming bitstream. This
can cause a variety of events depending upon the termios settings.

Called from the receive_buf path so single threaded.
.TH "n_tty_receive_overrun" 9 "n_tty_receive_overrun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_receive_overrun \- 	handle overrun reporting
.SH SYNOPSIS
.B "void" n_tty_receive_overrun
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal
.SH "DESCRIPTION"
Data arrived faster than we could process it. While the tty
driver has flagged this the bits that were missed are gone
forever.

Called from the receive_buf path so single threaded. Does not
need locking as num_overrun and overrun_time are function
private.
.TH "n_tty_receive_parity_error" 9 "n_tty_receive_parity_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_receive_parity_error \- 	error notifier
.SH SYNOPSIS
.B "void" n_tty_receive_parity_error
.BI "(struct tty_struct *" tty ","
.BI "unsigned char " c ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal device
.IP "c" 12
 character
.SH "DESCRIPTION"
Process a parity error and queue the right data to indicate
the error case if neccessary. Locking as per n_tty_receive_buf.
.TH "n_tty_receive_char" 9 "n_tty_receive_char" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_receive_char \- 	perform processing
.SH SYNOPSIS
.B "void" n_tty_receive_char
.BI "(struct tty_struct *" tty ","
.BI "unsigned char " c ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal device
.IP "c" 12
 character
.SH "DESCRIPTION"
Process an individual character of input received from the driver.
This is serialized with respect to itself by the rules for the 
driver above.
.TH "n_tty_receive_room" 9 "n_tty_receive_room" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_receive_room \- 	receive space
.SH SYNOPSIS
.B "int" n_tty_receive_room
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal
.SH "DESCRIPTION"
Called by the driver to find out how much data it is
permitted to feed to the line discipline without any being lost
and thus to manage flow control. Not serialized. Answers for the
"instant".
.TH "n_tty_write_wakeup" 9 "n_tty_write_wakeup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_write_wakeup \- 	asynchronous I/O notifier
.SH SYNOPSIS
.B "void" n_tty_write_wakeup
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 tty device
.SH "DESCRIPTION"
Required for the ptys, serial driver etc. since processes
that attach themselves to the master and rely on ASYNC
IO must be woken up
.TH "n_tty_receive_buf" 9 "n_tty_receive_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_receive_buf \- 	data receive
.SH SYNOPSIS
.B "void" n_tty_receive_buf
.BI "(struct tty_struct *" tty ","
.BI "const unsigned char *" cp ","
.BI "char *" fp ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal device
.IP "cp" 12
 buffer
.IP "fp" 12
 flag buffer
.IP "count" 12
 characters
.SH "DESCRIPTION"
Called by the terminal driver when a block of characters has
been received. This function must be called from soft contexts
not from interrupt context. The driver is responsible for making
calls one at a time and in order (or using flush_to_ldisc)
.TH "n_tty_set_termios" 9 "n_tty_set_termios" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_set_termios \- 	termios data changed
.SH SYNOPSIS
.B "void" n_tty_set_termios
.BI "(struct tty_struct *" tty ","
.BI "struct termios *" old ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal
.IP "old" 12
 previous data
.SH "DESCRIPTION"
Called by the tty layer when the user changes termios flags so
that the line discipline can plan ahead. This function cannot sleep
and is protected from re-entry by the tty layer. The user is 
guaranteed that this function will not be re-entered or in progress
when the ldisc is closed.
.TH "n_tty_close" 9 "n_tty_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_close \- 	close the ldisc for this tty
.SH SYNOPSIS
.B "void" n_tty_close
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 device
.SH "DESCRIPTION"
Called from the terminal layer when this line discipline is 
being shut down, either because of a close or becsuse of a 
discipline change. The function will not be called while other
ldisc methods are in progress.
.TH "n_tty_open" 9 "n_tty_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
n_tty_open \- 	open an ldisc
.SH SYNOPSIS
.B "int" n_tty_open
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal to open
.SH "DESCRIPTION"
Called when this line discipline is being attached to the 
terminal device. Can sleep. Called serialized so that no
other events will occur in parallel. No further open will occur
until a close.
.TH "copy_from_read_buf" 9 "copy_from_read_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_from_read_buf \- 	copy read data directly
.SH SYNOPSIS
.B "int" copy_from_read_buf
.BI "(struct tty_struct *" tty ","
.BI "unsigned char __user **" b ","
.BI "size_t *" nr ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal device
.IP "b" 12
 user data
.IP "nr" 12
 size of data
.SH "DESCRIPTION"
Helper function to speed up read_chan.  It is only called when
ICANON is off; it copies characters straight from the tty queue to
user space directly.  It can be profitably called twice; once to
drain the space from the tail pointer to the (physical) end of the
buffer, and once to drain the space from the (physical) beginning of
the buffer to head pointer.

Called under the tty-&gt;atomic_read sem and with TTY_DONT_FLIP set
.TH "job_control" 9 "job_control" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
job_control \- 	check job control
.SH SYNOPSIS
.B "int" job_control
.BI "(struct tty_struct *" tty ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "tty" 12
 tty
.IP "file" 12
 file handle
.SH "DESCRIPTION"
Perform job control management checks on this file/tty descriptor
and if appropriate send any needed signals and return a negative 
error code if action should be taken.
.TH "read_chan" 9 "read_chan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_chan \- 	read function for tty
.SH SYNOPSIS
.B "ssize_t" read_chan
.BI "(struct tty_struct *" tty ","
.BI "struct file *" file ","
.BI "unsigned char __user *" buf ","
.BI "size_t " nr ");"
.SH ARGUMENTS
.IP "tty" 12
 tty device
.IP "file" 12
 file object
.IP "buf" 12
 userspace buffer pointer
.IP "nr" 12
 size of I/O
.SH "DESCRIPTION"
Perform reads for the line discipline. We are guaranteed that the
line discipline will not be closed under us but we may get multiple
parallel readers and must handle this ourselves. We may also get
a hangup. Always called in user context, may sleep.

This code must be sure never to sleep through a hangup.
.TH "write_chan" 9 "write_chan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_chan \- 	write function for tty
.SH SYNOPSIS
.B "ssize_t" write_chan
.BI "(struct tty_struct *" tty ","
.BI "struct file *" file ","
.BI "const unsigned char *" buf ","
.BI "size_t " nr ");"
.SH ARGUMENTS
.IP "tty" 12
 tty device
.IP "file" 12
 file object
.IP "buf" 12
 userspace buffer pointer
.IP "nr" 12
 size of I/O
.SH "DESCRIPTION"
Write function of the terminal device. This is serialized with
respect to other write callers but not to termios changes, reads
and other such events. We must be careful with N_TTY as the receive
code will echo characters, thus calling driver write methods.

This code must be sure never to sleep through a hangup.
.TH "normal_poll" 9 "normal_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
normal_poll \- 	poll method for N_TTY
.SH SYNOPSIS
.B "unsigned int" normal_poll
.BI "(struct tty_struct *" tty ","
.BI "struct file *" file ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal device
.IP "file" 12
 file accessing it
.IP "wait" 12
 poll table
.SH "DESCRIPTION"
Called when the line discipline is asked to \fBpoll\fP for data or
for special events. This code is not serialized with respect to
other events save open/close.

This code must be sure never to sleep through a hangup.
Called without the kernel lock held - fine
.SH "FIXME"
 if someone changes the VMIN or discipline settings for the
terminal while another process is in \fBpoll\fP the poll does not
recompute the new limits. Possibly set_termios should issue
a read wakeup to fix this bug.
.TH "agp_free_memory" 9 "agp_free_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_free_memory \-  free memory associated with an agp_memory pointer.
.SH SYNOPSIS
.B "void" agp_free_memory
.BI "(struct agp_memory *" curr ");"
.SH ARGUMENTS
.IP "curr" 12
		agp_memory pointer to be freed.
.SH "DESCRIPTION"
It is the only function that can be called when the backend is not owned
by the caller.  (So it can free memory on client death.)
.SH "DESCRIPTION"
It is the only function that can be called when the backend is not owned
by the caller.  (So it can free memory on client death.)
.TH "agp_allocate_memory" 9 "agp_allocate_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_allocate_memory \-   allocate a group of pages of a certain type.
.SH SYNOPSIS
.B "struct agp_memory *" agp_allocate_memory
.BI "(struct agp_bridge_data *" bridge ","
.BI "size_t " page_count ","
.BI "u32 " type ");"
.SH ARGUMENTS
.IP "bridge" 12
-- undescribed --
.IP "page_count" 12
	size_t argument of the number of pages
.IP "type" 12
	u32 argument of the type of memory to be allocated.
.SH "DESCRIPTION"
Every agp bridge device will allow you to allocate AGP_NORMAL_MEMORY which
maps to physical ram.  Any other type is device dependent.

It returns NULL whenever memory is unavailable.
.SH "DESCRIPTION"
Every agp bridge device will allow you to allocate AGP_NORMAL_MEMORY which
maps to physical ram.  Any other type is device dependent.

It returns NULL whenever memory is unavailable.
.TH "agp_copy_info" 9 "agp_copy_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_copy_info \-   copy bridge state information
.SH SYNOPSIS
.B "int" agp_copy_info
.BI "(struct agp_bridge_data *" bridge ","
.BI "struct agp_kern_info *" info ");"
.SH ARGUMENTS
.IP "bridge" 12
-- undescribed --
.IP "info" 12
		agp_kern_info pointer.  The caller should insure that this pointer is valid. 
.SH "DESCRIPTION"
This function copies information about the agp bridge device and the state of
the agp backend into an agp_kern_info pointer.
.SH "DESCRIPTION"
This function copies information about the agp bridge device and the state of
the agp backend into an agp_kern_info pointer.
.TH "agp_bind_memory" 9 "agp_bind_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_bind_memory \-   Bind an agp_memory structure into the GATT.
.SH SYNOPSIS
.B "int" agp_bind_memory
.BI "(struct agp_memory *" curr ","
.BI "off_t " pg_start ");"
.SH ARGUMENTS
.IP "curr" 12
		agp_memory pointer
.IP "pg_start" 12
	an offset into the graphics aperture translation table
.SH "DESCRIPTION"
It returns -EINVAL if the pointer == NULL.
It returns -EBUSY if the area of the table requested is already in use.
.SH "DESCRIPTION"
It returns -EINVAL if the pointer == NULL.
It returns -EBUSY if the area of the table requested is already in use.
.TH "agp_unbind_memory" 9 "agp_unbind_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_unbind_memory \-   Removes an agp_memory structure from the GATT
.SH SYNOPSIS
.B "int" agp_unbind_memory
.BI "(struct agp_memory *" curr ");"
.SH ARGUMENTS
.IP "curr" 12
	agp_memory pointer to be removed from the GATT.
.SH "DESCRIPTION"
It returns -EINVAL if this piece of agp_memory is not currently bound to
the graphics aperture translation table or if the agp_memory pointer == NULL
.SH "DESCRIPTION"
It returns -EINVAL if this piece of agp_memory is not currently bound to
the graphics aperture translation table or if the agp_memory pointer == NULL
.TH "agp_collect_device_status" 9 "agp_collect_device_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_collect_device_status \-  determine correct agp_cmd from various agp_stat's
.SH SYNOPSIS
.B "u32" agp_collect_device_status
.BI "(struct agp_bridge_data *" bridge ","
.BI "u32 " requested_mode ","
.BI "u32 " bridge_agpstat ");"
.SH ARGUMENTS
.IP "bridge" 12
 an agp_bridge_data struct allocated for the AGP host bridge.
.IP "requested_mode" 12
 requested agp_stat from userspace (Typically from X)
.IP "bridge_agpstat" 12
 current agp_stat from AGP bridge.
.SH "DESCRIPTION"
This function will hunt for an AGP graphics card, and try to match
the requested mode to the capabilities of both the bridge and the card.
.TH "agp_enable" 9 "agp_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_enable \-   initialise the agp point-to-point connection.
.SH SYNOPSIS
.B "void" agp_enable
.BI "(struct agp_bridge_data *" bridge ","
.BI "u32 " mode ");"
.SH ARGUMENTS
.IP "bridge" 12
-- undescribed --
.IP "mode" 12
	agp mode register value to configure with.
.SH "DESCRIPTION"
.TH "agp_backend_acquire" 9 "agp_backend_acquire" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_backend_acquire \-   attempt to acquire an agp backend.
.SH SYNOPSIS
.B "struct agp_bridge_data *" agp_backend_acquire
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "agp_backend_release" 9 "agp_backend_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
agp_backend_release \-   release the lock on the agp backend.
.SH SYNOPSIS
.B "void" agp_backend_release
.BI "(struct agp_bridge_data *" bridge ");"
.SH ARGUMENTS
.IP "bridge" 12
-- undescribed --
.SH "DESCRIPTION"

The caller must insure that the graphics aperture translation table
is read for use by another entity.

(Ensure that all memory it bound is unbound.)
.TH "tty_ldisc_try" 9 "tty_ldisc_try" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_ldisc_try \- 	internal helper
.SH SYNOPSIS
.B "int" tty_ldisc_try
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 the tty
.SH "DESCRIPTION"
Make a single attempt to grab and bump the refcount on
the tty ldisc. Return 0 on failure or 1 on success. This is
used to implement both the waiting and non waiting versions
of tty_ldisc_ref
.TH "tty_ldisc_ref_wait" 9 "tty_ldisc_ref_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_ldisc_ref_wait \- 	wait for the tty ldisc
.SH SYNOPSIS
.B "struct tty_ldisc *" tty_ldisc_ref_wait
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 tty device
.SH "DESCRIPTION"
Dereference the line discipline for the terminal and take a 
reference to it. If the line discipline is in flux then 
wait patiently until it changes.
.SH "NOTE"
 Must not be called from an IRQ/timer context. The caller
must also be careful not to hold other locks that will deadlock
against a discipline change, such as an existing ldisc reference
(which we check for)
.TH "tty_ldisc_ref" 9 "tty_ldisc_ref" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_ldisc_ref \- 	get the tty ldisc
.SH SYNOPSIS
.B "struct tty_ldisc *" tty_ldisc_ref
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 tty device
.SH "DESCRIPTION"
Dereference the line discipline for the terminal and take a 
reference to it. If the line discipline is in flux then 
return NULL. Can be called from IRQ and timer functions.
.TH "tty_ldisc_deref" 9 "tty_ldisc_deref" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_ldisc_deref \- 	free a tty ldisc reference
.SH SYNOPSIS
.B "void" tty_ldisc_deref
.BI "(struct tty_ldisc *" ld ");"
.SH ARGUMENTS
.IP "ld" 12
 reference to free up
.SH "DESCRIPTION"
Undoes the effect of tty_ldisc_ref or tty_ldisc_ref_wait. May
be called in IRQ context.
.TH "tty_ldisc_enable" 9 "tty_ldisc_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_ldisc_enable \- 	allow ldisc use
.SH SYNOPSIS
.B "void" tty_ldisc_enable
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal to activate ldisc on
.SH "DESCRIPTION"
Set the TTY_LDISC flag when the line discipline can be called
again. Do neccessary wakeups for existing sleepers.
.SH "NOTE"
 nobody should set this bit except via this function. Clearing
directly is allowed.
.TH "tty_set_ldisc" 9 "tty_set_ldisc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_set_ldisc \- 	set line discipline
.SH SYNOPSIS
.B "int" tty_set_ldisc
.BI "(struct tty_struct *" tty ","
.BI "int " ldisc ");"
.SH ARGUMENTS
.IP "tty" 12
 the terminal to set
.IP "ldisc" 12
 the line discipline
.SH "DESCRIPTION"
Set the discipline of a tty line. Must be called from a process
context.
.TH "tty_wakeup" 9 "tty_wakeup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_wakeup \- 	request more data
.SH SYNOPSIS
.B "void" tty_wakeup
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 terminal
.SH "DESCRIPTION"
Internal and external helper for wakeups of tty. This function
informs the line discipline if present that the driver is ready
to receive more output data.
.TH "tty_ldisc_flush" 9 "tty_ldisc_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_ldisc_flush \- 	flush line discipline queue
.SH SYNOPSIS
.B "void" tty_ldisc_flush
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 tty
.SH "DESCRIPTION"
Flush the line discipline queue (if any) for this tty. If there
is no line discipline active this is a no-op.
.TH "tty_termios_baud_rate" 9 "tty_termios_baud_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_termios_baud_rate \- 
.SH SYNOPSIS
.B "int" tty_termios_baud_rate
.BI "(struct termios *" termios ");"
.SH ARGUMENTS
.IP "termios" 12
 termios structure
.SH "DESCRIPTION"
Convert termios baud rate data into a speed. This should be called
with the termios lock held if this termios is a terminal termios
structure. May change the termios data.
.TH "tty_get_baud_rate" 9 "tty_get_baud_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_get_baud_rate \- 	get tty bit rates
.SH SYNOPSIS
.B "int" tty_get_baud_rate
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 tty to query
.SH "DESCRIPTION"
Returns the baud rate as an integer for this terminal. The
termios lock must be held by the caller and the terminal bit
flags may be updated.
.TH "tty_flip_buffer_push" 9 "tty_flip_buffer_push" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_flip_buffer_push \- 	terminal
.SH SYNOPSIS
.B "void" tty_flip_buffer_push
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
 tty to push
.SH "DESCRIPTION"
Queue a push of the terminal flip buffers to the line discipline. This
function must not be called from IRQ context if tty-&gt;low_latency is set.

In the event of the queue being busy for flipping the work will be
held off and retried later.
.TH "tty_register_device" 9 "tty_register_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_register_device \-  register a tty device
.SH SYNOPSIS
.B "void" tty_register_device
.BI "(struct tty_driver *" driver ","
.BI "unsigned " index ","
.BI "struct device *" device ");"
.SH ARGUMENTS
.IP "driver" 12
 the tty driver that describes the tty device
.IP "index" 12
 the index in the tty driver for this tty device
.IP "device" 12
 a struct device that is associated with this tty device.
This field is optional, if there is no known struct device for this
tty device it can be set to NULL safely.
.SH "DESCRIPTION"
This call is required to be made to register an individual tty device if
the tty driver's flags have the TTY_DRIVER_NO_DEVFS bit set.  If that
bit is not set, this function should not be called.
.TH "tty_unregister_device" 9 "tty_unregister_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_unregister_device \-  unregister a tty device
.SH SYNOPSIS
.B "void" tty_unregister_device
.BI "(struct tty_driver *" driver ","
.BI "unsigned " index ");"
.SH ARGUMENTS
.IP "driver" 12
 the tty driver that describes the tty device
.IP "index" 12
 the index in the tty driver for this tty device
.SH "DESCRIPTION"
If a tty device is registered with a call to \fBtty_register_device\fP then
this function must be made when the tty device is gone.
.TH "drm_dma_setup" 9 "drm_dma_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_dma_setup \- 
.SH SYNOPSIS
.B "int" drm_dma_setup
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\return zero on success or a negative value on failure.

Allocate and initialize a drm_device_dma structure.
.TH "drm_dma_takedown" 9 "drm_dma_takedown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_dma_takedown \- 
.SH SYNOPSIS
.B "void" drm_dma_takedown
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.

Free all pages associated with DMA buffers, the buffers and pages lists, and
.SH "FINALLY THE THE DRM_DEVICE"
:dma structure itself.
.TH "drm_free_buffer" 9 "drm_free_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_free_buffer \- 
.SH SYNOPSIS
.B "void" drm_free_buffer
.BI "(drm_device_t *" dev ","
.BI "drm_buf_t *" buf ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param buf buffer to free.

Resets the fields of \p buf.
.TH "drm_core_reclaim_buffers" 9 "drm_core_reclaim_buffers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_core_reclaim_buffers \- 
.SH SYNOPSIS
.B "void" drm_core_reclaim_buffers
.BI "(drm_device_t *" dev ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.SH "DESCRIPTION"

\param filp file pointer.

Frees each buffer associated with \p filp not already on the hardware.
.TH "drm_compat_ioctl" 9 "drm_compat_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_compat_ioctl \- bit process running under a 64-bit kernel
.SH SYNOPSIS
.B "long" drm_compat_ioctl
.BI "(struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
performs an ioctl on /dev/drm.

\param filp file pointer.
\param cmd command.
\param arg user argument.
\return zero on success or negative number on failure.
.TH "drm_cpu_valid" 9 "drm_cpu_valid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_cpu_valid \- 
.SH SYNOPSIS
.B "int" drm_cpu_valid
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

\return non-zero if the DRI will run on this CPU, or zero otherwise.
.TH "drm_stub_open" 9 "drm_stub_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_stub_open \- 
.SH SYNOPSIS
.B "int" drm_stub_open
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.

Puts the dev-&gt;fops corresponding to the device minor number into
\p filp, call the \c open method, and restore the file operations.
.TH "drm_get_head" 9 "drm_get_head" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_get_head \- 
.SH SYNOPSIS
.B "int" drm_get_head
.BI "(drm_device_t *" dev ","
.BI "drm_head_t *" head ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "head" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev device data structure
\param sec-minor structure to hold the assigned minor
\return negative number on failure.

Search an empty entry and initialize it to the given parameters, and
create the proc init entry via \fBproc_init\fP. This routines assigns
minor numbers to secondary heads of multi-headed cards
.TH "drm_get_dev" 9 "drm_get_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_get_dev \- 
.SH SYNOPSIS
.B "int" drm_get_dev
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" ent ","
.BI "struct drm_driver *" driver ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.IP "ent" 12
-- undescribed --
.IP "driver" 12
-- undescribed --
.SH "DESCRIPTION"

\param pdev - PCI device structure
\param ent entry from the PCI ID table with device type flags
\return zero on success or a negative number on failure.

Attempt to gets inter module "drm" information. If we are first
then register the character device and inter module information.
Try and register, if we fail to register, backout previous work.
.TH "drm_put_dev" 9 "drm_put_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_put_dev \- 
.SH SYNOPSIS
.B "int" drm_put_dev
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev device data structure
\return always zero

Cleans up the proc resources. If it is the last minor then release the foreign
"drm" data, otherwise unregisters the "drm" data, frees the dev list and
unregisters the character device.
.TH "drm_put_head" 9 "drm_put_head" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_put_head \- 
.SH SYNOPSIS
.B "int" drm_put_head
.BI "(drm_head_t *" head ");"
.SH ARGUMENTS
.IP "head" 12
-- undescribed --
.SH "DESCRIPTION"

\param sec_minor - structure to be released
\return always zero

Cleans up the proc resources. Not legal for this to be the
last minor released.
.TH "mga_do_agp_dma_bootstrap" 9 "mga_do_agp_dma_bootstrap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mga_do_agp_dma_bootstrap \- 
.SH SYNOPSIS
.B "int" mga_do_agp_dma_bootstrap
.BI "(drm_device_t *" dev ","
.BI "drm_mga_dma_bootstrap_t *" dma_bs ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "dma_bs" 12
-- undescribed --
.SH "DESCRIPTION"

\todo
Investigate whether there is any benifit to storing the WARP microcode in
AGP memory.  If not, the microcode may as well always be put in PCI
memory.

\todo
This routine needs to set dma_bs-&gt;agp_mode to the mode actually configured
in the hardware.  Looking just at the Linux AGP driver code, I don't see
an easy way to determine this.

\sa mga_do_dma_bootstrap, mga_do_pci_dma_bootstrap
.TH "mga_do_pci_dma_bootstrap" 9 "mga_do_pci_dma_bootstrap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mga_do_pci_dma_bootstrap \- 
.SH SYNOPSIS
.B "int" mga_do_pci_dma_bootstrap
.BI "(drm_device_t *" dev ","
.BI "drm_mga_dma_bootstrap_t *" dma_bs ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "dma_bs" 12
-- undescribed --
.SH "DESCRIPTION"

\todo
The algorithm for decreasing the size of the primary DMA buffer could be
better.  The size should be rounded up to the nearest page size, then
decrease the request size by a single page each pass through the loop.

\todo
Determine whether the maximum address passed to drm_pci_alloc is correct.
The same goes for drm_addbufs_pci.

\sa mga_do_dma_bootstrap, mga_do_agp_dma_bootstrap
.TH "mga_driver_postcleanup" 9 "mga_driver_postcleanup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mga_driver_postcleanup \- 
.SH SYNOPSIS
.B "int" mga_driver_postcleanup
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.TH "mga_driver_pretakedown" 9 "mga_driver_pretakedown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mga_driver_pretakedown \- 
.SH SYNOPSIS
.B "void" mga_driver_pretakedown
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.TH "i915_driver_device_is_agp" 9 "i915_driver_device_is_agp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i915_driver_device_is_agp \- 
.SH SYNOPSIS
.B "int" i915_driver_device_is_agp
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

All Intel graphics chipsets are treated as AGP, even if they are really
PCI-e.

\param dev   The device to be tested.

\returns
A value of 1 is always retured to indictate every i9x5 is AGP.
.TH "drm_lookup_map" 9 "drm_lookup_map" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_lookup_map \- 
.SH SYNOPSIS
.B "drm_map_t *" drm_lookup_map
.BI "(unsigned long " offset ","
.BI "unsigned long " size ","
.BI "drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "offset" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
drm_memory.h.  
.TH "drm_mmap_dma" 9 "drm_mmap_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_mmap_dma \- 
.SH SYNOPSIS
.B "int" drm_mmap_dma
.BI "(struct file *" filp ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "vma" 12
-- undescribed --
.SH "DESCRIPTION"

\param filp file pointer.
\param vma virtual memory area.
\return zero on success or a negative number on failure.

Sets the virtual memory area operations structure to vm_dma_ops, the file
pointer, and calls \fBvm_open\fP.
.TH "drm_mmap" 9 "drm_mmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_mmap \- 
.SH SYNOPSIS
.B "int" drm_mmap
.BI "(struct file *" filp ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "vma" 12
-- undescribed --
.SH "DESCRIPTION"

\param filp file pointer.
\param vma virtual memory area.
\return zero on success or a negative number on failure.

If the virtual memory area has no offset associated with it then it's a DMA
area, so calls \fBmmap_dma\fP. Otherwise searches the map in drm_device::maplist,
checks that the restricted flag is not set, sets the virtual memory operations
according to the mapping type and remaps the pages. Finally sets the file
pointer and calls \fBvm_open\fP.
.TH "i830_driver_device_is_agp" 9 "i830_driver_device_is_agp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i830_driver_device_is_agp \- 
.SH SYNOPSIS
.B "int" i830_driver_device_is_agp
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

All Intel graphics chipsets are treated as AGP, even if they are really
PCI-e.

\param dev   The device to be tested.

\returns
A value of 1 is always retured to indictate every i8xx is AGP.
.TH "drm_hash_magic" 9 "drm_hash_magic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_hash_magic \- 
.SH SYNOPSIS
.B "int" drm_hash_magic
.BI "(drm_magic_t " magic ");"
.SH ARGUMENTS
.IP "magic" 12
-- undescribed --
.SH "DESCRIPTION"

\param magic magic.
\return hash key.

The key is the modulus of the hash table size, #DRM_HASH_SIZE, which must be
a power of 2.
.TH "drm_find_file" 9 "drm_find_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_find_file \- 
.SH SYNOPSIS
.B "drm_file_t *" drm_find_file
.BI "(drm_device_t *" dev ","
.BI "drm_magic_t " magic ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "magic" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param magic magic number.
.SH "SEARCHES IN DRM_DEVICE"
:magiclist within all files with the same hash key
the one with matching magic number, while holding the drm_device::struct_sem
lock.
.TH "drm_add_magic" 9 "drm_add_magic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_add_magic \- 
.SH SYNOPSIS
.B "int" drm_add_magic
.BI "(drm_device_t *" dev ","
.BI "drm_file_t *" priv ","
.BI "drm_magic_t " magic ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "priv" 12
-- undescribed --
.IP "magic" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param priv file private data.
\param magic magic number.

Creates a drm_magic_entry structure and appends to the linked list
.SH "ASSOCIATED THE MAGIC NUMBER HASH KEY IN DRM_DEVICE"
:magiclist, while holding
.SH "THE DRM_DEVICE"
:struct_sem lock.
.TH "drm_remove_magic" 9 "drm_remove_magic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_remove_magic \- 
.SH SYNOPSIS
.B "int" drm_remove_magic
.BI "(drm_device_t *" dev ","
.BI "drm_magic_t " magic ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "magic" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param magic magic number.
.SH "SEARCHES AND UNLINKS THE ENTRY IN DRM_DEVICE"
:magiclist with the magic
number hash key, while holding the drm_device::struct_sem lock.
.TH "drm_getmagic" 9 "drm_getmagic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_getmagic \- 
.SH SYNOPSIS
.B "int" drm_getmagic
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a resulting drm_auth structure.
\return zero on success, or a negative number on failure.
.SH "IF THERE IS A MAGIC NUMBER IN DRM_FILE"
:magic then use it, otherwise
searches an unique non-zero magic number and add it associating it with \p
filp.
.TH "drm_authmagic" 9 "drm_authmagic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_authmagic \- 
.SH SYNOPSIS
.B "int" drm_authmagic
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_auth structure.
\return zero if authentication successed, or a negative number otherwise.

Checks if \p filp is associated with the magic number passed in \arg.
.TH "mga_compat_ioctl" 9 "mga_compat_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mga_compat_ioctl \- bit process running under a 64-bit kernel
.SH SYNOPSIS
.B "long" mga_compat_ioctl
.BI "(struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
performs an ioctl on /dev/dri/card&lt;n&gt;.

\param filp file pointer.
\param cmd command.
\param arg user argument.
\return zero on success or negative number on failure.
.TH "drm_takedown" 9 "drm_takedown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_takedown \- 
.SH SYNOPSIS
.B "int" drm_takedown
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device structure.

Frees every resource in \p dev.

\sa drm_device
.TH "drm_init" 9 "drm_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_init \- 
.SH SYNOPSIS
.B "int" drm_init
.BI "(struct drm_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.SH "DESCRIPTION"
linux/init/main.c (this is not currently supported).

\return zero on success or a negative number on failure.

Initializes an array of drm_device structures, and attempts to
initialize all available devices, using consecutive minors, registering the
stubs and initializing the AGP device.

Expands the \c DRIVER_PREINIT and \c DRIVER_POST_INIT macros before and
after the initialization for driver customization.
.TH "drm_cleanup" 9 "drm_cleanup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_cleanup \- 
.SH SYNOPSIS
.B "void" drm_cleanup
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Cleans up all DRM device, calling \fBtakedown\fP.

\sa drm_init
.TH "drm_version" 9 "drm_version" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_version \- 
.SH SYNOPSIS
.B "int" drm_version
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_version structure.
\return zero on success or negative number on failure.

Fills in the version information in \p arg.
.TH "drm_ioctl" 9 "drm_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_ioctl \- 
.SH SYNOPSIS
.B "int" drm_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument.
\return zero on success or negative number on failure.
.SH "LOOKS UP THE IOCTL FUNCTION IN THE "
:ioctls table, checking for root
previleges if so required, and dispatches to the respective function.
.TH "r300_emit_cliprects" 9 "r300_emit_cliprects" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_emit_cliprects \- 
.SH SYNOPSIS
.B "int" r300_emit_cliprects
.BI "(drm_radeon_private_t *" dev_priv ","
.BI "drm_radeon_cmd_buffer_t *" cmdbuf ","
.BI "int " n ");"
.SH ARGUMENTS
.IP "dev_priv" 12
-- undescribed --
.IP "cmdbuf" 12
-- undescribed --
.IP "n" 12
-- undescribed --
.SH "DESCRIPTION"
buffer, starting with index n.
.TH "r300_emit_packet0" 9 "r300_emit_packet0" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_emit_packet0 \- 
.SH SYNOPSIS
.B "int" r300_emit_packet0
.BI "(drm_radeon_private_t *" dev_priv ","
.BI "drm_radeon_cmd_buffer_t *" cmdbuf ","
.BI "drm_r300_cmd_header_t " header ");"
.SH ARGUMENTS
.IP "dev_priv" 12
-- undescribed --
.IP "cmdbuf" 12
-- undescribed --
.IP "header" 12
-- undescribed --
.SH "DESCRIPTION"
Called by r300_do_cp_cmdbuf.

Note that checks are performed on contents and addresses of the registers
.TH "r300_emit_vpu" 9 "r300_emit_vpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_emit_vpu \- supplied vertex program instructions or parameters onto
.SH SYNOPSIS
.B "int" r300_emit_vpu
.BI "(drm_radeon_private_t *" dev_priv ","
.BI "drm_radeon_cmd_buffer_t *" cmdbuf ","
.BI "drm_r300_cmd_header_t " header ");"
.SH ARGUMENTS
.IP "dev_priv" 12
-- undescribed --
.IP "cmdbuf" 12
-- undescribed --
.IP "header" 12
-- undescribed --
.SH "DESCRIPTION"
the graphics card.
Called by r300_do_cp_cmdbuf.
.TH "r300_emit_clear" 9 "r300_emit_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_emit_clear \- 
.SH SYNOPSIS
.B "int" r300_emit_clear
.BI "(drm_radeon_private_t *" dev_priv ","
.BI "drm_radeon_cmd_buffer_t *" cmdbuf ");"
.SH ARGUMENTS
.IP "dev_priv" 12
-- undescribed --
.IP "cmdbuf" 12
-- undescribed --
.SH "DESCRIPTION"
Called by r300_emit_packet3.
.TH "r300_emit_packet3" 9 "r300_emit_packet3" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_emit_packet3 \- 
.SH SYNOPSIS
.B "int" r300_emit_packet3
.BI "(drm_radeon_private_t *" dev_priv ","
.BI "drm_radeon_cmd_buffer_t *" cmdbuf ","
.BI "drm_r300_cmd_header_t " header ");"
.SH ARGUMENTS
.IP "dev_priv" 12
-- undescribed --
.IP "cmdbuf" 12
-- undescribed --
.IP "header" 12
-- undescribed --
.SH "DESCRIPTION"
Called by r300_do_cp_cmdbuf.
.TH "r300_pacify" 9 "r300_pacify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_pacify \- 
.SH SYNOPSIS
.B "void" r300_pacify
.BI "(drm_radeon_private_t *" dev_priv ");"
.SH ARGUMENTS
.IP "dev_priv" 12
-- undescribed --
.TH "r300_discard_buffer" 9 "r300_discard_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_discard_buffer \- 
.SH SYNOPSIS
.B "void" r300_discard_buffer
.BI "(drm_device_t *" dev ","
.BI "drm_buf_t *" buf ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"
The actual age emit is done by r300_do_cp_cmdbuf, which is why you must
be careful about how this function is called.
.TH "r300_do_cp_cmdbuf" 9 "r300_do_cp_cmdbuf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r300_do_cp_cmdbuf \- supplied command buffer and emits appropriate
.SH SYNOPSIS
.B "int" r300_do_cp_cmdbuf
.BI "(drm_device_t *" dev ","
.BI "DRMFILE " filp ","
.BI "drm_file_t *" filp_priv ","
.BI "drm_radeon_cmd_buffer_t *" cmdbuf ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "filp_priv" 12
-- undescribed --
.IP "cmdbuf" 12
-- undescribed --
.SH "DESCRIPTION"
commands on the DMA ring buffer.
Called by the ioctl handler function radeon_cp_cmdbuf.
.TH "radeon_compat_ioctl" 9 "radeon_compat_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
radeon_compat_ioctl \- bit process running under a 64-bit kernel
.SH SYNOPSIS
.B "long" radeon_compat_ioctl
.BI "(struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
performs an ioctl on /dev/dri/card&lt;n&gt;.

\param filp file pointer.
\param cmd command.
\param arg user argument.
\return zero on success or negative number on failure.
.TH "drm_addmap_core" 9 "drm_addmap_core" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_addmap_core \- root process.
.SH SYNOPSIS
.B "int" drm_addmap_core
.BI "(drm_device_t *" dev ","
.BI "unsigned int " offset ","
.BI "unsigned int " size ","
.BI "drm_map_type_t " type ","
.BI "drm_map_flags_t " flags ","
.BI "drm_map_list_t **" maplist ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.IP "type" 12
-- undescribed --
.IP "flags" 12
-- undescribed --
.IP "maplist" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_map structure.
\return zero on success or a negative value on error.

Adjusts the memory offset to its absolute value according to the mapping
type.  Adds the map to the map list drm_device::maplist. Adds MTRR's where
applicable and if supported by the kernel.
.TH "drm_rmmap_locked" 9 "drm_rmmap_locked" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_rmmap_locked \- 
.SH SYNOPSIS
.B "int" drm_rmmap_locked
.BI "(drm_device_t *" dev ","
.BI "drm_local_map_t *" map ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "map" 12
-- undescribed --
.SH "DESCRIPTION"
isn't in use.

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_map_t structure.
\return zero on success or a negative value on error.
.SH "SEARCHES THE MAP ON DRM_DEVICE"
:maplist, removes it from the list, see if
its being used, and free any associate resource (such as MTRR's) if it's not
being on use.

\sa drm_addmap
.TH "drm_cleanup_buf_error" 9 "drm_cleanup_buf_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_cleanup_buf_error \- 
.SH SYNOPSIS
.B "void" drm_cleanup_buf_error
.BI "(drm_device_t *" dev ","
.BI "drm_buf_entry_t *" entry ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "entry" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param entry buffer entry where the error occurred.

Frees any pages and buffers associated with the given entry.
.TH "drm_addbufs_agp" 9 "drm_addbufs_agp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_addbufs_agp \- 
.SH SYNOPSIS
.B "int" drm_addbufs_agp
.BI "(drm_device_t *" dev ","
.BI "drm_buf_desc_t *" request ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "request" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev drm_device_t to which the buffers are to be added.
\param request pointer to a drm_buf_desc_t describing the request.
\return zero on success or a negative number on failure.

After some sanity checks creates a drm_buf structure for each buffer and
reallocates the buffer list of the same size order to accommodate the new
buffers.
.TH "drm_addbufs" 9 "drm_addbufs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_addbufs \- 
.SH SYNOPSIS
.B "int" drm_addbufs
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_buf_desc_t request.
\return zero on success or a negative number on failure.
.SH "ACCORDING WITH THE MEMORY TYPE SPECIFIED IN DRM_BUF_DESC"
:flags and the
build options, it dispatches the call either to \fBaddbufs_agp\fP,
\fBaddbufs_sg\fP or \fBaddbufs_pci\fP for AGP, scatter-gather or consistent
PCI memory respectively.
.TH "drm_infobufs" 9 "drm_infobufs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_infobufs \- 
.SH SYNOPSIS
.B "int" drm_infobufs
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

This was originally mean for debugging purposes, or by a sophisticated
client library to determine how best to use the available buffers (e.g.,
large buffers can be used for image transfer).

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_buf_info structure.
\return zero on success or a negative number on failure.
.SH "INCREMENTS DRM_DEVICE"
:buf_use while holding the drm_device::count_lock
lock, preventing of allocating more buffers after this call. Information
about each requested buffer is then copied into user space.
.TH "drm_markbufs" 9 "drm_markbufs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_markbufs \- 
.SH SYNOPSIS
.B "int" drm_markbufs
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg a pointer to a drm_buf_desc structure.
\return zero on success or a negative number on failure.

Verifies that the size order is bounded between the admissible orders and
.SH "UPDATES THE RESPECTIVE DRM_DEVICE_DMA"
:bufs entry low and high water mark.

\note This ioctl is deprecated and mostly never used.
.TH "drm_freebufs" 9 "drm_freebufs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_freebufs \- 
.SH SYNOPSIS
.B "int" drm_freebufs
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_buf_free structure.
\return zero on success or a negative number on failure.

Calls \fBfree_buffer\fP for each used buffer.
This function is primarily used for debugging.
.TH "drm_mapbufs" 9 "drm_mapbufs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_mapbufs \- virtual space (ioctl).
.SH SYNOPSIS
.B "int" drm_mapbufs
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_buf_map structure.
\return zero on success or a negative number on failure.

Maps the AGP or SG buffer region with \fBdo_mmap\fP, and copies information
about each buffer into user space. The PCI buffers are already mapped on the
\fBaddbufs_pci\fP call.
.TH "drm_order" 9 "drm_order" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_order \- 
.SH SYNOPSIS
.B "int" drm_order
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
is greater or equal to given number.

\param size size.
\return order.

\todo Can be made faster.
.TH "drm_sysfs_create" 9 "drm_sysfs_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_sysfs_create \-  create a struct drm_sysfs_class structure
.SH SYNOPSIS
.B "struct drm_sysfs_class *" drm_sysfs_create
.BI "(struct module *" owner ","
.BI "char *" name ");"
.SH ARGUMENTS
.IP "owner" 12
 pointer to the module that is to "own" this struct drm_sysfs_class
.IP "name" 12
 pointer to a string for the name of this class.
.SH "DESCRIPTION"
This is used to create a struct drm_sysfs_class pointer that can then be used
in calls to \fBdrm_sysfs_device_add\fP.

Note, the pointer created here is to be destroyed when finished by making a
call to \fBdrm_sysfs_destroy\fP.
.TH "drm_sysfs_destroy" 9 "drm_sysfs_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_sysfs_destroy \-  destroys a struct drm_sysfs_class structure
.SH SYNOPSIS
.B "void" drm_sysfs_destroy
.BI "(struct drm_sysfs_class *" cs ");"
.SH ARGUMENTS
.IP "cs" 12
 pointer to the struct drm_sysfs_class that is to be destroyed
.SH "DESCRIPTION"
Note, the pointer to be destroyed must have been created with a call to
\fBdrm_sysfs_create\fP.
.TH "drm_sysfs_device_add" 9 "drm_sysfs_device_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_sysfs_device_add \-  adds a class device to sysfs for a character driver
.SH SYNOPSIS
.B "struct class_device *" drm_sysfs_device_add
.BI "(struct drm_sysfs_class *" cs ","
.BI "dev_t " dev ","
.BI "struct device *" device ","
.BI "const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "cs" 12
 pointer to the struct drm_sysfs_class that this device should be registered to.
.IP "dev" 12
 the dev_t for the device to be added.
.IP "device" 12
 a pointer to a struct device that is assiociated with this class device.
.IP "fmt" 12
 string for the class device's name
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
A struct class_device will be created in sysfs, registered to the specified
class.  A "dev" file will be created, showing the dev_t for the device.  The
pointer to the struct class_device will be returned from the call.  Any further
sysfs files that might be required can be created using this pointer.
.SH "NOTE"
 the struct drm_sysfs_class passed to this function must have previously been
created with a call to \fBdrm_sysfs_create\fP.
.TH "drm_sysfs_device_remove" 9 "drm_sysfs_device_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_sysfs_device_remove \-  removes a class device that was created with drm_sysfs_device_add()
.SH SYNOPSIS
.B "void" drm_sysfs_device_remove
.BI "(dev_t " dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the dev_t of the device that was previously registered.
.SH "DESCRIPTION"
This call unregisters and cleans up a class device that was created with a
call to \fBdrm_sysfs_device_add\fP
.TH "i810_driver_device_is_agp" 9 "i810_driver_device_is_agp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_driver_device_is_agp \- 
.SH SYNOPSIS
.B "int" i810_driver_device_is_agp
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

All Intel graphics chipsets are treated as AGP, even if they are really
PCI-e.

\param dev   The device to be tested.

\returns
A value of 1 is always retured to indictate every i810 is AGP.
.TH "drm_getunique" 9 "drm_getunique" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_getunique \- 
.SH SYNOPSIS
.B "int" drm_getunique
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_unique structure.
\return zero on success or a negative number on failure.
.SH "COPIES THE BUS ID FROM DRM_DEVICE"
:unique into user space.
.TH "drm_setunique" 9 "drm_setunique" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_setunique \- 
.SH SYNOPSIS
.B "int" drm_setunique
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_unique structure.
\return zero on success or a negative number on failure.
.SH "COPIES THE BUS ID FROM USERSPACE INTO DRM_DEVICE"
:unique, and verifies that
it matches the device this DRM is attached to (EINVAL otherwise).  Deprecated
in interface version 1.1 and will return EBUSY when setversion has requested
version 1.1 or greater.
.TH "drm_getmap" 9 "drm_getmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_getmap \- 
.SH SYNOPSIS
.B "int" drm_getmap
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_map structure.

\return zero on success or a negative number on failure.

Searches for the mapping with the specified offset and copies its information
into userspace
.TH "drm_getclient" 9 "drm_getclient" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_getclient \- 
.SH SYNOPSIS
.B "int" drm_getclient
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_client structure.

\return zero on success or a negative number on failure.

Searches for the client with the specified index and copies its information
into userspace
.TH "drm_getstats" 9 "drm_getstats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_getstats \- 
.SH SYNOPSIS
.B "int" drm_getstats
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_stats structure.

\return zero on success or a negative number on failure.
.TH "drm_setversion" 9 "drm_setversion" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_setversion \- 
.SH SYNOPSIS
.B "int" drm_setversion
.BI "(" DRM_IOCTL_ARGS ");"
.SH ARGUMENTS
.IP "DRM_IOCTL_ARGS" 12
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_lock structure.
\return zero on success or negative number on failure.

Sets the requested interface version
.TH "DRM_GETSAREA" 9 "DRM_GETSAREA" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
DRM_GETSAREA \- 
.SH SYNOPSIS
.B "" DRM_GETSAREA
.SH ARGUMENTS
.SH "DESCRIPTION"
.SH "SEARCHES THE SAREA ON THE MAPPING LISTS AND POINTS DRM_DEVICE"
:sarea to it.
.TH "drm_irq_by_busid" 9 "drm_irq_by_busid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_irq_by_busid \- 
.SH SYNOPSIS
.B "int" drm_irq_by_busid
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_irq_busid structure.
\return zero on success or a negative number on failure.

Finds the PCI device with the specified bus id and gets its IRQ number.
This IOCTL is deprecated, and will now return EINVAL for any busid not equal
to that of the device that this DRM instance attached to.
.TH "drm_irq_install" 9 "drm_irq_install" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_irq_install \- 
.SH SYNOPSIS
.B "int" drm_irq_install
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param irq IRQ number.

Initializes the IRQ related data, and setups drm_device::vbl_queue. Installs the handler, calling the driver
\c \fBdrm_driver_irq_preinstall\fP and \c \fBdrm_driver_irq_postinstall\fP functions
before and after the installation.
.TH "drm_irq_uninstall" 9 "drm_irq_uninstall" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_irq_uninstall \- 
.SH SYNOPSIS
.B "int" drm_irq_uninstall
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.

Calls the driver's \c \fBdrm_driver_irq_uninstall\fP function, and stops the irq.
.TH "drm_control" 9 "drm_control" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_control \- 
.SH SYNOPSIS
.B "int" drm_control
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_control structure.
\return zero on success or a negative number on failure.

Calls \fBirq_install\fP or \fBirq_uninstall\fP according to \p arg.
.TH "drm_wait_vblank" 9 "drm_wait_vblank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_wait_vblank \- 
.SH SYNOPSIS
.B "int" drm_wait_vblank
.BI "(" DRM_IOCTL_ARGS ");"
.SH ARGUMENTS
.IP "DRM_IOCTL_ARGS" 12
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param data user argument, pointing to a drm_wait_vblank structure.
\return zero on success or a negative number on failure.

Verifies the IRQ is installed. 

If a signal is requested checks if this task has already scheduled the same signal
for the same vblank sequence number - nothing to be done in
that case. If the number of tasks waiting for the interrupt exceeds 100 the
function fails. Otherwise adds a new entry to drm_device::vbl_sigs for this
task.

If a signal is not requested, then calls \fBvblank_wait\fP.
.TH "drm_vbl_send_signals" 9 "drm_vbl_send_signals" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_vbl_send_signals \- 
.SH SYNOPSIS
.B "void" drm_vbl_send_signals
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
.SH "SENDS A SIGNAL FOR EACH TASK IN DRM_DEVICE"
:vbl_sigs and empties the list.

If a signal is not requested, then calls \fBvblank_wait\fP.
.TH "mga_driver_device_is_agp" 9 "mga_driver_device_is_agp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mga_driver_device_is_agp \- 
.SH SYNOPSIS
.B "int" mga_driver_device_is_agp
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

In addition to the usual tests performed by \c drm_device_is_agp, this
function detects PCI G450 cards that appear to the system exactly like
AGP G450 cards.

\param dev   The device to be tested.

\returns
If the device is a PCI G450, zero is returned.  Otherwise 2 is returned.
.TH "drm_lock" 9 "drm_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_lock \- 
.SH SYNOPSIS
.B "int" drm_lock
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_lock structure.
\return zero on success or negative number on failure.

Add the current task to the lock wait queue, and attempt to take to lock.
.TH "drm_unlock" 9 "drm_unlock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_unlock \- 
.SH SYNOPSIS
.B "int" drm_unlock
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument, pointing to a drm_lock structure.
\return zero on success or negative number on failure.

Transfer and free the lock.
.TH "drm_lock_take" 9 "drm_lock_take" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_lock_take \- 
.SH SYNOPSIS
.B "int" drm_lock_take
.BI "(__volatile__ unsigned int *" lock ","
.BI "unsigned int " context ");"
.SH ARGUMENTS
.IP "lock" 12
-- undescribed --
.IP "context" 12
-- undescribed --
.SH "DESCRIPTION"

\param lock lock pointer.
\param context locking context.
\return one if the lock is held, or zero otherwise.

Attempt to mark the lock as held by the given context, via the \p cmpxchg instruction.
.TH "drm_lock_transfer" 9 "drm_lock_transfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_lock_transfer \- 
.SH SYNOPSIS
.B "int" drm_lock_transfer
.BI "(drm_device_t *" dev ","
.BI "__volatile__ unsigned int *" lock ","
.BI "unsigned int " context ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "lock" 12
-- undescribed --
.IP "context" 12
-- undescribed --
.SH "DESCRIPTION"
inside *_unlock to give lock to kernel before calling *_dma_schedule. 

\param dev DRM device.
\param lock lock pointer.
\param context locking context.
\return always one.

Resets the lock file pointer.
Marks the lock as held by the given context, via the \p cmpxchg instruction.
.TH "drm_lock_free" 9 "drm_lock_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_lock_free \- 
.SH SYNOPSIS
.B "int" drm_lock_free
.BI "(drm_device_t *" dev ","
.BI "__volatile__ unsigned int *" lock ","
.BI "unsigned int " context ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "lock" 12
-- undescribed --
.IP "context" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param lock lock.
\param context context.

Resets the lock file pointer.
Marks the lock as not held, via the \p cmpxchg instruction. Wakes any task
waiting on the lock queue.
.TH "drm_notifier" 9 "drm_notifier" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_notifier \- 
.SH SYNOPSIS
.B "int" drm_notifier
.BI "(void *" priv ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.SH "DESCRIPTION"
without calling DRM_IOCTL_UNLOCK.

If the lock is not held, then let the signal proceed as usual.  If the lock
is held, then set the contended flag and keep the signal blocked.

\param priv pointer to a drm_sigdata structure.
\return one if the signal should be delivered normally, or zero if the
signal should be blocked.
.TH "i915_compat_ioctl" 9 "i915_compat_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i915_compat_ioctl \- bit process running under a 64-bit kernel
.SH SYNOPSIS
.B "long" i915_compat_ioctl
.BI "(struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
performs an ioctl on /dev/dri/card&lt;n&gt;.

\param filp file pointer.
\param cmd command.
\param arg user argument.
\return zero on success or negative number on failure.
.TH "drm_mem_info" 9 "drm_mem_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_mem_info \- 
.SH SYNOPSIS
.B "int" drm_mem_info
.BI "(char *" buf ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " len ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "buf" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"

\param buf output buffer.
\param start start of output data.
\param offset requested start offset.
\param len requested number of bytes.
\param eof whether there is no more data to return.
\param data private data.
\return number of written bytes.

No-op. 
.TH "drm_alloc_pages" 9 "drm_alloc_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_alloc_pages \- 
.SH SYNOPSIS
.B "unsigned long" drm_alloc_pages
.BI "(int " order ","
.BI "int " area ");"
.SH ARGUMENTS
.IP "order" 12
-- undescribed --
.IP "area" 12
-- undescribed --
.SH "DESCRIPTION"

\param order size order.
\param area memory area. (Not used.)
\return page address on success, or zero on failure.

Allocate and reserve free pages.
.TH "drm_free_pages" 9 "drm_free_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_free_pages \- 
.SH SYNOPSIS
.B "void" drm_free_pages
.BI "(unsigned long " address ","
.BI "int " order ","
.BI "int " area ");"
.SH ARGUMENTS
.IP "address" 12
-- undescribed --
.IP "order" 12
-- undescribed --
.IP "area" 12
-- undescribed --
.SH "DESCRIPTION"

\param address address of the pages to free.
\param order size order.
\param area memory area. (Not used.)

Unreserve and free pages allocated by \fBalloc_pages\fP.
.TH "drm_open" 9 "drm_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_open \- 
.SH SYNOPSIS
.B "int" drm_open
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode
\param filp file pointer.
\return zero on success or a negative number on failure.

Searches the DRM device with the same minor number, calls \fBopen_helper\fP, and
increments the device open count. If the open count was previous at zero,
i.e., it's the first that the device is open, then calls \fBsetup\fP.
.TH "drm_release" 9 "drm_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_release \- 
.SH SYNOPSIS
.B "int" drm_release
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode
\param filp file pointer.
\return zero on success or a negative number on failure.

If the hardware lock is held then free it, and take it again for the kernel
context since it's necessary to reclaim buffers. Unlink the file private
data from its list and free it. Decreases the open count and if it reaches
zero calls \fBtakedown\fP.
.TH "drm_open_helper" 9 "drm_open_helper" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_open_helper \- 
.SH SYNOPSIS
.B "int" drm_open_helper
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param dev device.
\return zero on success or a negative number on failure.

Creates and initializes a drm_file structure for the file private data in \p
filp and add it into the double linked list in \p dev.
.TH "drm_ctxbitmap_free" 9 "drm_ctxbitmap_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_ctxbitmap_free \- 
.SH SYNOPSIS
.B "void" drm_ctxbitmap_free
.BI "(drm_device_t *" dev ","
.BI "int " ctx_handle ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "ctx_handle" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param ctx_handle context handle.

Clears the bit specified by \p ctx_handle in drm_device::ctx_bitmap and the entry
.SH "IN DRM_DEVICE"
:context_sareas, while holding the drm_device::struct_sem
lock.
.TH "drm_ctxbitmap_next" 9 "drm_ctxbitmap_next" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_ctxbitmap_next \- 
.SH SYNOPSIS
.B "int" drm_ctxbitmap_next
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\return (non-negative) context handle on success or a negative number on failure.
.SH "FIND THE FIRST ZERO BIT IN DRM_DEVICE"
:ctx_bitmap and (re)allocates
.SH "DRM_DEVICE"
:struct_sem lock.
.SH "DRM_DEVICE"
:struct_sem lock.
.TH "drm_ctxbitmap_init" 9 "drm_ctxbitmap_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_ctxbitmap_init \- 
.SH SYNOPSIS
.B "int" drm_ctxbitmap_init
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
.SH "ALLOCATES AND INITIALIZE DRM_DEVICE"
:ctx_bitmap and drm_device::context_sareas, while holding
.SH "THE DRM_DEVICE"
:struct_sem lock.
.TH "drm_ctxbitmap_cleanup" 9 "drm_ctxbitmap_cleanup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_ctxbitmap_cleanup \- 
.SH SYNOPSIS
.B "void" drm_ctxbitmap_cleanup
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
.SH "FREES DRM_DEVICE"
:ctx_bitmap and drm_device::context_sareas, while holding
.SH "THE DRM_DEVICE"
:struct_sem lock.
.TH "drm_getsareactx" 9 "drm_getsareactx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_getsareactx \- context SAREA.
.SH SYNOPSIS
.B "int" drm_getsareactx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx_priv_map structure.
\return zero on success or a negative number on failure.
.SH "GETS THE MAP FROM DRM_DEVICE"
:context_sareas with the handle specified and
returns its handle.
.TH "drm_setsareactx" 9 "drm_setsareactx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_setsareactx \- context SAREA.
.SH SYNOPSIS
.B "int" drm_setsareactx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx_priv_map structure.
\return zero on success or a negative number on failure.

Searches the mapping specified in \p arg and update the entry in
.SH "DRM_DEVICE"
:context_sareas with it.
.TH "drm_context_switch" 9 "drm_context_switch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_context_switch \- 
.SH SYNOPSIS
.B "int" drm_context_switch
.BI "(drm_device_t *" dev ","
.BI "int " old ","
.BI "int " new ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "old" 12
-- undescribed --
.IP "new" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param old old context handle.
\param new new context handle.
\return zero on success or a negative number on failure.
.SH "ATTEMPT TO SET DRM_DEVICE"
:context_flag.
.TH "drm_context_switch_complete" 9 "drm_context_switch_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_context_switch_complete \- 
.SH SYNOPSIS
.B "int" drm_context_switch_complete
.BI "(drm_device_t *" dev ","
.BI "int " new ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "new" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device.
\param new new context handle.
\return zero on success or a negative number on failure.
.SH "UPDATES DRM_DEVICE"
:last_context and drm_device::last_switch. Verifies the
hardware lock is held, clears the drm_device::context_flag and wakes up
.SH "DRM_DEVICE"
:context_wait.
.TH "drm_resctx" 9 "drm_resctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_resctx \- 
.SH SYNOPSIS
.B "int" drm_resctx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx_res structure.
\return zero on success or a negative number on failure.
.TH "drm_addctx" 9 "drm_addctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_addctx \- 
.SH SYNOPSIS
.B "int" drm_addctx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx structure.
\return zero on success or a negative number on failure.

Get a new handle for the context and copy to userspace.
.TH "drm_getctx" 9 "drm_getctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_getctx \- 
.SH SYNOPSIS
.B "int" drm_getctx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx structure.
\return zero on success or a negative number on failure.
.TH "drm_switchctx" 9 "drm_switchctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_switchctx \- 
.SH SYNOPSIS
.B "int" drm_switchctx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx structure.
\return zero on success or a negative number on failure.

Calls \fBcontext_switch\fP.
.TH "drm_newctx" 9 "drm_newctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_newctx \- 
.SH SYNOPSIS
.B "int" drm_newctx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx structure.
\return zero on success or a negative number on failure.

Calls \fBcontext_switch_complete\fP.
.TH "drm_rmctx" 9 "drm_rmctx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_rmctx \- 
.SH SYNOPSIS
.B "int" drm_rmctx
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument pointing to a drm_ctx structure.
\return zero on success or a negative number on failure.

If not the special kernel context, calls \fBctxbitmap_free\fP to free the specified context.
.TH "drm_agp_info" 9 "drm_agp_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_info \- 
.SH SYNOPSIS
.B "int" drm_agp_info
.BI "(drm_device_t *" dev ","
.BI "drm_agp_info_t *" info ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a (output) drm_agp_info structure.
\return zero on success or a negative number on failure.

Verifies the AGP device has been initialized and acquired and fills in the
.SH "DRM_AGP_INFO STRUCTURE WITH THE INFORMATION IN DRM_AGP_HEAD"
:agp_info.
.TH "drm_agp_acquire" 9 "drm_agp_acquire" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_acquire \- 
.SH SYNOPSIS
.B "int" drm_agp_acquire
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device that is to acquire AGP
\return zero on success or a negative number on failure. 

Verifies the AGP device hasn't been acquired before and calls
\c agp_backend_acquire.
.TH "drm_agp_acquire_ioctl" 9 "drm_agp_acquire_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_acquire_ioctl \- 
.SH SYNOPSIS
.B "int" drm_agp_acquire_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg user argument.
\return zero on success or a negative number on failure.

Verifies the AGP device hasn't been acquired before and calls
\c agp_backend_acquire.
.TH "drm_agp_release" 9 "drm_agp_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_release \- 
.SH SYNOPSIS
.B "int" drm_agp_release
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device that is to release AGP
\return zero on success or a negative number on failure.

Verifies the AGP device has been acquired and calls \c agp_backend_release.
.TH "drm_agp_enable" 9 "drm_agp_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_enable \- 
.SH SYNOPSIS
.B "int" drm_agp_enable
.BI "(drm_device_t *" dev ","
.BI "drm_agp_mode_t " mode ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "mode" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device that has previously acquired AGP.
\param mode Requested AGP mode.
\return zero on success or a negative number on failure.

Verifies the AGP device has been acquired but not enabled, and calls
\c agp_enable.
.TH "drm_agp_alloc" 9 "drm_agp_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_alloc \- 
.SH SYNOPSIS
.B "int" drm_agp_alloc
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_agp_buffer structure.
\return zero on success or a negative number on failure.

Verifies the AGP device is present and has been acquired, allocates the
memory via \fBalloc_agp\fP and creates a drm_agp_mem entry for it.
.TH "drm_agp_lookup_entry" 9 "drm_agp_lookup_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_lookup_entry \- 
.SH SYNOPSIS
.B "drm_agp_mem_t *" drm_agp_lookup_entry
.BI "(drm_device_t *" dev ","
.BI "unsigned long " handle ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "handle" 12
-- undescribed --
.SH "DESCRIPTION"

\param dev DRM device structure.
\param handle AGP memory handle.
\return pointer to the drm_agp_mem structure associated with \p handle.
.SH "WALKS THROUGH DRM_AGP_HEAD"
:memory until finding a matching handle.
.TH "drm_agp_unbind" 9 "drm_agp_unbind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_unbind \- 
.SH SYNOPSIS
.B "int" drm_agp_unbind
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_agp_binding structure.
\return zero on success or a negative number on failure.

Verifies the AGP device is present and acquired, looks-up the AGP memory
entry and passes it to the \fBunbind_agp\fP function.
.TH "drm_agp_bind" 9 "drm_agp_bind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_bind \- 
.SH SYNOPSIS
.B "int" drm_agp_bind
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_agp_binding structure.
\return zero on success or a negative number on failure.

Verifies the AGP device is present and has been acquired and that no memory
is currently bound into the GATT. Looks-up the AGP memory entry and passes
it to \fBbind_agp\fP function.
.TH "drm_agp_free" 9 "drm_agp_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_free \- 
.SH SYNOPSIS
.B "int" drm_agp_free
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\param inode device inode.
\param filp file pointer.
\param cmd command.
\param arg pointer to a drm_agp_buffer structure.
\return zero on success or a negative number on failure.

Verifies the AGP device is present and has been acquired and looks up the
AGP memory entry. If the memory it's currently bound, unbind it via
\fBunbind_agp\fP. Frees it via \fBfree_agp\fP as well as the entry itself
and unlinks from the doubly linked list it's inserted in.
.TH "drm_agp_init" 9 "drm_agp_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drm_agp_init \- 
.SH SYNOPSIS
.B "drm_agp_head_t *" drm_agp_init
.BI "(drm_device_t *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\return pointer to a drm_agp_head structure.
.TH "r128_compat_ioctl" 9 "r128_compat_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
r128_compat_ioctl \- bit process running under a 64-bit kernel
.SH SYNOPSIS
.B "long" r128_compat_ioctl
.BI "(struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "filp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
performs an ioctl on /dev/dri/card&lt;n&gt;.

\param filp file pointer.
\param cmd command.
\param arg user argument.
\return zero on success or negative number on failure.
.TH "mmtimer_ioctl" 9 "mmtimer_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmtimer_ioctl \-  ioctl interface for /dev/mmtimer
.SH SYNOPSIS
.B "int" mmtimer_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of the device
.IP "file" 12
 file structure for the device
.IP "cmd" 12
 command to execute
.IP "arg" 12
 optional argument to command
.SH "DESCRIPTION"
Executes the command specified by \fIcmd\fP.  Returns 0 for success, &lt; 0 for
failure.
.SH "VALID COMMANDS"

MMTIMER_GETOFFSET - Should return the offset (relative to the start
of the page where the registers are mapped) for the counter in question.

MMTIMER_GETRES - Returns the resolution of the clock in femto (10^-15)
seconds

MMTIMER_GETFREQ - Copies the frequency of the clock in Hz to the address
specified by \fIarg\fP

MMTIMER_GETBITS - Returns the number of bits in the clock's counter

MMTIMER_MMAPAVAIL - Returns 1 if the registers can be mmap'd into userspace

MMTIMER_GETCOUNTER - Gets the current value in the counter and places it
in the address specified by \fIarg\fP.
.TH "mmtimer_mmap" 9 "mmtimer_mmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmtimer_mmap \-  maps the clock's registers into userspace
.SH SYNOPSIS
.B "int" mmtimer_mmap
.BI "(struct file *" file ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "file" 12
 file structure for the device
.IP "vma" 12
 VMA to map the registers into
.SH "DESCRIPTION"
Calls \fBremap_pfn_range\fP to map the clock's registers into
the calling process' address space.
.TH "mmtimer_interrupt" 9 "mmtimer_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmtimer_interrupt \-  timer interrupt handler
.SH SYNOPSIS
.B "irqreturn_t" mmtimer_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 irq received
.IP "dev_id" 12
 device the irq came from
.IP "regs" 12
 register state upon receipt of the interrupt
.SH "DESCRIPTION"
Called when one of the comarators matches the counter, This
routine will send signals to processes that have requested
them.

This interrupt is run in an interrupt context
by the SHUB. It is therefore safe to locally access SHub
registers.
.TH "mmtimer_init" 9 "mmtimer_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmtimer_init \-  device initialization routine
.SH SYNOPSIS
.B "int __init" mmtimer_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Does initial setup for the mmtimer device.
.TH "misc_register" 9 "misc_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
misc_register \- 	register a miscellaneous device
.SH SYNOPSIS
.B "int" misc_register
.BI "(struct miscdevice *" misc ");"
.SH ARGUMENTS
.IP "misc" 12
 device structure
.SH "DESCRIPTION"
Register a miscellaneous device with the kernel. If the minor
number is set to MISC_DYNAMIC_MINOR a minor number is assigned
and placed in the minor field of the structure. For other cases
the minor number requested is used.

The structure passed is linked into the kernel and may not be
destroyed until it has been unregistered.

A zero is returned on success and a negative errno code for
failure.
.TH "misc_deregister" 9 "misc_deregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
misc_deregister \-  unregister a miscellaneous device
.SH SYNOPSIS
.B "int" misc_deregister
.BI "(struct miscdevice *" misc ");"
.SH ARGUMENTS
.IP "misc" 12
 device to unregister
.SH "DESCRIPTION"
Unregister a miscellaneous device that was previously
successfully registered with \fBmisc_register\fP. Success
is indicated by a zero return, a negative errno code
indicates an error.
.TH "mbcs_completion_intr_handler" 9 "mbcs_completion_intr_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mbcs_completion_intr_handler \-  Primary completion handler.
.SH SYNOPSIS
.B "irqreturn_t" mbcs_completion_intr_handler
.BI "(int " irq ","
.BI "void *" arg ","
.BI "struct pt_regs *" ep ");"
.SH ARGUMENTS
.IP "irq" 12
 irq
.IP "arg" 12
 soft struct for device
.IP "ep" 12
 regs
.TH "mbcs_intr_alloc" 9 "mbcs_intr_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mbcs_intr_alloc \-  Allocate interrupts.
.SH SYNOPSIS
.B "int" mbcs_intr_alloc
.BI "(struct cx_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device pointer
.TH "mbcs_intr_dealloc" 9 "mbcs_intr_dealloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mbcs_intr_dealloc \-  Remove interrupts.
.SH SYNOPSIS
.B "void" mbcs_intr_dealloc
.BI "(struct cx_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device pointer
.TH "mbcs_probe" 9 "mbcs_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mbcs_probe \-  Initialize for device
.SH SYNOPSIS
.B "int" mbcs_probe
.BI "(struct cx_dev *" dev ","
.BI "const struct cx_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 device pointer
.IP "id" 12
-- undescribed --
.TH "wdrtas_set_interval" 9 "wdrtas_set_interval" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_set_interval \-  sets the watchdog interval
.SH SYNOPSIS
.B "int" wdrtas_set_interval
.BI "(int " interval ");"
.SH ARGUMENTS
.IP "interval" 12
 new interval
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failures

wdrtas_set_interval sets the watchdog keepalive interval by calling the
RTAS function set-indicator (surveillance). The unit of interval is
seconds.
.TH "wdrtas_get_interval" 9 "wdrtas_get_interval" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_get_interval \-  returns the current watchdog interval
.SH SYNOPSIS
.B "int" wdrtas_get_interval
.BI "(int " fallback_value ");"
.SH ARGUMENTS
.IP "fallback_value" 12
 value (in seconds) to use, if the RTAS call fails
.SH "DESCRIPTION"
returns the interval

wdrtas_get_interval returns the current watchdog keepalive interval
as reported by the RTAS function ibm,get-system-parameter. The unit
of the return value is seconds.
.TH "wdrtas_timer_start" 9 "wdrtas_timer_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_timer_start \-  starts watchdog
.SH SYNOPSIS
.B "void" wdrtas_timer_start
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

wdrtas_timer_start starts the watchdog by calling the RTAS function
set-interval (surveillance)
.TH "wdrtas_timer_stop" 9 "wdrtas_timer_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_timer_stop \-  stops watchdog
.SH SYNOPSIS
.B "void" wdrtas_timer_stop
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

wdrtas_timer_stop stops the watchdog timer by calling the RTAS function
set-interval (surveillance)
.TH "wdrtas_log_scanned_event" 9 "wdrtas_log_scanned_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_log_scanned_event \-  logs an event we received during keepalive
.SH SYNOPSIS
.B "void" wdrtas_log_scanned_event
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

wdrtas_log_scanned_event prints a message to the log buffer dumping
the results of the last event-scan call
.TH "wdrtas_timer_keepalive" 9 "wdrtas_timer_keepalive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_timer_keepalive \-  resets watchdog timer to keep system alive
.SH SYNOPSIS
.B "void" wdrtas_timer_keepalive
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

wdrtas_timer_keepalive restarts the watchdog timer by calling the
RTAS function event-scan and repeats these calls as long as there are
events available. All events will be dumped.
.TH "wdrtas_get_temperature" 9 "wdrtas_get_temperature" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_get_temperature \-  returns current temperature
.SH SYNOPSIS
.B "int" wdrtas_get_temperature
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

returns temperature or &lt;0 on failures

wdrtas_get_temperature returns the current temperature in Fahrenheit. It
uses the RTAS call get-sensor-state, token 3 to do so
.TH "wdrtas_get_status" 9 "wdrtas_get_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_get_status \-  returns the status of the watchdog
.SH SYNOPSIS
.B "int" wdrtas_get_status
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

returns a bitmask of defines WDIOF_... as defined in
include/linux/watchdog.h
.TH "wdrtas_get_boot_status" 9 "wdrtas_get_boot_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_get_boot_status \-  returns the reason for the last boot
.SH SYNOPSIS
.B "int" wdrtas_get_boot_status
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

returns a bitmask of defines WDIOF_... as defined in
include/linux/watchdog.h, indicating why the watchdog rebooted the system
.TH "wdrtas_ioctl" 9 "wdrtas_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_ioctl \-  ioctl function for the watchdog device
.SH SYNOPSIS
.B "int" wdrtas_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 inode structure
.IP "file" 12
 file structure
.IP "cmd" 12
 command for ioctl
.IP "arg" 12
 argument pointer
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure

wdrtas_ioctl implements the watchdog API ioctls
.TH "wdrtas_open" 9 "wdrtas_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_open \-  open function of watchdog device
.SH SYNOPSIS
.B "int" wdrtas_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode structure
.IP "file" 12
 file structure
.SH "DESCRIPTION"
returns 0 on success, -EBUSY if the file has been opened already, &lt;0 on
other failures

function called when watchdog device is opened
.TH "wdrtas_close" 9 "wdrtas_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_close \-  close function of watchdog device
.SH SYNOPSIS
.B "int" wdrtas_close
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode structure
.IP "file" 12
 file structure
.SH "DESCRIPTION"
returns 0 on success

close function. Always succeeds
.TH "wdrtas_temp_read" 9 "wdrtas_temp_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_temp_read \-  gives back the temperature in fahrenheit
.SH SYNOPSIS
.B "ssize_t" wdrtas_temp_read
.BI "(struct file *" file ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
 file structure
.IP "buf" 12
 user buffer
.IP "count" 12
 number of bytes to be read
.IP "ppos" 12
 position in file
.SH "DESCRIPTION"
returns always 1 or -EFAULT in case of user space copy failures, &lt;0 on
other failures

wdrtas_temp_read gives the temperature to the users by copying this
value as one byte into the user space buffer. The unit is Fahrenheit...
.TH "wdrtas_temp_open" 9 "wdrtas_temp_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_temp_open \-  open function of temperature device
.SH SYNOPSIS
.B "int" wdrtas_temp_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode structure
.IP "file" 12
 file structure
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure

function called when temperature device is opened
.TH "wdrtas_temp_close" 9 "wdrtas_temp_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_temp_close \-  close function of temperature device
.SH SYNOPSIS
.B "int" wdrtas_temp_close
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode structure
.IP "file" 12
 file structure
.SH "DESCRIPTION"
returns 0 on success

close function. Always succeeds
.TH "wdrtas_reboot" 9 "wdrtas_reboot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_reboot \-  reboot notifier function
.SH SYNOPSIS
.B "int" wdrtas_reboot
.BI "(struct notifier_block *" this ","
.BI "unsigned long " code ","
.BI "void *" ptr ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.IP "code" 12
 reboot code
.IP "ptr" 12
 unused
.SH "DESCRIPTION"
returns NOTIFY_DONE

wdrtas_reboot stops the watchdog in case of a reboot
.TH "wdrtas_get_tokens" 9 "wdrtas_get_tokens" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_get_tokens \-  reads in RTAS tokens
.SH SYNOPSIS
.B "int" wdrtas_get_tokens
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

returns 0 on succes, &lt;0 on failure

wdrtas_get_tokens reads in the tokens for the RTAS calls used in
this watchdog driver. It tolerates, if "get-sensor-state" and
"ibm,get-system-parameter" are not available.
.TH "wdrtas_unregister_devs" 9 "wdrtas_unregister_devs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_unregister_devs \-  unregisters the misc dev handlers
.SH SYNOPSIS
.B "void" wdrtas_unregister_devs
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

wdrtas_register_devs unregisters the watchdog and temperature watchdog
misc devs
.TH "wdrtas_register_devs" 9 "wdrtas_register_devs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_register_devs \-  registers the misc dev handlers
.SH SYNOPSIS
.B "int" wdrtas_register_devs
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

returns 0 on succes, &lt;0 on failure

wdrtas_register_devs registers the watchdog and temperature watchdog
misc devs
.TH "wdrtas_init" 9 "wdrtas_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_init \-  init function of the watchdog driver
.SH SYNOPSIS
.B "int __init" wdrtas_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

returns 0 on succes, &lt;0 on failure

registers the file handlers and the reboot notifier
.TH "wdrtas_exit" 9 "wdrtas_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdrtas_exit \-  exit function of the watchdog driver
.SH SYNOPSIS
.B "void __exit" wdrtas_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

unregisters the file handlers and the reboot notifier
.TH "wdtpci_start" 9 "wdtpci_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_start \- 
.SH SYNOPSIS
.B "int" wdtpci_start
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Start the watchdog driver.
.TH "wdtpci_stop" 9 "wdtpci_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_stop \- 
.SH SYNOPSIS
.B "int" wdtpci_stop
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Stop the watchdog driver.
.TH "wdtpci_ping" 9 "wdtpci_ping" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_ping \- 
.SH SYNOPSIS
.B "int" wdtpci_ping
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Reload counter one with the watchdog heartbeat. We don't bother reloading
the cascade counter.
.TH "wdtpci_set_heartbeat" 9 "wdtpci_set_heartbeat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_set_heartbeat \- 
.SH SYNOPSIS
.B "int" wdtpci_set_heartbeat
.BI "(int " t ");"
.SH ARGUMENTS
.IP "t" 12
		the new heartbeat value that needs to be set.
.SH "DESCRIPTION"
Set a new heartbeat value for the watchdog device. If the heartbeat value is
incorrect we keep the old value and return -EINVAL. If successfull we
return 0.
.TH "wdtpci_get_status" 9 "wdtpci_get_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_get_status \- 
.SH SYNOPSIS
.B "int" wdtpci_get_status
.BI "(int *" status ");"
.SH ARGUMENTS
.IP "status" 12
		the new status.
.SH "DESCRIPTION"
Extract the status information from a WDT watchdog device. There are
several board variants so we have to know which bits are valid. Some
bits default to one and some to zero in order to be maximally painful.

we then map the bits onto the status ioctl flags.
.TH "wdtpci_get_temperature" 9 "wdtpci_get_temperature" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_get_temperature \- 
.SH SYNOPSIS
.B "int" wdtpci_get_temperature
.BI "(int *" temperature ");"
.SH ARGUMENTS
.IP "temperature" 12
-- undescribed --
.SH "DESCRIPTION"

Reports the temperature in degrees Fahrenheit. The API is in
farenheit. It was designed by an imperial measurement luddite.
.TH "wdtpci_interrupt" 9 "wdtpci_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_interrupt \- 
.SH SYNOPSIS
.B "irqreturn_t" wdtpci_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
		Interrupt number
.IP "dev_id" 12
	Unused as we don't allow multiple devices.
.IP "regs" 12
		Unused.
.SH "DESCRIPTION"
Handle an interrupt from the board. These are raised when the status
map changes in what the board considers an interesting way. That means
a failure condition occurring.
.TH "wdtpci_write" 9 "wdtpci_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_write \- 
.SH SYNOPSIS
.B "ssize_t" wdtpci_write
.BI "(struct file *" file ","
.BI "const char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
 file handle to the watchdog
.IP "buf" 12
 buffer to write (unused as data does not matter here
.IP "count" 12
 count of bytes
.IP "ppos" 12
 pointer to the position to write. No seeks allowed
.SH "DESCRIPTION"
A write to a watchdog device is defined as a keepalive signal. Any
write of data will do, as we we don't define content meaning.
.TH "wdtpci_ioctl" 9 "wdtpci_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_ioctl \- 
.SH SYNOPSIS
.B "int" wdtpci_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of the device
.IP "file" 12
 file handle to the device
.IP "cmd" 12
 watchdog command
.IP "arg" 12
 argument pointer
.SH "DESCRIPTION"
The watchdog API defines a common set of functions for all watchdogs
according to their available features. We only actually usefully support
querying capabilities and current status.
.TH "wdtpci_open" 9 "wdtpci_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_open \- 
.SH SYNOPSIS
.B "int" wdtpci_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle to device
.SH "DESCRIPTION"
The watchdog device has been opened. The watchdog device is single
open and on opening we load the counters. Counter zero is a 100Hz
cascade, into counter 1 which downcounts to reboot. When the counter
triggers counter 2 downcounts the length of the reset pulse which
set set to be as long as possible.
.TH "wdtpci_release" 9 "wdtpci_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_release \- 
.SH SYNOPSIS
.B "int" wdtpci_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to board
.IP "file" 12
 file handle to board
.SH "DESCRIPTION"
The watchdog has a configurable API. There is a religious dispute
between people who want their watchdog to be able to shut down and
those who want to be sure if the watchdog manager dies the machine
reboots. In the former case we disable the counters, in the latter
case you have to open it again very soon.
.TH "wdtpci_temp_read" 9 "wdtpci_temp_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_temp_read \- 
.SH SYNOPSIS
.B "ssize_t" wdtpci_temp_read
.BI "(struct file *" file ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ptr ");"
.SH ARGUMENTS
.IP "file" 12
 file handle to the watchdog board
.IP "buf" 12
 buffer to write 1 byte into
.IP "count" 12
 length of buffer
.IP "ptr" 12
 offset (no seek allowed)
.SH "DESCRIPTION"
Read reports the temperature in degrees Fahrenheit. The API is in
fahrenheit. It was designed by an imperial measurement luddite.
.TH "wdtpci_temp_open" 9 "wdtpci_temp_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_temp_open \- 
.SH SYNOPSIS
.B "int" wdtpci_temp_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle to device
.SH "DESCRIPTION"
The temperature device has been opened.
.TH "wdtpci_temp_release" 9 "wdtpci_temp_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_temp_release \- 
.SH SYNOPSIS
.B "int" wdtpci_temp_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to board
.IP "file" 12
 file handle to board
.SH "DESCRIPTION"
The temperature device has been closed.
.TH "wdtpci_notify_sys" 9 "wdtpci_notify_sys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_notify_sys \- 
.SH SYNOPSIS
.B "int" wdtpci_notify_sys
.BI "(struct notifier_block *" this ","
.BI "unsigned long " code ","
.BI "void *" unused ");"
.SH ARGUMENTS
.IP "this" 12
 our notifier block
.IP "code" 12
 the event being reported
.IP "unused" 12
 unused
.SH "DESCRIPTION"
Our notifier is called on system shutdowns. We want to turn the card
off at reboot otherwise the machine will reboot again during memory
test or worse yet during the following fsck. This would suck, in fact
trust me - if it happens it does suck.
.TH "wdtpci_cleanup" 9 "wdtpci_cleanup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_cleanup \- 
.SH SYNOPSIS
.B "void __exit" wdtpci_cleanup
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unload the watchdog. You cannot do this with any file handles open.
If your watchdog is set to continue ticking on close and you unload
it, well it keeps ticking. We won't get the interrupt but the board
will not touch PC memory so all is fine. You just have to load a new
module in xx seconds or reboot.
.TH "wdtpci_init" 9 "wdtpci_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdtpci_init \- 
.SH SYNOPSIS
.B "int __init" wdtpci_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Set up the WDT watchdog board. All we have to do is grab the
resources we require and bitch if anyone beat us to them.
The \fBopen\fP function will actually kick the board off.
.TH "usb_pcwd_delete" 9 "usb_pcwd_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_pcwd_delete \- 
.SH SYNOPSIS
.B "void" usb_pcwd_delete
.BI "(struct usb_pcwd_private *" usb_pcwd ");"
.SH ARGUMENTS
.IP "usb_pcwd" 12
-- undescribed --
.TH "usb_pcwd_probe" 9 "usb_pcwd_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_pcwd_probe \- 
.SH SYNOPSIS
.B "int" usb_pcwd_probe
.BI "(struct usb_interface *" interface ","
.BI "const struct usb_device_id *" id ");"
.SH ARGUMENTS
.IP "interface" 12
-- undescribed --
.IP "id" 12
-- undescribed --
.SH "DESCRIPTION"

Called by the usb core when a new device is connected that it thinks
this driver might be interested in.
.TH "usb_pcwd_disconnect" 9 "usb_pcwd_disconnect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_pcwd_disconnect \- 
.SH SYNOPSIS
.B "void" usb_pcwd_disconnect
.BI "(struct usb_interface *" interface ");"
.SH ARGUMENTS
.IP "interface" 12
-- undescribed --
.SH "DESCRIPTION"

Called by the usb core when the device is removed from the system.

This routine guarantees that the driver will not submit any more urbs
by clearing dev-&gt;udev.
.TH "usb_pcwd_init" 9 "usb_pcwd_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_pcwd_init \- 
.SH SYNOPSIS
.B "int __init" usb_pcwd_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "usb_pcwd_exit" 9 "usb_pcwd_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_pcwd_exit \- 
.SH SYNOPSIS
.B "void __exit" usb_pcwd_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "eurwdt_ping" 9 "eurwdt_ping" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_ping \- 
.SH SYNOPSIS
.B "void" eurwdt_ping
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Reload counter one with the watchdog timeout.
.TH "eurwdt_write" 9 "eurwdt_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_write \- 
.SH SYNOPSIS
.B "ssize_t" eurwdt_write
.BI "(struct file *" file ","
.BI "const char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
 file handle to the watchdog
.IP "buf" 12
 buffer to write (unused as data does not matter here
.IP "count" 12
 count of bytes
.IP "ppos" 12
 pointer to the position to write. No seeks allowed
.SH "DESCRIPTION"
A write to a watchdog device is defined as a keepalive signal. Any
write of data will do, as we we don't define content meaning.
.TH "eurwdt_ioctl" 9 "eurwdt_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_ioctl \- 
.SH SYNOPSIS
.B "int" eurwdt_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of the device
.IP "file" 12
 file handle to the device
.IP "cmd" 12
 watchdog command
.IP "arg" 12
 argument pointer
.SH "DESCRIPTION"
The watchdog API defines a common set of functions for all watchdogs
according to their available features.
.TH "eurwdt_open" 9 "eurwdt_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_open \- 
.SH SYNOPSIS
.B "int" eurwdt_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle to device
.SH "DESCRIPTION"
The misc device has been opened. The watchdog device is single
open and on opening we load the counter.
.TH "eurwdt_release" 9 "eurwdt_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_release \- 
.SH SYNOPSIS
.B "int" eurwdt_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to board
.IP "file" 12
 file handle to board
.SH "DESCRIPTION"
The watchdog has a configurable API. There is a religious dispute
between people who want their watchdog to be able to shut down and
those who want to be sure if the watchdog manager dies the machine
reboots. In the former case we disable the counters, in the latter
case you have to open it again very soon.
.TH "eurwdt_notify_sys" 9 "eurwdt_notify_sys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_notify_sys \- 
.SH SYNOPSIS
.B "int" eurwdt_notify_sys
.BI "(struct notifier_block *" this ","
.BI "unsigned long " code ","
.BI "void *" unused ");"
.SH ARGUMENTS
.IP "this" 12
 our notifier block
.IP "code" 12
 the event being reported
.IP "unused" 12
 unused
.SH "DESCRIPTION"
Our notifier is called on system shutdowns. We want to turn the card
off at reboot otherwise the machine will reboot again during memory
test or worse yet during the following fsck. This would suck, in fact
trust me - if it happens it does suck.
.TH "eurwdt_exit" 9 "eurwdt_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_exit \- 
.SH SYNOPSIS
.B "void __exit" eurwdt_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unload the watchdog. You cannot do this with any file handles open.
If your watchdog is set to continue ticking on close and you unload
it, well it keeps ticking. We won't get the interrupt but the board
will not touch PC memory so all is fine. You just have to load a new
module in 60 seconds or reboot.
.TH "eurwdt_init" 9 "eurwdt_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eurwdt_init \- 
.SH SYNOPSIS
.B "int __init" eurwdt_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Set up the WDT watchdog board. After grabbing the resources
we require we need also to unlock the device.
The \fBopen\fP function will actually kick the board off.
.TH "sh_wdt_start" 9 "sh_wdt_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_start \-  Start the Watchdog
.SH SYNOPSIS
.B "void" sh_wdt_start
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Starts the watchdog.
.TH "sh_wdt_stop" 9 "sh_wdt_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_stop \-  Stop the Watchdog
.SH SYNOPSIS
.B "void" sh_wdt_stop
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Stops the watchdog.
.TH "sh_wdt_keepalive" 9 "sh_wdt_keepalive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_keepalive \-  Keep the Userspace Watchdog Alive
.SH SYNOPSIS
.B "void" sh_wdt_keepalive
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.SH "THE USERSPACE WATCHDOG GOT A KEEPALIVE"
 schedule the next heartbeat.
.TH "sh_wdt_set_heartbeat" 9 "sh_wdt_set_heartbeat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_set_heartbeat \-  Set the Userspace Watchdog heartbeat
.SH SYNOPSIS
.B "int" sh_wdt_set_heartbeat
.BI "(int " t ");"
.SH ARGUMENTS
.IP "t" 12
-- undescribed --
.SH "DESCRIPTION"

Set the Userspace Watchdog heartbeat
.TH "sh_wdt_ping" 9 "sh_wdt_ping" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_ping \-  Ping the Watchdog
.SH SYNOPSIS
.B "void" sh_wdt_ping
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 Unused
.SH "DESCRIPTION"
Clears overflow bit, resets timer counter.
.SH "DESCRIPTION"
Clears overflow bit, resets timer counter.
.TH "sh_wdt_open" 9 "sh_wdt_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_open \-  Open the Device
.SH SYNOPSIS
.B "int" sh_wdt_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle of device
.SH "DESCRIPTION"
Watchdog device is opened and started.
.SH "DESCRIPTION"
Watchdog device is opened and started.
.TH "sh_wdt_close" 9 "sh_wdt_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_close \-  Close the Device
.SH SYNOPSIS
.B "int" sh_wdt_close
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle of device
.SH "DESCRIPTION"
Watchdog device is closed and stopped.
.SH "DESCRIPTION"
Watchdog device is closed and stopped.
.TH "sh_wdt_write" 9 "sh_wdt_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_write \-  Write to Device
.SH SYNOPSIS
.B "ssize_t" sh_wdt_write
.BI "(struct file *" file ","
.BI "const char *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
 file handle of device
.IP "buf" 12
 buffer to write
.IP "count" 12
 length of buffer
.IP "ppos" 12
 offset
.SH "DESCRIPTION"
Pings the watchdog on write.
.SH "DESCRIPTION"
Pings the watchdog on write.
.TH "sh_wdt_ioctl" 9 "sh_wdt_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_ioctl \-  Query Device
.SH SYNOPSIS
.B "int" sh_wdt_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle of device
.IP "cmd" 12
 watchdog command
.IP "arg" 12
 argument
.SH "DESCRIPTION"
Query basic information from the device or ping it, as outlined by the
watchdog API.
.SH "DESCRIPTION"
Query basic information from the device or ping it, as outlined by the
watchdog API.
.TH "sh_wdt_notify_sys" 9 "sh_wdt_notify_sys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_notify_sys \-  Notifier Handler
.SH SYNOPSIS
.B "int" sh_wdt_notify_sys
.BI "(struct notifier_block *" this ","
.BI "unsigned long " code ","
.BI "void *" unused ");"
.SH ARGUMENTS
.IP "this" 12
 notifier block
.IP "code" 12
 notifier event
.IP "unused" 12
 unused
.SH "DESCRIPTION"
Handles specific events, such as turning off the watchdog during a
shutdown event.
.SH "DESCRIPTION"
Handles specific events, such as turning off the watchdog during a
shutdown event.
.TH "sh_wdt_init" 9 "sh_wdt_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_init \-  Initialize module
.SH SYNOPSIS
.B "int __init" sh_wdt_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Registers the device and notifier handler. Actual device
initialization is handled by \fBsh_wdt_open\fP.
.TH "sh_wdt_exit" 9 "sh_wdt_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_wdt_exit \-  Deinitialize module
.SH SYNOPSIS
.B "void __exit" sh_wdt_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters the device and notifier handler. Actual device
deinitialization is handled by \fBsh_wdt_close\fP.
.TH "wdt_start" 9 "wdt_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_start \- 
.SH SYNOPSIS
.B "int" wdt_start
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Start the watchdog driver.
.TH "wdt_stop" 9 "wdt_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_stop \- 
.SH SYNOPSIS
.B "int" wdt_stop
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Stop the watchdog driver.
.TH "wdt_ping" 9 "wdt_ping" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_ping \- 
.SH SYNOPSIS
.B "int" wdt_ping
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Reload counter one with the watchdog heartbeat. We don't bother reloading
the cascade counter.
.TH "wdt_set_heartbeat" 9 "wdt_set_heartbeat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_set_heartbeat \- 
.SH SYNOPSIS
.B "int" wdt_set_heartbeat
.BI "(int " t ");"
.SH ARGUMENTS
.IP "t" 12
		the new heartbeat value that needs to be set.
.SH "DESCRIPTION"
Set a new heartbeat value for the watchdog device. If the heartbeat value is
incorrect we keep the old value and return -EINVAL. If successfull we
return 0.
.TH "wdt_get_status" 9 "wdt_get_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_get_status \- 
.SH SYNOPSIS
.B "int" wdt_get_status
.BI "(int *" status ");"
.SH ARGUMENTS
.IP "status" 12
		the new status.
.SH "DESCRIPTION"
Extract the status information from a WDT watchdog device. There are
several board variants so we have to know which bits are valid. Some
bits default to one and some to zero in order to be maximally painful.

we then map the bits onto the status ioctl flags.
.TH "wdt_get_temperature" 9 "wdt_get_temperature" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_get_temperature \- 
.SH SYNOPSIS
.B "int" wdt_get_temperature
.BI "(int *" temperature ");"
.SH ARGUMENTS
.IP "temperature" 12
-- undescribed --
.SH "DESCRIPTION"

Reports the temperature in degrees Fahrenheit. The API is in
farenheit. It was designed by an imperial measurement luddite.
.TH "wdt_interrupt" 9 "wdt_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_interrupt \- 
.SH SYNOPSIS
.B "irqreturn_t" wdt_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
		Interrupt number
.IP "dev_id" 12
	Unused as we don't allow multiple devices.
.IP "regs" 12
		Unused.
.SH "DESCRIPTION"
Handle an interrupt from the board. These are raised when the status
map changes in what the board considers an interesting way. That means
a failure condition occurring.
.TH "wdt_write" 9 "wdt_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_write \- 
.SH SYNOPSIS
.B "ssize_t" wdt_write
.BI "(struct file *" file ","
.BI "const char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
 file handle to the watchdog
.IP "buf" 12
 buffer to write (unused as data does not matter here
.IP "count" 12
 count of bytes
.IP "ppos" 12
 pointer to the position to write. No seeks allowed
.SH "DESCRIPTION"
A write to a watchdog device is defined as a keepalive signal. Any
write of data will do, as we we don't define content meaning.
.TH "wdt_ioctl" 9 "wdt_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_ioctl \- 
.SH SYNOPSIS
.B "int" wdt_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of the device
.IP "file" 12
 file handle to the device
.IP "cmd" 12
 watchdog command
.IP "arg" 12
 argument pointer
.SH "DESCRIPTION"
The watchdog API defines a common set of functions for all watchdogs
according to their available features. We only actually usefully support
querying capabilities and current status.
.TH "wdt_open" 9 "wdt_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_open \- 
.SH SYNOPSIS
.B "int" wdt_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle to device
.SH "DESCRIPTION"
The watchdog device has been opened. The watchdog device is single
open and on opening we load the counters. Counter zero is a 100Hz
cascade, into counter 1 which downcounts to reboot. When the counter
triggers counter 2 downcounts the length of the reset pulse which
set set to be as long as possible.
.TH "wdt_release" 9 "wdt_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_release \- 
.SH SYNOPSIS
.B "int" wdt_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to board
.IP "file" 12
 file handle to board
.SH "DESCRIPTION"
The watchdog has a configurable API. There is a religious dispute
between people who want their watchdog to be able to shut down and
those who want to be sure if the watchdog manager dies the machine
reboots. In the former case we disable the counters, in the latter
case you have to open it again very soon.
.TH "wdt_temp_read" 9 "wdt_temp_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_temp_read \- 
.SH SYNOPSIS
.B "ssize_t" wdt_temp_read
.BI "(struct file *" file ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ptr ");"
.SH ARGUMENTS
.IP "file" 12
 file handle to the watchdog board
.IP "buf" 12
 buffer to write 1 byte into
.IP "count" 12
 length of buffer
.IP "ptr" 12
 offset (no seek allowed)
.SH "DESCRIPTION"
Temp_read reports the temperature in degrees Fahrenheit. The API is in
farenheit. It was designed by an imperial measurement luddite.
.TH "wdt_temp_open" 9 "wdt_temp_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_temp_open \- 
.SH SYNOPSIS
.B "int" wdt_temp_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle to device
.SH "DESCRIPTION"
The temperature device has been opened.
.TH "wdt_temp_release" 9 "wdt_temp_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_temp_release \- 
.SH SYNOPSIS
.B "int" wdt_temp_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode to board
.IP "file" 12
 file handle to board
.SH "DESCRIPTION"
The temperature device has been closed.
.TH "wdt_notify_sys" 9 "wdt_notify_sys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_notify_sys \- 
.SH SYNOPSIS
.B "int" wdt_notify_sys
.BI "(struct notifier_block *" this ","
.BI "unsigned long " code ","
.BI "void *" unused ");"
.SH ARGUMENTS
.IP "this" 12
 our notifier block
.IP "code" 12
 the event being reported
.IP "unused" 12
 unused
.SH "DESCRIPTION"
Our notifier is called on system shutdowns. We want to turn the card
off at reboot otherwise the machine will reboot again during memory
test or worse yet during the following fsck. This would suck, in fact
trust me - if it happens it does suck.
.TH "wdt_exit" 9 "wdt_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_exit \- 
.SH SYNOPSIS
.B "void __exit" wdt_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unload the watchdog. You cannot do this with any file handles open.
If your watchdog is set to continue ticking on close and you unload
it, well it keeps ticking. We won't get the interrupt but the board
will not touch PC memory so all is fine. You just have to load a new
module in 60 seconds or reboot.
.TH "wdt_init" 9 "wdt_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wdt_init \- 
.SH SYNOPSIS
.B "int __init" wdt_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Set up the WDT watchdog board. All we have to do is grab the
resources we require and bitch if anyone beat us to them.
The \fBopen\fP function will actually kick the board off.
.TH "ldisc_receive_buf" 9 "ldisc_receive_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ldisc_receive_buf \- 
.SH SYNOPSIS
.B "void" ldisc_receive_buf
.BI "(struct tty_struct *" tty ","
.BI "const __u8 *" data ","
.BI "char *" flags ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "flags" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"

The wrappers maintain line discipline references
while calling into the line discipline.

ldisc_receive_buf  - pass receive data to line discipline
.TH "hdlcdev_attach" 9 "hdlcdev_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_attach \- 
.SH SYNOPSIS
.B "int" hdlcdev_attach
.BI "(struct net_device *" dev ","
.BI "unsigned short " encoding ","
.BI "unsigned short " parity ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "encoding" 12
-- undescribed --
.IP "parity" 12
-- undescribed --
.SH "DESCRIPTION"
set encoding and frame check sequence (FCS) options

dev       pointer to network device structure
encoding  serial encoding setting
parity    FCS setting

returns 0 if success, otherwise error code
.TH "hdlcdev_xmit" 9 "hdlcdev_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_xmit \- 
.SH SYNOPSIS
.B "int" hdlcdev_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "skb" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

skb  socket buffer containing HDLC frame
dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_open" 9 "hdlcdev_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_open \- 
.SH SYNOPSIS
.B "int" hdlcdev_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
claim resources and initialize hardware

dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_close" 9 "hdlcdev_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_close \- 
.SH SYNOPSIS
.B "int" hdlcdev_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
shutdown hardware and release resources

dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_ioctl" 9 "hdlcdev_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_ioctl \- 
.SH SYNOPSIS
.B "int" hdlcdev_ioctl
.BI "(struct net_device *" dev ","
.BI "struct ifreq *" ifr ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "ifr" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.SH "DESCRIPTION"

dev  pointer to network device structure
ifr  pointer to network interface request structure
cmd  IOCTL command code

returns 0 if success, otherwise error code
.TH "hdlcdev_tx_timeout" 9 "hdlcdev_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_tx_timeout \- 
.SH SYNOPSIS
.B "void" hdlcdev_tx_timeout
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

dev  pointer to network device structure
.TH "hdlcdev_tx_done" 9 "hdlcdev_tx_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_tx_done \- 
.SH SYNOPSIS
.B "void" hdlcdev_tx_done
.BI "(struct mgsl_struct *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
reenable network layer transmit if stopped

info  pointer to device instance information
.TH "hdlcdev_rx" 9 "hdlcdev_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_rx \- 
.SH SYNOPSIS
.B "void" hdlcdev_rx
.BI "(struct mgsl_struct *" info ","
.BI "char *" buf ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
pass frame to network layer

info  pointer to device instance information
buf   pointer to buffer contianing frame data
size  count of data bytes in buf
.TH "hdlcdev_init" 9 "hdlcdev_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_init \- 
.SH SYNOPSIS
.B "int" hdlcdev_init
.BI "(struct mgsl_struct *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
do generic HDLC initialization

info  pointer to device instance information

returns 0 if success, otherwise error code
.TH "hdlcdev_exit" 9 "hdlcdev_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_exit \- 
.SH SYNOPSIS
.B "void" hdlcdev_exit
.BI "(struct mgsl_struct *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
do generic HDLC cleanup

info  pointer to device instance information
.TH "ldisc_flush_buffer" 9 "ldisc_flush_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ldisc_flush_buffer \- 
.SH SYNOPSIS
.B "void" ldisc_flush_buffer
.BI "(struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"

The wrappers maintain line discipline references
while calling into the line discipline.

ldisc_flush_buffer - flush line discipline receive buffers
ldisc_receive_buf  - pass receive data to line discipline
.TH "hdlcdev_attach" 9 "hdlcdev_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_attach \- 
.SH SYNOPSIS
.B "int" hdlcdev_attach
.BI "(struct net_device *" dev ","
.BI "unsigned short " encoding ","
.BI "unsigned short " parity ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "encoding" 12
-- undescribed --
.IP "parity" 12
-- undescribed --
.SH "DESCRIPTION"
set encoding and frame check sequence (FCS) options

dev       pointer to network device structure
encoding  serial encoding setting
parity    FCS setting

returns 0 if success, otherwise error code
.TH "hdlcdev_xmit" 9 "hdlcdev_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_xmit \- 
.SH SYNOPSIS
.B "int" hdlcdev_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "skb" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

skb  socket buffer containing HDLC frame
dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_open" 9 "hdlcdev_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_open \- 
.SH SYNOPSIS
.B "int" hdlcdev_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
claim resources and initialize hardware

dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_close" 9 "hdlcdev_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_close \- 
.SH SYNOPSIS
.B "int" hdlcdev_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
shutdown hardware and release resources

dev  pointer to network device structure

returns 0 if success, otherwise error code
.TH "hdlcdev_ioctl" 9 "hdlcdev_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_ioctl \- 
.SH SYNOPSIS
.B "int" hdlcdev_ioctl
.BI "(struct net_device *" dev ","
.BI "struct ifreq *" ifr ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "ifr" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.SH "DESCRIPTION"

dev  pointer to network device structure
ifr  pointer to network interface request structure
cmd  IOCTL command code

returns 0 if success, otherwise error code
.TH "hdlcdev_tx_timeout" 9 "hdlcdev_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_tx_timeout \- 
.SH SYNOPSIS
.B "void" hdlcdev_tx_timeout
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

dev  pointer to network device structure
.TH "hdlcdev_tx_done" 9 "hdlcdev_tx_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_tx_done \- 
.SH SYNOPSIS
.B "void" hdlcdev_tx_done
.BI "(MGSLPC_INFO *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
reenable network layer transmit if stopped

info  pointer to device instance information
.TH "hdlcdev_rx" 9 "hdlcdev_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_rx \- 
.SH SYNOPSIS
.B "void" hdlcdev_rx
.BI "(MGSLPC_INFO *" info ","
.BI "char *" buf ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
pass frame to network layer

info  pointer to device instance information
buf   pointer to buffer contianing frame data
size  count of data bytes in buf
.TH "hdlcdev_init" 9 "hdlcdev_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_init \- 
.SH SYNOPSIS
.B "int" hdlcdev_init
.BI "(MGSLPC_INFO *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
do generic HDLC initialization

info  pointer to device instance information

returns 0 if success, otherwise error code
.TH "hdlcdev_exit" 9 "hdlcdev_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hdlcdev_exit \- 
.SH SYNOPSIS
.B "void" hdlcdev_exit
.BI "(MGSLPC_INFO *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
do generic HDLC cleanup

info  pointer to device instance information
.TH "ib_ud_header_init" 9 "ib_ud_header_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_ud_header_init \-  Initialize UD header structure
.SH SYNOPSIS
.B "void" ib_ud_header_init
.BI "(int " payload_bytes ","
.BI "int " grh_present ","
.BI "struct ib_ud_header *" header ");"
.SH ARGUMENTS
.IP "payload_bytes" 12
Length of packet payload
.IP "grh_present" 12
GRH flag (if non-zero, GRH will be included)
.IP "header" 12
Structure to initialize
.SH "DESCRIPTION"
\fBib_ud_header_init\fP initializes the lrh.link_version, lrh.link_next_header,
lrh.packet_length, grh.ip_version, grh.payload_length,
grh.next_header, bth.opcode, bth.pad_count and
bth.transport_header_version fields of a &amp;struct ib_ud_header given
the payload length and whether a GRH will be included.
.TH "ib_ud_header_pack" 9 "ib_ud_header_pack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_ud_header_pack \-  Pack UD header struct into wire format
.SH SYNOPSIS
.B "int" ib_ud_header_pack
.BI "(struct ib_ud_header *" header ","
.BI "void *" buf ");"
.SH ARGUMENTS
.IP "header" 12
UD header struct
.IP "buf" 12
Buffer to pack into
.SH "DESCRIPTION"
\fBib_ud_header_pack\fP packs the UD header structure \fIheader\fP into wire
format in the buffer \fIbuf\fP.
.TH "ib_ud_header_unpack" 9 "ib_ud_header_unpack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_ud_header_unpack \-  Unpack UD header struct from wire format
.SH SYNOPSIS
.B "int" ib_ud_header_unpack
.BI "(void *" buf ","
.BI "struct ib_ud_header *" header ");"
.SH ARGUMENTS
.IP "buf" 12
Buffer to pack into
.IP "header" 12
UD header struct
.SH "DESCRIPTION"
\fBib_ud_header_pack\fP unpacks the UD header structure \fIheader\fP from wire
format in the buffer \fIbuf\fP.
.TH "ib_sa_cancel_query" 9 "ib_sa_cancel_query" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_sa_cancel_query \-  try to cancel an SA query
.SH SYNOPSIS
.B "void" ib_sa_cancel_query
.BI "(int " id ","
.BI "struct ib_sa_query *" query ");"
.SH ARGUMENTS
.IP "id" 12
ID of query to cancel
.IP "query" 12
query pointer to cancel
.SH "DESCRIPTION"
Try to cancel an SA query.  If the id and query don't match up or
the query has already completed, nothing is done.  Otherwise the
query is canceled and will complete with a status of -EINTR.
.TH "ib_sa_path_rec_get" 9 "ib_sa_path_rec_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_sa_path_rec_get \-  Start a Path get query
.SH SYNOPSIS
.B "int" ib_sa_path_rec_get
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "struct ib_sa_path_rec *" rec ","
.BI "ib_sa_comp_mask " comp_mask ","
.BI "int " timeout_ms ","
.BI "gfp_t " gfp_mask ","
.BI "void (*" callback ") (int status, 					struct ib_sa_path_rec *resp, 					void *context),"
.BI "void *" context ","
.BI "struct ib_sa_query **" sa_query ");"
.SH ARGUMENTS
.IP "device" 12
device to send query on
.IP "port_num" 12
 port number to send query on
.IP "rec" 12
Path Record to send in query
.IP "comp_mask" 12
component mask to send in query
.IP "timeout_ms" 12
time to wait for response
.IP "gfp_mask" 12
GFP mask to use for internal allocations
.IP "callback" 12
function called when query completes, times out or is
canceled
.IP "context" 12
opaque user context passed to callback
.IP "sa_query" 12
query context, used to cancel query
.SH "DESCRIPTION"
Send a Path Record Get query to the SA to look up a path.  The
callback function will be called when the query completes (or
fails); status is 0 for a successful response, -EINTR if the query
is canceled, -ETIMEDOUT is the query timed out, or -EIO if an error
occurred sending the query.  The resp parameter of the callback is
only valid if status is 0.

If the return value of \fBib_sa_path_rec_get\fP is negative, it is an
error code.  Otherwise it is a query ID that can be used to cancel
the query.
.TH "ib_sa_service_rec_query" 9 "ib_sa_service_rec_query" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_sa_service_rec_query \-  Start Service Record operation
.SH SYNOPSIS
.B "int" ib_sa_service_rec_query
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "u8 " method ","
.BI "struct ib_sa_service_rec *" rec ","
.BI "ib_sa_comp_mask " comp_mask ","
.BI "int " timeout_ms ","
.BI "gfp_t " gfp_mask ","
.BI "void (*" callback ") (int status, 					     struct ib_sa_service_rec *resp, 					     void *context),"
.BI "void *" context ","
.BI "struct ib_sa_query **" sa_query ");"
.SH ARGUMENTS
.IP "device" 12
device to send request on
.IP "port_num" 12
 port number to send request on
.IP "method" 12
SA method - should be get, set, or delete
.IP "rec" 12
Service Record to send in request
.IP "comp_mask" 12
component mask to send in request
.IP "timeout_ms" 12
time to wait for response
.IP "gfp_mask" 12
GFP mask to use for internal allocations
.IP "callback" 12
function called when request completes, times out or is
canceled
.IP "context" 12
opaque user context passed to callback
.IP "sa_query" 12
request context, used to cancel request
.SH "DESCRIPTION"
Send a Service Record set/get/delete to the SA to register,
unregister or query a service record.
The callback function will be called when the request completes (or
fails); status is 0 for a successful response, -EINTR if the query
is canceled, -ETIMEDOUT is the query timed out, or -EIO if an error
occurred sending the query.  The resp parameter of the callback is
only valid if status is 0.

If the return value of \fBib_sa_service_rec_query\fP is negative, it is an
error code.  Otherwise it is a request ID that can be used to cancel
the query.
.TH "ib_pack" 9 "ib_pack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_pack \-  Pack a structure into a buffer
.SH SYNOPSIS
.B "void" ib_pack
.BI "(const struct ib_field *" desc ","
.BI "int " desc_len ","
.BI "void *" structure ","
.BI "void *" buf ");"
.SH ARGUMENTS
.IP "desc" 12
Array of structure field descriptions
.IP "desc_len" 12
Number of entries in \fIdesc\fP
.IP "structure" 12
Structure to pack from
.IP "buf" 12
Buffer to pack into
.SH "DESCRIPTION"
\fBib_pack\fP packs a list of structure fields into a buffer,
controlled by the array of fields in \fIdesc\fP.
.TH "ib_unpack" 9 "ib_unpack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_unpack \-  Unpack a buffer into a structure
.SH SYNOPSIS
.B "void" ib_unpack
.BI "(const struct ib_field *" desc ","
.BI "int " desc_len ","
.BI "void *" buf ","
.BI "void *" structure ");"
.SH ARGUMENTS
.IP "desc" 12
Array of structure field descriptions
.IP "desc_len" 12
Number of entries in \fIdesc\fP
.IP "buf" 12
Buffer to unpack from
.IP "structure" 12
Structure to unpack into
.SH "DESCRIPTION"
\fBib_pack\fP unpacks a list of structure fields from a buffer,
controlled by the array of fields in \fIdesc\fP.
.TH "ib_alloc_device" 9 "ib_alloc_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_alloc_device \-  allocate an IB device struct
.SH SYNOPSIS
.B "struct ib_device *" ib_alloc_device
.BI "(size_t " size ");"
.SH ARGUMENTS
.IP "size" 12
size of structure to allocate
.SH "DESCRIPTION"
Low-level drivers should use \fBib_alloc_device\fP to allocate &amp;struct
ib_device.  \fIsize\fP is the size of the structure to be allocated,
including any private data used by the low-level driver.
\fBib_dealloc_device\fP must be used to free structures allocated with
\fBib_alloc_device\fP.
.TH "ib_dealloc_device" 9 "ib_dealloc_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_dealloc_device \-  free an IB device struct
.SH SYNOPSIS
.B "void" ib_dealloc_device
.BI "(struct ib_device *" device ");"
.SH ARGUMENTS
.IP "device" 12
structure to free
.SH "DESCRIPTION"
Free a structure allocated with \fBib_alloc_device\fP.
.TH "ib_register_device" 9 "ib_register_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_register_device \-  Register an IB device with IB core
.SH SYNOPSIS
.B "int" ib_register_device
.BI "(struct ib_device *" device ");"
.SH ARGUMENTS
.IP "device" 12
Device to register
.SH "DESCRIPTION"
Low-level drivers use \fBib_register_device\fP to register their
devices with the IB core.  All registered clients will receive a
callback for each device that is added. \fIdevice\fP must be allocated
with \fBib_alloc_device\fP.
.TH "ib_unregister_device" 9 "ib_unregister_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_unregister_device \-  Unregister an IB device
.SH SYNOPSIS
.B "void" ib_unregister_device
.BI "(struct ib_device *" device ");"
.SH ARGUMENTS
.IP "device" 12
Device to unregister
.SH "DESCRIPTION"
Unregister an IB device.  All clients will receive a remove callback.
.TH "ib_register_client" 9 "ib_register_client" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_register_client \-  Register an IB client
.SH SYNOPSIS
.B "int" ib_register_client
.BI "(struct ib_client *" client ");"
.SH ARGUMENTS
.IP "client" 12
Client to register
.SH "DESCRIPTION"
Upper level users of the IB drivers can use \fBib_register_client\fP to
register callbacks for IB device addition and removal.  When an IB
device is added, each registered client's add method will be called
(in the order the clients were registered), and when a device is
removed, each client's remove method will be called (in the reverse
order that clients were registered).  In addition, when
\fBib_register_client\fP is called, the client will receive an add
callback for all devices already registered.
.TH "ib_unregister_client" 9 "ib_unregister_client" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_unregister_client \-  Unregister an IB client
.SH SYNOPSIS
.B "void" ib_unregister_client
.BI "(struct ib_client *" client ");"
.SH ARGUMENTS
.IP "client" 12
Client to unregister
.SH "DESCRIPTION"
Upper level users use \fBib_unregister_client\fP to remove their client
registration.  When \fBib_unregister_client\fP is called, the client
will receive a remove callback for each IB device still registered.
.TH "ib_get_client_data" 9 "ib_get_client_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_get_client_data \-  Get IB client context
.SH SYNOPSIS
.B "void *" ib_get_client_data
.BI "(struct ib_device *" device ","
.BI "struct ib_client *" client ");"
.SH ARGUMENTS
.IP "device" 12
Device to get context for
.IP "client" 12
Client to get context for
.SH "DESCRIPTION"
\fBib_get_client_data\fP returns client context set with
\fBib_set_client_data\fP.
.TH "ib_set_client_data" 9 "ib_set_client_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_set_client_data \-  Get IB client context
.SH SYNOPSIS
.B "void" ib_set_client_data
.BI "(struct ib_device *" device ","
.BI "struct ib_client *" client ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "device" 12
Device to set context for
.IP "client" 12
Client to set context for
.IP "data" 12
Context to set
.SH "DESCRIPTION"
\fBib_set_client_data\fP sets client context that can be retrieved with
\fBib_get_client_data\fP.
.TH "ib_register_event_handler" 9 "ib_register_event_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_register_event_handler \-  Register an IB event handler
.SH SYNOPSIS
.B "int" ib_register_event_handler
.BI "(struct ib_event_handler *" event_handler ");"
.SH ARGUMENTS
.IP "event_handler" 12
Handler to register
.SH "DESCRIPTION"
\fBib_register_event_handler\fP registers an event handler that will be
called back when asynchronous IB events occur (as defined in
chapter 11 of the InfiniBand Architecture Specification).  This
callback may occur in interrupt context.
.TH "ib_unregister_event_handler" 9 "ib_unregister_event_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_unregister_event_handler \-  Unregister an event handler
.SH SYNOPSIS
.B "int" ib_unregister_event_handler
.BI "(struct ib_event_handler *" event_handler ");"
.SH ARGUMENTS
.IP "event_handler" 12
Handler to unregister
.SH "DESCRIPTION"
Unregister an event handler registered with
\fBib_register_event_handler\fP.
.TH "ib_dispatch_event" 9 "ib_dispatch_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_dispatch_event \-  Dispatch an asynchronous event
.SH SYNOPSIS
.B "void" ib_dispatch_event
.BI "(struct ib_event *" event ");"
.SH ARGUMENTS
.IP "event" 12
Event to dispatch
.SH "DESCRIPTION"
Low-level drivers must call \fBib_dispatch_event\fP to dispatch the
event to all registered event handlers when an asynchronous event
occurs.
.TH "ib_query_device" 9 "ib_query_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_device \-  Query IB device attributes
.SH SYNOPSIS
.B "int" ib_query_device
.BI "(struct ib_device *" device ","
.BI "struct ib_device_attr *" device_attr ");"
.SH ARGUMENTS
.IP "device" 12
Device to query
.IP "device_attr" 12
Device attributes
.SH "DESCRIPTION"
\fBib_query_device\fP returns the attributes of a device through the
\fIdevice_attr\fP pointer.
.TH "ib_query_port" 9 "ib_query_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_port \-  Query IB port attributes
.SH SYNOPSIS
.B "int" ib_query_port
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "struct ib_port_attr *" port_attr ");"
.SH ARGUMENTS
.IP "device" 12
Device to query
.IP "port_num" 12
Port number to query
.IP "port_attr" 12
Port attributes
.SH "DESCRIPTION"
\fBib_query_port\fP returns the attributes of a port through the
\fIport_attr\fP pointer.
.TH "ib_query_gid" 9 "ib_query_gid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_gid \-  Get GID table entry
.SH SYNOPSIS
.B "int" ib_query_gid
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "int " index ","
.BI "union ib_gid *" gid ");"
.SH ARGUMENTS
.IP "device" 12
Device to query
.IP "port_num" 12
Port number to query
.IP "index" 12
GID table index to query
.IP "gid" 12
Returned GID
.SH "DESCRIPTION"
\fBib_query_gid\fP fetches the specified GID table entry.
.TH "ib_query_pkey" 9 "ib_query_pkey" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_query_pkey \-  Get P_Key table entry
.SH SYNOPSIS
.B "int" ib_query_pkey
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "u16 " index ","
.BI "u16 *" pkey ");"
.SH ARGUMENTS
.IP "device" 12
Device to query
.IP "port_num" 12
Port number to query
.IP "index" 12
P_Key table index to query
.IP "pkey" 12
Returned P_Key
.SH "DESCRIPTION"
\fBib_query_pkey\fP fetches the specified P_Key table entry.
.TH "ib_modify_device" 9 "ib_modify_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_modify_device \-  Change IB device attributes
.SH SYNOPSIS
.B "int" ib_modify_device
.BI "(struct ib_device *" device ","
.BI "int " device_modify_mask ","
.BI "struct ib_device_modify *" device_modify ");"
.SH ARGUMENTS
.IP "device" 12
Device to modify
.IP "device_modify_mask" 12
Mask of attributes to change
.IP "device_modify" 12
New attribute values
.SH "DESCRIPTION"
\fBib_modify_device\fP changes a device's attributes as specified by
the \fIdevice_modify_mask\fP and \fIdevice_modify\fP structure.
.TH "ib_modify_port" 9 "ib_modify_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_modify_port \-  Modifies the attributes for the specified port.
.SH SYNOPSIS
.B "int" ib_modify_port
.BI "(struct ib_device *" device ","
.BI "u8 " port_num ","
.BI "int " port_modify_mask ","
.BI "struct ib_port_modify *" port_modify ");"
.SH ARGUMENTS
.IP "device" 12
 The device to modify.
.IP "port_num" 12
 The number of the port to modify.
.IP "port_modify_mask" 12
 Mask used to specify which attributes of the port
to change.
.IP "port_modify" 12
 New attribute values for the port.
.SH "DESCRIPTION"
\fBib_modify_port\fP changes a port's attributes as specified by the
\fIport_modify_mask\fP and \fIport_modify\fP structure.
.TH "ib_create_fmr_pool" 9 "ib_create_fmr_pool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_create_fmr_pool \-  Create an FMR pool
.SH SYNOPSIS
.B "struct ib_fmr_pool *" ib_create_fmr_pool
.BI "(struct ib_pd *" pd ","
.BI "struct ib_fmr_pool_param *" params ");"
.SH ARGUMENTS
.IP "pd" 12
Protection domain for FMRs
.IP "params" 12
FMR pool parameters
.SH "DESCRIPTION"
Create a pool of FMRs.  Return value is pointer to new pool or
error code if creation failed.
.TH "ib_destroy_fmr_pool" 9 "ib_destroy_fmr_pool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_destroy_fmr_pool \-  Free FMR pool
.SH SYNOPSIS
.B "void" ib_destroy_fmr_pool
.BI "(struct ib_fmr_pool *" pool ");"
.SH ARGUMENTS
.IP "pool" 12
FMR pool to free
.SH "DESCRIPTION"
Destroy an FMR pool and free all associated resources.
.TH "ib_flush_fmr_pool" 9 "ib_flush_fmr_pool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_flush_fmr_pool \-  Invalidate all unmapped FMRs
.SH SYNOPSIS
.B "int" ib_flush_fmr_pool
.BI "(struct ib_fmr_pool *" pool ");"
.SH ARGUMENTS
.IP "pool" 12
FMR pool to flush
.SH "DESCRIPTION"
Ensure that all unmapped FMRs are fully invalidated.
.TH "ib_fmr_pool_map_phys" 9 "ib_fmr_pool_map_phys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_fmr_pool_map_phys \- 
.SH SYNOPSIS
.B "struct ib_pool_fmr *" ib_fmr_pool_map_phys
.BI "(struct ib_fmr_pool *" pool_handle ","
.BI "u64 *" page_list ","
.BI "int " list_len ","
.BI "u64 *" io_virtual_address ");"
.SH ARGUMENTS
.IP "pool_handle" 12
-- undescribed --
.IP "page_list" 12
List of pages to map
.IP "list_len" 12
Number of pages in \fIpage_list\fP
.IP "io_virtual_address" 12
I/O virtual address for new FMR
.SH "DESCRIPTION"
Map an FMR from an FMR pool.
.TH "ib_fmr_pool_unmap" 9 "ib_fmr_pool_unmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ib_fmr_pool_unmap \-  Unmap FMR
.SH SYNOPSIS
.B "int" ib_fmr_pool_unmap
.BI "(struct ib_pool_fmr *" fmr ");"
.SH ARGUMENTS
.IP "fmr" 12
FMR to unmap
.SH "DESCRIPTION"
Unmap an FMR.  The FMR mapping may remain valid until the FMR is
reused (or until \fBib_flush_fmr_pool\fP is called).
.TH "smi_data_buf_free" 9 "smi_data_buf_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
smi_data_buf_free \- 
.SH SYNOPSIS
.B "void" smi_data_buf_free
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "smi_data_buf_realloc" 9 "smi_data_buf_realloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
smi_data_buf_realloc \- 
.SH SYNOPSIS
.B "int" smi_data_buf_realloc
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
-- undescribed --
.TH "smi_request" 9 "smi_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
smi_request \- 
.SH SYNOPSIS
.B "int" smi_request
.BI "(struct smi_cmd *" smi_cmd ");"
.SH ARGUMENTS
.IP "smi_cmd" 12
-- undescribed --
.SH "DESCRIPTION"

Called with smi_data_lock.
.TH "smi_request_store" 9 "smi_request_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
smi_request_store \- 
.SH SYNOPSIS
.B "ssize_t" smi_request_store
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "attr" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
.SH "0"
 zero SMI data buffer
.SH "1"
 generate calling interface SMI
.SH "2"
 generate raw SMI

User application writes smi_cmd to smi_data before telling driver
to generate SMI.
.TH "host_control_smi" 9 "host_control_smi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
host_control_smi \- 
.SH SYNOPSIS
.B "int" host_control_smi
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Caller must set up the host control command in smi_data_buf.
.TH "dcdbas_host_control" 9 "dcdbas_host_control" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dcdbas_host_control \- 
.SH SYNOPSIS
.B "void" dcdbas_host_control
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function is called by the driver after the system has
finished shutting down if the user application specified a
host control action to perform on shutdown.  It is safe to
use smi_data_buf at this point because the system has finished
shutting down and no userspace apps are running.
.TH "dcdbas_reboot_notify" 9 "dcdbas_reboot_notify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dcdbas_reboot_notify \- 
.SH SYNOPSIS
.B "int" dcdbas_reboot_notify
.BI "(struct notifier_block *" nb ","
.BI "unsigned long " code ","
.BI "void *" unused ");"
.SH ARGUMENTS
.IP "nb" 12
-- undescribed --
.IP "code" 12
-- undescribed --
.IP "unused" 12
-- undescribed --
.TH "dcdbas_init" 9 "dcdbas_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dcdbas_init \- 
.SH SYNOPSIS
.B "int __init" dcdbas_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "dcdbas_exit" 9 "dcdbas_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dcdbas_exit \- 
.SH SYNOPSIS
.B "void __exit" dcdbas_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "edd_show_raw_data" 9 "edd_show_raw_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
edd_show_raw_data \-  copies raw data to buffer for userspace to parse
.SH SYNOPSIS
.B "ssize_t" edd_show_raw_data
.BI "(struct edd_device *" edev ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "edev" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"
.SH "RETURNS"
 number of bytes written, or -EINVAL on failure
.TH "edd_release" 9 "edd_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
edd_release \-  free edd structure
.SH SYNOPSIS
.B "void" edd_release
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	kobject of edd structure
.SH "DESCRIPTION"
This is called when the refcount of the edd structure
reaches 0. This should happen right after we unregister,
but just in case, we use the release callback anyway.
.TH "edd_dev_is_type" 9 "edd_dev_is_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
edd_dev_is_type \-  is this EDD device a 'type' device?
.SH SYNOPSIS
.B "int" edd_dev_is_type
.BI "(struct edd_device *" edev ","
.BI "const char *" type ");"
.SH ARGUMENTS
.IP "edev" 12
-- undescribed --
.IP "type" 12
-- undescribed --
.SH "DESCRIPTION"
\fIedev\fP
\fItype\fP - a host bus or interface identifier string per the EDD spec

Returns 1 (TRUE) if it is a 'type' device, 0 otherwise.
.TH "edd_get_pci_dev" 9 "edd_get_pci_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
edd_get_pci_dev \-  finds pci_dev that matches edev
.SH SYNOPSIS
.B "struct pci_dev *" edd_get_pci_dev
.BI "(struct edd_device *" edev ");"
.SH ARGUMENTS
.IP "edev" 12
-- undescribed --
.SH "DESCRIPTION"
\fIedev\fP - edd_device

Returns pci_dev if found, or NULL
.TH "edd_init" 9 "edd_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
edd_init \-  creates sysfs tree of EDD data
.SH SYNOPSIS
.B "int __init" edd_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "ucb1x00_io_set_dir" 9 "ucb1x00_io_set_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_io_set_dir \-  set IO direction
.SH SYNOPSIS
.B "void" ucb1x00_io_set_dir
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " in ","
.BI "unsigned int " out ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "in" 12
  bitfield of IO pins to be set as inputs
.IP "out" 12
 bitfield of IO pins to be set as outputs
.SH "DESCRIPTION"
Set the IO direction of the ten general purpose IO pins on
the UCB1x00 chip.  The \fIin\fP bitfield has priority over the
\fIout\fP bitfield, in that if you specify a pin as both input
and output, it will end up as an input.

ucb1x00_enable must have been called to enable the comms
before using this function.

This function takes a spinlock, disabling interrupts.
.TH "ucb1x00_io_write" 9 "ucb1x00_io_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_io_write \-  set or clear IO outputs
.SH SYNOPSIS
.B "void" ucb1x00_io_write
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " set ","
.BI "unsigned int " clear ");"
.SH ARGUMENTS
.IP "ucb" 12
   UCB1x00 structure describing chip
.IP "set" 12
   bitfield of IO pins to set to logic '1'
.IP "clear" 12
 bitfield of IO pins to set to logic '0'
.SH "DESCRIPTION"
Set the IO output state of the specified IO pins.  The value
is retained if the pins are subsequently configured as inputs.
The \fIclear\fP bitfield has priority over the \fIset\fP bitfield -
outputs will be cleared.

ucb1x00_enable must have been called to enable the comms
before using this function.

This function takes a spinlock, disabling interrupts.
.TH "ucb1x00_io_read" 9 "ucb1x00_io_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_io_read \-  read the current state of the IO pins
.SH SYNOPSIS
.B "unsigned int" ucb1x00_io_read
.BI "(struct ucb1x00 *" ucb ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.SH "DESCRIPTION"
Return a bitfield describing the logic state of the ten
general purpose IO pins.

ucb1x00_enable must have been called to enable the comms
before using this function.

This function does not take any semaphores or spinlocks.
.TH "ucb1x00_adc_enable" 9 "ucb1x00_adc_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_adc_enable \-  enable the ADC converter
.SH SYNOPSIS
.B "void" ucb1x00_adc_enable
.BI "(struct ucb1x00 *" ucb ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.SH "DESCRIPTION"
Enable the ucb1x00 and ADC converter on the UCB1x00 for use.
Any code wishing to use the ADC converter must call this
function prior to using it.

This function takes the ADC semaphore to prevent two or more
concurrent uses, and therefore may sleep.  As a result, it
can only be called from process context, not interrupt
context.

You should release the ADC as soon as possible using
ucb1x00_adc_disable.
.TH "ucb1x00_adc_read" 9 "ucb1x00_adc_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_adc_read \-  read the specified ADC channel
.SH SYNOPSIS
.B "unsigned int" ucb1x00_adc_read
.BI "(struct ucb1x00 *" ucb ","
.BI "int " adc_channel ","
.BI "int " sync ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "adc_channel" 12
 ADC channel mask
.IP "sync" 12
 wait for syncronisation pulse.
.SH "DESCRIPTION"
Start an ADC conversion and wait for the result.  Note that
synchronised ADC conversions (via the ADCSYNC pin) must wait
until the trigger is asserted and the conversion is finished.

This function currently spins waiting for the conversion to
complete (2 frames max without sync).

If called for a synchronised ADC conversion, it may sleep
with the ADC semaphore held.
.TH "ucb1x00_adc_disable" 9 "ucb1x00_adc_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_adc_disable \-  disable the ADC converter
.SH SYNOPSIS
.B "void" ucb1x00_adc_disable
.BI "(struct ucb1x00 *" ucb ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.SH "DESCRIPTION"
Disable the ADC converter and release the ADC semaphore.
.TH "ucb1x00_hook_irq" 9 "ucb1x00_hook_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_hook_irq \-  hook a UCB1x00 interrupt
.SH SYNOPSIS
.B "int" ucb1x00_hook_irq
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " idx ","
.BI "void (*" fn ") (int, void *),"
.BI "void *" devid ");"
.SH ARGUMENTS
.IP "ucb" 12
   UCB1x00 structure describing chip
.IP "idx" 12
   interrupt index
.IP "fn" 12
    function to call when interrupt is triggered
.IP "devid" 12
 device id to pass to interrupt handler
.SH "DESCRIPTION"
Hook the specified interrupt.  You can only register one handler
for each interrupt source.  The interrupt source is not enabled
by this function; use ucb1x00_enable_irq instead.

Interrupt handlers will be called with other interrupts enabled.

Returns zero on success, or one of the following errors:
-EINVAL if the interrupt index is invalid
-EBUSY if the interrupt has already been hooked
.TH "ucb1x00_enable_irq" 9 "ucb1x00_enable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_enable_irq \-  enable an UCB1x00 interrupt source
.SH SYNOPSIS
.B "void" ucb1x00_enable_irq
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " idx ","
.BI "int " edges ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "idx" 12
 interrupt index
.IP "edges" 12
 interrupt edges to enable
.SH "DESCRIPTION"
Enable the specified interrupt to trigger on UCB_RISING,
UCB_FALLING or both edges.  The interrupt should have been
hooked by ucb1x00_hook_irq.
.TH "ucb1x00_disable_irq" 9 "ucb1x00_disable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_disable_irq \-  disable an UCB1x00 interrupt source
.SH SYNOPSIS
.B "void" ucb1x00_disable_irq
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " idx ","
.BI "int " edges ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "idx" 12
-- undescribed --
.IP "edges" 12
 interrupt edges to disable
.SH "DESCRIPTION"
Disable the specified interrupt triggering on the specified
(UCB_RISING, UCB_FALLING or both) edges.
.TH "ucb1x00_free_irq" 9 "ucb1x00_free_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_free_irq \-  disable and free the specified UCB1x00 interrupt
.SH SYNOPSIS
.B "int" ucb1x00_free_irq
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " idx ","
.BI "void *" devid ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "idx" 12
 interrupt index
.IP "devid" 12
 device id.
.SH "DESCRIPTION"
Disable the interrupt source and remove the handler.  devid must
match the devid passed when hooking the interrupt.

Returns zero on success, or one of the following errors:
-EINVAL if the interrupt index is invalid
-ENOENT if devid does not match
.TH "ucb1x00_clkrate" 9 "ucb1x00_clkrate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_clkrate \-  return the UCB1x00 SIB clock rate
.SH SYNOPSIS
.B "unsigned int" ucb1x00_clkrate
.BI "(struct ucb1x00 *" ucb ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.SH "DESCRIPTION"
Return the SIB clock rate in Hz.
.TH "ucb1x00_enable" 9 "ucb1x00_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_enable \-  enable the UCB1x00 SIB clock
.SH SYNOPSIS
.B "void" ucb1x00_enable
.BI "(struct ucb1x00 *" ucb ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.SH "DESCRIPTION"
Enable the SIB clock.  This can be called multiple times.
.TH "ucb1x00_disable" 9 "ucb1x00_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_disable \-  disable the UCB1x00 SIB clock
.SH SYNOPSIS
.B "void" ucb1x00_disable
.BI "(struct ucb1x00 *" ucb ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.SH "DESCRIPTION"
Disable the SIB clock.  The SIB clock will only be disabled
when the number of ucb1x00_enable calls match the number of
ucb1x00_disable calls.
.TH "ucb1x00_reg_write" 9 "ucb1x00_reg_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_reg_write \-  write a UCB1x00 register
.SH SYNOPSIS
.B "void" ucb1x00_reg_write
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " reg ","
.BI "unsigned int " val ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "reg" 12
 UCB1x00 4-bit register index to write
.IP "val" 12
 UCB1x00 16-bit value to write
.SH "DESCRIPTION"
Write the UCB1x00 register \fIreg\fP with value \fIval\fP.  The SIB
clock must be running for this function to return.
.TH "ucb1x00_reg_read" 9 "ucb1x00_reg_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_reg_read \-  read a UCB1x00 register
.SH SYNOPSIS
.B "unsigned int" ucb1x00_reg_read
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " reg ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "reg" 12
 UCB1x00 4-bit register index to write
.SH "DESCRIPTION"
Read the UCB1x00 register \fIreg\fP and return its value.  The SIB
clock must be running for this function to return.
.TH "ucb1x00_set_audio_divisor" 9 "ucb1x00_set_audio_divisor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_set_audio_divisor \-  
.SH SYNOPSIS
.B "void" ucb1x00_set_audio_divisor
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " div ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "div" 12
 SIB clock divisor
.TH "ucb1x00_set_telecom_divisor" 9 "ucb1x00_set_telecom_divisor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ucb1x00_set_telecom_divisor \- 
.SH SYNOPSIS
.B "void" ucb1x00_set_telecom_divisor
.BI "(struct ucb1x00 *" ucb ","
.BI "unsigned int " div ");"
.SH ARGUMENTS
.IP "ucb" 12
 UCB1x00 structure describing chip
.IP "div" 12
 SIB clock divisor
.TH "mcp_set_telecom_divisor" 9 "mcp_set_telecom_divisor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mcp_set_telecom_divisor \-  set the telecom divisor
.SH SYNOPSIS
.B "void" mcp_set_telecom_divisor
.BI "(struct mcp *" mcp ","
.BI "unsigned int " div ");"
.SH ARGUMENTS
.IP "mcp" 12
 MCP interface structure
.IP "div" 12
 SIB clock divisor
.SH "DESCRIPTION"
Set the telecom divisor on the MCP interface.  The resulting
sample rate is SIBCLOCK/div.
.TH "mcp_set_audio_divisor" 9 "mcp_set_audio_divisor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mcp_set_audio_divisor \-  set the audio divisor
.SH SYNOPSIS
.B "void" mcp_set_audio_divisor
.BI "(struct mcp *" mcp ","
.BI "unsigned int " div ");"
.SH ARGUMENTS
.IP "mcp" 12
 MCP interface structure
.IP "div" 12
 SIB clock divisor
.SH "DESCRIPTION"
Set the audio divisor on the MCP interface.
.TH "mcp_reg_write" 9 "mcp_reg_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mcp_reg_write \-  write a device register
.SH SYNOPSIS
.B "void" mcp_reg_write
.BI "(struct mcp *" mcp ","
.BI "unsigned int " reg ","
.BI "unsigned int " val ");"
.SH ARGUMENTS
.IP "mcp" 12
 MCP interface structure
.IP "reg" 12
 4-bit register index
.IP "val" 12
 16-bit data value
.SH "DESCRIPTION"
Write a device register.  The MCP interface must be enabled
to prevent this function hanging.
.TH "mcp_reg_read" 9 "mcp_reg_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mcp_reg_read \-  read a device register
.SH SYNOPSIS
.B "unsigned int" mcp_reg_read
.BI "(struct mcp *" mcp ","
.BI "unsigned int " reg ");"
.SH ARGUMENTS
.IP "mcp" 12
 MCP interface structure
.IP "reg" 12
 4-bit register index
.SH "DESCRIPTION"
Read a device register and return its value.  The MCP interface
must be enabled to prevent this function hanging.
.TH "mcp_enable" 9 "mcp_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mcp_enable \-  enable the MCP interface
.SH SYNOPSIS
.B "void" mcp_enable
.BI "(struct mcp *" mcp ");"
.SH ARGUMENTS
.IP "mcp" 12
 MCP interface to enable
.SH "DESCRIPTION"
Enable the MCP interface.  Each call to mcp_enable will need
a corresponding call to mcp_disable to disable the interface.
.TH "mcp_disable" 9 "mcp_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mcp_disable \-  disable the MCP interface
.SH SYNOPSIS
.B "void" mcp_disable
.BI "(struct mcp *" mcp ");"
.SH ARGUMENTS
.IP "mcp" 12
 MCP interface to disable
.SH "DESCRIPTION"
Disable the MCP interface.  The MCP interface will only be
disabled once the number of calls to mcp_enable matches the
number of calls to mcp_disable.
.TH "set_safe_settings" 9 "set_safe_settings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_safe_settings \-  if the use_safe_settings option is set then
.SH SYNOPSIS
.B "void __devinit" set_safe_settings
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
set all values to the safe and slow values.
.TH "fix_settings" 9 "fix_settings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fix_settings \-  reset any boot parameters which are out of range
.SH SYNOPSIS
.B "void __devinit" fix_settings
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
back to the default values.
.TH "eeprom_index_to_delay" 9 "eeprom_index_to_delay" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eeprom_index_to_delay \-  Take the eeprom delay setting and convert it
.SH SYNOPSIS
.B "void __devinit" eeprom_index_to_delay
.BI "(struct NvRamType *" eeprom ");"
.SH ARGUMENTS
.IP "eeprom" 12
 The eeprom structure in which we find the delay index to map.
.SH "DESCRIPTION"
into a number of seconds.
.TH "delay_to_eeprom_index" 9 "delay_to_eeprom_index" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
delay_to_eeprom_index \-  Take a delay in seconds and return the
.SH SYNOPSIS
.B "int __devinit" delay_to_eeprom_index
.BI "(int " delay ");"
.SH ARGUMENTS
.IP "delay" 12
 The delay, in seconds, to find the eeprom index for.
.SH "DESCRIPTION"
closest eeprom index which will delay for at least that amount of
seconds.
.TH "eeprom_override" 9 "eeprom_override" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
eeprom_override \-  Override the eeprom settings, in the provided
.SH SYNOPSIS
.B "void __devinit" eeprom_override
.BI "(struct NvRamType *" eeprom ");"
.SH ARGUMENTS
.IP "eeprom" 12
 The eeprom data to override with command line options.
.SH "DESCRIPTION"
eeprom structure, with values that have been set on the command
line.
.TH "dc395x_queue_command" 9 "dc395x_queue_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_queue_command \-  queue scsi command passed from the mid
.SH SYNOPSIS
.B "int" dc395x_queue_command
.BI "(struct scsi_cmnd *" cmd ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "cmd" 12
 pointer to scsi command object
.IP "done" 12
 function pointer to be invoked on completion
.SH "DESCRIPTION"
Returns 1 if the adapter (host) is busy, else returns 0. One
reason for an adapter to be busy is that the number
of outstanding queued commands is already equal to
.SH "DESCRIPTION"
Returns 1 if the adapter (host) is busy, else returns 0. One
reason for an adapter to be busy is that the number
of outstanding queued commands is already equal to
.SH "STRUCT SCSI_HOST"
:can_queue .
.SH "REQUIRED"
 if struct Scsi_Host::can_queue is ever non-zero
then this function is required.
.SH "LOCKS"
 struct Scsi_Host::host_lock held on entry (with "irqsave")
and is expected to be held on return.
.TH "dc395x_handle_interrupt" 9 "dc395x_handle_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_handle_interrupt \-  Handle an interrupt that has been confirmed to
.SH SYNOPSIS
.B "void" dc395x_handle_interrupt
.BI "(struct AdapterCtlBlk *" acb ","
.BI "u16 " scsi_status ");"
.SH ARGUMENTS
.IP "acb" 12
	 a pointer to the adpter control block
.IP "scsi_status" 12
 the status return when we checked the card
.SH "DESCRIPTION"
have been triggered for this card.
.TH "device_alloc" 9 "device_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_alloc \-  Allocate a new device instance. This create the
.SH SYNOPSIS
.B "struct DeviceCtlBlk *" device_alloc
.BI "(struct AdapterCtlBlk *" acb ","
.BI "u8 " target ","
.BI "u8 " lun ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter to obtain configuration information from.
.IP "target" 12
 The target for the new device.
.IP "lun" 12
 The lun for the new device.
.SH "DESCRIPTION"
Return the new device if succesfull or NULL on failure.
.SH "DESCRIPTION"
Return the new device if succesfull or NULL on failure.
.TH "adapter_add_device" 9 "adapter_add_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_add_device \-  Adds the device instance to the adaptor instance.
.SH SYNOPSIS
.B "void" adapter_add_device
.BI "(struct AdapterCtlBlk *" acb ","
.BI "struct DeviceCtlBlk *" dcb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter device to be updated
.IP "dcb" 12
 A newly created and intialised device instance to add.
.SH "DESCRIPTION"
.TH "adapter_remove_device" 9 "adapter_remove_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_remove_device \-  Removes the device instance from the adaptor
.SH SYNOPSIS
.B "void" adapter_remove_device
.BI "(struct AdapterCtlBlk *" acb ","
.BI "struct DeviceCtlBlk *" dcb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter device to be updated
.IP "dcb" 12
 A device that has previously been added to the adapter.
.SH "DESCRIPTION"
instance. The device instance is not check in any way or freed by this. 
The caller is expected to take care of that. This will simply remove the
device from the adapters data strcutures.
.TH "adapter_remove_and_free_device" 9 "adapter_remove_and_free_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_remove_and_free_device \-  Removes a single device from the adapter
.SH SYNOPSIS
.B "void" adapter_remove_and_free_device
.BI "(struct AdapterCtlBlk *" acb ","
.BI "struct DeviceCtlBlk *" dcb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter device to be updated
.IP "dcb" 12
 A device that has previously been added to the adapter.
.SH "DESCRIPTION"
and then frees the device information.
.TH "adapter_remove_and_free_all_devices" 9 "adapter_remove_and_free_all_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_remove_and_free_all_devices \-  Removes and frees all of the
.SH SYNOPSIS
.B "void" adapter_remove_and_free_all_devices
.BI "(struct AdapterCtlBlk *" acb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter from which all devices should be removed.
.SH "DESCRIPTION"
devices associated with the specified adapter.
.TH "dc395x_slave_alloc" 9 "dc395x_slave_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_slave_alloc \-  Called by the scsi mid layer to tell us about a new
.SH SYNOPSIS
.B "int" dc395x_slave_alloc
.BI "(struct scsi_device *" scsi_device ");"
.SH ARGUMENTS
.IP "scsi_device" 12
 The new scsi device that we need to handle.
.SH "DESCRIPTION"
scsi device that we need to deal with. We allocate a new device and then
insert that device into the adapters device list.
.TH "dc395x_slave_destroy" 9 "dc395x_slave_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_slave_destroy \-  Called by the scsi mid layer to tell us about a
.SH SYNOPSIS
.B "void" dc395x_slave_destroy
.BI "(struct scsi_device *" scsi_device ");"
.SH ARGUMENTS
.IP "scsi_device" 12
 The new scsi device that we need to handle.
.SH "DESCRIPTION"
device that is going away.
.TH "trms1040_wait_30us" 9 "trms1040_wait_30us" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
trms1040_wait_30us \- 
.SH SYNOPSIS
.B "void __devinit" trms1040_wait_30us
.BI "(unsigned long " io_port ");"
.SH ARGUMENTS
.IP "io_port" 12
 base I/O address
.SH "DESCRIPTION"

Waits for 30us (using the chip by the looks of it..)
.TH "trms1040_write_cmd" 9 "trms1040_write_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
trms1040_write_cmd \-  write the secified command and address to
.SH SYNOPSIS
.B "void __devinit" trms1040_write_cmd
.BI "(unsigned long " io_port ","
.BI "u8 " cmd ","
.BI "u8 " addr ");"
.SH ARGUMENTS
.IP "io_port" 12
	base I/O address
.IP "cmd" 12
	SB + op code (command) to send
.IP "addr" 12
	address to send
.SH "DESCRIPTION"
chip
.TH "trms1040_set_data" 9 "trms1040_set_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
trms1040_set_data \-  store a single byte in the eeprom
.SH SYNOPSIS
.B "void __devinit" trms1040_set_data
.BI "(unsigned long " io_port ","
.BI "u8 " addr ","
.BI "u8 " byte ");"
.SH ARGUMENTS
.IP "io_port" 12
	base I/O address
.IP "addr" 12
	offset into EEPROM
.IP "byte" 12
	bytes to write
.SH "DESCRIPTION"

Called from write all to write a single byte into the SSEEPROM
Which is done one bit at a time.
.TH "trms1040_write_all" 9 "trms1040_write_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
trms1040_write_all \-  write 128 bytes to the eeprom
.SH SYNOPSIS
.B "void __devinit" trms1040_write_all
.BI "(struct NvRamType *" eeprom ","
.BI "unsigned long " io_port ");"
.SH ARGUMENTS
.IP "eeprom" 12
	the data to write
.IP "io_port" 12
	the base io port
.SH "DESCRIPTION"

Write the supplied 128 bytes to the chips SEEPROM
.TH "trms1040_get_data" 9 "trms1040_get_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
trms1040_get_data \-  get a single byte from the eeprom
.SH SYNOPSIS
.B "u8 __devinit" trms1040_get_data
.BI "(unsigned long " io_port ","
.BI "u8 " addr ");"
.SH ARGUMENTS
.IP "io_port" 12
	base I/O address
.IP "addr" 12
	offset into SEEPROM
.SH "DESCRIPTION"
Returns the the byte read.
.SH "DESCRIPTION"
Returns the the byte read.
.TH "trms1040_read_all" 9 "trms1040_read_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
trms1040_read_all \-  read all bytes from the eeprom
.SH SYNOPSIS
.B "void __devinit" trms1040_read_all
.BI "(struct NvRamType *" eeprom ","
.BI "unsigned long " io_port ");"
.SH ARGUMENTS
.IP "eeprom" 12
	where to store the data
.IP "io_port" 12
	the base io port
.SH "DESCRIPTION"

Read the 128 bytes from the SEEPROM.
.TH "check_eeprom" 9 "check_eeprom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_eeprom \-  get and check contents of the eeprom
.SH SYNOPSIS
.B "void __devinit" check_eeprom
.BI "(struct NvRamType *" eeprom ","
.BI "unsigned long " io_port ");"
.SH ARGUMENTS
.IP "eeprom" 12
	caller allocated strcuture to read the eeprom data into
.IP "io_port" 12
	io port to read from
.SH "DESCRIPTION"

Read seeprom 128 bytes into the memory provider in eeprom.
Checks the checksum and if it's not correct it uses a set of default
values.
.TH "print_eeprom_settings" 9 "print_eeprom_settings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
print_eeprom_settings \-  output the eeprom settings
.SH SYNOPSIS
.B "void __devinit" print_eeprom_settings
.BI "(struct NvRamType *" eeprom ");"
.SH ARGUMENTS
.IP "eeprom" 12
 The eeprom data strucutre to show details for.
.SH "DESCRIPTION"
to the kernel log so people can see what they were.
.TH "adapter_print_config" 9 "adapter_print_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_print_config \-  print adapter connection and termination
.SH SYNOPSIS
.B "void __devinit" adapter_print_config
.BI "(struct AdapterCtlBlk *" acb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter to print the information for.
.SH "DESCRIPTION"
config

The io port in the adapter needs to have been set before calling
this function.
.TH "adapter_init_params" 9 "adapter_init_params" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_init_params \-  Initialize the various parameters in the
.SH SYNOPSIS
.B "void __devinit" adapter_init_params
.BI "(struct AdapterCtlBlk *" acb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter to initialize.
.SH "DESCRIPTION"
adapter structure. Note that the pointer to the scsi_host is set
early (when this instance is created) and the io_port and irq
values are set later after they have been reserved. This just gets
everything set to a good starting position.

The eeprom structure in the adapter needs to have been set before
calling this function.
.TH "adapter_init_scsi_host" 9 "adapter_init_scsi_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_init_scsi_host \-  Initialize the scsi host instance based on
.SH SYNOPSIS
.B "void __devinit" adapter_init_scsi_host
.BI "(struct Scsi_Host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 The scsi host instance to fill in the values for.
.SH "DESCRIPTION"
values that we have already stored in the adapter instance. There's
some mention that a lot of these are deprecated, so we won't use
them (we'll use the ones in the adapter instance) but we'll fill
them in in case something else needs them.

The eeprom structure, irq and io ports in the adapter need to have
been set before calling this function.
.TH "adapter_init_chip" 9 "adapter_init_chip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_init_chip \-  Get the chip into a know state and figure out
.SH SYNOPSIS
.B "void __devinit" adapter_init_chip
.BI "(struct AdapterCtlBlk *" acb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter which we are to init.
.SH "DESCRIPTION"
some of the settings that apply to this adapter.

The io port in the adapter needs to have been set before calling
this function. The config will be configured correctly on return.
.TH "adapter_init" 9 "adapter_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_init \-  Grab the resource for the card, setup the adapter
.SH SYNOPSIS
.B "int __devinit" adapter_init
.BI "(struct AdapterCtlBlk *" acb ","
.BI "unsigned long " io_port ","
.BI "u32 " io_port_len ","
.BI "unsigned int " irq ");"
.SH ARGUMENTS
.IP "acb" 12
-- undescribed --
.IP "io_port" 12
	The base I/O port
.IP "io_port_len" 12
-- undescribed --
.IP "irq" 12
	IRQ
.SH "DESCRIPTION"
Returns 0 if the initialization succeeds, any other value on
failure.
.SH "DESCRIPTION"
Returns 0 if the initialization succeeds, any other value on
failure.
.TH "adapter_uninit_chip" 9 "adapter_uninit_chip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_uninit_chip \-  cleanly shut down the scsi controller chip,
.SH SYNOPSIS
.B "void" adapter_uninit_chip
.BI "(struct AdapterCtlBlk *" acb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter which we are to shutdown.
.SH "DESCRIPTION"
stopping all operations and disabling interrupt generation on the
card.
.TH "adapter_uninit" 9 "adapter_uninit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
adapter_uninit \-  Shut down the chip and release any resources that
.SH SYNOPSIS
.B "void" adapter_uninit
.BI "(struct AdapterCtlBlk *" acb ");"
.SH ARGUMENTS
.IP "acb" 12
 The adapter which we are to un-initialize.
.SH "DESCRIPTION"
we had allocated. Once this returns the adapter should not be used
anymore.
.TH "banner_display" 9 "banner_display" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
banner_display \-  Display banner on first instance of driver
.SH SYNOPSIS
.B "void" banner_display
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
initialized.
.TH "dc395x_init_one" 9 "dc395x_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_init_one \-  Initialise a single instance of the adapter.
.SH SYNOPSIS
.B "int __devinit" dc395x_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device to intialize.
.IP "id" 12
 Looks like a pointer to the entry in our pci device table
that was actually matched by the PCI subsystem.
.SH "DESCRIPTION"
Returns 0 on success, or an error code (-ve) on failure.
.SH "DESCRIPTION"
Returns 0 on success, or an error code (-ve) on failure.
.TH "dc395x_remove_one" 9 "dc395x_remove_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_remove_one \-  Called to remove a single instance of the
.SH SYNOPSIS
.B "void __devexit" dc395x_remove_one
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device to intialize.
.SH "DESCRIPTION"
adapter.
.TH "dc395x_module_init" 9 "dc395x_module_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_module_init \-  Module initialization function
.SH SYNOPSIS
.B "int __init" dc395x_module_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Used by both module and built-in driver to initialise this driver.
.TH "dc395x_module_exit" 9 "dc395x_module_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc395x_module_exit \-  Module cleanup function.
.SH SYNOPSIS
.B "void __exit" dc395x_module_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "scsi_unlock_floptical" 9 "scsi_unlock_floptical" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_unlock_floptical \-  unlock device via a special MODE SENSE command
.SH SYNOPSIS
.B "void" scsi_unlock_floptical
.BI "(struct scsi_device *" sdev ","
.BI "unsigned char *" result ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi device to send command to
.IP "result" 12
	area to store the result of the MODE SENSE
.SH "DESCRIPTION"
Send a vendor specific MODE SENSE (not a MODE SELECT) command.
Called for BLIST_KEY devices.
.TH "print_inquiry" 9 "print_inquiry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
print_inquiry \-  printk the inquiry information
.SH SYNOPSIS
.B "void" print_inquiry
.BI "(unsigned char *" inq_result ");"
.SH ARGUMENTS
.IP "inq_result" 12
	printk this SCSI INQUIRY
.SH "DESCRIPTION"
printk the vendor, model, and other information found in the
INQUIRY data in \fIinq_result\fP.
.SH "NOTES"
Remove this, and replace with a hotplug event that logs any
relevant information.
.TH "scsi_alloc_sdev" 9 "scsi_alloc_sdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_alloc_sdev \-  allocate and setup a scsi_Device
.SH SYNOPSIS
.B "struct scsi_device *" scsi_alloc_sdev
.BI "(struct scsi_target *" starget ","
.BI "unsigned int " lun ","
.BI "void *" hostdata ");"
.SH ARGUMENTS
.IP "starget" 12
-- undescribed --
.IP "lun" 12
-- undescribed --
.IP "hostdata" 12
-- undescribed --
.SH "DESCRIPTION"
Allocate, initialize for io, and return a pointer to a scsi_Device.
Stores the \fIshost\fP, \fIchannel\fP, \fIid\fP, and \fIlun\fP in the scsi_Device, and
adds scsi_Device to the appropriate list.
.SH "DESCRIPTION"
Allocate, initialize for io, and return a pointer to a scsi_Device.
Stores the \fIshost\fP, \fIchannel\fP, \fIid\fP, and \fIlun\fP in the scsi_Device, and
adds scsi_Device to the appropriate list.
.SH "RETURN VALUE"
scsi_Device pointer, or NULL on failure.
.TH "scsi_target_reap" 9 "scsi_target_reap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_target_reap \-  check to see if target is in use and destroy if not
.SH SYNOPSIS
.B "void" scsi_target_reap
.BI "(struct scsi_target *" starget ");"
.SH ARGUMENTS
.IP "starget" 12
 target to be checked
.SH "DESCRIPTION"
This is used after removing a LUN or doing a last put of the target
it checks atomically that nothing is using the target and removes
it if so.
.SH "DESCRIPTION"
This is used after removing a LUN or doing a last put of the target
it checks atomically that nothing is using the target and removes
it if so.
.TH "scsi_probe_lun" 9 "scsi_probe_lun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_probe_lun \-  probe a single LUN using a SCSI INQUIRY
.SH SYNOPSIS
.B "int" scsi_probe_lun
.BI "(struct scsi_device *" sdev ","
.BI "char *" inq_result ","
.BI "int " result_len ","
.BI "int *" bflags ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi_device to probe
.IP "inq_result" 12
	area to store the INQUIRY result
.IP "result_len" 12
 len of inq_result
.IP "bflags" 12
	store any bflags found here
.SH "DESCRIPTION"
Probe the lun associated with \fIreq\fP using a standard SCSI INQUIRY;

If the INQUIRY is successful, zero is returned and the
INQUIRY data is in \fIinq_result\fP; the scsi_level and INQUIRY length
are copied to the Scsi_Device any flags value is stored in *\fIbflags\fP.
.TH "scsi_add_lun" 9 "scsi_add_lun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_add_lun \-  allocate and fully initialze a Scsi_Device
.SH SYNOPSIS
.B "int" scsi_add_lun
.BI "(struct scsi_device *" sdev ","
.BI "char *" inq_result ","
.BI "int *" bflags ");"
.SH ARGUMENTS
.IP "sdev" 12
-- undescribed --
.IP "inq_result" 12
	holds the result of a previous INQUIRY to the LUN
.IP "bflags" 12
	black/white list flag
.SH "DESCRIPTION"
Allocate and initialize a Scsi_Device matching sdevscan. Optionally
set fields based on values in *\fIbflags\fP. If \fIsdevnew\fP is not
NULL, store the address of the new Scsi_Device in *\fIsdevnew\fP (needed
when scanning a particular LUN).
.SH "SCSI_SCAN_NO_RESPONSE"
 could not allocate or setup a Scsi_Device
.SH "SCSI_SCAN_LUN_PRESENT"
 a new Scsi_Device was allocated and initialized
.TH "scsi_probe_and_add_lun" 9 "scsi_probe_and_add_lun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_probe_and_add_lun \-  probe a LUN, if a LUN is found add it
.SH SYNOPSIS
.B "int" scsi_probe_and_add_lun
.BI "(struct scsi_target *" starget ","
.BI "uint " lun ","
.BI "int *" bflagsp ","
.BI "struct scsi_device **" sdevp ","
.BI "int " rescan ","
.BI "void *" hostdata ");"
.SH ARGUMENTS
.IP "starget" 12
	pointer to target device structure
.IP "lun" 12
	LUN of target device
.IP "bflagsp" 12
	store bflags here if not NULL
.IP "sdevp" 12
-- undescribed --
.IP "rescan" 12
-- undescribed --
.IP "hostdata" 12
-- undescribed --
.SH "DESCRIPTION"
Call scsi_probe_lun, if a LUN with an attached device is found,
allocate and set it up by calling scsi_add_lun.
.SH "SCSI_SCAN_NO_RESPONSE"
 could not allocate or setup a Scsi_Device
.SH "SCSI_SCAN_TARGET_PRESENT"
 target responded, but no device is
attached at the LUN
.SH "SCSI_SCAN_LUN_PRESENT"
 a new Scsi_Device was allocated and initialized
.TH "scsi_sequential_lun_scan" 9 "scsi_sequential_lun_scan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_sequential_lun_scan \-  sequentially scan a SCSI target
.SH SYNOPSIS
.B "void" scsi_sequential_lun_scan
.BI "(struct scsi_target *" starget ","
.BI "int " bflags ","
.BI "int " lun0_res ","
.BI "int " scsi_level ","
.BI "int " rescan ");"
.SH ARGUMENTS
.IP "starget" 12
	pointer to target structure to scan
.IP "bflags" 12
	black/white list flag for LUN 0
.IP "lun0_res" 12
	result of scanning LUN 0
.IP "scsi_level" 12
-- undescribed --
.IP "rescan" 12
-- undescribed --
.SH "DESCRIPTION"
Generally, scan from LUN 1 (LUN 0 is assumed to already have been
scanned) to some maximum lun until a LUN is found with no device
attached. Use the bflags to figure out any oddities.

Modifies sdevscan-&gt;lun.
.TH "scsilun_to_int" 9 "scsilun_to_int" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsilun_to_int \- 
.SH SYNOPSIS
.B "int" scsilun_to_int
.BI "(struct scsi_lun *" scsilun ");"
.SH ARGUMENTS
.IP "scsilun" 12
	struct scsi_lun to be converted.
.SH "DESCRIPTION"
Convert \fIscsilun\fP from a struct scsi_lun to a four byte host byte-ordered
integer, and return the result. The caller must check for
truncation before using this function.
.SH "NOTES"
The struct scsi_lun is assumed to be four levels, with each level
effectively containing a SCSI byte-ordered (big endian) short; the
addressing bits of each level are ignored (the highest two bits).
For a description of the LUN format, post SCSI-3 see the SCSI
Architecture Model, for SCSI-3 see the SCSI Controller Commands.
.SH "GIVEN A STRUCT SCSI_LUN OF"
 0a 04 0b 03 00 00 00 00, this function returns
.SH "THE INTEGER"
 0x0b030a04
.TH "int_to_scsilun" 9 "int_to_scsilun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
int_to_scsilun \- 
.SH SYNOPSIS
.B "void" int_to_scsilun
.BI "(unsigned int " lun ","
.BI "struct scsi_lun *" scsilun ");"
.SH ARGUMENTS
.IP "lun" 12
-- undescribed --
.IP "scsilun" 12
	struct scsi_lun to be set.
.SH "DESCRIPTION"
Reverts the functionality of the scsilun_to_int, which packed
an 8-byte lun value into an int. This routine unpacks the int
back into the lun value.
.SH "NOTE"
 the \fBscsilun_to_int\fP routine does not truly handle all
8bytes of the lun value. This functions restores only as much
as was set by the routine.
.SH "GIVEN AN INTEGER "
 0x0b030a04,  this function returns a
.SH "SCSI_LUN OF "
 struct scsi_lun of: 0a 04 0b 03 00 00 00 00
.TH "scsi_report_lun_scan" 9 "scsi_report_lun_scan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_report_lun_scan \-  Scan using SCSI REPORT LUN results
.SH SYNOPSIS
.B "int" scsi_report_lun_scan
.BI "(struct scsi_target *" starget ","
.BI "int " bflags ","
.BI "int " rescan ");"
.SH ARGUMENTS
.IP "starget" 12
-- undescribed --
.IP "bflags" 12
-- undescribed --
.IP "rescan" 12
-- undescribed --
.SH "DESCRIPTION"
If \fIsdevscan\fP is for a SCSI-3 or up device, send a REPORT LUN
command, and scan the resulting list of LUNs by calling
scsi_probe_and_add_lun.

Modifies sdevscan-&gt;lun.
.SH "0"
 scan completed (or no memory, so further scanning is futile)
.SH "1"
 no report lun scan, or not configured
.TH "scsi_scan_target" 9 "scsi_scan_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_scan_target \-  scan a target id, possibly including all LUNs on the
.SH SYNOPSIS
.B "void" scsi_scan_target
.BI "(struct device *" parent ","
.BI "unsigned int " channel ","
.BI "unsigned int " id ","
.BI "unsigned int " lun ","
.BI "int " rescan ");"
.SH ARGUMENTS
.IP "parent" 12
	host to scan
.IP "channel" 12
	channel to scan
.IP "id" 12
		target id to scan
.IP "lun" 12
	Specific LUN to scan or SCAN_WILD_CARD
.IP "rescan" 12
	passed to LUN scanning routines
.SH "DESCRIPTION"
Scan the target id on \fIparent\fP, \fIchannel\fP, and \fIid\fP. Scan at least LUN 0,
and possibly all LUNs on the target id.

First try a REPORT LUN scan, if that does not scan the target, do a
sequential scan of LUNs on the target id.
.SH "DESCRIPTION"
Scan the target id on \fIparent\fP, \fIchannel\fP, and \fIid\fP. Scan at least LUN 0,
and possibly all LUNs on the target id.

First try a REPORT LUN scan, if that does not scan the target, do a
sequential scan of LUNs on the target id.
.TH "scsi_scan_host" 9 "scsi_scan_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_scan_host \-  scan the given adapter
.SH SYNOPSIS
.B "void" scsi_scan_host
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	adapter to scan
.TH "scsi_scan_single_target" 9 "scsi_scan_single_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_scan_single_target \-  scan the given SCSI target
.SH SYNOPSIS
.B "void" scsi_scan_single_target
.BI "(struct Scsi_Host *" shost ","
.BI "unsigned int " chan ","
.BI "unsigned int " id ");"
.SH ARGUMENTS
.IP "shost" 12
         adapter to scan
.IP "chan" 12
          channel to scan
.IP "id" 12
            target id to scan
.TH "sd_init_command" 9 "sd_init_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_init_command \-  build a scsi (read or write) command from
.SH SYNOPSIS
.B "int" sd_init_command
.BI "(struct scsi_cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 pointer to mid-level's per scsi command structure that
contains request and into which the scsi command is written
.SH "DESCRIPTION"
Returns 1 if successful and 0 if error (or cannot be done now).
.SH "DESCRIPTION"
Returns 1 if successful and 0 if error (or cannot be done now).
.TH "sd_open" 9 "sd_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_open \-  open a scsi disk device
.SH SYNOPSIS
.B "int" sd_open
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
 only i_rdev member may be used
.IP "filp" 12
 only f_mode and f_flags may be used
.SH "DESCRIPTION"
Returns 0 if successful. Returns a negated errno value in case 
of error.
.SH "NOTE"
 This can be called from a user context (e.g. fsck(1) )
or from within the kernel (e.g. as a result of a mount(1) ).
In the latter case \fIinode\fP and \fIfilp\fP carry an abridged amount
of information as noted above.
.TH "sd_release" 9 "sd_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_release \-  invoked when the (last) close(2) is called on this
.SH SYNOPSIS
.B "int" sd_release
.BI "(struct inode *" inode ","
.BI "struct file *" filp ");"
.SH ARGUMENTS
.IP "inode" 12
 only i_rdev member may be used
.IP "filp" 12
 only f_mode and f_flags may be used
.SH "DESCRIPTION"
Returns 0. 
.SH "DESCRIPTION"
Returns 0. 
.SH "NOTE"
 may block (uninterruptible) if error recovery is underway
on this disk.
.TH "sd_ioctl" 9 "sd_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_ioctl \-  process an ioctl
.SH SYNOPSIS
.B "int" sd_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" filp ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 only i_rdev/i_bdev members may be used
.IP "filp" 12
 only f_mode and f_flags may be used
.IP "cmd" 12
 ioctl command number
.IP "arg" 12
 this is third argument given to ioctl(2) system call.
Often contains a pointer.
.SH "DESCRIPTION"
Returns 0 if successful (some ioctls return postive numbers on
success as well). Returns a negated errno value in case of error.
.SH "NOTE"
 most ioctls are forward onto the block subsystem or further
down in the scsi subsytem.
.TH "sd_media_changed" 9 "sd_media_changed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_media_changed \-  check if our medium changed
.SH SYNOPSIS
.B "int" sd_media_changed
.BI "(struct gendisk *" disk ");"
.SH ARGUMENTS
.IP "disk" 12
 kernel device descriptor 
.SH "DESCRIPTION"
Returns 0 if not applicable or no change; 1 if change
.SH "NOTE"
 this function is invoked from the block subsystem.
.TH "sd_rw_intr" 9 "sd_rw_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_rw_intr \-  bottom half handler: called when the lower level
.SH SYNOPSIS
.B "void" sd_rw_intr
.BI "(struct scsi_cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 mid-level's per command structure.
.SH "DESCRIPTION"
driver has completed (successfully or otherwise) a scsi command.
.SH "NOTE"
 potentially run from within an ISR. Must not block.
.TH "sd_revalidate_disk" 9 "sd_revalidate_disk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_revalidate_disk \-  called the first time a new disk is seen,
.SH SYNOPSIS
.B "int" sd_revalidate_disk
.BI "(struct gendisk *" disk ");"
.SH ARGUMENTS
.IP "disk" 12
 struct gendisk we care about
.SH "DESCRIPTION"
performs disk spin up, read_capacity, etc.
.TH "sd_probe" 9 "sd_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_probe \-  called during driver initialization and whenever a
.SH SYNOPSIS
.B "int" sd_probe
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to device object
.SH "DESCRIPTION"
Returns 0 if successful (or not interested in this scsi device 
(e.g. scanner)); 1 when there is an error.
.SH "DESCRIPTION"
Returns 0 if successful (or not interested in this scsi device 
(e.g. scanner)); 1 when there is an error.
.SH "NOTE"
 this function is invoked from the scsi mid-level.
This function sets up the mapping between a given 
&lt;host,channel,id,lun&gt; (found in sdp) and new device name 
(e.g. /dev/sda). More precisely it is the block device major 
and minor number that is chosen here.

Assume sd_attach is not re-entrant (for time being)
Also think about \fBsd_attach\fP and \fBsd_remove\fP running coincidentally.
.TH "sd_remove" 9 "sd_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sd_remove \-  called whenever a scsi disk (previously recognized by
.SH SYNOPSIS
.B "int" sd_remove
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
sd_probe) is detached from the system. It is called (potentially
multiple times) during sd module unload.
.SH "NOTE"
 this function is invoked from the scsi mid-level.
This function potentially frees up a device name (e.g. /dev/sdc)
that could be re-used by a subsequent \fBsd_probe\fP.
This function is not called when the built-in sd driver is "exit-ed".
.TH "scsi_disk_release" 9 "scsi_disk_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_disk_release \-  Called to free the scsi_disk structure
.SH SYNOPSIS
.B "void" scsi_disk_release
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
 pointer to embedded kref
.SH "DESCRIPTION"
sd_ref_sem must be held entering this routine.  Because it is
called on last put, you should always use the \fBscsi_disk_get\fP
\fBscsi_disk_put\fP helpers which manipulate the semaphore directly
and never do a direct \fBkref_put\fP.
.TH "init_sd" 9 "init_sd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_sd \-  entry point for this driver (both when built in or when
.SH SYNOPSIS
.B "int __init" init_sd
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
a module).
.SH "NOTE"
 this function registers this driver with the scsi mid-level.
.TH "exit_sd" 9 "exit_sd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
exit_sd \-  exit point for this driver (when it is a module).
.SH SYNOPSIS
.B "void __exit" exit_sd
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.SH "NOTE"
 this function unregisters this driver from the scsi mid-level.
.TH "piix_pata_cbl_detect" 9 "piix_pata_cbl_detect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_pata_cbl_detect \-  Probe host controller cable detect info
.SH SYNOPSIS
.B "void" piix_pata_cbl_detect
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port for which cable detect info is desired
.SH "DESCRIPTION"
Read 80c cable indicator from ATA PCI device's PCI config
register.  This register is normally set by firmware (BIOS).
.SH "LOCKING"
None (inherited from caller).
.TH "piix_pata_phy_reset" 9 "piix_pata_phy_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_pata_phy_reset \-  Probe specified port on PATA host controller
.SH SYNOPSIS
.B "void" piix_pata_phy_reset
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to probe
.SH "DESCRIPTION"
Probe PATA phy.
.SH "LOCKING"
None (inherited from caller).
.TH "piix_sata_probe" 9 "piix_sata_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_sata_probe \-  Probe PCI device for present SATA devices
.SH SYNOPSIS
.B "int" piix_sata_probe
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port associated with the PCI device we wish to probe
.SH "DESCRIPTION"
Reads SATA PCI device's PCI config register Port Configuration
and Status (PCS) to determine port and device availability.
.SH "LOCKING"
None (inherited from caller).
.SH "RETURNS"
Non-zero if port is enabled, it may or may not have a device
attached in that case (PRESENT bit would only be set if BIOS probe
was done). Zero is returned if port is disabled.
.TH "piix_sata_phy_reset" 9 "piix_sata_phy_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_sata_phy_reset \-  Probe specified port on SATA host controller
.SH SYNOPSIS
.B "void" piix_sata_phy_reset
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to probe
.SH "DESCRIPTION"
Probe SATA phy.
.SH "LOCKING"
None (inherited from caller).
.TH "piix_set_piomode" 9 "piix_set_piomode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_set_piomode \-  Initialize host controller PATA PIO timings
.SH SYNOPSIS
.B "void" piix_set_piomode
.BI "(struct ata_port *" ap ","
.BI "struct ata_device *" adev ");"
.SH ARGUMENTS
.IP "ap" 12
 Port whose timings we are configuring
.IP "adev" 12
 um
.SH "DESCRIPTION"
Set PIO mode for device, in host controller PCI config space.
.SH "LOCKING"
None (inherited from caller).
.TH "piix_set_dmamode" 9 "piix_set_dmamode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_set_dmamode \-  Initialize host controller PATA PIO timings
.SH SYNOPSIS
.B "void" piix_set_dmamode
.BI "(struct ata_port *" ap ","
.BI "struct ata_device *" adev ");"
.SH ARGUMENTS
.IP "ap" 12
 Port whose timings we are configuring
.IP "adev" 12
 um
.SH "DESCRIPTION"
Set UDMA mode for device, in host controller PCI config space.
.SH "LOCKING"
None (inherited from caller).
.TH "piix_init_one" 9 "piix_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_init_one \-  Register PIIX ATA PCI device with kernel services
.SH SYNOPSIS
.B "int" piix_init_one
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" ent ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device to register
.IP "ent" 12
 Entry in piix_pci_tbl matching with \fIpdev\fP
.SH "DESCRIPTION"
Called from kernel PCI layer.  We probe for combined mode (sigh),
and then hand over control to libata, for it to do the rest.
.SH "LOCKING"
Inherited from PCI layer (may sleep).
.SH "RETURNS"
Zero on success, or -ERRNO value.
.TH "atp870u_queuecommand" 9 "atp870u_queuecommand" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atp870u_queuecommand \- 	Queue SCSI command
.SH SYNOPSIS
.B "int" atp870u_queuecommand
.BI "(struct scsi_cmnd *" req_p ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "req_p" 12
 request block
.IP "done" 12
 completion function
.SH "DESCRIPTION"
Queue a command to the ATP queue. Called with the host lock held.
.TH "send_s870" 9 "send_s870" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
send_s870 \- 	send a command to the controller
.SH SYNOPSIS
.B "void" send_s870
.BI "(struct atp_unit *" dev ","
.BI "unsigned char " c ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "c" 12
-- undescribed --
.SH "DESCRIPTION"
On entry there is work queued to be done. We move some of that work to the
controller itself. 

Caller holds the host lock.
.TH "mraid_mm_open" 9 "mraid_mm_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_open \-  open routine for char node interface
.SH SYNOPSIS
.B "int" mraid_mm_open
.BI "(struct inode *" inode ","
.BI "struct file *" filep ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filep" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinod\fP	: unused
\fIfilep\fP	: unused

allow ioctl operations by apps only if they superuser privilege
.TH "mraid_mm_ioctl" 9 "mraid_mm_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_ioctl \-  module entry-point for ioctls
.SH SYNOPSIS
.B "int" mraid_mm_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" filep ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filep" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP	: inode (ignored)
\fIfilep\fP	: file operations pointer (ignored)
\fIcmd\fP		: ioctl command
\fIarg\fP		: user ioctl packet
.TH "mraid_mm_get_adapter" 9 "mraid_mm_get_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_get_adapter \-  Returns corresponding adapters for the mimd packet
.SH SYNOPSIS
.B "mraid_mmadp_t *" mraid_mm_get_adapter
.BI "(mimd_t __user *" umimd ","
.BI "int *" rval ");"
.SH ARGUMENTS
.IP "umimd" 12
-- undescribed --
.IP "rval" 12
-- undescribed --
.SH "DESCRIPTION"
\fIumimd\fP	: User space mimd_t ioctl packet
\fIadapter\fP	: pointer to the adapter (OUT)
.TH "mimd_to_kioc" 9 "mimd_to_kioc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mimd_to_kioc \-  Converter from old to new ioctl format
.SH SYNOPSIS
.B "int" mimd_to_kioc
.BI "(mimd_t __user *" umimd ","
.BI "mraid_mmadp_t *" adp ","
.BI "uioc_t *" kioc ");"
.SH ARGUMENTS
.IP "umimd" 12
-- undescribed --
.IP "adp" 12
-- undescribed --
.IP "kioc" 12
-- undescribed --
.SH "DESCRIPTION"

\fIumimd\fP	: user space old MIMD IOCTL
\fIkioc\fP	: kernel space new format IOCTL

Routine to convert MIMD interface IOCTL to new interface IOCTL packet. The
new packet is in kernel space so that driver can perform operations on it
freely.
.TH "mraid_mm_attach_buf" 9 "mraid_mm_attach_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_attach_buf \-  Attach a free dma buffer for required size
.SH SYNOPSIS
.B "int" mraid_mm_attach_buf
.BI "(mraid_mmadp_t *" adp ","
.BI "uioc_t *" kioc ","
.BI "int " xferlen ");"
.SH ARGUMENTS
.IP "adp" 12
-- undescribed --
.IP "kioc" 12
-- undescribed --
.IP "xferlen" 12
-- undescribed --
.SH "DESCRIPTION"

\fIadp\fP		: Adapter softstate
\fIkioc\fP	: kioc that the buffer needs to be attached to
\fIxferlen\fP	: required length for buffer

First we search for a pool with smallest buffer that is &gt;= \fIxferlen\fP. If
that pool has no free buffer, we will try for the next bigger size. If none
is available, we will try to allocate the smallest buffer that is &gt;=
\fIxferlen\fP and attach it the pool.
.TH "mraid_mm_alloc_kioc" 9 "mraid_mm_alloc_kioc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_alloc_kioc \-  Returns a uioc_t from free list
.SH SYNOPSIS
.B "uioc_t *" mraid_mm_alloc_kioc
.BI "(mraid_mmadp_t *" adp ");"
.SH ARGUMENTS
.IP "adp" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadp\fP	: Adapter softstate for this module

The kioc_semaphore is initialized with number of kioc nodes in the
free kioc pool. If the kioc pool is empty, this function blocks till
a kioc becomes free.
.TH "mraid_mm_dealloc_kioc" 9 "mraid_mm_dealloc_kioc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_dealloc_kioc \-  Return kioc to free pool
.SH SYNOPSIS
.B "void" mraid_mm_dealloc_kioc
.BI "(mraid_mmadp_t *" adp ","
.BI "uioc_t *" kioc ");"
.SH ARGUMENTS
.IP "adp" 12
-- undescribed --
.IP "kioc" 12
-- undescribed --
.SH "DESCRIPTION"

\fIadp\fP		: Adapter softstate
\fIkioc\fP	: uioc_t node to be returned to free pool
.TH "lld_ioctl" 9 "lld_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lld_ioctl \-  Routine to issue ioctl to low level drvr
.SH SYNOPSIS
.B "int" lld_ioctl
.BI "(mraid_mmadp_t *" adp ","
.BI "uioc_t *" kioc ");"
.SH ARGUMENTS
.IP "adp" 12
-- undescribed --
.IP "kioc" 12
-- undescribed --
.SH "DESCRIPTION"

\fIadp\fP		: The adapter handle
\fIkioc\fP	: The ioctl packet with kernel addresses
.TH "ioctl_done" 9 "ioctl_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioctl_done \-  callback from the low level driver
.SH SYNOPSIS
.B "void" ioctl_done
.BI "(uioc_t *" kioc ");"
.SH ARGUMENTS
.IP "kioc" 12
-- undescribed --
.SH "DESCRIPTION"

\fIkioc\fP	: completed ioctl packet
.TH "kioc_to_mimd" 9 "kioc_to_mimd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kioc_to_mimd \- 
.SH SYNOPSIS
.B "int" kioc_to_mimd
.BI "(uioc_t *" kioc ","
.BI "mimd_t __user *" mimd ");"
.SH ARGUMENTS
.IP "kioc" 12
-- undescribed --
.IP "mimd" 12
-- undescribed --
.SH "DESCRIPTION"

\fIkioc\fP	: Kernel space IOCTL packet (successfully issued)
\fImimd\fP	: User space MIMD packet
.TH "hinfo_to_cinfo" 9 "hinfo_to_cinfo" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hinfo_to_cinfo \-  Convert new format hba info into old format
.SH SYNOPSIS
.B "void" hinfo_to_cinfo
.BI "(mraid_hba_info_t *" hinfo ","
.BI "mcontroller_t *" cinfo ");"
.SH ARGUMENTS
.IP "hinfo" 12
-- undescribed --
.IP "cinfo" 12
-- undescribed --
.SH "DESCRIPTION"

\fIhinfo\fP	: New format, more comprehensive adapter info
\fIcinfo\fP	: Old format adapter info to support mimd_t apps
.TH "mraid_mm_adapter_app_handle" 9 "mraid_mm_adapter_app_handle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_adapter_app_handle \-  return the application handle for this adapter
.SH SYNOPSIS
.B "uint32_t" mraid_mm_adapter_app_handle
.BI "(uint32_t " unique_id ");"
.SH ARGUMENTS
.IP "unique_id" 12
-- undescribed --
.SH "DESCRIPTION"
\fIreturn\fP adapter handle if found in the list
\fIreturn\fP 0 if adapter could not be located, should never happen though
.SH "DESCRIPTION"
\fIreturn\fP adapter handle if found in the list
\fIreturn\fP 0 if adapter could not be located, should never happen though
.TH "mraid_mm_setup_dma_pools" 9 "mraid_mm_setup_dma_pools" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_setup_dma_pools \-  Set up dma buffer pools per adapter
.SH SYNOPSIS
.B "int" mraid_mm_setup_dma_pools
.BI "(mraid_mmadp_t *" adp ");"
.SH ARGUMENTS
.IP "adp" 12
-- undescribed --
.SH "DESCRIPTION"

\fIadp\fP	: Adapter softstate

We maintain a pool of dma buffers per each adapter. Each pool has one
buffer. E.g, we may have 5 dma pools - one each for 4k, 8k ... 64k buffers.
We have just one 4k buffer in 4k pool, one 8k buffer in 8k pool etc. We
dont' want to waste too much memory by allocating more buffers per each
pool.
.TH "mraid_mm_free_adp_resources" 9 "mraid_mm_free_adp_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_free_adp_resources \-  Free adapter softstate
.SH SYNOPSIS
.B "void" mraid_mm_free_adp_resources
.BI "(mraid_mmadp_t *" adp ");"
.SH ARGUMENTS
.IP "adp" 12
-- undescribed --
.SH "DESCRIPTION"

\fIadp\fP	: Adapter softstate
.TH "mraid_mm_teardown_dma_pools" 9 "mraid_mm_teardown_dma_pools" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_teardown_dma_pools \-  Free all per adapter dma buffers
.SH SYNOPSIS
.B "void" mraid_mm_teardown_dma_pools
.BI "(mraid_mmadp_t *" adp ");"
.SH ARGUMENTS
.IP "adp" 12
-- undescribed --
.SH "DESCRIPTION"

\fIadp\fP	: Adapter softstate
.TH "mraid_mm_init" 9 "mraid_mm_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_init \- 
.SH SYNOPSIS
.B "int __init" mraid_mm_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "mraid_mm_compat_ioctl" 9 "mraid_mm_compat_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_compat_ioctl \- 
.SH SYNOPSIS
.B "long" mraid_mm_compat_ioctl
.BI "(struct file *" filep ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "filep" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.TH "mraid_mm_exit" 9 "mraid_mm_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mraid_mm_exit \- 
.SH SYNOPSIS
.B "void __exit" mraid_mm_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "megasas_get_cmd" 9 "megasas_get_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_get_cmd \- 	Get a command from the free pool
.SH SYNOPSIS
.B "struct megasas_cmd *" megasas_get_cmd
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.SH "DESCRIPTION"
Returns a free command from the pool
.TH "megasas_return_cmd" 9 "megasas_return_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_return_cmd \- 	Return a cmd to free command pool
.SH SYNOPSIS
.B "void" megasas_return_cmd
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.IP "cmd" 12
		Command packet to be returned to free command pool
.TH "megasas_enable_intr" 9 "megasas_enable_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_enable_intr \- 	Enables interrupts
.SH SYNOPSIS
.B "void" megasas_enable_intr
.BI "(struct megasas_register_set __iomem *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
			MFI register set
.TH "megasas_disable_intr" 9 "megasas_disable_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_disable_intr \- 	Disables interrupts
.SH SYNOPSIS
.B "void" megasas_disable_intr
.BI "(struct megasas_register_set __iomem *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
			MFI register set
.TH "megasas_issue_polled" 9 "megasas_issue_polled" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_issue_polled \- 	Issues a polling command
.SH SYNOPSIS
.B "int" megasas_issue_polled
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "cmd" 12
			Command packet to be issued 
.SH "DESCRIPTION"
For polling, MFI requires the cmd_status to be set to 0xFF before posting.
.TH "megasas_issue_blocked_cmd" 9 "megasas_issue_blocked_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_issue_blocked_cmd \- 	Synchronous wrapper around regular FW cmds
.SH SYNOPSIS
.B "int" megasas_issue_blocked_cmd
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "cmd" 12
			Command to be issued
.SH "DESCRIPTION"
This function waits on an event for the command to be returned from ISR.
Used to issue ioctl commands.
.TH "megasas_issue_blocked_abort_cmd" 9 "megasas_issue_blocked_abort_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_issue_blocked_abort_cmd \- 	Aborts previously issued cmd
.SH SYNOPSIS
.B "int" megasas_issue_blocked_abort_cmd
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd_to_abort ");"
.SH ARGUMENTS
.IP "instance" 12
				Adapter soft state
.IP "cmd_to_abort" 12
			Previously issued cmd to be aborted
.SH "DESCRIPTION"
MFI firmware can abort previously issued AEN comamnd (automatic event
notification). The \fBmegasas_issue_blocked_abort_cmd\fP issues such abort
cmd and blocks till it is completed.
.TH "megasas_make_sgl32" 9 "megasas_make_sgl32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_make_sgl32 \- 	Prepares 32-bit SGL
.SH SYNOPSIS
.B "int" megasas_make_sgl32
.BI "(struct megasas_instance *" instance ","
.BI "struct scsi_cmnd *" scp ","
.BI "union megasas_sgl *" mfi_sgl ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.IP "scp" 12
		SCSI command from the mid-layer
.IP "mfi_sgl" 12
		SGL to be filled in
.SH "DESCRIPTION"
If successful, this function returns the number of SG elements. Otherwise,
it returnes -1.
.TH "megasas_make_sgl64" 9 "megasas_make_sgl64" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_make_sgl64 \- 	Prepares 64-bit SGL
.SH SYNOPSIS
.B "int" megasas_make_sgl64
.BI "(struct megasas_instance *" instance ","
.BI "struct scsi_cmnd *" scp ","
.BI "union megasas_sgl *" mfi_sgl ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.IP "scp" 12
		SCSI command from the mid-layer
.IP "mfi_sgl" 12
		SGL to be filled in
.SH "DESCRIPTION"
If successful, this function returns the number of SG elements. Otherwise,
it returnes -1.
.TH "megasas_build_dcdb" 9 "megasas_build_dcdb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_build_dcdb \- 	Prepares a direct cdb (DCDB) command
.SH SYNOPSIS
.B "int" megasas_build_dcdb
.BI "(struct megasas_instance *" instance ","
.BI "struct scsi_cmnd *" scp ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.IP "scp" 12
		SCSI command
.IP "cmd" 12
		Command to be prepared in
.SH "DESCRIPTION"
This function prepares CDB commands. These are typcially pass-through
commands to the devices.
.TH "megasas_build_ldio" 9 "megasas_build_ldio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_build_ldio \- 	Prepares IOs to logical devices
.SH SYNOPSIS
.B "int" megasas_build_ldio
.BI "(struct megasas_instance *" instance ","
.BI "struct scsi_cmnd *" scp ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.IP "scp" 12
		SCSI command
.IP "cmd" 12
		Command to to be prepared
.SH "DESCRIPTION"
Frames (and accompanying SGLs) for regular SCSI IOs use this function.
.TH "megasas_build_cmd" 9 "megasas_build_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_build_cmd \- 	Prepares a command packet
.SH SYNOPSIS
.B "struct megasas_cmd *" megasas_build_cmd
.BI "(struct megasas_instance *" instance ","
.BI "struct scsi_cmnd *" scp ","
.BI "int *" frame_count ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.IP "scp" 12
		SCSI command
.IP "frame_count" 12
	[OUT] Number of frames used to prepare this command
.TH "megasas_queue_command" 9 "megasas_queue_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_queue_command \- 	Queue entry point
.SH SYNOPSIS
.B "int" megasas_queue_command
.BI "(struct scsi_cmnd *" scmd ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "scmd" 12
			SCSI command to be queued
.IP "done" 12
			Callback entry point
.TH "megasas_wait_for_outstanding" 9 "megasas_wait_for_outstanding" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_wait_for_outstanding \- 	Wait for all outstanding cmds
.SH SYNOPSIS
.B "int" megasas_wait_for_outstanding
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
				Adapter soft state
.SH "DESCRIPTION"
This function waits for upto MEGASAS_RESET_WAIT_TIME seconds for FW to
complete all its outstanding commands. Returns error if one or more IOs
are pending after this time period. It also marks the controller dead.
.TH "megasas_generic_reset" 9 "megasas_generic_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_generic_reset \- 	Generic reset routine
.SH SYNOPSIS
.B "int" megasas_generic_reset
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
			Mid-layer SCSI command
.SH "DESCRIPTION"
This routine implements a generic reset handler for device, bus and host
reset requests. Device, bus and host specific reset handlers can use this
function after they do their specific tasks.
.TH "megasas_reset_device" 9 "megasas_reset_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_reset_device \- 	Device reset handler entry point
.SH SYNOPSIS
.B "int" megasas_reset_device
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
-- undescribed --
.TH "megasas_reset_bus_host" 9 "megasas_reset_bus_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_reset_bus_host \- 	Bus \\\amp; host reset handler entry point
.SH SYNOPSIS
.B "int" megasas_reset_bus_host
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
-- undescribed --
.TH "megasas_service_aen" 9 "megasas_service_aen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_service_aen \- 	Processes an event notification
.SH SYNOPSIS
.B "void" megasas_service_aen
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "cmd" 12
			AEN command completed by the ISR
.SH "DESCRIPTION"
For AEN, driver sends a command down to FW that is held by the FW till an
event occurs. When an event of interest occurs, FW completes the command
that it was previously holding.

This routines sends SIGIO signal to processes that have registered with the
driver for AEN.
.TH "megasas_complete_int_cmd" 9 "megasas_complete_int_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_complete_int_cmd \- 	Completes an internal command
.SH SYNOPSIS
.B "void" megasas_complete_int_cmd
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "cmd" 12
			Command to be completed
.SH "DESCRIPTION"
The \fBmegasas_issue_blocked_cmd\fP function waits for a command to complete
after it issues a command. This function wakes up that waiting routine by
calling \fBwake_up\fP on the wait queue.
.TH "megasas_complete_abort" 9 "megasas_complete_abort" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_complete_abort \- 	Completes aborting a command
.SH SYNOPSIS
.B "void" megasas_complete_abort
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "cmd" 12
			Cmd that was issued to abort another cmd
.SH "DESCRIPTION"
The \fBmegasas_issue_blocked_abort_cmd\fP function waits on abort_cmd_wait_q 
after it issues an abort on a previously issued command. This function 
wakes up all functions waiting on the same wait queue.
.TH "megasas_unmap_sgbuf" 9 "megasas_unmap_sgbuf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_unmap_sgbuf \- 	Unmap SG buffers
.SH SYNOPSIS
.B "void" megasas_unmap_sgbuf
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "cmd" 12
			Completed command
.TH "megasas_complete_cmd" 9 "megasas_complete_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_complete_cmd \- 	Completes a command
.SH SYNOPSIS
.B "void" megasas_complete_cmd
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_cmd *" cmd ","
.BI "u8 " alt_status ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "cmd" 12
			Command to be completed
.IP "alt_status" 12
			If non-zero, use this value as status to 
SCSI mid-layer instead of the value returned
by the FW. This should be used if caller wants
an alternate status (as in the case of aborted
commands)
.TH "megasas_deplete_reply_queue" 9 "megasas_deplete_reply_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_deplete_reply_queue \- 	Processes all completed commands
.SH SYNOPSIS
.B "int" megasas_deplete_reply_queue
.BI "(struct megasas_instance *" instance ","
.BI "u8 " alt_status ");"
.SH ARGUMENTS
.IP "instance" 12
				Adapter soft state
.IP "alt_status" 12
				Alternate status to be returned to
SCSI mid-layer instead of the status
returned by the FW
.TH "megasas_isr" 9 "megasas_isr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_isr \-  isr entry point
.SH SYNOPSIS
.B "irqreturn_t" megasas_isr
.BI "(int " irq ","
.BI "void *" devp ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "devp" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.TH "megasas_transition_to_ready" 9 "megasas_transition_to_ready" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_transition_to_ready \- 	Move the FW to READY state
.SH SYNOPSIS
.B "int" megasas_transition_to_ready
.BI "(struct megasas_register_set __iomem *" reg_set ");"
.SH ARGUMENTS
.IP "reg_set" 12
				MFI register set
.SH "DESCRIPTION"
During the initialization, FW passes can potentially be in any one of
several possible states. If the FW in operational, waiting-for-handshake
states, driver must take steps to bring it to ready state. Otherwise, it
has to wait for the ready state.
.TH "megasas_teardown_frame_pool" 9 "megasas_teardown_frame_pool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_teardown_frame_pool \- 	Destroy the cmd frame DMA pool
.SH SYNOPSIS
.B "void" megasas_teardown_frame_pool
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
				Adapter soft state
.TH "megasas_create_frame_pool" 9 "megasas_create_frame_pool" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_create_frame_pool \- 	Creates DMA pool for cmd frames
.SH SYNOPSIS
.B "int" megasas_create_frame_pool
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.SH "DESCRIPTION"
Each command packet has an embedded DMA memory buffer that is used for
filling MFI frame and the SG list that immediately follows the frame. This
function creates those DMA memory buffers for each command packet by using
PCI pool facility.
.TH "megasas_free_cmds" 9 "megasas_free_cmds" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_free_cmds \- 	Free all the cmds in the free cmd pool
.SH SYNOPSIS
.B "void" megasas_free_cmds
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.TH "megasas_alloc_cmds" 9 "megasas_alloc_cmds" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_alloc_cmds \- 	Allocates the command packets
.SH SYNOPSIS
.B "int" megasas_alloc_cmds
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.SH "DESCRIPTION"
Each command that is issued to the FW, whether IO commands from the OS or
internal commands like IOCTLs, are wrapped in local data structure called
megasas_cmd. The frame embedded in this megasas_cmd is actually issued to
the FW.

Each frame has a 32-bit field called context (tag). This context is used
to get back the megasas_cmd from the frame when a frame gets completed in
the ISR. Typically the address of the megasas_cmd itself would be used as
the context. But we wanted to keep the differences between 32 and 64 bit
systems to the mininum. We always use 32 bit integers for the context. In
this driver, the 32 bit values are the indices into an array cmd_list.
This array is used only to look up the megasas_cmd given the context. The
free commands themselves are maintained in a linked list called cmd_pool.
.TH "megasas_get_ctrl_info" 9 "megasas_get_ctrl_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_get_ctrl_info \- 	Returns FW's controller structure
.SH SYNOPSIS
.B "int" megasas_get_ctrl_info
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_ctrl_info *" ctrl_info ");"
.SH ARGUMENTS
.IP "instance" 12
				Adapter soft state
.IP "ctrl_info" 12
				Controller information structure
.SH "DESCRIPTION"
Issues an internal command (DCMD) to get the FW's controller structure.
This information is mainly used to find out the maximum IO transfer per
command supported by the FW.
.TH "megasas_init_mfi" 9 "megasas_init_mfi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_init_mfi \- 	Initializes the FW
.SH SYNOPSIS
.B "int" megasas_init_mfi
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.SH "DESCRIPTION"
This is the main function for initializing MFI firmware.
.TH "megasas_release_mfi" 9 "megasas_release_mfi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_release_mfi \- 	Reverses the FW initialization
.SH SYNOPSIS
.B "void" megasas_release_mfi
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
-- undescribed --
.TH "megasas_get_seq_num" 9 "megasas_get_seq_num" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_get_seq_num \- 	Gets latest event sequence numbers
.SH SYNOPSIS
.B "int" megasas_get_seq_num
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_evt_log_info *" eli ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "eli" 12
			FW event log sequence numbers information
.SH "DESCRIPTION"
FW maintains a log of all events in a non-volatile area. Upper layers would
usually find out the latest sequence number of the events, the seq number at
the boot etc. They would "read" all the events below the latest seq number
by issuing a direct fw cmd (DCMD). For the future events (beyond latest seq
number), they would subsribe to AEN (asynchronous event notification) and
wait for the events to happen.
.TH "megasas_register_aen" 9 "megasas_register_aen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_register_aen \- 	Registers for asynchronous event notification
.SH SYNOPSIS
.B "int" megasas_register_aen
.BI "(struct megasas_instance *" instance ","
.BI "u32 " seq_num ","
.BI "u32 " class_locale_word ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "seq_num" 12
			The starting sequence number
.IP "class_locale_word" 12
-- undescribed --
.SH "DESCRIPTION"
This function subscribes for AEN for events beyond the \fIseq_num\fP. It requests
to be notified if and only if the event is of type \fIclass_locale\fP
.TH "megasas_start_aen" 9 "megasas_start_aen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_start_aen \- 	Subscribes to AEN during driver load time
.SH SYNOPSIS
.B "int" megasas_start_aen
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.TH "megasas_io_attach" 9 "megasas_io_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_io_attach \- 	Attaches this driver to SCSI mid-layer
.SH SYNOPSIS
.B "int" megasas_io_attach
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
		Adapter soft state
.TH "megasas_probe_one" 9 "megasas_probe_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_probe_one \- 	PCI hotplug entry point
.SH SYNOPSIS
.B "int __devinit" megasas_probe_one
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "pdev" 12
		PCI device structure
.IP "id" 12
			PCI ids of supported hotplugged adapter	
.TH "megasas_flush_cache" 9 "megasas_flush_cache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_flush_cache \- 	Requests FW to flush all its caches
.SH SYNOPSIS
.B "void" megasas_flush_cache
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.TH "megasas_shutdown_controller" 9 "megasas_shutdown_controller" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_shutdown_controller \- 	Instructs FW to shutdown the controller
.SH SYNOPSIS
.B "void" megasas_shutdown_controller
.BI "(struct megasas_instance *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
				Adapter soft state
.TH "megasas_detach_one" 9 "megasas_detach_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_detach_one \- 	PCI hot"un"plug entry point
.SH SYNOPSIS
.B "void" megasas_detach_one
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
		PCI device structure
.TH "megasas_shutdown" 9 "megasas_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_shutdown \- 	Shutdown entry point
.SH SYNOPSIS
.B "void" megasas_shutdown
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.TH "megasas_mgmt_open" 9 "megasas_mgmt_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_mgmt_open \- 	char node "open" entry point
.SH SYNOPSIS
.B "int" megasas_mgmt_open
.BI "(struct inode *" inode ","
.BI "struct file *" filep ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filep" 12
-- undescribed --
.TH "megasas_mgmt_release" 9 "megasas_mgmt_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_mgmt_release \-  char node "release" entry point
.SH SYNOPSIS
.B "int" megasas_mgmt_release
.BI "(struct inode *" inode ","
.BI "struct file *" filep ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filep" 12
-- undescribed --
.TH "megasas_mgmt_fasync" 9 "megasas_mgmt_fasync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_mgmt_fasync \- 	Async notifier registration from applications
.SH SYNOPSIS
.B "int" megasas_mgmt_fasync
.BI "(int " fd ","
.BI "struct file *" filep ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "fd" 12
-- undescribed --
.IP "filep" 12
-- undescribed --
.IP "mode" 12
-- undescribed --
.SH "DESCRIPTION"

This function adds the calling process to a driver global queue. When an
event occurs, SIGIO will be sent to all processes in this queue.
.TH "megasas_mgmt_fw_ioctl" 9 "megasas_mgmt_fw_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_mgmt_fw_ioctl \- 	Issues management ioctls to FW
.SH SYNOPSIS
.B "int" megasas_mgmt_fw_ioctl
.BI "(struct megasas_instance *" instance ","
.BI "struct megasas_iocpacket __user *" user_ioc ","
.BI "struct megasas_iocpacket *" ioc ");"
.SH ARGUMENTS
.IP "instance" 12
			Adapter soft state
.IP "user_ioc" 12
-- undescribed --
.IP "ioc" 12
-- undescribed --
.TH "megasas_mgmt_ioctl" 9 "megasas_mgmt_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_mgmt_ioctl \- 	char node ioctl entry point
.SH SYNOPSIS
.B "long" megasas_mgmt_ioctl
.BI "(struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.TH "megasas_init" 9 "megasas_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_init \-  Driver load entry point
.SH SYNOPSIS
.B "int __init" megasas_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "megasas_exit" 9 "megasas_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megasas_exit \-  Driver unload entry point
.SH SYNOPSIS
.B "void __exit" megasas_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "ioctl_probe" 9 "ioctl_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioctl_probe \- -  return host identification
.SH SYNOPSIS
.B "int" ioctl_probe
.BI "(struct Scsi_Host *" host ","
.BI "void __user *" buffer ");"
.SH ARGUMENTS
.IP "host" 12
	host to identify
.IP "buffer" 12
	userspace buffer for identification
.SH "DESCRIPTION"
Return an identifying string at \fIbuffer\fP, if \fIbuffer\fP is non-NULL, filling
to the length stored at * (int *) \fIbuffer\fP.
.TH "scsi_host_set_state" 9 "scsi_host_set_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_host_set_state \-  Take the given host through the host
.SH SYNOPSIS
.B "int" scsi_host_set_state
.BI "(struct Scsi_Host *" shost ","
.BI "enum scsi_host_state " state ");"
.SH ARGUMENTS
.IP "shost" 12
	scsi host to change the state of.
.IP "state" 12
	state to change to.
.SH "DESCRIPTION"
Returns zero if unsuccessful or an error if the requested
transition is illegal.
.SH "DESCRIPTION"
Returns zero if unsuccessful or an error if the requested
transition is illegal.
.TH "scsi_remove_host" 9 "scsi_remove_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_remove_host \-  remove a scsi host
.SH SYNOPSIS
.B "void" scsi_remove_host
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	a pointer to a scsi host to remove
.TH "scsi_add_host" 9 "scsi_add_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_add_host \-  add a scsi host
.SH SYNOPSIS
.B "int" scsi_add_host
.BI "(struct Scsi_Host *" shost ","
.BI "struct device *" dev ");"
.SH ARGUMENTS
.IP "shost" 12
	scsi host pointer to add
.IP "dev" 12
	a struct device of type scsi class
.SH "RETURN VALUE"
 
0 on success / != 0 for error
.TH "scsi_host_alloc" 9 "scsi_host_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_host_alloc \-  register a scsi host adapter instance.
.SH SYNOPSIS
.B "struct Scsi_Host *" scsi_host_alloc
.BI "(struct scsi_host_template *" sht ","
.BI "int " privsize ");"
.SH ARGUMENTS
.IP "sht" 12
	pointer to scsi host template
.IP "privsize" 12
	extra bytes to allocate for driver
.SH "NOTE"
Allocate a new Scsi_Host and perform basic initialization.
The host is not published to the scsi midlayer until scsi_add_host
is called.
.SH "RETURN VALUE"
Pointer to a new Scsi_Host
.TH "scsi_host_lookup" 9 "scsi_host_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_host_lookup \-  get a reference to a Scsi_Host by host no
.SH SYNOPSIS
.B "struct Scsi_Host *" scsi_host_lookup
.BI "(unsigned short " hostnum ");"
.SH ARGUMENTS
.IP "hostnum" 12
	host number to locate
.SH "DESCRIPTION"
.SH "RETURN VALUE"
A pointer to located Scsi_Host or NULL.
.TH "scsi_host_get" 9 "scsi_host_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_host_get \-  inc a Scsi_Host ref count
.SH SYNOPSIS
.B "struct Scsi_Host *" scsi_host_get
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	Pointer to Scsi_Host to inc.
.TH "scsi_host_put" 9 "scsi_host_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_host_put \-  dec a Scsi_Host ref count
.SH SYNOPSIS
.B "void" scsi_host_put
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	Pointer to Scsi_Host to dec.
.TH "scsi_queue_work" 9 "scsi_queue_work" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_queue_work \-  Queue work to the Scsi_Host workqueue.
.SH SYNOPSIS
.B "int" scsi_queue_work
.BI "(struct Scsi_Host *" shost ","
.BI "struct work_struct *" work ");"
.SH ARGUMENTS
.IP "shost" 12
	Pointer to Scsi_Host.
.IP "work" 12
	Work to queue for execution.
.SH "RETURN VALUE"
0 on success / != 0 for error
.TH "scsi_flush_work" 9 "scsi_flush_work" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_flush_work \-  Flush a Scsi_Host's workqueue.
.SH SYNOPSIS
.B "void" scsi_flush_work
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	Pointer to Scsi_Host.
.TH "scsi_sysfs_add_sdev" 9 "scsi_sysfs_add_sdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_sysfs_add_sdev \-  add scsi device to sysfs
.SH SYNOPSIS
.B "int" scsi_sysfs_add_sdev
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi_device to add
.SH "RETURN VALUE"
0 on Success / non-zero on Failure
.TH "scsi_remove_device" 9 "scsi_remove_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_remove_device \-  unregister a device from the scsi bus
.SH SYNOPSIS
.B "void" scsi_remove_device
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi_device to unregister
.TH "scsi_remove_target" 9 "scsi_remove_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_remove_target \-  try to remove a target and all its devices
.SH SYNOPSIS
.B "void" scsi_remove_target
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 generic starget or parent of generic stargets to be removed
.SH "NOTE"
 This is slightly racy.  It is possible that if the user
requests the addition of another device then the target won't be
removed.
.TH "scsi_sysfs_add_host" 9 "scsi_sysfs_add_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_sysfs_add_host \-  add scsi host to subsystem
.SH SYNOPSIS
.B "int" scsi_sysfs_add_host
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
     scsi host struct to add to subsystem
.TH "ibmvscsi_handle_event" 9 "ibmvscsi_handle_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_handle_event \-  Interrupt handler for crq events
.SH SYNOPSIS
.B "irqreturn_t" ibmvscsi_handle_event
.BI "(int " irq ","
.BI "void *" dev_instance ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
	number of irq to handle, not used
.IP "dev_instance" 12
 ibmvscsi_host_data of host that received interrupt
.IP "regs" 12
	pt_regs with registers
.SH "DESCRIPTION"
Disables interrupts and schedules srp_task
Always returns IRQ_HANDLED
.TH "ibmvscsi_release_crq_queue" 9 "ibmvscsi_release_crq_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_release_crq_queue \-  Deallocates data and unregisters CRQ
.SH SYNOPSIS
.B "void" ibmvscsi_release_crq_queue
.BI "(struct crq_queue *" queue ","
.BI "struct ibmvscsi_host_data *" hostdata ","
.BI "int " max_requests ");"
.SH ARGUMENTS
.IP "queue" 12
	crq_queue to initialize and register
.IP "hostdata" 12
-- undescribed --
.IP "max_requests" 12
-- undescribed --
.SH "DESCRIPTION"
Frees irq, deallocates a page for messages, unmaps dma, and unregisters
the crq with the hypervisor.
.TH "crq_queue_next_crq" 9 "crq_queue_next_crq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crq_queue_next_crq \-  Returns the next entry in message queue
.SH SYNOPSIS
.B "struct viosrp_crq *" crq_queue_next_crq
.BI "(struct crq_queue *" queue ");"
.SH ARGUMENTS
.IP "queue" 12
	crq_queue to use
.SH "DESCRIPTION"
Returns pointer to next entry in queue, or NULL if there are no new 
entried in the CRQ.
.TH "ibmvscsi_send_crq" 9 "ibmvscsi_send_crq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_send_crq \-  Send a CRQ
.SH SYNOPSIS
.B "int" ibmvscsi_send_crq
.BI "(struct ibmvscsi_host_data *" hostdata ","
.BI "u64 " word1 ","
.BI "u64 " word2 ");"
.SH ARGUMENTS
.IP "hostdata" 12
	the adapter
.IP "word1" 12
	the first 64 bits of the data
.IP "word2" 12
	the second 64 bits of the data
.TH "ibmvscsi_task" 9 "ibmvscsi_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_task \-  Process srps asynchronously
.SH SYNOPSIS
.B "void" ibmvscsi_task
.BI "(void *" data ");"
.SH ARGUMENTS
.IP "data" 12
	ibmvscsi_host_data of host
.TH "ibmvscsi_init_crq_queue" 9 "ibmvscsi_init_crq_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_init_crq_queue \-  Initializes and registers CRQ with hypervisor
.SH SYNOPSIS
.B "int" ibmvscsi_init_crq_queue
.BI "(struct crq_queue *" queue ","
.BI "struct ibmvscsi_host_data *" hostdata ","
.BI "int " max_requests ");"
.SH ARGUMENTS
.IP "queue" 12
	crq_queue to initialize and register
.IP "hostdata" 12
	ibmvscsi_host_data of host
.IP "max_requests" 12
-- undescribed --
.SH "DESCRIPTION"
Allocates a page for messages, maps it for dma, and registers
the crq with the hypervisor.
Returns zero on success.
.TH "ibmvscsi_reset_crq_queue" 9 "ibmvscsi_reset_crq_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_reset_crq_queue \-  resets a crq after a failure
.SH SYNOPSIS
.B "void" ibmvscsi_reset_crq_queue
.BI "(struct crq_queue *" queue ","
.BI "struct ibmvscsi_host_data *" hostdata ");"
.SH ARGUMENTS
.IP "queue" 12
	crq_queue to initialize and register
.IP "hostdata" 12
	ibmvscsi_host_data of host
.TH "ibmvscsi_handle_event" 9 "ibmvscsi_handle_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_handle_event \- 
.SH SYNOPSIS
.B "void" ibmvscsi_handle_event
.BI "(struct HvLpEvent *" lpevt ");"
.SH ARGUMENTS
.IP "lpevt" 12
-- undescribed --
.TH "ibmvscsi_reset_crq_queue" 9 "ibmvscsi_reset_crq_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_reset_crq_queue \-  resets a crq after a failure
.SH SYNOPSIS
.B "void" ibmvscsi_reset_crq_queue
.BI "(struct crq_queue *" queue ","
.BI "struct ibmvscsi_host_data *" hostdata ");"
.SH ARGUMENTS
.IP "queue" 12
	crq_queue to initialize and register
.IP "hostdata" 12
	ibmvscsi_host_data of host
.SH "DESCRIPTION"
no-op for iSeries
.TH "ibmvscsi_send_crq" 9 "ibmvscsi_send_crq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmvscsi_send_crq \-  Send a CRQ
.SH SYNOPSIS
.B "int" ibmvscsi_send_crq
.BI "(struct ibmvscsi_host_data *" hostdata ","
.BI "u64 " word1 ","
.BI "u64 " word2 ");"
.SH ARGUMENTS
.IP "hostdata" 12
	the adapter
.IP "word1" 12
	the first 64 bits of the data
.IP "word2" 12
	the second 64 bits of the data
.TH "mega_setup_mailbox" 9 "mega_setup_mailbox" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_setup_mailbox \- 
.SH SYNOPSIS
.B "int" mega_setup_mailbox
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Allocates a 8 byte aligned memory for the handshake mailbox.
.TH "mega_runpendq" 9 "mega_runpendq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_runpendq \- 
.SH SYNOPSIS
.B "void" mega_runpendq
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Runs through the list of pending requests.
.TH "mega_allocate_scb" 9 "mega_allocate_scb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_allocate_scb \- 
.SH SYNOPSIS
.B "scb_t *" mega_allocate_scb
.BI "(adapter_t *" adapter ","
.BI "Scsi_Cmnd *" cmd ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIcmd\fP - scsi command from the mid-layer

Allocate a SCB structure. This is the central structure for controller
commands.
.TH "mega_get_ldrv_num" 9 "mega_get_ldrv_num" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_get_ldrv_num \- 
.SH SYNOPSIS
.B "int" mega_get_ldrv_num
.BI "(adapter_t *" adapter ","
.BI "Scsi_Cmnd *" cmd ","
.BI "int " channel ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "channel" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIcmd\fP - scsi mid layer command
\fIchannel\fP - channel on the controller

Calculate the logical drive number based on the information in scsi command
and the channel number.
.TH "mega_build_cmd" 9 "mega_build_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_build_cmd \- 
.SH SYNOPSIS
.B "scb_t *" mega_build_cmd
.BI "(adapter_t *" adapter ","
.BI "Scsi_Cmnd *" cmd ","
.BI "int *" busy ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "busy" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIcmd\fP - Prepare using this scsi command
\fIbusy\fP - busy flag if no resources

Prepares a command and scatter gather list for the controller. This routine
also finds out if the commands is intended for a logical drive or a
physical device and prepares the controller command accordingly.

We also re-order the logical drives and physical devices based on their
boot settings.
.TH "mega_prepare_passthru" 9 "mega_prepare_passthru" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_prepare_passthru \- 
.SH SYNOPSIS
.B "mega_passthru *" mega_prepare_passthru
.BI "(adapter_t *" adapter ","
.BI "scb_t *" scb ","
.BI "Scsi_Cmnd *" cmd ","
.BI "int " channel ","
.BI "int " target ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "scb" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "channel" 12
-- undescribed --
.IP "target" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIscb\fP - our scsi control block
\fIcmd\fP - scsi command from the mid-layer
\fIchannel\fP - actual channel on the controller
\fItarget\fP - actual id on the controller.

prepare a command for the scsi physical devices.
.TH "mega_prepare_extpassthru" 9 "mega_prepare_extpassthru" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_prepare_extpassthru \- 
.SH SYNOPSIS
.B "mega_ext_passthru *" mega_prepare_extpassthru
.BI "(adapter_t *" adapter ","
.BI "scb_t *" scb ","
.BI "Scsi_Cmnd *" cmd ","
.BI "int " channel ","
.BI "int " target ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "scb" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "channel" 12
-- undescribed --
.IP "target" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIscb\fP - our scsi control block
\fIcmd\fP - scsi command from the mid-layer
\fIchannel\fP - actual channel on the controller
\fItarget\fP - actual id on the controller.

prepare a command for the scsi physical devices. This rountine prepares
commands for devices which can take extended CDBs (&gt;10 bytes)
.TH "issue_scb" 9 "issue_scb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
issue_scb \- 
.SH SYNOPSIS
.B "int" issue_scb
.BI "(adapter_t *" adapter ","
.BI "scb_t *" scb ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "scb" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIscb\fP - scsi control block

Post a command to the card if the mailbox is available, otherwise return
busy. We also take the scb from the pending list if the mailbox is
available.
.TH "issue_scb_block" 9 "issue_scb_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
issue_scb_block \- 
.SH SYNOPSIS
.B "int" issue_scb_block
.BI "(adapter_t *" adapter ","
.BI "u_char *" raw_mbox ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "raw_mbox" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIraw_mbox\fP - the mailbox

Issue a scb in synchronous and non-interrupt mode
.TH "megaraid_isr_iomapped" 9 "megaraid_isr_iomapped" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megaraid_isr_iomapped \- 
.SH SYNOPSIS
.B "irqreturn_t" megaraid_isr_iomapped
.BI "(int " irq ","
.BI "void *" devp ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "devp" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.SH "DESCRIPTION"
\fIirq\fP - irq
\fIdevp\fP - pointer to our soft state
\fIregs\fP - unused

Interrupt service routine for io-mapped controllers.
Find out if our device is interrupting. If yes, acknowledge the interrupt
and service the completed commands.
.TH "megaraid_isr_memmapped" 9 "megaraid_isr_memmapped" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megaraid_isr_memmapped \- 
.SH SYNOPSIS
.B "irqreturn_t" megaraid_isr_memmapped
.BI "(int " irq ","
.BI "void *" devp ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "devp" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.SH "DESCRIPTION"
\fIirq\fP - irq
\fIdevp\fP - pointer to our soft state
\fIregs\fP - unused

Interrupt service routine for memory-mapped controllers.
Find out if our device is interrupting. If yes, acknowledge the interrupt
and service the completed commands.
.TH "mega_cmd_done" 9 "mega_cmd_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_cmd_done \- 
.SH SYNOPSIS
.B "void" mega_cmd_done
.BI "(adapter_t *" adapter ","
.BI "u8 " completed[] ","
.BI "int " nstatus ","
.BI "int " status ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "completed[]" 12
-- undescribed --
.IP "nstatus" 12
-- undescribed --
.IP "status" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIcompleted\fP - array of ids of completed commands
\fInstatus\fP - number of completed commands
\fIstatus\fP - status of the last command completed

Complete the comamnds and call the scsi mid-layer callback hooks.
.TH "megaraid_abort_and_reset" 9 "megaraid_abort_and_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megaraid_abort_and_reset \- 
.SH SYNOPSIS
.B "int" megaraid_abort_and_reset
.BI "(adapter_t *" adapter ","
.BI "Scsi_Cmnd *" cmd ","
.BI "int " aor ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "aor" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - megaraid soft state
\fIcmd\fP - scsi command to be aborted or reset
\fIaor\fP - abort or reset flag

Try to locate the scsi command in the pending queue. If found and is not
issued to the controller, abort/reset it. Otherwise return failure
.TH "mega_allocate_inquiry" 9 "mega_allocate_inquiry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_allocate_inquiry \- 
.SH SYNOPSIS
.B "void *" mega_allocate_inquiry
.BI "(dma_addr_t *" dma_handle ","
.BI "struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "dma_handle" 12
-- undescribed --
.IP "pdev" 12
-- undescribed --
.SH "DESCRIPTION"
\fIdma_handle\fP - handle returned for dma address
\fIpdev\fP - handle to pci device

allocates memory for inquiry structure
.TH "mega_create_proc_entry" 9 "mega_create_proc_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_create_proc_entry \- 
.SH SYNOPSIS
.B "void" mega_create_proc_entry
.BI "(int " index ","
.BI "struct proc_dir_entry *" parent ");"
.SH ARGUMENTS
.IP "index" 12
-- undescribed --
.IP "parent" 12
-- undescribed --
.SH "DESCRIPTION"
\fIindex\fP - index in soft state array
\fIparent\fP - parent node for this /proc entry

Creates /proc entries for our controllers.
.TH "proc_read_config" 9 "proc_read_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_read_config \- 
.SH SYNOPSIS
.B "int" proc_read_config
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display configuration information about the controller.
.TH "proc_read_stat" 9 "proc_read_stat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_read_stat \- 
.SH SYNOPSIS
.B "int" proc_read_stat
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Diaplay statistical information about the I/O activity.
.TH "proc_read_mbox" 9 "proc_read_mbox" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_read_mbox \- 
.SH SYNOPSIS
.B "int" proc_read_mbox
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display mailbox information for the last command issued. This information
is good for debugging.
.TH "proc_rebuild_rate" 9 "proc_rebuild_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_rebuild_rate \- 
.SH SYNOPSIS
.B "int" proc_rebuild_rate
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display current rebuild rate
.TH "proc_battery" 9 "proc_battery" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_battery \- 
.SH SYNOPSIS
.B "int" proc_battery
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display information about the battery module on the controller.
.TH "proc_pdrv_ch0" 9 "proc_pdrv_ch0" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_pdrv_ch0 \- 
.SH SYNOPSIS
.B "int" proc_pdrv_ch0
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display information about the physical drives on physical channel 0.
.TH "proc_pdrv_ch1" 9 "proc_pdrv_ch1" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_pdrv_ch1 \- 
.SH SYNOPSIS
.B "int" proc_pdrv_ch1
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display information about the physical drives on physical channel 1.
.TH "proc_pdrv_ch2" 9 "proc_pdrv_ch2" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_pdrv_ch2 \- 
.SH SYNOPSIS
.B "int" proc_pdrv_ch2
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display information about the physical drives on physical channel 2.
.TH "proc_pdrv_ch3" 9 "proc_pdrv_ch3" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_pdrv_ch3 \- 
.SH SYNOPSIS
.B "int" proc_pdrv_ch3
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display information about the physical drives on physical channel 3.
.TH "proc_pdrv" 9 "proc_pdrv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_pdrv \- 
.SH SYNOPSIS
.B "int" proc_pdrv
.BI "(adapter_t *" adapter ","
.BI "char *" page ","
.BI "int " channel ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "page" 12
-- undescribed --
.IP "channel" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIadapter\fP - pointer to our soft state

Display information about the physical drives.
.TH "proc_rdrv_10" 9 "proc_rdrv_10" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_rdrv_10 \- 
.SH SYNOPSIS
.B "int" proc_rdrv_10
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display real time information about the logical drives 0 through 9.
.TH "proc_rdrv_20" 9 "proc_rdrv_20" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_rdrv_20 \- 
.SH SYNOPSIS
.B "int" proc_rdrv_20
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display real time information about the logical drives 0 through 9.
.TH "proc_rdrv_30" 9 "proc_rdrv_30" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_rdrv_30 \- 
.SH SYNOPSIS
.B "int" proc_rdrv_30
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display real time information about the logical drives 0 through 9.
.TH "proc_rdrv_40" 9 "proc_rdrv_40" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_rdrv_40 \- 
.SH SYNOPSIS
.B "int" proc_rdrv_40
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIstart\fP - where the actual data has been written in page
\fIoffset\fP - same meaning as the read system call
\fIcount\fP - same meaning as the read system call
\fIeof\fP - set if no more data needs to be returned
\fIdata\fP - pointer to our soft state

Display real time information about the logical drives 0 through 9.
.TH "proc_rdrv" 9 "proc_rdrv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_rdrv \- 
.SH SYNOPSIS
.B "int" proc_rdrv
.BI "(adapter_t *" adapter ","
.BI "char *" page ","
.BI "int " start ","
.BI "int " end ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "end" 12
-- undescribed --
.SH "DESCRIPTION"
\fIpage\fP - buffer to write the data in
\fIadapter\fP - pointer to our soft state
\fIstart\fP - starting logical drive to display
\fIend\fP - ending logical drive to display

We do not print the inquiry information since its already available through
/proc/scsi/scsi interface
.TH "megaraid_biosparam" 9 "megaraid_biosparam" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megaraid_biosparam \- 
.SH SYNOPSIS
.B "int" megaraid_biosparam
.BI "(struct scsi_device *" sdev ","
.BI "struct block_device *" bdev ","
.BI "sector_t " capacity ","
.BI "int " geom[] ");"
.SH ARGUMENTS
.IP "sdev" 12
-- undescribed --
.IP "bdev" 12
-- undescribed --
.IP "capacity" 12
-- undescribed --
.IP "geom[]" 12
-- undescribed --
.SH "DESCRIPTION"

Return the disk geometry for a particular disk
.TH "mega_init_scb" 9 "mega_init_scb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_init_scb \- 
.SH SYNOPSIS
.B "int" mega_init_scb
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
.SH "ALLOCATE MEMORY FOR THE VARIOUS POINTERS IN THE SCB STRUCTURES"
scatter-gather list pointer, passthru and extended passthru structure
pointers.
.TH "megadev_open" 9 "megadev_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megadev_open \- 
.SH SYNOPSIS
.B "int" megadev_open
.BI "(struct inode *" inode ","
.BI "struct file *" filep ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filep" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - unused
\fIfilep\fP - unused

Routines for the character/ioctl interface to the driver. Find out if this
is a valid open. If yes, increment the module use count so that it cannot
be unloaded.
.TH "megadev_ioctl" 9 "megadev_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
megadev_ioctl \- 
.SH SYNOPSIS
.B "int" megadev_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" filep ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "filep" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"
\fIinode\fP - Our device inode
\fIfilep\fP - unused
\fIcmd\fP - ioctl command
\fIarg\fP - user buffer

ioctl entry point for our private ioctl interface. We move the data in from
the user space, prepare the command (if necessary, convert the old MIMD
ioctl to new ioctl command), and issue a synchronous command to the
controller.
.TH "mega_m_to_n" 9 "mega_m_to_n" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_m_to_n \- 
.SH SYNOPSIS
.B "int" mega_m_to_n
.BI "(void __user *" arg ","
.BI "nitioctl_t *" uioc ");"
.SH ARGUMENTS
.IP "arg" 12
-- undescribed --
.IP "uioc" 12
-- undescribed --
.SH "DESCRIPTION"
\fIarg\fP - user address
\fIuioc\fP - new ioctl structure

A thin layer to convert older mimd interface ioctl structure to NIT ioctl
structure

Converts the older mimd ioctl structure to newer NIT structure
.TH "mega_is_bios_enabled" 9 "mega_is_bios_enabled" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_is_bios_enabled \- 
.SH SYNOPSIS
.B "int" mega_is_bios_enabled
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

issue command to find out if the BIOS is enabled for this controller
.TH "mega_enum_raid_scsi" 9 "mega_enum_raid_scsi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_enum_raid_scsi \- 
.SH SYNOPSIS
.B "void" mega_enum_raid_scsi
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Find out what channels are RAID/SCSI. This information is used to
differentiate the virtual channels and physical channels and to support
ROMB feature and non-disk devices.
.TH "mega_get_boot_drv" 9 "mega_get_boot_drv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_get_boot_drv \- 
.SH SYNOPSIS
.B "void" mega_get_boot_drv
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Find out which device is the boot device. Note, any logical drive or any
phyical device (e.g., a CDROM) can be designated as a boot device.
.TH "mega_support_random_del" 9 "mega_support_random_del" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_support_random_del \- 
.SH SYNOPSIS
.B "int" mega_support_random_del
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Find out if this controller supports random deletion and addition of
logical drives
.TH "mega_support_ext_cdb" 9 "mega_support_ext_cdb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_support_ext_cdb \- 
.SH SYNOPSIS
.B "int" mega_support_ext_cdb
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Find out if this firmware support cdblen &gt; 10
.TH "mega_del_logdrv" 9 "mega_del_logdrv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_del_logdrv \- 
.SH SYNOPSIS
.B "int" mega_del_logdrv
.BI "(adapter_t *" adapter ","
.BI "int " logdrv ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "logdrv" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIlogdrv\fP - logical drive to be deleted

Delete the specified logical drive. It is the responsibility of the user
app to let the OS know about this operation.
.TH "mega_get_max_sgl" 9 "mega_get_max_sgl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_get_max_sgl \- 
.SH SYNOPSIS
.B "void" mega_get_max_sgl
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Find out the maximum number of scatter-gather elements supported by this
version of the firmware
.TH "mega_support_cluster" 9 "mega_support_cluster" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_support_cluster \- 
.SH SYNOPSIS
.B "int" mega_support_cluster
.BI "(adapter_t *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state

Find out if this firmware support cluster calls.
.TH "mega_adapinq" 9 "mega_adapinq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_adapinq \- 
.SH SYNOPSIS
.B "int" mega_adapinq
.BI "(adapter_t *" adapter ","
.BI "dma_addr_t " dma_handle ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "dma_handle" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIdma_handle\fP - DMA address of the buffer

Issue internal comamnds while interrupts are available.
We only issue direct mailbox commands from within the driver. \fBioctl\fP
interface using these routines can issue passthru commands.
.TH "mega_internal_command" 9 "mega_internal_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_internal_command \- 
.SH SYNOPSIS
.B "int" mega_internal_command
.BI "(adapter_t *" adapter ","
.BI "lockscope_t " ls ","
.BI "megacmd_t *" mc ","
.BI "mega_passthru *" pthru ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "ls" 12
-- undescribed --
.IP "mc" 12
-- undescribed --
.IP "pthru" 12
-- undescribed --
.SH "DESCRIPTION"
\fIadapter\fP - pointer to our soft state
\fIls\fP - the scope of the exclusion lock.
\fImc\fP - the mailbox command
\fIpthru\fP - Passthru structure for DCDB commands

Issue the internal commands in interrupt mode.
The last argument is the address of the passthru structure if the command
to be fired is a passthru command

lockscope specifies whether the caller has already acquired the lock. Of
course, the caller must know which lock we are talking about.
.SH "NOTE"
 parameter 'pthru' is null for non-passthru commands.
.TH "mega_internal_done" 9 "mega_internal_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mega_internal_done \- 
.SH SYNOPSIS
.B "void" mega_internal_done
.BI "(Scsi_Cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
-- undescribed --
.SH "DESCRIPTION"
\fIscmd\fP - internal scsi command

Callback routine for internal commands.
.TH "sr_kref_release" 9 "sr_kref_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sr_kref_release \-  Called to free the scsi_cd structure
.SH SYNOPSIS
.B "void" sr_kref_release
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
 pointer to embedded kref
.SH "DESCRIPTION"
sr_ref_sem must be held entering this routine.  Because it is
called on last put, you should always use the \fBscsi_cd_get\fP
\fBscsi_cd_put\fP helpers which manipulate the semaphore directly
and never do a direct \fBkref_put\fP.
.TH "scsi_eh_scmd_add" 9 "scsi_eh_scmd_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_scmd_add \-  add scsi cmd to error handling.
.SH SYNOPSIS
.B "int" scsi_eh_scmd_add
.BI "(struct scsi_cmnd *" scmd ","
.BI "int " eh_flag ");"
.SH ARGUMENTS
.IP "scmd" 12
	scmd to run eh on.
.IP "eh_flag" 12
	optional SCSI_EH flag.
.SH "RETURN VALUE"
0 on failure.
.TH "scsi_add_timer" 9 "scsi_add_timer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_add_timer \-  Start timeout timer for a single scsi command.
.SH SYNOPSIS
.B "void" scsi_add_timer
.BI "(struct scsi_cmnd *" scmd ","
.BI "int " timeout ","
.BI "void (*" complete ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "scmd" 12
	scsi command that is about to start running.
.IP "timeout" 12
	amount of time to allow this command to run.
.IP "complete" 12
	timeout function to call if timer isn't canceled.
.SH "NOTES"
This should be turned into an inline function.  Each scsi command
has its own timer, and as it is added to the queue, we set up the
timer.  When the command completes, we cancel the timer.
.TH "scsi_delete_timer" 9 "scsi_delete_timer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_delete_timer \-  Delete/cancel timer for a given function.
.SH SYNOPSIS
.B "int" scsi_delete_timer
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	Cmd that we are canceling timer for
.SH "NOTES"
This should be turned into an inline function.
.SH "RETURN VALUE"
1 if we were able to detach the timer.  0 if we blew it, and the
timer function has already started to run.
.TH "scsi_times_out" 9 "scsi_times_out" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_times_out \-  Timeout function for normal scsi commands.
.SH SYNOPSIS
.B "void" scsi_times_out
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	Cmd that is timing out.
.SH "NOTES"
We do not need to lock this.  There is the potential for a race
only in that the normal completion handling might run, but if the
normal completion function determines that the timer has already
fired, then it mustn't do anything.
.TH "scsi_block_when_processing_errors" 9 "scsi_block_when_processing_errors" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_block_when_processing_errors \-  Prevent cmds from being queued.
.SH SYNOPSIS
.B "int" scsi_block_when_processing_errors
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	Device on which we are performing recovery.
.SH "DESCRIPTION"
We block until the host is out of error recovery, and then check to
see whether the host or the device is offline.
.SH "RETURN VALUE"
0 when dev was taken offline by error recovery. 1 OK to proceed.
.TH "scsi_eh_prt_fail_stats" 9 "scsi_eh_prt_fail_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_prt_fail_stats \-  Log info on failures.
.SH SYNOPSIS
.B "void" scsi_eh_prt_fail_stats
.BI "(struct Scsi_Host *" shost ","
.BI "struct list_head *" work_q ");"
.SH ARGUMENTS
.IP "shost" 12
	scsi host being recovered.
.IP "work_q" 12
	Queue of scsi cmds to process.
.TH "scsi_check_sense" 9 "scsi_check_sense" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_check_sense \-  Examine scsi cmd sense
.SH SYNOPSIS
.B "int" scsi_check_sense
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	Cmd to have sense checked.
.SH "RETURN VALUE"
SUCCESS or FAILED or NEEDS_RETRY
.SH "NOTES"
When a deferred error is detected the current command has
not been executed and needs retrying.
.TH "scsi_eh_completed_normally" 9 "scsi_eh_completed_normally" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_completed_normally \-  Disposition a eh cmd on return from LLD.
.SH SYNOPSIS
.B "int" scsi_eh_completed_normally
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI cmd to examine.
.SH "NOTES"
This is *only* called when we are examining the status of commands
queued during error recovery.  the main difference here is that we
don't allow for the possibility of retries here, and we are a lot
more restrictive about what we consider acceptable.
.TH "scsi_eh_times_out" 9 "scsi_eh_times_out" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_times_out \-  timeout function for error handling.
.SH SYNOPSIS
.B "void" scsi_eh_times_out
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	Cmd that is timing out.
.SH "NOTES"
During error handling, the kernel thread will be sleeping waiting
for some action to complete on the device.  our only job is to
record that it timed out, and to wake up the thread.
.TH "scsi_eh_done" 9 "scsi_eh_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_done \-  Completion function for error handling.
.SH SYNOPSIS
.B "void" scsi_eh_done
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	Cmd that is done.
.TH "scsi_send_eh_cmnd" 9 "scsi_send_eh_cmnd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_send_eh_cmnd \-  send a cmd to a device as part of error recovery.
.SH SYNOPSIS
.B "int" scsi_send_eh_cmnd
.BI "(struct scsi_cmnd *" scmd ","
.BI "int " timeout ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI Cmd to send.
.IP "timeout" 12
	Timeout for cmd.
.SH "NOTES"
The initialization of the structures is quite a bit different in
this case, and furthermore, there is a different completion handler
vs scsi_dispatch_cmd.
.SH "RETURN VALUE"
SUCCESS or FAILED or NEEDS_RETRY
.TH "scsi_request_sense" 9 "scsi_request_sense" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_request_sense \-  Request sense data from a particular target.
.SH SYNOPSIS
.B "int" scsi_request_sense
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI cmd for request sense.
.SH "NOTES"
Some hosts automatically obtain this information, others require
that we obtain it on our own. This function will *not* return until
the command either times out, or it completes.
.TH "scsi_eh_finish_cmd" 9 "scsi_eh_finish_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_finish_cmd \-  Handle a cmd that eh is finished with.
.SH SYNOPSIS
.B "void" scsi_eh_finish_cmd
.BI "(struct scsi_cmnd *" scmd ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "scmd" 12
	Original SCSI cmd that eh has finished.
.IP "done_q" 12
	Queue for processed commands.
.SH "NOTES"
We don't want to use the normal command completion while we are are
still handling errors - it may cause other commands to be queued,
and that would disturb what we are doing.  thus we really want to
keep a list of pending commands for final completion, and once we
are ready to leave error handling we handle completion for real.
.TH "scsi_eh_get_sense" 9 "scsi_eh_get_sense" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_get_sense \-  Get device sense data.
.SH SYNOPSIS
.B "int" scsi_eh_get_sense
.BI "(struct list_head *" work_q ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "work_q" 12
	Queue of commands to process.
.IP "done_q" 12
	Queue of proccessed commands..
.SH "DESCRIPTION"
See if we need to request sense information.  if so, then get it
now, so we have a better idea of what to do.  
.SH "NOTES"
This has the unfortunate side effect that if a shost adapter does
not automatically request sense information, that we end up shutting
it down before we request it.

All drivers should request sense information internally these days,
so for now all I have to say is tough noogies if you end up in here.
.SH "XXX"
 Long term this code should go away, but that needs an audit of
all LLDDs first.
.TH "scsi_try_to_abort_cmd" 9 "scsi_try_to_abort_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_try_to_abort_cmd \-  Ask host to abort a running command.
.SH SYNOPSIS
.B "int" scsi_try_to_abort_cmd
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI cmd to abort from Lower Level.
.SH "NOTES"
This function will not return until the user's completion function
has been called.  there is no timeout on this operation.  if the
author of the low-level driver wishes this operation to be timed,
they can provide this facility themselves.  helper functions in
scsi_error.c can be supplied to make this easier to do.
.TH "scsi_eh_tur" 9 "scsi_eh_tur" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_tur \-  Send TUR to device.
.SH SYNOPSIS
.B "int" scsi_eh_tur
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	Scsi cmd to send TUR
.SH "RETURN VALUE"
0 - Device is ready. 1 - Device NOT ready.
.TH "scsi_eh_abort_cmds" 9 "scsi_eh_abort_cmds" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_abort_cmds \-  abort canceled commands.
.SH SYNOPSIS
.B "int" scsi_eh_abort_cmds
.BI "(struct list_head *" work_q ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "work_q" 12
-- undescribed --
.IP "done_q" 12
-- undescribed --
.SH "DECRIPTION"
Try and see whether or not it makes sense to try and abort the
running command.  this only works out to be the case if we have one
command that has timed out.  if the command simply failed, it makes
no sense to try and abort the command, since as far as the shost
adapter is concerned, it isn't running.
.TH "scsi_try_bus_device_reset" 9 "scsi_try_bus_device_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_try_bus_device_reset \-  Ask host to perform a BDR on a dev
.SH SYNOPSIS
.B "int" scsi_try_bus_device_reset
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI cmd used to send BDR	
.SH "NOTES"
There is no timeout for this operation.  if this operation is
unreliable for a given host, then the host itself needs to put a
timer on it, and set the host back to a consistent state prior to
returning.
.TH "scsi_eh_try_stu" 9 "scsi_eh_try_stu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_try_stu \-  Send START_UNIT to device.
.SH SYNOPSIS
.B "int" scsi_eh_try_stu
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	Scsi cmd to send START_UNIT
.SH "RETURN VALUE"
0 - Device is ready. 1 - Device NOT ready.
.TH "scsi_eh_bus_device_reset" 9 "scsi_eh_bus_device_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_bus_device_reset \-  send bdr if needed
.SH SYNOPSIS
.B "int" scsi_eh_bus_device_reset
.BI "(struct Scsi_Host *" shost ","
.BI "struct list_head *" work_q ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "shost" 12
	scsi host being recovered.
.IP "work_q" 12
-- undescribed --
.IP "done_q" 12
-- undescribed --
.SH "NOTES"
Try a bus device reset.  still, look to see whether we have multiple
devices that are jammed or not - if we have multiple devices, it
makes no sense to try bus_device_reset - we really would need to try
a bus_reset instead. 
.TH "scsi_try_bus_reset" 9 "scsi_try_bus_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_try_bus_reset \-  ask host to perform a bus reset
.SH SYNOPSIS
.B "int" scsi_try_bus_reset
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI cmd to send bus reset.
.TH "scsi_try_host_reset" 9 "scsi_try_host_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_try_host_reset \-  ask host adapter to reset itself
.SH SYNOPSIS
.B "int" scsi_try_host_reset
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI cmd to send hsot reset.
.TH "scsi_eh_bus_reset" 9 "scsi_eh_bus_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_bus_reset \-  send a bus reset 
.SH SYNOPSIS
.B "int" scsi_eh_bus_reset
.BI "(struct Scsi_Host *" shost ","
.BI "struct list_head *" work_q ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "shost" 12
	scsi host being recovered.
.IP "work_q" 12
-- undescribed --
.IP "done_q" 12
-- undescribed --
.TH "scsi_eh_host_reset" 9 "scsi_eh_host_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_host_reset \-  send a host reset 
.SH SYNOPSIS
.B "int" scsi_eh_host_reset
.BI "(struct list_head *" work_q ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "work_q" 12
	list_head for processed commands.
.IP "done_q" 12
	list_head for processed commands.
.TH "scsi_eh_offline_sdevs" 9 "scsi_eh_offline_sdevs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_offline_sdevs \-  offline scsi devices that fail to recover
.SH SYNOPSIS
.B "void" scsi_eh_offline_sdevs
.BI "(struct list_head *" work_q ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "work_q" 12
	list_head for processed commands.
.IP "done_q" 12
	list_head for processed commands.
.TH "scsi_decide_disposition" 9 "scsi_decide_disposition" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_decide_disposition \-  Disposition a cmd on return from LLD.
.SH SYNOPSIS
.B "int" scsi_decide_disposition
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI cmd to examine.
.SH "NOTES"
This is *only* called when we are examining the status after sending
out the actual data command.  any commands that are queued for error
recovery (e.g. test_unit_ready) do *not* come through here.

When this routine returns failed, it means the error handler thread
is woken.  In cases where the error code indicates an error that
doesn't require the error handler read (i.e. we don't need to
abort/reset), this function should return SUCCESS.
.TH "scsi_eh_lock_done" 9 "scsi_eh_lock_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_lock_done \-  done function for eh door lock request
.SH SYNOPSIS
.B "void" scsi_eh_lock_done
.BI "(struct scsi_cmnd *" scmd ");"
.SH ARGUMENTS
.IP "scmd" 12
	SCSI command block for the door lock request
.SH "NOTES"
We completed the asynchronous door lock request, and it has either
locked the door or failed.  We must free the command structures
associated with this request.
.TH "scsi_eh_lock_door" 9 "scsi_eh_lock_door" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_lock_door \-  Prevent medium removal for the specified device
.SH SYNOPSIS
.B "void" scsi_eh_lock_door
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	SCSI device to prevent medium removal
.SH "LOCKING"
We must be called from process context; \fBscsi_allocate_request\fP
may sleep.
.SH "NOTES"
We queue up an asynchronous "ALLOW MEDIUM REMOVAL" request on the
head of the devices request queue, and continue.
.SH "BUGS"
\fBscsi_allocate_request\fP may sleep waiting for existing requests to
be processed.  However, since we haven't kicked off any request
processing for this host, this may deadlock.

If \fBscsi_allocate_request\fP fails for what ever reason, we
completely forget to lock the door.
.TH "scsi_restart_operations" 9 "scsi_restart_operations" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_restart_operations \-  restart io operations to the specified host.
.SH SYNOPSIS
.B "void" scsi_restart_operations
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	Host we are restarting.
.SH "NOTES"
When we entered the error handler, we blocked all further i/o to
this device.  we need to 'reverse' this process.
.TH "scsi_eh_ready_devs" 9 "scsi_eh_ready_devs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_ready_devs \-  check device ready state and recover if not.
.SH SYNOPSIS
.B "void" scsi_eh_ready_devs
.BI "(struct Scsi_Host *" shost ","
.BI "struct list_head *" work_q ","
.BI "struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "shost" 12
 	host to be recovered.
.IP "work_q" 12
-- undescribed --
.IP "done_q" 12
-- undescribed --
.TH "scsi_eh_flush_done_q" 9 "scsi_eh_flush_done_q" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_eh_flush_done_q \-  finish processed commands or retry them.
.SH SYNOPSIS
.B "void" scsi_eh_flush_done_q
.BI "(struct list_head *" done_q ");"
.SH ARGUMENTS
.IP "done_q" 12
	list_head of processed commands.
.TH "scsi_unjam_host" 9 "scsi_unjam_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_unjam_host \-  Attempt to fix a host which has a cmd that failed.
.SH SYNOPSIS
.B "void" scsi_unjam_host
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	Host to unjam.
.SH "NOTES"
When we come in here, we *know* that all commands on the bus have
either completed, failed or timed out.  we also know that no further
commands are being sent to the host, so things are relatively quiet
and we have freedom to fiddle with things as we wish.

This is only the *default* implementation.  it is possible for
individual drivers to supply their own version of this function, and
if the maintainer wishes to do this, it is strongly suggested that
this function be taken as a template and modified.  this function
was designed to correctly handle problems for about 95% of the
different cases out there, and it should always provide at least a
reasonable amount of error recovery.

Any command marked 'failed' or 'timeout' must eventually have
\fBscsi_finish_cmd\fP called for it.  we do all of the retry stuff
here, so when we restart the host after we return it should have an
empty queue.
.TH "scsi_error_handler" 9 "scsi_error_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_error_handler \-  Handle errors/timeouts of SCSI cmds.
.SH SYNOPSIS
.B "int" scsi_error_handler
.BI "(void *" data ");"
.SH ARGUMENTS
.IP "data" 12
	Host for which we are running.
.SH "NOTES"
This is always run in the context of a kernel thread.  The idea is
that we start this thing up when the kernel starts up (one per host
that we detect), and it immediately goes to sleep and waits for some
event (i.e. failure).  When this takes place, we have the job of
trying to unjam the bus and restarting things.
.TH "scsi_normalize_sense" 9 "scsi_normalize_sense" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_normalize_sense \-  normalize main elements from either fixed or
.SH SYNOPSIS
.B "int" scsi_normalize_sense
.BI "(const u8 *" sense_buffer ","
.BI "int " sb_len ","
.BI "struct scsi_sense_hdr *" sshdr ");"
.SH ARGUMENTS
.IP "sense_buffer" 12
	byte array containing sense data returned by device
.IP "sb_len" 12
		number of valid bytes in sense_buffer
.IP "sshdr" 12
		pointer to instance of structure that common
elements are written to.
.SH "DESCRIPTION"
descriptor sense data format into a common format.
.SH "NOTES"
The "main elements" from sense data are: response_code, sense_key,
asc, ascq and additional_length (only for descriptor format).

Typically this function can be called after a device has
responded to a SCSI command with the CHECK_CONDITION status.
.SH "RETURN VALUE"
1 if valid sense data information found, else 0;
.TH "scsi_sense_desc_find" 9 "scsi_sense_desc_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_sense_desc_find \-  search for a given descriptor type in
.SH SYNOPSIS
.B "const u8 *" scsi_sense_desc_find
.BI "(const u8 *" sense_buffer ","
.BI "int " sb_len ","
.BI "int " desc_type ");"
.SH ARGUMENTS
.IP "sense_buffer" 12
	byte array of descriptor format sense data
.IP "sb_len" 12
		number of valid bytes in sense_buffer
.IP "desc_type" 12
		value of descriptor type to find
(e.g. 0 -&gt; information)
.SH "DESCRIPTION"
descriptor sense data format.
.SH "NOTES"
only valid when sense data is in descriptor format
.SH "RETURN VALUE"
pointer to start of (first) descriptor if found else NULL
.TH "scsi_get_sense_info_fld" 9 "scsi_get_sense_info_fld" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_get_sense_info_fld \-  attempts to get information field from
.SH SYNOPSIS
.B "int" scsi_get_sense_info_fld
.BI "(const u8 *" sense_buffer ","
.BI "int " sb_len ","
.BI "u64 *" info_out ");"
.SH ARGUMENTS
.IP "sense_buffer" 12
	byte array of sense data
.IP "sb_len" 12
		number of valid bytes in sense_buffer
.IP "info_out" 12
		pointer to 64 integer where 8 or 4 byte information
field will be placed if found.
.SH "DESCRIPTION"
sense data (either fixed or descriptor format)
.SH "RETURN VALUE"
1 if information field found, 0 if not found.
.TH "qla2x00_get_serdes_params" 9 "qla2x00_get_serdes_params" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_get_serdes_params \- 
.SH SYNOPSIS
.B "int" qla2x00_get_serdes_params
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t *" sw_em_1g ","
.BI "uint16_t *" sw_em_2g ","
.BI "uint16_t *" sw_em_4g ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "sw_em_1g" 12
-- undescribed --
.IP "sw_em_2g" 12
-- undescribed --
.IP "sw_em_4g" 12
-- undescribed --
.SH "DESCRIPTION"
Returns
.TH "qla2x00_set_serdes_params" 9 "qla2x00_set_serdes_params" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_set_serdes_params \- 
.SH SYNOPSIS
.B "int" qla2x00_set_serdes_params
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t " sw_em_1g ","
.BI "uint16_t " sw_em_2g ","
.BI "uint16_t " sw_em_4g ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "sw_em_1g" 12
-- undescribed --
.IP "sw_em_2g" 12
-- undescribed --
.IP "sw_em_4g" 12
-- undescribed --
.SH "DESCRIPTION"
Returns
.TH "qla2300_fw_dump" 9 "qla2300_fw_dump" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2300_fw_dump \-  Dumps binary data from the 2300 firmware.
.SH SYNOPSIS
.B "void" qla2300_fw_dump
.BI "(scsi_qla_host_t *" ha ","
.BI "int " hardware_locked ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "hardware_locked" 12
 Called with the hardware_lock
.TH "qla2300_ascii_fw_dump" 9 "qla2300_ascii_fw_dump" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2300_ascii_fw_dump \-  Converts a binary firmware dump to ASCII.
.SH SYNOPSIS
.B "void" qla2300_ascii_fw_dump
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.TH "qla2100_fw_dump" 9 "qla2100_fw_dump" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2100_fw_dump \-  Dumps binary data from the 2100/2200 firmware.
.SH SYNOPSIS
.B "void" qla2100_fw_dump
.BI "(scsi_qla_host_t *" ha ","
.BI "int " hardware_locked ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "hardware_locked" 12
 Called with the hardware_lock
.TH "qla2100_ascii_fw_dump" 9 "qla2100_ascii_fw_dump" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2100_ascii_fw_dump \-  Converts a binary firmware dump to ASCII.
.SH SYNOPSIS
.B "void" qla2100_ascii_fw_dump
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.TH "qla2x00_get_cmd_direction" 9 "qla2x00_get_cmd_direction" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_get_cmd_direction \-  Determine control_flag data direction.
.SH SYNOPSIS
.B "uint16_t" qla2x00_get_cmd_direction
.BI "(struct scsi_cmnd *" cmd ");"
.SH ARGUMENTS
.IP "cmd" 12
 SCSI command
.SH "DESCRIPTION"
Returns the proper CF_* direction based on CDB.
.TH "qla2x00_calc_iocbs_32" 9 "qla2x00_calc_iocbs_32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_calc_iocbs_32 \-  Determine number of Command Type 2 and
.SH SYNOPSIS
.B "uint16_t" qla2x00_calc_iocbs_32
.BI "(uint16_t " dsds ");"
.SH ARGUMENTS
.IP "dsds" 12
 number of data segment decriptors needed
.SH "DESCRIPTION"
Returns the number of IOCB entries needed to store \fIdsds\fP.
.SH "DESCRIPTION"
Returns the number of IOCB entries needed to store \fIdsds\fP.
.TH "qla2x00_calc_iocbs_64" 9 "qla2x00_calc_iocbs_64" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_calc_iocbs_64 \-  Determine number of Command Type 3 and
.SH SYNOPSIS
.B "uint16_t" qla2x00_calc_iocbs_64
.BI "(uint16_t " dsds ");"
.SH ARGUMENTS
.IP "dsds" 12
 number of data segment decriptors needed
.SH "DESCRIPTION"
Returns the number of IOCB entries needed to store \fIdsds\fP.
.SH "DESCRIPTION"
Returns the number of IOCB entries needed to store \fIdsds\fP.
.TH "qla2x00_prep_cont_type0_iocb" 9 "qla2x00_prep_cont_type0_iocb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_prep_cont_type0_iocb \-  Initialize a Continuation Type 0 IOCB.
.SH SYNOPSIS
.B "cont_entry_t *" qla2x00_prep_cont_type0_iocb
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns a pointer to the Continuation Type 0 IOCB packet.
.TH "qla2x00_prep_cont_type1_iocb" 9 "qla2x00_prep_cont_type1_iocb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_prep_cont_type1_iocb \-  Initialize a Continuation Type 1 IOCB.
.SH SYNOPSIS
.B "cont_a64_entry_t *" qla2x00_prep_cont_type1_iocb
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns a pointer to the continuation type 1 IOCB packet.
.TH "qla2x00_build_scsi_iocbs_32" 9 "qla2x00_build_scsi_iocbs_32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_build_scsi_iocbs_32 \-  Build IOCB command utilizing 32bit
.SH SYNOPSIS
.B "void" qla2x00_build_scsi_iocbs_32
.BI "(srb_t *" sp ","
.BI "cmd_entry_t *" cmd_pkt ","
.BI "uint16_t " tot_dsds ");"
.SH ARGUMENTS
.IP "sp" 12
 SRB command to process
.IP "cmd_pkt" 12
 Command type 2 IOCB
.IP "tot_dsds" 12
 Total number of segments to transfer
.SH "DESCRIPTION"
capable IOCB types.
.TH "qla2x00_build_scsi_iocbs_64" 9 "qla2x00_build_scsi_iocbs_64" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_build_scsi_iocbs_64 \-  Build IOCB command utilizing 64bit
.SH SYNOPSIS
.B "void" qla2x00_build_scsi_iocbs_64
.BI "(srb_t *" sp ","
.BI "cmd_entry_t *" cmd_pkt ","
.BI "uint16_t " tot_dsds ");"
.SH ARGUMENTS
.IP "sp" 12
 SRB command to process
.IP "cmd_pkt" 12
 Command type 3 IOCB
.IP "tot_dsds" 12
 Total number of segments to transfer
.SH "DESCRIPTION"
capable IOCB types.
.TH "qla2x00_start_scsi" 9 "qla2x00_start_scsi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_start_scsi \-  Send a SCSI command to the ISP
.SH SYNOPSIS
.B "int" qla2x00_start_scsi
.BI "(srb_t *" sp ");"
.SH ARGUMENTS
.IP "sp" 12
 command to send to the ISP
.SH "DESCRIPTION"
Returns non-zero if a failure occured, else zero.
.TH "__qla2x00_marker" 9 "__qla2x00_marker" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__qla2x00_marker \-  Send a marker IOCB to the firmware.
.SH SYNOPSIS
.B "int" __qla2x00_marker
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t " loop_id ","
.BI "uint16_t " lun ","
.BI "uint8_t " type ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "loop_id" 12
 loop ID
.IP "lun" 12
 LUN
.IP "type" 12
 marker modifier
.SH "DESCRIPTION"
Can be called from both normal and interrupt context.

Returns non-zero if a failure occured, else zero.
.TH "qla2x00_req_pkt" 9 "qla2x00_req_pkt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_req_pkt \-  Retrieve a request packet from the request ring.
.SH SYNOPSIS
.B "request_t *" qla2x00_req_pkt
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "NOTE"
 The caller must hold the hardware lock before calling this routine.

Returns NULL if function failed, else, a pointer to the request packet.
.TH "qla2x00_isp_cmd" 9 "qla2x00_isp_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_isp_cmd \-  Modify the request ring pointer.
.SH SYNOPSIS
.B "void" qla2x00_isp_cmd
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "NOTE"
 The caller must hold the hardware lock before calling this routine.
.TH "qla24xx_calc_iocbs" 9 "qla24xx_calc_iocbs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_calc_iocbs \-  Determine number of Command Type 3 and
.SH SYNOPSIS
.B "uint16_t" qla24xx_calc_iocbs
.BI "(uint16_t " dsds ");"
.SH ARGUMENTS
.IP "dsds" 12
 number of data segment decriptors needed
.SH "DESCRIPTION"
Returns the number of IOCB entries needed to store \fIdsds\fP.
.SH "DESCRIPTION"
Returns the number of IOCB entries needed to store \fIdsds\fP.
.TH "qla24xx_build_scsi_iocbs" 9 "qla24xx_build_scsi_iocbs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_build_scsi_iocbs \-  Build IOCB command utilizing Command Type 7
.SH SYNOPSIS
.B "void" qla24xx_build_scsi_iocbs
.BI "(srb_t *" sp ","
.BI "struct cmd_type_7 *" cmd_pkt ","
.BI "uint16_t " tot_dsds ");"
.SH ARGUMENTS
.IP "sp" 12
 SRB command to process
.IP "cmd_pkt" 12
 Command type 3 IOCB
.IP "tot_dsds" 12
 Total number of segments to transfer
.SH "DESCRIPTION"
IOCB types.
.TH "qla24xx_start_scsi" 9 "qla24xx_start_scsi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_start_scsi \-  Send a SCSI command to the ISP
.SH SYNOPSIS
.B "int" qla24xx_start_scsi
.BI "(srb_t *" sp ");"
.SH ARGUMENTS
.IP "sp" 12
 command to send to the ISP
.SH "DESCRIPTION"
Returns non-zero if a failure occured, else zero.
.TH "qla2x00_config_dma_addressing" 9 "qla2x00_config_dma_addressing" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_config_dma_addressing \-  Configure OS DMA addressing method.
.SH SYNOPSIS
.B "void" qla2x00_config_dma_addressing
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
At exit, the \fIha\fP's flags.enable_64bit_addressing set to indicated
supported addressing method.
.TH "qla2x00_module_init" 9 "qla2x00_module_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_module_init \-  Module initialization.
.SH SYNOPSIS
.B "int __init" qla2x00_module_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "qla2x00_module_exit" 9 "qla2x00_module_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_module_exit \-  Module cleanup.
.SH SYNOPSIS
.B "void __exit" qla2x00_module_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "qla2x00_prep_ms_iocb" 9 "qla2x00_prep_ms_iocb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_prep_ms_iocb \-  Prepare common MS/CT IOCB fields for SNS CT query.
.SH SYNOPSIS
.B "void *" qla2x00_prep_ms_iocb
.BI "(scsi_qla_host_t *" ha ","
.BI "uint32_t " req_size ","
.BI "uint32_t " rsp_size ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "req_size" 12
 request size in bytes
.IP "rsp_size" 12
 response size in bytes
.SH "DESCRIPTION"
Returns a pointer to the \fIha\fP's ms_iocb.
.TH "qla24xx_prep_ms_iocb" 9 "qla24xx_prep_ms_iocb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_prep_ms_iocb \-  Prepare common CT IOCB fields for SNS CT query.
.SH SYNOPSIS
.B "void *" qla24xx_prep_ms_iocb
.BI "(scsi_qla_host_t *" ha ","
.BI "uint32_t " req_size ","
.BI "uint32_t " rsp_size ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "req_size" 12
 request size in bytes
.IP "rsp_size" 12
 response size in bytes
.SH "DESCRIPTION"
Returns a pointer to the \fIha\fP's ms_iocb.
.TH "qla2x00_prep_ct_req" 9 "qla2x00_prep_ct_req" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_prep_ct_req \-  Prepare common CT request fields for SNS query.
.SH SYNOPSIS
.B "struct ct_sns_req *" qla2x00_prep_ct_req
.BI "(struct ct_sns_req *" ct_req ","
.BI "uint16_t " cmd ","
.BI "uint16_t " rsp_size ");"
.SH ARGUMENTS
.IP "ct_req" 12
 CT request buffer
.IP "cmd" 12
 GS command
.IP "rsp_size" 12
 response size in bytes
.SH "DESCRIPTION"
Returns a pointer to the intitialized \fIct_req\fP.
.TH "qla2x00_ga_nxt" 9 "qla2x00_ga_nxt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_ga_nxt \-  SNS scan for fabric devices via GA_NXT command.
.SH SYNOPSIS
.B "int" qla2x00_ga_nxt
.BI "(scsi_qla_host_t *" ha ","
.BI "fc_port_t *" fcport ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "fcport" 12
 fcport entry to updated
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_gid_pt" 9 "qla2x00_gid_pt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_gid_pt \-  SNS scan for fabric devices via GID_PT command.
.SH SYNOPSIS
.B "int" qla2x00_gid_pt
.BI "(scsi_qla_host_t *" ha ","
.BI "sw_info_t *" list ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "list" 12
 switch info entries to populate
.SH "NOTE"
 Non-Nx_Ports are not requested.

Returns 0 on success.
.TH "qla2x00_gpn_id" 9 "qla2x00_gpn_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_gpn_id \-  SNS Get Port Name (GPN_ID) query.
.SH SYNOPSIS
.B "int" qla2x00_gpn_id
.BI "(scsi_qla_host_t *" ha ","
.BI "sw_info_t *" list ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "list" 12
 switch info entries to populate
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_gnn_id" 9 "qla2x00_gnn_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_gnn_id \-  SNS Get Node Name (GNN_ID) query.
.SH SYNOPSIS
.B "int" qla2x00_gnn_id
.BI "(scsi_qla_host_t *" ha ","
.BI "sw_info_t *" list ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "list" 12
 switch info entries to populate
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_rft_id" 9 "qla2x00_rft_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_rft_id \-  SNS Register FC-4 TYPEs (RFT_ID) supported by the HBA.
.SH SYNOPSIS
.B "int" qla2x00_rft_id
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_rff_id" 9 "qla2x00_rff_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_rff_id \-  SNS Register FC-4 Features (RFF_ID) supported by the HBA.
.SH SYNOPSIS
.B "int" qla2x00_rff_id
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_rnn_id" 9 "qla2x00_rnn_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_rnn_id \-  SNS Register Node Name (RNN_ID) of the HBA.
.SH SYNOPSIS
.B "int" qla2x00_rnn_id
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_rsnn_nn" 9 "qla2x00_rsnn_nn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_rsnn_nn \-  SNS Register Symbolic Node Name (RSNN_NN) of the HBA.
.SH SYNOPSIS
.B "int" qla2x00_rsnn_nn
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_prep_sns_cmd" 9 "qla2x00_prep_sns_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_prep_sns_cmd \-  Prepare common SNS command request fields for query.
.SH SYNOPSIS
.B "struct sns_cmd_pkt *" qla2x00_prep_sns_cmd
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t " cmd ","
.BI "uint16_t " scmd_len ","
.BI "uint16_t " data_size ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "cmd" 12
 GS command
.IP "scmd_len" 12
 Subcommand length
.IP "data_size" 12
 response size in bytes
.SH "DESCRIPTION"
Returns a pointer to the \fIha\fP's sns_cmd.
.TH "qla2x00_sns_ga_nxt" 9 "qla2x00_sns_ga_nxt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_sns_ga_nxt \-  SNS scan for fabric devices via GA_NXT command.
.SH SYNOPSIS
.B "int" qla2x00_sns_ga_nxt
.BI "(scsi_qla_host_t *" ha ","
.BI "fc_port_t *" fcport ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "fcport" 12
 fcport entry to updated
.SH "DESCRIPTION"
This command uses the old Exectute SNS Command mailbox routine.

Returns 0 on success.
.TH "qla2x00_sns_gid_pt" 9 "qla2x00_sns_gid_pt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_sns_gid_pt \-  SNS scan for fabric devices via GID_PT command.
.SH SYNOPSIS
.B "int" qla2x00_sns_gid_pt
.BI "(scsi_qla_host_t *" ha ","
.BI "sw_info_t *" list ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "list" 12
 switch info entries to populate
.SH "DESCRIPTION"
This command uses the old Exectute SNS Command mailbox routine.
.SH "NOTE"
 Non-Nx_Ports are not requested.

Returns 0 on success.
.TH "qla2x00_sns_gpn_id" 9 "qla2x00_sns_gpn_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_sns_gpn_id \-  SNS Get Port Name (GPN_ID) query.
.SH SYNOPSIS
.B "int" qla2x00_sns_gpn_id
.BI "(scsi_qla_host_t *" ha ","
.BI "sw_info_t *" list ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "list" 12
 switch info entries to populate
.SH "DESCRIPTION"
This command uses the old Exectute SNS Command mailbox routine.

Returns 0 on success.
.TH "qla2x00_sns_gnn_id" 9 "qla2x00_sns_gnn_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_sns_gnn_id \-  SNS Get Node Name (GNN_ID) query.
.SH SYNOPSIS
.B "int" qla2x00_sns_gnn_id
.BI "(scsi_qla_host_t *" ha ","
.BI "sw_info_t *" list ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "list" 12
 switch info entries to populate
.SH "DESCRIPTION"
This command uses the old Exectute SNS Command mailbox routine.

Returns 0 on success.
.TH "qla2x00_sns_rft_id" 9 "qla2x00_sns_rft_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_sns_rft_id \-  SNS Register FC-4 TYPEs (RFT_ID) supported by the HBA.
.SH SYNOPSIS
.B "int" qla2x00_sns_rft_id
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
This command uses the old Exectute SNS Command mailbox routine.

Returns 0 on success.
.TH "qla2x00_sns_rnn_id" 9 "qla2x00_sns_rnn_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_sns_rnn_id \-  SNS Register Node Name (RNN_ID) of the HBA.
.SH SYNOPSIS
.B "int" qla2x00_sns_rnn_id
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
This command uses the old Exectute SNS Command mailbox routine.

Returns 0 on success.
.SH "DESCRIPTION"
This command uses the old Exectute SNS Command mailbox routine.

Returns 0 on success.
.TH "qla2x00_mgmt_svr_login" 9 "qla2x00_mgmt_svr_login" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_mgmt_svr_login \-  Login to fabric Managment Service.
.SH SYNOPSIS
.B "int" qla2x00_mgmt_svr_login
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_prep_ms_fdmi_iocb" 9 "qla2x00_prep_ms_fdmi_iocb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_prep_ms_fdmi_iocb \-  Prepare common MS IOCB fields for FDMI query.
.SH SYNOPSIS
.B "void *" qla2x00_prep_ms_fdmi_iocb
.BI "(scsi_qla_host_t *" ha ","
.BI "uint32_t " req_size ","
.BI "uint32_t " rsp_size ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "req_size" 12
 request size in bytes
.IP "rsp_size" 12
 response size in bytes
.SH "DESCRIPTION"
Returns a pointer to the \fIha\fP's ms_iocb.
.TH "qla24xx_prep_ms_fdmi_iocb" 9 "qla24xx_prep_ms_fdmi_iocb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_prep_ms_fdmi_iocb \-  Prepare common MS IOCB fields for FDMI query.
.SH SYNOPSIS
.B "void *" qla24xx_prep_ms_fdmi_iocb
.BI "(scsi_qla_host_t *" ha ","
.BI "uint32_t " req_size ","
.BI "uint32_t " rsp_size ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "req_size" 12
 request size in bytes
.IP "rsp_size" 12
 response size in bytes
.SH "DESCRIPTION"
Returns a pointer to the \fIha\fP's ms_iocb.
.TH "qla2x00_prep_ct_fdmi_req" 9 "qla2x00_prep_ct_fdmi_req" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_prep_ct_fdmi_req \-  Prepare common CT request fields for SNS query.
.SH SYNOPSIS
.B "struct ct_sns_req *" qla2x00_prep_ct_fdmi_req
.BI "(struct ct_sns_req *" ct_req ","
.BI "uint16_t " cmd ","
.BI "uint16_t " rsp_size ");"
.SH ARGUMENTS
.IP "ct_req" 12
 CT request buffer
.IP "cmd" 12
 GS command
.IP "rsp_size" 12
 response size in bytes
.SH "DESCRIPTION"
Returns a pointer to the intitialized \fIct_req\fP.
.TH "qla2x00_fdmi_rhba" 9 "qla2x00_fdmi_rhba" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_fdmi_rhba \- 
.SH SYNOPSIS
.B "int" qla2x00_fdmi_rhba
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_fdmi_dhba" 9 "qla2x00_fdmi_dhba" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_fdmi_dhba \- 
.SH SYNOPSIS
.B "int" qla2x00_fdmi_dhba
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_fdmi_rpa" 9 "qla2x00_fdmi_rpa" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_fdmi_rpa \- 
.SH SYNOPSIS
.B "int" qla2x00_fdmi_rpa
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_fdmi_register" 9 "qla2x00_fdmi_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_fdmi_register \- 
.SH SYNOPSIS
.B "int" qla2x00_fdmi_register
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_normalize_dma_addr" 9 "qla2x00_normalize_dma_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_normalize_dma_addr \-  Normalize an DMA address.
.SH SYNOPSIS
.B "int" qla2x00_normalize_dma_addr
.BI "(dma_addr_t *" e_addr ","
.BI "uint32_t *" e_len ","
.BI "dma_addr_t *" ne_addr ","
.BI "uint32_t *" ne_len ");"
.SH ARGUMENTS
.IP "e_addr" 12
 Raw DMA address
.IP "e_len" 12
 Raw DMA length
.IP "ne_addr" 12
 Normalized second DMA address
.IP "ne_len" 12
 Normalized second DMA length
.SH "DESCRIPTION"
If the address does not span a 4GB page boundary, the contents of \fIne_addr\fP
and \fIne_len\fP are undefined.  \fIe_len\fP is updated to reflect a normalization.
.SH "EXAMPLE"

ffffabc0ffffeeee	(e_addr) start of DMA address
0000000020000000	(e_len)  length of DMA transfer
ffffabc11fffeeed	end of DMA transfer

Is the 4GB boundary crossed?

ffffabc0ffffeeee	(e_addr)
ffffabc11fffeeed	(e_addr + e_len - 1)
00000001e0000003	((e_addr ^ (e_addr + e_len - 1))
0000000100000000	((e_addr ^ (e_addr + e_len - 1)) &amp; ~(0xffffffff)
.SH "COMPUTE START OF SECOND DMA SEGMENT"

ffffabc0ffffeeee	(e_addr)
ffffabc1ffffeeee	(0x100000000 + e_addr)
ffffabc100000000	(0x100000000 + e_addr) &amp; ~(0xffffffff)
ffffabc100000000	(ne_addr)
.SH "COMPUTE LENGTH OF SECOND DMA SEGMENT"

00000000ffffeeee	(e_addr &amp; 0xffffffff)
0000000000001112	(0x100000000 - (e_addr &amp; 0xffffffff))
000000001fffeeee	(e_len - (0x100000000 - (e_addr &amp; 0xffffffff))
000000001fffeeee	(ne_len)

Adjust length of first DMA segment

0000000020000000	(e_len)
0000000000001112	(e_len - ne_len)
0000000000001112	(e_len)

Returns non-zero if the specified address was normalized, else zero.
.TH "qla2x00_issue_marker" 9 "qla2x00_issue_marker" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_issue_marker \-  Issue a Marker IOCB if necessary.
.SH SYNOPSIS
.B "int" qla2x00_issue_marker
.BI "(scsi_qla_host_t *" ha ","
.BI "int " ha_locked ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "ha_locked" 12
 is function called with the hardware lock
.SH "DESCRIPTION"
Returns non-zero if a failure occured, else zero.
.TH "qla2100_intr_handler" 9 "qla2100_intr_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2100_intr_handler \-  Process interrupts for the ISP2100 and ISP2200.
.SH SYNOPSIS
.B "irqreturn_t" qla2100_intr_handler
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "dev_id" 12
 SCSI driver HA context
.IP "regs" 12
.SH "DESCRIPTION"
Called by system whenever the host adapter generates an interrupt.

Returns handled flag.
.TH "qla2300_intr_handler" 9 "qla2300_intr_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2300_intr_handler \-  Process interrupts for the ISP23xx and ISP63xx.
.SH SYNOPSIS
.B "irqreturn_t" qla2300_intr_handler
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "dev_id" 12
 SCSI driver HA context
.IP "regs" 12
.SH "DESCRIPTION"
Called by system whenever the host adapter generates an interrupt.

Returns handled flag.
.TH "qla2x00_mbx_completion" 9 "qla2x00_mbx_completion" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_mbx_completion \-  Process mailbox command completions.
.SH SYNOPSIS
.B "void" qla2x00_mbx_completion
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t " mb0 ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "mb0" 12
 Mailbox0 register
.TH "qla2x00_async_event" 9 "qla2x00_async_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_async_event \-  Process aynchronous events.
.SH SYNOPSIS
.B "void" qla2x00_async_event
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t *" mb ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "mb" 12
 Mailbox registers (0 - 3)
.TH "qla2x00_process_completed_request" 9 "qla2x00_process_completed_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_process_completed_request \-  Process a Fast Post response.
.SH SYNOPSIS
.B "void" qla2x00_process_completed_request
.BI "(struct scsi_qla_host *" ha ","
.BI "uint32_t " index ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "index" 12
 SRB index
.TH "qla2x00_process_response_queue" 9 "qla2x00_process_response_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_process_response_queue \-  Process response queue entries.
.SH SYNOPSIS
.B "void" qla2x00_process_response_queue
.BI "(struct scsi_qla_host *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.TH "qla2x00_status_entry" 9 "qla2x00_status_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_status_entry \-  Process a Status IOCB entry.
.SH SYNOPSIS
.B "void" qla2x00_status_entry
.BI "(scsi_qla_host_t *" ha ","
.BI "void *" pkt ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "pkt" 12
 Entry pointer
.TH "qla2x00_status_cont_entry" 9 "qla2x00_status_cont_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_status_cont_entry \-  Process a Status Continuations entry.
.SH SYNOPSIS
.B "void" qla2x00_status_cont_entry
.BI "(scsi_qla_host_t *" ha ","
.BI "sts_cont_entry_t *" pkt ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "pkt" 12
 Entry pointer
.SH "DESCRIPTION"
Extended sense data.
.TH "qla2x00_error_entry" 9 "qla2x00_error_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_error_entry \-  Process an error entry.
.SH SYNOPSIS
.B "void" qla2x00_error_entry
.BI "(scsi_qla_host_t *" ha ","
.BI "sts_entry_t *" pkt ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "pkt" 12
 Entry pointer
.TH "qla2x00_ms_entry" 9 "qla2x00_ms_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_ms_entry \-  Process a Management Server entry.
.SH SYNOPSIS
.B "void" qla2x00_ms_entry
.BI "(scsi_qla_host_t *" ha ","
.BI "ms_iocb_entry_t *" pkt ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "pkt" 12
-- undescribed --
.TH "qla24xx_mbx_completion" 9 "qla24xx_mbx_completion" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_mbx_completion \-  Process mailbox command completions.
.SH SYNOPSIS
.B "void" qla24xx_mbx_completion
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t " mb0 ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "mb0" 12
 Mailbox0 register
.TH "qla24xx_process_response_queue" 9 "qla24xx_process_response_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_process_response_queue \-  Process response queue entries.
.SH SYNOPSIS
.B "void" qla24xx_process_response_queue
.BI "(struct scsi_qla_host *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.TH "qla24xx_intr_handler" 9 "qla24xx_intr_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_intr_handler \-  Process interrupts for the ISP23xx and ISP63xx.
.SH SYNOPSIS
.B "irqreturn_t" qla24xx_intr_handler
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "dev_id" 12
 SCSI driver HA context
.IP "regs" 12
.SH "DESCRIPTION"
Called by system whenever the host adapter generates an interrupt.

Returns handled flag.
.TH "qla24xx_ms_entry" 9 "qla24xx_ms_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_ms_entry \-  Process a Management Server entry.
.SH SYNOPSIS
.B "void" qla24xx_ms_entry
.BI "(scsi_qla_host_t *" ha ","
.BI "struct ct_entry_24xx *" pkt ");"
.SH ARGUMENTS
.IP "ha" 12
 SCSI driver HA context
.IP "pkt" 12
-- undescribed --
.TH "qla2100_pci_config" 9 "qla2100_pci_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2100_pci_config \-  Setup ISP21xx PCI configuration registers.
.SH SYNOPSIS
.B "int" qla2100_pci_config
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2300_pci_config" 9 "qla2300_pci_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2300_pci_config \-  Setup ISP23xx PCI configuration registers.
.SH SYNOPSIS
.B "int" qla2300_pci_config
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla24xx_pci_config" 9 "qla24xx_pci_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_pci_config \-  Setup ISP24xx PCI configuration registers.
.SH SYNOPSIS
.B "int" qla24xx_pci_config
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_isp_firmware" 9 "qla2x00_isp_firmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_isp_firmware \-  Choose firmware image.
.SH SYNOPSIS
.B "int" qla2x00_isp_firmware
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_reset_chip" 9 "qla2x00_reset_chip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_reset_chip \-  Reset ISP chip.
.SH SYNOPSIS
.B "void" qla2x00_reset_chip
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla24xx_reset_risc" 9 "qla24xx_reset_risc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_reset_risc \-  Perform full reset of ISP24xx RISC.
.SH SYNOPSIS
.B "void" qla24xx_reset_risc
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla24xx_reset_chip" 9 "qla24xx_reset_chip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_reset_chip \-  Reset ISP24xx chip.
.SH SYNOPSIS
.B "void" qla24xx_reset_chip
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_chip_diag" 9 "qla2x00_chip_diag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_chip_diag \-  Test chip for proper operation.
.SH SYNOPSIS
.B "int" qla2x00_chip_diag
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla24xx_chip_diag" 9 "qla24xx_chip_diag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla24xx_chip_diag \-  Test ISP24xx for proper operation.
.SH SYNOPSIS
.B "int" qla24xx_chip_diag
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_resize_request_q" 9 "qla2x00_resize_request_q" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_resize_request_q \-  Resize request queue given available ISP memory.
.SH SYNOPSIS
.B "void" qla2x00_resize_request_q
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_setup_chip" 9 "qla2x00_setup_chip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_setup_chip \-  Load and start RISC firmware.
.SH SYNOPSIS
.B "int" qla2x00_setup_chip
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_init_response_q_entries" 9 "qla2x00_init_response_q_entries" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_init_response_q_entries \-  Initializes response queue entries.
.SH SYNOPSIS
.B "void" qla2x00_init_response_q_entries
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Beginning of request ring has initialization control block already built
by nvram config routine.

Returns 0 on success.
.TH "qla2x00_update_fw_options" 9 "qla2x00_update_fw_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_update_fw_options \-  Read and process firmware options.
.SH SYNOPSIS
.B "void" qla2x00_update_fw_options
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_init_rings" 9 "qla2x00_init_rings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_init_rings \-  Initializes firmware.
.SH SYNOPSIS
.B "int" qla2x00_init_rings
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Beginning of request ring has initialization control block already built
by nvram config routine.

Returns 0 on success.
.TH "qla2x00_fw_ready" 9 "qla2x00_fw_ready" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_fw_ready \-  Waits for firmware ready.
.SH SYNOPSIS
.B "int" qla2x00_fw_ready
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.SH "DESCRIPTION"
Returns 0 on success.
.TH "qla2x00_alloc_fcport" 9 "qla2x00_alloc_fcport" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_alloc_fcport \-  Allocate a generic fcport.
.SH SYNOPSIS
.B "fc_port_t *" qla2x00_alloc_fcport
.BI "(scsi_qla_host_t *" ha ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "flags" 12
 allocation flags
.SH "DESCRIPTION"
Returns a pointer to the allocated fcport, or NULL, if none available.
.TH "qla2x00_lock_nvram_access" 9 "qla2x00_lock_nvram_access" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_lock_nvram_access \- 
.SH SYNOPSIS
.B "void" qla2x00_lock_nvram_access
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.TH "qla2x00_unlock_nvram_access" 9 "qla2x00_unlock_nvram_access" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_unlock_nvram_access \- 
.SH SYNOPSIS
.B "void" qla2x00_unlock_nvram_access
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.TH "qla2x00_get_nvram_word" 9 "qla2x00_get_nvram_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_get_nvram_word \-  Calculates word position in NVRAM and calls the
.SH SYNOPSIS
.B "uint16_t" qla2x00_get_nvram_word
.BI "(scsi_qla_host_t *" ha ","
.BI "uint32_t " addr ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "addr" 12
 Address in NVRAM to read
.SH "DESCRIPTION"
Returns the word read from nvram \fIaddr\fP.
.SH "DESCRIPTION"
Returns the word read from nvram \fIaddr\fP.
.TH "qla2x00_write_nvram_word" 9 "qla2x00_write_nvram_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_write_nvram_word \-  Write NVRAM data.
.SH SYNOPSIS
.B "void" qla2x00_write_nvram_word
.BI "(scsi_qla_host_t *" ha ","
.BI "uint32_t " addr ","
.BI "uint16_t " data ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "addr" 12
 Address in NVRAM to write
.IP "data" 12
 word to program
.TH "qla2x00_nvram_request" 9 "qla2x00_nvram_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_nvram_request \-  Sends read command to NVRAM and gets data from
.SH SYNOPSIS
.B "uint16_t" qla2x00_nvram_request
.BI "(scsi_qla_host_t *" ha ","
.BI "uint32_t " nv_cmd ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "nv_cmd" 12
 NVRAM command
.SH "DESCRIPTION"
NVRAM.
.SH "BIT DEFINITIONS FOR NVRAM COMMAND"

Bit 26     = start bit
Bit 25, 24 = opcode
Bit 23-16  = address
Bit 15-0   = write data

Returns the word read from nvram \fIaddr\fP.
.TH "qla2x00_nv_deselect" 9 "qla2x00_nv_deselect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_nv_deselect \-  Clean NVRAM operations.
.SH SYNOPSIS
.B "void" qla2x00_nv_deselect
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.TH "qla2x00_nv_write" 9 "qla2x00_nv_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_nv_write \-  Prepare for NVRAM read/write operation.
.SH SYNOPSIS
.B "void" qla2x00_nv_write
.BI "(scsi_qla_host_t *" ha ","
.BI "uint16_t " data ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.IP "data" 12
 Serial interface selector
.TH "qla2x00_clear_nvram_protection" 9 "qla2x00_clear_nvram_protection" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qla2x00_clear_nvram_protection \- 
.SH SYNOPSIS
.B "int" qla2x00_clear_nvram_protection
.BI "(scsi_qla_host_t *" ha ");"
.SH ARGUMENTS
.IP "ha" 12
 HA context
.TH "internal_setup" 9 "internal_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
internal_setup \- 	handle lilo command string override
.SH SYNOPSIS
.B "void __init" internal_setup
.BI "(int " board ","
.BI "char *" str ","
.BI "int *" ints ");"
.SH ARGUMENTS
.IP "board" 12
	BOARD_* identifier for the board
.IP "str" 12
 unused
.IP "ints" 12
 numeric parameters
.SH "DESCRIPTION"
Do LILO command line initialization of the overrides array. Display
errors when needed
.SH "LOCKS"
 none
.TH "do_NCR5380_setup" 9 "do_NCR5380_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_NCR5380_setup \- 	set up entry point
.SH SYNOPSIS
.B "int __init" do_NCR5380_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
 unused
.SH "DESCRIPTION"
Setup function invoked at boot to parse the ncr5380= command
line.
.TH "do_NCR53C400_setup" 9 "do_NCR53C400_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_NCR53C400_setup \- 	set up entry point
.SH SYNOPSIS
.B "int __init" do_NCR53C400_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
 unused
.SH "DESCRIPTION"
Setup function invoked at boot to parse the ncr53c400= command
line.
.TH "do_NCR53C400A_setup" 9 "do_NCR53C400A_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_NCR53C400A_setup \- 	set up entry point
.SH SYNOPSIS
.B "int __init" do_NCR53C400A_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
 unused
.SH "DESCRIPTION"
Setup function invoked at boot to parse the ncr53c400a= command
line.
.TH "do_DTC3181E_setup" 9 "do_DTC3181E_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_DTC3181E_setup \- 	set up entry point
.SH SYNOPSIS
.B "int __init" do_DTC3181E_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
 unused
.SH "DESCRIPTION"
Setup function invoked at boot to parse the dtc3181e= command
line.
.TH "generic_NCR5380_detect" 9 "generic_NCR5380_detect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_NCR5380_detect \- 	look for NCR5380 controllers
.SH SYNOPSIS
.B "int __init" generic_NCR5380_detect
.BI "(Scsi_Host_Template *" tpnt ");"
.SH ARGUMENTS
.IP "tpnt" 12
 the scsi template
.SH "DESCRIPTION"
Scan for the present of NCR5380, NCR53C400, NCR53C400A, DTC3181E
and DTC436(ISAPnP) controllers. If overrides have been set we use
them.

The caller supplied NCR5380_init function is invoked from here, before
the interrupt line is taken.
.SH "LOCKS"
 none
.TH "generic_NCR5380_info" 9 "generic_NCR5380_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_NCR5380_info \- 	reporting string
.SH SYNOPSIS
.B "const char *" generic_NCR5380_info
.BI "(struct Scsi_Host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 NCR5380 to report on
.SH "DESCRIPTION"
Report driver information for the NCR5380
.TH "generic_NCR5380_release_resources" 9 "generic_NCR5380_release_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_NCR5380_release_resources \- 	free resources
.SH SYNOPSIS
.B "int" generic_NCR5380_release_resources
.BI "(struct Scsi_Host *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
 host adapter to clean up 
.SH "DESCRIPTION"
Free the generic interface resources from this adapter.
.SH "LOCKS"
 none
.TH "generic_NCR5380_biosparam" 9 "generic_NCR5380_biosparam" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_NCR5380_biosparam \- 
.SH SYNOPSIS
.B "int" generic_NCR5380_biosparam
.BI "(struct scsi_device *" sdev ","
.BI "struct block_device *" bdev ","
.BI "sector_t " capacity ","
.BI "int *" ip ");"
.SH ARGUMENTS
.IP "sdev" 12
-- undescribed --
.IP "bdev" 12
-- undescribed --
.IP "capacity" 12
-- undescribed --
.IP "ip" 12
 sizes to fill in
.SH "DESCRIPTION"
Generates a BIOS / DOS compatible H-C-S mapping for the specified 
device / size.

XXX Most SCSI boards use this mapping, I could be incorrect.  Someone
using hard disks on a trantor should verify that this mapping
corresponds to that used by the BIOS / ASPI driver by running the linux
fdisk program and matching the H_C_S coordinates to what DOS uses.
.SH "LOCKS"
 none
.TH "NCR5380_pread" 9 "NCR5380_pread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_pread \- 	pseudo DMA read
.SH SYNOPSIS
.B "int" NCR5380_pread
.BI "(struct Scsi_Host *" instance ","
.BI "unsigned char *" dst ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter to read from
.IP "dst" 12
 buffer to read into
.IP "len" 12
 buffer length
.SH "DESCRIPTION"
Perform a psuedo DMA mode read from an NCR53C400 or equivalent
controller
.TH "NCR5380_pwrite" 9 "NCR5380_pwrite" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_pwrite \- 	pseudo DMA write
.SH SYNOPSIS
.B "int" NCR5380_pwrite
.BI "(struct Scsi_Host *" instance ","
.BI "unsigned char *" src ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter to read from
.IP "src" 12
-- undescribed --
.IP "len" 12
 buffer length
.SH "DESCRIPTION"
Perform a psuedo DMA mode read from an NCR53C400 or equivalent
controller
.TH "sprint_Scsi_Cmnd" 9 "sprint_Scsi_Cmnd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sprint_Scsi_Cmnd \- 	print a scsi command
.SH SYNOPSIS
.B "int" sprint_Scsi_Cmnd
.BI "(char *" buffer ","
.BI "int " len ","
.BI "Scsi_Cmnd *" cmd ");"
.SH ARGUMENTS
.IP "buffer" 12
 buffr to print into
.IP "len" 12
 buffer length
.IP "cmd" 12
 SCSI command block
.SH "DESCRIPTION"
Print out the target and command data in hex
.TH "generic_NCR5380_proc_info" 9 "generic_NCR5380_proc_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_NCR5380_proc_info \- 	/proc for NCR5380 driver
.SH SYNOPSIS
.B "int" generic_NCR5380_proc_info
.BI "(struct Scsi_Host *" scsi_ptr ","
.BI "char *" buffer ","
.BI "char **" start ","
.BI "off_t " offset ","
.BI "int " length ","
.BI "int " inout ");"
.SH ARGUMENTS
.IP "scsi_ptr" 12
-- undescribed --
.IP "buffer" 12
 buffer to print into
.IP "start" 12
 start position
.IP "offset" 12
 offset into buffer
.IP "length" 12
-- undescribed --
.IP "inout" 12
 read/write
.SH "DESCRIPTION"
Provide the procfs information for the 5380 controller. We fill
this with useful debugging information including the commands
being executed, disconnected command queue and the statistical
data
.SH "LOCKS"
 global cli/lock for queue walk
.TH "scsi_execute" 9 "scsi_execute" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_execute \-  insert request and wait for the result
.SH SYNOPSIS
.B "int" scsi_execute
.BI "(struct scsi_device *" sdev ","
.BI "const unsigned char *" cmd ","
.BI "int " data_direction ","
.BI "void *" buffer ","
.BI "unsigned " bufflen ","
.BI "unsigned char *" sense ","
.BI "int " timeout ","
.BI "int " retries ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi device
.IP "cmd" 12
	scsi command
.IP "data_direction" 12
 data direction
.IP "buffer" 12
	data buffer
.IP "bufflen" 12
	len of buffer
.IP "sense" 12
	optional sense buffer
.IP "timeout" 12
	request timeout in seconds
.IP "retries" 12
	number of times to retry request
.IP "flags" 12
	or into request flags;
.SH "DESCRIPTION"
returns the req-&gt;errors value which is the the scsi_cmnd result
field.
.TH "scsi_mode_sense" 9 "scsi_mode_sense" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_mode_sense \-  issue a mode sense, falling back from 10 to 
.SH SYNOPSIS
.B "int" scsi_mode_sense
.BI "(struct scsi_device *" sdev ","
.BI "int " dbd ","
.BI "int " modepage ","
.BI "unsigned char *" buffer ","
.BI "int " len ","
.BI "int " timeout ","
.BI "int " retries ","
.BI "struct scsi_mode_data *" data ","
.BI "struct scsi_sense_hdr *" sshdr ");"
.SH ARGUMENTS
.IP "sdev" 12
	SCSI device to be queried
.IP "dbd" 12
	set if mode sense will allow block descriptors to be returned
.IP "modepage" 12
 mode page being requested
.IP "buffer" 12
 request buffer (may not be smaller than eight bytes)
.IP "len" 12
	length of request buffer.
.IP "timeout" 12
 command timeout
.IP "retries" 12
 number of retries before failing
.IP "data" 12
 returns a structure abstracting the mode header data
.IP "sshdr" 12
-- undescribed --
.SH "DESCRIPTION"
Returns zero if unsuccessful, or the header offset (either 4
or 8 depending on whether a six or ten byte command was
issued) if successful.
.SH "DESCRIPTION"
Returns zero if unsuccessful, or the header offset (either 4
or 8 depending on whether a six or ten byte command was
issued) if successful.
.TH "scsi_device_set_state" 9 "scsi_device_set_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_set_state \-  Take the given device through the device
.SH SYNOPSIS
.B "int" scsi_device_set_state
.BI "(struct scsi_device *" sdev ","
.BI "enum scsi_device_state " state ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi device to change the state of.
.IP "state" 12
	state to change to.
.SH "DESCRIPTION"
Returns zero if unsuccessful or an error if the requested 
transition is illegal.
.SH "DESCRIPTION"
Returns zero if unsuccessful or an error if the requested 
transition is illegal.
.TH "scsi_device_quiesce" 9 "scsi_device_quiesce" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_quiesce \-  Block user issued commands.
.SH SYNOPSIS
.B "int" scsi_device_quiesce
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi device to quiesce.
.SH "DESCRIPTION"
This works by trying to transition to the SDEV_QUIESCE state
(which must be a legal transition).  When the device is in this
state, only special requests will be accepted, all others will
be deferred.  Since special requests may also be requeued requests,
a successful return doesn't guarantee the device will be 
totally quiescent.

Must be called with user context, may sleep.

Returns zero if unsuccessful or an error if not.
.TH "scsi_device_resume" 9 "scsi_device_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_resume \-  Restart user issued commands to a quiesced device.
.SH SYNOPSIS
.B "void" scsi_device_resume
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	scsi device to resume.
.SH "DESCRIPTION"
Moves the device from quiesced back to running and restarts the
queues.

Must be called with user context, may sleep.
.TH "scsi_internal_device_block" 9 "scsi_internal_device_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_internal_device_block \-  internal function to put a device
.SH SYNOPSIS
.B "int" scsi_internal_device_block
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	device to block
.SH "DESCRIPTION"
Block request made by scsi lld's to temporarily stop all
scsi commands on the specified device.  Called from interrupt
or normal process context.

Returns zero if successful or error if not
.SH "DESCRIPTION"
Block request made by scsi lld's to temporarily stop all
scsi commands on the specified device.  Called from interrupt
or normal process context.

Returns zero if successful or error if not
.SH "NOTES"
       
This routine transitions the device to the SDEV_BLOCK state
(which must be a legal transition).  When the device is in this
state, all commands are deferred until the scsi lld reenables
the device with scsi_device_unblock or device_block_tmo fires.
This routine assumes the host_lock is held on entry.
.TH "scsi_internal_device_unblock" 9 "scsi_internal_device_unblock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_internal_device_unblock \-  resume a device after a block request
.SH SYNOPSIS
.B "int" scsi_internal_device_unblock
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	device to resume
.SH "DESCRIPTION"
Called by scsi lld's or the midlayer to restart the device queue
for the previously suspended scsi device.  Called from interrupt or
normal process context.

Returns zero if successful or error if not.
.SH "NOTES"
       
This routine transitions the device to the SDEV_RUNNING state
(which must be a legal transition) allowing the midlayer to
goose the queue for this device.  This routine assumes the 
host_lock is held upon entry.
.TH "spi_schedule_dv_device" 9 "spi_schedule_dv_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spi_schedule_dv_device \-  schedule domain validation to occur on the device
.SH SYNOPSIS
.B "void" spi_schedule_dv_device
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	The device to validate
.SH "DESCRIPTION"
Identical to \fBspi_dv_device\fP above, except that the DV will be
scheduled to occur in a workqueue later.  All memory allocations
are atomic, so may be called from any context including those holding
SCSI locks.
.TH "spi_display_xfer_agreement" 9 "spi_display_xfer_agreement" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spi_display_xfer_agreement \-  Print the current target transfer agreement
.SH SYNOPSIS
.B "void" spi_display_xfer_agreement
.BI "(struct scsi_target *" starget ");"
.SH ARGUMENTS
.IP "starget" 12
 The target for which to display the agreement
.SH "DESCRIPTION"
Each SPI port is required to maintain a transfer agreement for each
other port on the bus.  This function prints a one-line summary of
the current agreement; more detailed information is available in sysfs.
.TH "NCR5380_poll_politely" 9 "NCR5380_poll_politely" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_poll_politely \- 	wait for NCR5380 status bits
.SH SYNOPSIS
.B "int" NCR5380_poll_politely
.BI "(struct Scsi_Host *" instance ","
.BI "int " reg ","
.BI "int " bit ","
.BI "int " val ","
.BI "int " t ");"
.SH ARGUMENTS
.IP "instance" 12
 controller to poll
.IP "reg" 12
 5380 register to poll
.IP "bit" 12
 Bitmask to check
.IP "val" 12
 Value required to exit
.IP "t" 12
-- undescribed --
.SH "DESCRIPTION"
Polls the NCR5380 in a reasonably efficient manner waiting for
an event to occur, after a short quick poll we begin giving the
CPU back in non IRQ contexts

Returns the value of the register or a negative error code.
.TH "NCR5380_print" 9 "NCR5380_print" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_print \- 	print scsi bus signals
.SH SYNOPSIS
.B "void" NCR5380_print
.BI "(struct Scsi_Host *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
	adapter state to dump
.SH "DESCRIPTION"
Print the SCSI bus signals for debugging purposes
.SH "LOCKS"
 caller holds hostdata lock (not essential)
.TH "probe_intr" 9 "probe_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_intr \- 	helper for IRQ autoprobe
.SH SYNOPSIS
.B "irqreturn_t __init" probe_intr
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt number
.IP "dev_id" 12
 unused
.IP "regs" 12
 unused
.SH "DESCRIPTION"
Set a flag to indicate the IRQ in question was received. This is
used by the IRQ probe code.
.TH "NCR5380_probe_irq" 9 "NCR5380_probe_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_probe_irq \- 	find the IRQ of an NCR5380
.SH SYNOPSIS
.B "int __init" NCR5380_probe_irq
.BI "(struct Scsi_Host *" instance ","
.BI "int " possible ");"
.SH ARGUMENTS
.IP "instance" 12
 NCR5380 controller
.IP "possible" 12
 bitmask of ISA IRQ lines
.SH "DESCRIPTION"
Autoprobe for the IRQ line used by the NCR5380 by triggering an IRQ
and then looking to see what interrupt actually turned up.
.SH "LOCKS"
 none, irqs must be enabled on entry
.TH "NCR5380_print_options" 9 "NCR5380_print_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_print_options \- 	show options
.SH SYNOPSIS
.B "void __init" NCR5380_print_options
.BI "(struct Scsi_Host *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
 unused for now
.SH "DESCRIPTION"
Called by probe code indicating the NCR5380 driver options that 
were selected. At some point this will switch to runtime options
read from the adapter in question
.SH "LOCKS"
 none
.TH "NCR5380_print_status" 9 "NCR5380_print_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_print_status \- 	dump controller info
.SH SYNOPSIS
.B "void" NCR5380_print_status
.BI "(struct Scsi_Host *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
 controller to dump
.SH "DESCRIPTION"
Print commands in the various queues, called from NCR5380_abort 
and NCR5380_debug to aid debugging.
.SH "LOCKS"
 called functions disable irqs
.TH "NCR5380_init" 9 "NCR5380_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_init \- 	initialise an NCR5380
.SH SYNOPSIS
.B "int __devinit" NCR5380_init
.BI "(struct Scsi_Host *" instance ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter to configure
.IP "flags" 12
 control flags
.SH "DESCRIPTION"
Initializes *instance and corresponding 5380 chip,
with flags OR'd into the initial flags value.
.SH "NOTES "
 I assume that the host, hostno, and id bits have been
set correctly.  I don't care about the irq and other fields. 

Returns 0 for success
.SH "LOCKS"
 interrupts must be enabled when we are called 
.TH "NCR5380_exit" 9 "NCR5380_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_exit \- 	remove an NCR5380
.SH SYNOPSIS
.B "void __devexit" NCR5380_exit
.BI "(struct Scsi_Host *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter to remove
.TH "NCR5380_queue_command" 9 "NCR5380_queue_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_queue_command \- 	queue a command
.SH SYNOPSIS
.B "int" NCR5380_queue_command
.BI "(Scsi_Cmnd *" cmd ","
.BI "void (*" done ") (Scsi_Cmnd *));"
.SH ARGUMENTS
.IP "cmd" 12
 SCSI command
.IP "done" 12
 completion handler
.SH "DESCRIPTION"
cmd is added to the per instance issue_queue, with minor 
twiddling done to the host specific fields of cmd.  If the 
main coroutine is not running, it is restarted.
.SH "LOCKS"
 host lock taken by caller
.TH "NCR5380_main" 9 "NCR5380_main" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_main \- 	NCR state machines
.SH SYNOPSIS
.B "void" NCR5380_main
.BI "(void *" p ");"
.SH ARGUMENTS
.IP "p" 12
-- undescribed --
.SH "DESCRIPTION"

NCR5380_main is a coroutine that runs as long as more work can 
be done on the NCR5380 host adapters in a system.  Both 
\fBNCR5380_queue_command\fP and \fBNCR5380_intr\fP will try to start it 
in case it is not running.
.SH "LOCKS"
 called as its own thread with no locks held. Takes the
host lock and called routines may take the isa dma lock.
.TH "NCR5380_intr" 9 "NCR5380_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_intr \- 	generic NCR5380 irq handler
.SH SYNOPSIS
.B "irqreturn_t" NCR5380_intr
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt number
.IP "dev_id" 12
 device info
.IP "regs" 12
 registers (unused)
.SH "DESCRIPTION"
Handle interrupts, reestablishing I_T_L or I_T_L_Q nexuses
from the disconnected queue, and restarting \fBNCR5380_main\fP 
as required.
.SH "LOCKS"
 takes the needed instance locks
.TH "collect_stats" 9 "collect_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
collect_stats \- 	collect stats on a scsi command
.SH SYNOPSIS
.B "void" collect_stats
.BI "(struct NCR5380_hostdata *" hostdata ","
.BI "Scsi_Cmnd *" cmd ");"
.SH ARGUMENTS
.IP "hostdata" 12
 adapter 
.IP "cmd" 12
 command being issued
.SH "DESCRIPTION"
Update the statistical data by parsing the command in question
.TH "do_reset" 9 "do_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_reset \- 	issue a reset command
.SH SYNOPSIS
.B "void" do_reset
.BI "(struct Scsi_Host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 adapter to reset
.SH "DESCRIPTION"
Issue a reset sequence to the NCR5380 and try and get the bus
back into sane shape.
.SH "LOCKS"
 caller holds queue lock
.TH "ata_tf_load_pio" 9 "ata_tf_load_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_load_pio \-  send taskfile registers to host controller
.SH SYNOPSIS
.B "void" ata_tf_load_pio
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to which output is sent
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Outputs ATA taskfile to standard ATA host controller.
.SH "LOCKING"
Inherited from caller.
.TH "ata_tf_load_mmio" 9 "ata_tf_load_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_load_mmio \-  send taskfile registers to host controller
.SH SYNOPSIS
.B "void" ata_tf_load_mmio
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to which output is sent
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Outputs ATA taskfile to standard ATA host controller using MMIO.
.SH "LOCKING"
Inherited from caller.
.TH "ata_tf_load" 9 "ata_tf_load" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_load \-  send taskfile registers to host controller
.SH SYNOPSIS
.B "void" ata_tf_load
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to which output is sent
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Outputs ATA taskfile to standard ATA host controller using MMIO
or PIO as indicated by the ATA_FLAG_MMIO flag.
Writes the control, feature, nsect, lbal, lbam, and lbah registers.
Optionally (ATA_TFLAG_LBA48) writes hob_feature, hob_nsect,
hob_lbal, hob_lbam, and hob_lbah.

This function waits for idle (!BUSY and !DRQ) after writing
registers.  If the control register has a new value, this
function also waits for idle after writing control and before
writing the remaining registers.

May be used as the \fBtf_load\fP entry in ata_port_operations.
.SH "LOCKING"
Inherited from caller.
.TH "ata_exec_command_pio" 9 "ata_exec_command_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_exec_command_pio \-  issue ATA command to host controller
.SH SYNOPSIS
.B "void" ata_exec_command_pio
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 port to which command is being issued
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Issues PIO write to ATA command register, with proper
synchronization with interrupt handler / other threads.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_exec_command_mmio" 9 "ata_exec_command_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_exec_command_mmio \-  issue ATA command to host controller
.SH SYNOPSIS
.B "void" ata_exec_command_mmio
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 port to which command is being issued
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Issues MMIO write to ATA command register, with proper
synchronization with interrupt handler / other threads.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_exec_command" 9 "ata_exec_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_exec_command \-  issue ATA command to host controller
.SH SYNOPSIS
.B "void" ata_exec_command
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 port to which command is being issued
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Issues PIO/MMIO write to ATA command register, with proper
synchronization with interrupt handler / other threads.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_exec" 9 "ata_exec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_exec \-  issue ATA command to host controller
.SH SYNOPSIS
.B "void" ata_exec
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 port to which command is being issued
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Issues PIO/MMIO write to ATA command register, with proper
synchronization with interrupt handler / other threads.
.SH "LOCKING"
Obtains host_set lock.
.TH "ata_tf_to_host" 9 "ata_tf_to_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_to_host \-  issue ATA taskfile to host controller
.SH SYNOPSIS
.B "void" ata_tf_to_host
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 port to which command is being issued
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Issues ATA taskfile register set to ATA host controller,
with proper synchronization with interrupt handler and
other threads.
.SH "LOCKING"
Obtains host_set lock.
.TH "ata_tf_to_host_nolock" 9 "ata_tf_to_host_nolock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_to_host_nolock \-  issue ATA taskfile to host controller
.SH SYNOPSIS
.B "void" ata_tf_to_host_nolock
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 port to which command is being issued
.IP "tf" 12
 ATA taskfile register set
.SH "DESCRIPTION"
Issues ATA taskfile register set to ATA host controller,
with proper synchronization with interrupt handler and
other threads.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_tf_read_pio" 9 "ata_tf_read_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_read_pio \-  input device's ATA taskfile shadow registers
.SH SYNOPSIS
.B "void" ata_tf_read_pio
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 Port from which input is read
.IP "tf" 12
 ATA taskfile register set for storing input
.SH "DESCRIPTION"
Reads ATA taskfile registers for currently-selected device
into \fItf\fP.
.SH "LOCKING"
Inherited from caller.
.TH "ata_tf_read_mmio" 9 "ata_tf_read_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_read_mmio \-  input device's ATA taskfile shadow registers
.SH SYNOPSIS
.B "void" ata_tf_read_mmio
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 Port from which input is read
.IP "tf" 12
 ATA taskfile register set for storing input
.SH "DESCRIPTION"
Reads ATA taskfile registers for currently-selected device
into \fItf\fP via MMIO.
.SH "LOCKING"
Inherited from caller.
.TH "ata_tf_read" 9 "ata_tf_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_read \-  input device's ATA taskfile shadow registers
.SH SYNOPSIS
.B "void" ata_tf_read
.BI "(struct ata_port *" ap ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "ap" 12
 Port from which input is read
.IP "tf" 12
 ATA taskfile register set for storing input
.SH "DESCRIPTION"
Reads ATA taskfile registers for currently-selected device
into \fItf\fP.

Reads nsect, lbal, lbam, lbah, and device.  If ATA_TFLAG_LBA48
is set, also reads the hob registers.

May be used as the \fBtf_read\fP entry in ata_port_operations.
.SH "LOCKING"
Inherited from caller.
.TH "ata_check_status_pio" 9 "ata_check_status_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_check_status_pio \-  Read device status reg \\\amp; clear interrupt
.SH SYNOPSIS
.B "u8" ata_check_status_pio
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 port where the device is
.SH "DESCRIPTION"
Reads ATA taskfile status register for currently-selected device
and return its value. This also clears pending interrupts
from this device
.SH "LOCKING"
Inherited from caller.
.TH "ata_check_status_mmio" 9 "ata_check_status_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_check_status_mmio \-  Read device status reg \\\amp; clear interrupt
.SH SYNOPSIS
.B "u8" ata_check_status_mmio
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 port where the device is
.SH "DESCRIPTION"
Reads ATA taskfile status register for currently-selected device
via MMIO and return its value. This also clears pending interrupts
from this device
.SH "LOCKING"
Inherited from caller.
.TH "ata_check_status" 9 "ata_check_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_check_status \-  Read device status reg \\\amp; clear interrupt
.SH SYNOPSIS
.B "u8" ata_check_status
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 port where the device is
.SH "DESCRIPTION"
Reads ATA taskfile status register for currently-selected device
and return its value. This also clears pending interrupts
from this device

May be used as the \fBcheck_status\fP entry in ata_port_operations.
.SH "LOCKING"
Inherited from caller.
.TH "ata_altstatus" 9 "ata_altstatus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_altstatus \-  Read device alternate status reg
.SH SYNOPSIS
.B "u8" ata_altstatus
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 port where the device is
.SH "DESCRIPTION"
Reads ATA taskfile alternate status register for
currently-selected device and return its value.
.SH "NOTE"
 may NOT be used as the \fBcheck_altstatus\fP entry in
ata_port_operations.
.SH "LOCKING"
Inherited from caller.
.TH "ata_chk_err" 9 "ata_chk_err" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_chk_err \-  Read device error reg
.SH SYNOPSIS
.B "u8" ata_chk_err
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 port where the device is
.SH "DESCRIPTION"
Reads ATA taskfile error register for
currently-selected device and return its value.
.SH "NOTE"
 may NOT be used as the \fBcheck_err\fP entry in
ata_port_operations.
.SH "LOCKING"
Inherited from caller.
.TH "ata_tf_to_fis" 9 "ata_tf_to_fis" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_to_fis \-  Convert ATA taskfile to SATA FIS structure
.SH SYNOPSIS
.B "void" ata_tf_to_fis
.BI "(struct ata_taskfile *" tf ","
.BI "u8 *" fis ","
.BI "u8 " pmp ");"
.SH ARGUMENTS
.IP "tf" 12
 Taskfile to convert
.IP "fis" 12
 Buffer into which data will output
.IP "pmp" 12
 Port multiplier port
.SH "DESCRIPTION"
Converts a standard ATA taskfile to a Serial ATA
FIS structure (Register - Host to Device).
.SH "LOCKING"
Inherited from caller.
.TH "ata_tf_from_fis" 9 "ata_tf_from_fis" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_tf_from_fis \-  Convert SATA FIS to ATA taskfile
.SH SYNOPSIS
.B "void" ata_tf_from_fis
.BI "(u8 *" fis ","
.BI "struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "fis" 12
 Buffer from which data will be input
.IP "tf" 12
 Taskfile to output
.SH "DESCRIPTION"
Converts a standard ATA taskfile to a Serial ATA
FIS structure (Register - Host to Device).
.SH "LOCKING"
Inherited from caller.
.TH "ata_prot_to_cmd" 9 "ata_prot_to_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_prot_to_cmd \-  determine which read/write opcodes to use
.SH SYNOPSIS
.B "int" ata_prot_to_cmd
.BI "(int " protocol ","
.BI "int " lba48 ");"
.SH ARGUMENTS
.IP "protocol" 12
 ATA_PROT_xxx taskfile protocol
.IP "lba48" 12
 true is lba48 is present
.SH "DESCRIPTION"
Given necessary input, determine which read/write commands
to use to transfer data.
.SH "LOCKING"
None.
.TH "ata_dev_set_protocol" 9 "ata_dev_set_protocol" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_set_protocol \-  set taskfile protocol and r/w commands
.SH SYNOPSIS
.B "void" ata_dev_set_protocol
.BI "(struct ata_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to examine and configure
.SH "DESCRIPTION"
Examine the device configuration, after we have
read the identify-device page and configured the
data transfer mode.  Set internal state related to
the ATA taskfile protocol (pio, pio mult, dma, etc.)
and calculate the proper read/write commands to use.
.SH "LOCKING"
caller.
.TH "ata_mode_string" 9 "ata_mode_string" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_mode_string \-  convert UDMA bit offset to string
.SH SYNOPSIS
.B "const char *" ata_mode_string
.BI "(unsigned int " mask ");"
.SH ARGUMENTS
.IP "mask" 12
 mask of bits supported; only highest bit counts.
.SH "DESCRIPTION"
Determine string which represents the highest speed
(highest bit in \fIudma_mask\fP).
.SH "LOCKING"
None.
.SH "RETURNS"
Constant C string representing highest speed listed in
\fIudma_mask\fP, or the constant C string "&lt;n/a&gt;".
.TH "ata_pio_devchk" 9 "ata_pio_devchk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pio_devchk \-  PATA device presence detection
.SH SYNOPSIS
.B "unsigned int" ata_pio_devchk
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA channel to examine
.IP "device" 12
 Device to examine (starting at zero)
.SH "DESCRIPTION"
This technique was originally described in
Hale Landis's ATADRVR (www.ata-atapi.com), and
later found its way into the ATA/ATAPI spec.

Write a pattern to the ATA shadow registers,
and if a device is present, it will respond by
correctly storing and echoing back the
ATA shadow register contents.
.SH "LOCKING"
caller.
.TH "ata_mmio_devchk" 9 "ata_mmio_devchk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_mmio_devchk \-  PATA device presence detection
.SH SYNOPSIS
.B "unsigned int" ata_mmio_devchk
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA channel to examine
.IP "device" 12
 Device to examine (starting at zero)
.SH "DESCRIPTION"
This technique was originally described in
Hale Landis's ATADRVR (www.ata-atapi.com), and
later found its way into the ATA/ATAPI spec.

Write a pattern to the ATA shadow registers,
and if a device is present, it will respond by
correctly storing and echoing back the
ATA shadow register contents.
.SH "LOCKING"
caller.
.TH "ata_devchk" 9 "ata_devchk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_devchk \-  PATA device presence detection
.SH SYNOPSIS
.B "unsigned int" ata_devchk
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA channel to examine
.IP "device" 12
 Device to examine (starting at zero)
.SH "DESCRIPTION"
Dispatch ATA device presence detection, depending
on whether we are using PIO or MMIO to talk to the
ATA shadow registers.
.SH "LOCKING"
caller.
.TH "ata_dev_classify" 9 "ata_dev_classify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_classify \-  determine device type based on ATA-spec signature
.SH SYNOPSIS
.B "unsigned int" ata_dev_classify
.BI "(struct ata_taskfile *" tf ");"
.SH ARGUMENTS
.IP "tf" 12
 ATA taskfile register set for device to be identified
.SH "DESCRIPTION"
Determine from taskfile register contents whether a device is
ATA or ATAPI, as per "Signature and persistence" section
of ATA/PI spec (volume 1, sect 5.14).
.SH "LOCKING"
None.
.SH "RETURNS"
Device type, ATA_DEV_ATA, ATA_DEV_ATAPI, or ATA_DEV_UNKNOWN
the event of failure.
.TH "ata_dev_try_classify" 9 "ata_dev_try_classify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_try_classify \-  Parse returned ATA device signature
.SH SYNOPSIS
.B "u8" ata_dev_try_classify
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA channel to examine
.IP "device" 12
 Device to examine (starting at zero)
.SH "DESCRIPTION"
After an event -- SRST, E.D.D., or SATA COMRESET -- occurs,
an ATA/ATAPI-defined set of values is placed in the ATA
shadow registers, indicating the results of device detection
and diagnostics.

Select the ATA device, and read the values from the ATA shadow
registers.  Then parse according to the Error register value,
and the spec-defined values examined by \fBata_dev_classify\fP.
.SH "LOCKING"
caller.
.TH "ata_dev_id_string" 9 "ata_dev_id_string" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_id_string \-  Convert IDENTIFY DEVICE page into string
.SH SYNOPSIS
.B "void" ata_dev_id_string
.BI "(u16 *" id ","
.BI "unsigned char *" s ","
.BI "unsigned int " ofs ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "id" 12
 IDENTIFY DEVICE results we will examine
.IP "s" 12
 string into which data is output
.IP "ofs" 12
 offset into identify device page
.IP "len" 12
 length of string to return. must be an even number.
.SH "DESCRIPTION"
The strings in the IDENTIFY DEVICE page are broken up into
16-bit chunks.  Run through the string, and output each
8-bit chunk linearly, regardless of platform.
.SH "LOCKING"
caller.
.TH "ata_noop_dev_select" 9 "ata_noop_dev_select" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_noop_dev_select \-  Select device 0/1 on ATA bus
.SH SYNOPSIS
.B "void" ata_noop_dev_select
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA channel to manipulate
.IP "device" 12
 ATA device (numbered from zero) to select
.SH "DESCRIPTION"
This function performs no actual function.

May be used as the \fBdev_select\fP entry in ata_port_operations.
.SH "LOCKING"
caller.
.TH "ata_std_dev_select" 9 "ata_std_dev_select" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_std_dev_select \-  Select device 0/1 on ATA bus
.SH SYNOPSIS
.B "void" ata_std_dev_select
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA channel to manipulate
.IP "device" 12
 ATA device (numbered from zero) to select
.SH "DESCRIPTION"
Use the method defined in the ATA specification to
make either device 0, or device 1, active on the
ATA channel.  Works with both PIO and MMIO.

May be used as the \fBdev_select\fP entry in ata_port_operations.
.SH "LOCKING"
caller.
.TH "ata_dev_select" 9 "ata_dev_select" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_select \-  Select device 0/1 on ATA bus
.SH SYNOPSIS
.B "void" ata_dev_select
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ","
.BI "unsigned int " wait ","
.BI "unsigned int " can_sleep ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA channel to manipulate
.IP "device" 12
 ATA device (numbered from zero) to select
.IP "wait" 12
 non-zero to wait for Status register BSY bit to clear
.IP "can_sleep" 12
 non-zero if context allows sleeping
.SH "DESCRIPTION"
Use the method defined in the ATA specification to
make either device 0, or device 1, active on the
ATA channel.

This is a high-level version of \fBata_std_dev_select\fP,
which additionally provides the services of inserting
the proper pauses and status polling, where needed.
.SH "LOCKING"
caller.
.TH "ata_dump_id" 9 "ata_dump_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dump_id \-  IDENTIFY DEVICE info debugging output
.SH SYNOPSIS
.B "void" ata_dump_id
.BI "(struct ata_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Device whose IDENTIFY DEVICE page we will dump
.SH "DESCRIPTION"
Dump selected 16-bit words from a detected device's
IDENTIFY PAGE page.
.SH "LOCKING"
caller.
.TH "ata_dev_identify" 9 "ata_dev_identify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_identify \-  obtain IDENTIFY x DEVICE page
.SH SYNOPSIS
.B "void" ata_dev_identify
.BI "(struct ata_port *" ap ","
.BI "unsigned int " device ");"
.SH ARGUMENTS
.IP "ap" 12
 port on which device we wish to probe resides
.IP "device" 12
 device bus address, starting at zero
.SH "DESCRIPTION"
Following bus reset, we issue the IDENTIFY [PACKET] DEVICE
command, and read back the 512-byte device information page.
The device information page is fed to us via the standard
PIO-IN protocol, but we hand-code it here. (TODO: investigate
using standard PIO-IN paths)

After reading the device information page, we use several
bits of information from it to initialize data structures
that will be used during the lifetime of the ata_device.
Other data from the info page is used to disqualify certain
older ATA devices we do not wish to support.
.SH "LOCKING"
Inherited from caller.  Some functions called by this function
obtain the host_set lock.
.TH "ata_dev_config" 9 "ata_dev_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_config \-  Run device specific handlers and check for
.SH SYNOPSIS
.B "void" ata_dev_config
.BI "(struct ata_port *" ap ","
.BI "unsigned int " i ");"
.SH ARGUMENTS
.IP "ap" 12
 Bus
.IP "i" 12
  Device
.SH "DESCRIPTION"
SATA-&gt;PATA bridges
.TH "ata_bus_probe" 9 "ata_bus_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bus_probe \-  Reset and probe ATA bus
.SH SYNOPSIS
.B "int" ata_bus_probe
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Bus to probe
.SH "DESCRIPTION"
Master ATA bus probing function.  Initiates a hardware-dependent
bus reset, then attempts to identify any devices found on
the bus.
.SH "LOCKING"
PCI/etc. bus probe sem.
.SH "RETURNS"
Zero on success, non-zero on error.
.TH "ata_port_probe" 9 "ata_port_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_port_probe \-  Mark port as enabled
.SH SYNOPSIS
.B "void" ata_port_probe
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port for which we indicate enablement
.SH "DESCRIPTION"
Modify \fIap\fP data structure such that the system
thinks that the entire port is enabled.
.SH "LOCKING"
 host_set lock, or some other form of
serialization.
.TH "__sata_phy_reset" 9 "__sata_phy_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__sata_phy_reset \-  Wake/reset a low-level SATA PHY
.SH SYNOPSIS
.B "void" __sata_phy_reset
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 SATA port associated with target SATA PHY.
.SH "DESCRIPTION"
This function issues commands to standard SATA Sxxx
PHY registers, to wake up the phy (and device), and
clear any reset condition.
.SH "LOCKING"
PCI/etc. bus probe sem.
.TH "sata_phy_reset" 9 "sata_phy_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sata_phy_reset \-  Reset SATA bus.
.SH SYNOPSIS
.B "void" sata_phy_reset
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 SATA port associated with target SATA PHY.
.SH "DESCRIPTION"
This function resets the SATA bus, and then probes
the bus for devices.
.SH "LOCKING"
PCI/etc. bus probe sem.
.TH "ata_port_disable" 9 "ata_port_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_port_disable \-  Disable port.
.SH SYNOPSIS
.B "void" ata_port_disable
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to be disabled.
.SH "DESCRIPTION"
Modify \fIap\fP data structure such that the system
thinks that the entire port is disabled, and should
never attempt to probe or communicate with devices
on this port.
.SH "LOCKING"
 host_set lock, or some other form of
serialization.
.TH "ata_set_mode" 9 "ata_set_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_set_mode \-  Program timings and issue SET FEATURES - XFER
.SH SYNOPSIS
.B "void" ata_set_mode
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 port on which timings will be programmed
.SH "DESCRIPTION"
Set ATA device disk transfer mode (PIO3, UDMA6, etc.).
.SH "LOCKING"
PCI/etc. bus probe sem.
.TH "ata_busy_sleep" 9 "ata_busy_sleep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_busy_sleep \-  sleep until BSY clears, or timeout
.SH SYNOPSIS
.B "unsigned int" ata_busy_sleep
.BI "(struct ata_port *" ap ","
.BI "unsigned long " tmout_pat ","
.BI "unsigned long " tmout ");"
.SH ARGUMENTS
.IP "ap" 12
 port containing status register to be polled
.IP "tmout_pat" 12
 impatience timeout
.IP "tmout" 12
 overall timeout
.SH "DESCRIPTION"
Sleep until ATA Status register bit BSY clears,
or a timeout occurs.
.SH "LOCKING"
 None.
.TH "ata_bus_edd" 9 "ata_bus_edd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bus_edd \-  Issue EXECUTE DEVICE DIAGNOSTIC command.
.SH SYNOPSIS
.B "unsigned int" ata_bus_edd
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to reset and probe
.SH "DESCRIPTION"
Use the EXECUTE DEVICE DIAGNOSTIC command to reset and
probe the bus.  Not often used these days.
.SH "LOCKING"
PCI/etc. bus probe sem.
.TH "ata_bus_reset" 9 "ata_bus_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bus_reset \-  reset host port and associated ATA channel
.SH SYNOPSIS
.B "void" ata_bus_reset
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 port to reset
.SH "DESCRIPTION"
This is typically the first time we actually start issuing
commands to the ATA channel.  We wait for BSY to clear, then
issue EXECUTE DEVICE DIAGNOSTIC command, polling for its
result.  Determine what devices, if any, are on the channel
by looking at the device 0/1 error register.  Look at the signature
stored in each device's taskfile registers, to determine if
the device is ATA or ATAPI.
.SH "LOCKING"
PCI/etc. bus probe sem.
Obtains host_set lock.
.SH "SIDE EFFECTS"
Sets ATA_FLAG_PORT_DISABLED if bus reset fails.
.TH "ata_choose_xfer_mode" 9 "ata_choose_xfer_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_choose_xfer_mode \-  attempt to find best transfer mode
.SH SYNOPSIS
.B "int" ata_choose_xfer_mode
.BI "(struct ata_port *" ap ","
.BI "u8 *" xfer_mode_out ","
.BI "unsigned int *" xfer_shift_out ");"
.SH ARGUMENTS
.IP "ap" 12
 Port for which an xfer mode will be selected
.IP "xfer_mode_out" 12
 (output) SET FEATURES - XFER MODE code
.IP "xfer_shift_out" 12
 (output) bit shift that selects this mode
.SH "DESCRIPTION"
Based on host and device capabilities, determine the
maximum transfer mode that is amenable to all.
.SH "LOCKING"
PCI/etc. bus probe sem.
.SH "RETURNS"
Zero on success, negative on error.
.TH "ata_dev_set_xfermode" 9 "ata_dev_set_xfermode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_dev_set_xfermode \-  Issue SET FEATURES - XFER MODE command
.SH SYNOPSIS
.B "void" ata_dev_set_xfermode
.BI "(struct ata_port *" ap ","
.BI "struct ata_device *" dev ");"
.SH ARGUMENTS
.IP "ap" 12
 Port associated with device \fIdev\fP
.IP "dev" 12
 Device to which command will be sent
.SH "DESCRIPTION"
Issue SET FEATURES - XFER MODE command to device \fIdev\fP
on port \fIap\fP.
.SH "LOCKING"
PCI/etc. bus probe sem.
.TH "ata_sg_clean" 9 "ata_sg_clean" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_sg_clean \-  Unmap DMA memory associated with command
.SH SYNOPSIS
.B "void" ata_sg_clean
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command containing DMA memory to be released
.SH "DESCRIPTION"
Unmap all mapped DMA memory associated with this command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_fill_sg" 9 "ata_fill_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_fill_sg \-  Fill PCI IDE PRD table
.SH SYNOPSIS
.B "void" ata_fill_sg
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Metadata associated with taskfile to be transferred
.SH "DESCRIPTION"
Fill PCI IDE PRD (scatter-gather) table with segments
associated with the current disk command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_check_atapi_dma" 9 "ata_check_atapi_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_check_atapi_dma \-  Check whether ATAPI DMA can be supported
.SH SYNOPSIS
.B "int" ata_check_atapi_dma
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Metadata associated with taskfile to check
.SH "DESCRIPTION"
Allow low-level driver to filter ATA PACKET commands, returning
a status indicating whether or not it is OK to use DMA for the
supplied PACKET command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
 0 when ATAPI DMA can be used
nonzero otherwise
.TH "ata_qc_prep" 9 "ata_qc_prep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_prep \-  Prepare taskfile for submission
.SH SYNOPSIS
.B "void" ata_qc_prep
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Metadata associated with taskfile to be prepared
.SH "DESCRIPTION"
Prepare ATA taskfile for submission.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_sg_init_one" 9 "ata_sg_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_sg_init_one \-  Associate command with memory buffer
.SH SYNOPSIS
.B "void" ata_sg_init_one
.BI "(struct ata_queued_cmd *" qc ","
.BI "void *" buf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "qc" 12
 Command to be associated
.IP "buf" 12
 Memory buffer
.IP "buflen" 12
 Length of memory buffer, in bytes.
.SH "DESCRIPTION"
Initialize the data-related elements of queued_cmd \fIqc\fP
to point to a single memory buffer, \fIbuf\fP of byte length \fIbuflen\fP.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_sg_init" 9 "ata_sg_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_sg_init \-  Associate command with scatter-gather table.
.SH SYNOPSIS
.B "void" ata_sg_init
.BI "(struct ata_queued_cmd *" qc ","
.BI "struct scatterlist *" sg ","
.BI "unsigned int " n_elem ");"
.SH ARGUMENTS
.IP "qc" 12
 Command to be associated
.IP "sg" 12
 Scatter-gather table.
.IP "n_elem" 12
 Number of elements in s/g table.
.SH "DESCRIPTION"
Initialize the data-related elements of queued_cmd \fIqc\fP
to point to a scatter-gather table \fIsg\fP, containing \fIn_elem\fP
elements.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_sg_setup_one" 9 "ata_sg_setup_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_sg_setup_one \-  DMA-map the memory buffer associated with a command.
.SH SYNOPSIS
.B "int" ata_sg_setup_one
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command with memory buffer to be mapped.
.SH "DESCRIPTION"
DMA-map the memory buffer associated with queued_cmd \fIqc\fP.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, negative on error.
.TH "ata_sg_setup" 9 "ata_sg_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_sg_setup \-  DMA-map the scatter-gather table associated with a command.
.SH SYNOPSIS
.B "int" ata_sg_setup
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command with scatter-gather table to be mapped.
.SH "DESCRIPTION"
DMA-map the scatter-gather table associated with queued_cmd \fIqc\fP.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, negative on error.
.TH "ata_poll_qc_complete" 9 "ata_poll_qc_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_poll_qc_complete \-  turn irq back on and finish qc
.SH SYNOPSIS
.B "void" ata_poll_qc_complete
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 " drv_stat ");"
.SH ARGUMENTS
.IP "qc" 12
 Command to complete
.IP "drv_stat" 12
 ATA status register content
.SH "LOCKING"
None.  (grabs host lock)
.TH "ata_pio_poll" 9 "ata_pio_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pio_poll \- 
.SH SYNOPSIS
.B "unsigned long" ata_pio_poll
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
.SH "LOCKING"
None.  (executing in kernel thread context)
.SH "RETURNS"
.TH "ata_pio_complete" 9 "ata_pio_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pio_complete \- 
.SH SYNOPSIS
.B "int" ata_pio_complete
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
.SH "LOCKING"
None.  (executing in kernel thread context)
.SH "RETURNS"
Non-zero if qc completed, zero otherwise.
.TH "swap_buf_le16" 9 "swap_buf_le16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
swap_buf_le16 \- 
.SH SYNOPSIS
.B "void" swap_buf_le16
.BI "(u16 *" buf ","
.BI "unsigned int " buf_words ");"
.SH ARGUMENTS
.IP "buf" 12
  Buffer to swap
.IP "buf_words" 12
  Number of 16-bit words in buffer.
.SH "DESCRIPTION"
Swap halves of 16-bit words if needed to convert from
little-endian byte order to native cpu byte order, or
vice-versa.
.TH "ata_mmio_data_xfer" 9 "ata_mmio_data_xfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_mmio_data_xfer \-  Transfer data by MMIO
.SH SYNOPSIS
.B "void" ata_mmio_data_xfer
.BI "(struct ata_port *" ap ","
.BI "unsigned char *" buf ","
.BI "unsigned int " buflen ","
.BI "int " write_data ");"
.SH ARGUMENTS
.IP "ap" 12
 port to read/write
.IP "buf" 12
 data buffer
.IP "buflen" 12
 buffer length
.IP "write_data" 12
 read/write
.SH "DESCRIPTION"
Transfer data from/to the device data register by MMIO.
.SH "LOCKING"
Inherited from caller.
.TH "ata_pio_data_xfer" 9 "ata_pio_data_xfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pio_data_xfer \-  Transfer data by PIO
.SH SYNOPSIS
.B "void" ata_pio_data_xfer
.BI "(struct ata_port *" ap ","
.BI "unsigned char *" buf ","
.BI "unsigned int " buflen ","
.BI "int " write_data ");"
.SH ARGUMENTS
.IP "ap" 12
 port to read/write
.IP "buf" 12
 data buffer
.IP "buflen" 12
 buffer length
.IP "write_data" 12
 read/write
.SH "DESCRIPTION"
Transfer data from/to the device data register by PIO.
.SH "LOCKING"
Inherited from caller.
.TH "ata_data_xfer" 9 "ata_data_xfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_data_xfer \-  Transfer data from/to the data register.
.SH SYNOPSIS
.B "void" ata_data_xfer
.BI "(struct ata_port *" ap ","
.BI "unsigned char *" buf ","
.BI "unsigned int " buflen ","
.BI "int " do_write ");"
.SH ARGUMENTS
.IP "ap" 12
 port to read/write
.IP "buf" 12
 data buffer
.IP "buflen" 12
 buffer length
.IP "do_write" 12
 read/write
.SH "DESCRIPTION"
Transfer data from/to the device data register.
.SH "LOCKING"
Inherited from caller.
.TH "ata_pio_sector" 9 "ata_pio_sector" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pio_sector \-  Transfer ATA_SECT_SIZE (512 bytes) of data.
.SH SYNOPSIS
.B "void" ata_pio_sector
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command on going
.SH "DESCRIPTION"
Transfer ATA_SECT_SIZE of data from/to the ATA device.
.SH "LOCKING"
Inherited from caller.
.TH "__atapi_pio_bytes" 9 "__atapi_pio_bytes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__atapi_pio_bytes \-  Transfer data from/to the ATAPI device.
.SH SYNOPSIS
.B "void" __atapi_pio_bytes
.BI "(struct ata_queued_cmd *" qc ","
.BI "unsigned int " bytes ");"
.SH ARGUMENTS
.IP "qc" 12
 Command on going
.IP "bytes" 12
 number of bytes
.SH "DESCRIPTION"
Transfer Transfer data from/to the ATAPI device.
.SH "LOCKING"
Inherited from caller.
.TH "atapi_pio_bytes" 9 "atapi_pio_bytes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atapi_pio_bytes \-  Transfer data from/to the ATAPI device.
.SH SYNOPSIS
.B "void" atapi_pio_bytes
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command on going
.SH "DESCRIPTION"
Transfer Transfer data from/to the ATAPI device.
.SH "LOCKING"
Inherited from caller.
.TH "ata_pio_block" 9 "ata_pio_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pio_block \- 
.SH SYNOPSIS
.B "void" ata_pio_block
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
.SH "LOCKING"
None.  (executing in kernel thread context)
.TH "ata_qc_timeout" 9 "ata_qc_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_timeout \-  Handle timeout of queued command
.SH SYNOPSIS
.B "void" ata_qc_timeout
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command that timed out
.SH "DESCRIPTION"
Some part of the kernel (currently, only the SCSI layer)
has noticed that the active command on port \fIap\fP has not
completed after a specified length of time.  Handle this
condition by disabling DMA (if necessary) and completing
transactions, with error if necessary.

This also handles the case of the "lost interrupt", where
for some reason (possibly hardware bug, possibly driver bug)
an interrupt was not delivered to the driver, even though the
transaction completed successfully.
.SH "LOCKING"
Inherited from SCSI layer (none, can sleep)
.TH "ata_eng_timeout" 9 "ata_eng_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_eng_timeout \-  Handle timeout of queued command
.SH SYNOPSIS
.B "void" ata_eng_timeout
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port on which timed-out command is active
.SH "DESCRIPTION"
Some part of the kernel (currently, only the SCSI layer)
has noticed that the active command on port \fIap\fP has not
completed after a specified length of time.  Handle this
condition by disabling DMA (if necessary) and completing
transactions, with error if necessary.

This also handles the case of the "lost interrupt", where
for some reason (possibly hardware bug, possibly driver bug)
an interrupt was not delivered to the driver, even though the
transaction completed successfully.
.SH "LOCKING"
Inherited from SCSI layer (none, can sleep)
.TH "ata_qc_new" 9 "ata_qc_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_new \-  Request an available ATA command, for queueing
.SH SYNOPSIS
.B "struct ata_queued_cmd *" ata_qc_new
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port associated with device \fIdev\fP
.SH "LOCKING"
None.
.TH "ata_qc_new_init" 9 "ata_qc_new_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_new_init \-  Request an available ATA command, and initialize it
.SH SYNOPSIS
.B "struct ata_queued_cmd *" ata_qc_new_init
.BI "(struct ata_port *" ap ","
.BI "struct ata_device *" dev ");"
.SH ARGUMENTS
.IP "ap" 12
 Port associated with device \fIdev\fP
.IP "dev" 12
 Device from whom we request an available command structure
.SH "LOCKING"
None.
.TH "ata_qc_free" 9 "ata_qc_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_free \-  free unused ata_queued_cmd
.SH SYNOPSIS
.B "void" ata_qc_free
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command to complete
.SH "DESCRIPTION"
Designed to free unused ata_queued_cmd object
in case something prevents using it.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_qc_complete" 9 "ata_qc_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_complete \-  Complete an active ATA command
.SH SYNOPSIS
.B "void" ata_qc_complete
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 " drv_stat ");"
.SH ARGUMENTS
.IP "qc" 12
 Command to complete
.IP "drv_stat" 12
 ATA Status register contents
.SH "DESCRIPTION"
Indicate to the mid and upper layers that an ATA
command has completed, with either an ok or not-ok status.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_qc_issue" 9 "ata_qc_issue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_issue \-  issue taskfile to device
.SH SYNOPSIS
.B "int" ata_qc_issue
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 command to issue to device
.SH "DESCRIPTION"
Prepare an ATA command to submission to device.
This includes mapping the data into a DMA-able
area, filling in the S/G table, and finally
writing the taskfile to hardware, starting the command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, negative on error.
.TH "ata_qc_issue_prot" 9 "ata_qc_issue_prot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_qc_issue_prot \-  issue taskfile to device in proto-dependent manner
.SH SYNOPSIS
.B "int" ata_qc_issue_prot
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 command to issue to device
.SH "DESCRIPTION"
Using various libata functions and hooks, this function
starts an ATA command.  ATA commands are grouped into
classes called "protocols", and issuing each type of protocol
is slightly different.

May be used as the \fBqc_issue\fP entry in ata_port_operations.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, negative on error.
.TH "ata_bmdma_setup_mmio" 9 "ata_bmdma_setup_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_setup_mmio \-  Set up PCI IDE BMDMA transaction
.SH SYNOPSIS
.B "void" ata_bmdma_setup_mmio
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_start_mmio" 9 "ata_bmdma_start_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_start_mmio \-  Start a PCI IDE BMDMA transaction
.SH SYNOPSIS
.B "void" ata_bmdma_start_mmio
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_setup_pio" 9 "ata_bmdma_setup_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_setup_pio \-  Set up PCI IDE BMDMA transaction (PIO)
.SH SYNOPSIS
.B "void" ata_bmdma_setup_pio
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_start_pio" 9 "ata_bmdma_start_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_start_pio \-  Start a PCI IDE BMDMA transaction (PIO)
.SH SYNOPSIS
.B "void" ata_bmdma_start_pio
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_start" 9 "ata_bmdma_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_start \-  Start a PCI IDE BMDMA transaction
.SH SYNOPSIS
.B "void" ata_bmdma_start
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "DESCRIPTION"
Writes the ATA_DMA_START flag to the DMA command register.

May be used as the \fBbmdma_start\fP entry in ata_port_operations.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_setup" 9 "ata_bmdma_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_setup \-  Set up PCI IDE BMDMA transaction
.SH SYNOPSIS
.B "void" ata_bmdma_setup
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "DESCRIPTION"
Writes address of PRD table to device's PRD Table Address
register, sets the DMA control register, and calls
ops-&gt;\fBexec_command\fP to start the transfer.

May be used as the \fBbmdma_setup\fP entry in ata_port_operations.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_irq_clear" 9 "ata_bmdma_irq_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_irq_clear \-  Clear PCI IDE BMDMA interrupt.
.SH SYNOPSIS
.B "void" ata_bmdma_irq_clear
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port associated with this ATA transaction.
.SH "DESCRIPTION"
Clear interrupt and error flags in DMA status register.

May be used as the \fBirq_clear\fP entry in ata_port_operations.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_status" 9 "ata_bmdma_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_status \-  Read PCI IDE BMDMA status
.SH SYNOPSIS
.B "u8" ata_bmdma_status
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port associated with this ATA transaction.
.SH "DESCRIPTION"
Read and return BMDMA status register.

May be used as the \fBbmdma_status\fP entry in ata_port_operations.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_bmdma_stop" 9 "ata_bmdma_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_bmdma_stop \-  Stop PCI IDE BMDMA transfer
.SH SYNOPSIS
.B "void" ata_bmdma_stop
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Command we are ending DMA for
.SH "DESCRIPTION"
Clears the ATA_DMA_START flag in the dma control register

May be used as the \fBbmdma_stop\fP entry in ata_port_operations.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_host_intr" 9 "ata_host_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_host_intr \-  Handle host interrupt for given (port, task)
.SH SYNOPSIS
.B "unsigned int" ata_host_intr
.BI "(struct ata_port *" ap ","
.BI "struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "ap" 12
 Port on which interrupt arrived (possibly...)
.IP "qc" 12
 Taskfile currently active in engine
.SH "DESCRIPTION"
Handle host interrupt for given queued command.  Currently,
only DMA interrupts are handled.  All other commands are
handled via polling with interrupts disabled (nIEN bit).
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
One if interrupt was handled, zero if not (shared irq).
.TH "ata_interrupt" 9 "ata_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_interrupt \-  Default ATA host interrupt handler
.SH SYNOPSIS
.B "irqreturn_t" ata_interrupt
.BI "(int " irq ","
.BI "void *" dev_instance ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 irq line (unused)
.IP "dev_instance" 12
 pointer to our ata_host_set information structure
.IP "regs" 12
 unused
.SH "DESCRIPTION"
Default interrupt handler for PCI IDE devices.  Calls
\fBata_host_intr\fP for each port that is not disabled.
.SH "LOCKING"
Obtains host_set lock during operation.
.SH "RETURNS"
IRQ_NONE or IRQ_HANDLED.
.TH "atapi_packet_task" 9 "atapi_packet_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atapi_packet_task \-  Write CDB bytes to hardware
.SH SYNOPSIS
.B "void" atapi_packet_task
.BI "(void *" _data ");"
.SH ARGUMENTS
.IP "_data" 12
 Port to which ATAPI device is attached.
.SH "DESCRIPTION"
When device has indicated its readiness to accept
a CDB, this function is called.  Send the CDB.
If DMA is to be performed, exit immediately.
Otherwise, we are in polling mode, so poll
status under operation succeeds or fails.
.SH "LOCKING"
Kernel thread context (may sleep)
.TH "ata_port_start" 9 "ata_port_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_port_start \-  Set port up for dma.
.SH SYNOPSIS
.B "int" ata_port_start
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to initialize
.SH "DESCRIPTION"
Called just after data structures for each port are
initialized.  Allocates space for PRD table.

May be used as the \fBport_start\fP entry in ata_port_operations.
.TH "ata_port_stop" 9 "ata_port_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_port_stop \-  Undo ata_port_start()
.SH SYNOPSIS
.B "void" ata_port_stop
.BI "(struct ata_port *" ap ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to shut down
.SH "DESCRIPTION"
Frees the PRD table.

May be used as the \fBport_stop\fP entry in ata_port_operations.
.TH "ata_host_remove" 9 "ata_host_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_host_remove \-  Unregister SCSI host structure with upper layers
.SH SYNOPSIS
.B "void" ata_host_remove
.BI "(struct ata_port *" ap ","
.BI "unsigned int " do_unregister ");"
.SH ARGUMENTS
.IP "ap" 12
 Port to unregister
.IP "do_unregister" 12
 1 if we fully unregister, 0 to just stop the port
.TH "ata_host_init" 9 "ata_host_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_host_init \-  Initialize an ata_port structure
.SH SYNOPSIS
.B "void" ata_host_init
.BI "(struct ata_port *" ap ","
.BI "struct Scsi_Host *" host ","
.BI "struct ata_host_set *" host_set ","
.BI "struct ata_probe_ent *" ent ","
.BI "unsigned int " port_no ");"
.SH ARGUMENTS
.IP "ap" 12
 Structure to initialize
.IP "host" 12
 associated SCSI mid-layer structure
.IP "host_set" 12
 Collection of hosts to which \fIap\fP belongs
.IP "ent" 12
 Probe information provided by low-level driver
.IP "port_no" 12
 Port number associated with this ata_port
.SH "DESCRIPTION"
Initialize a new ata_port structure, and its associated
scsi_host.
.SH "LOCKING"
Inherited from caller.
.TH "ata_host_add" 9 "ata_host_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_host_add \-  Attach low-level ATA driver to system
.SH SYNOPSIS
.B "struct ata_port *" ata_host_add
.BI "(struct ata_probe_ent *" ent ","
.BI "struct ata_host_set *" host_set ","
.BI "unsigned int " port_no ");"
.SH ARGUMENTS
.IP "ent" 12
 Information provided by low-level driver
.IP "host_set" 12
 Collections of ports to which we add
.IP "port_no" 12
 Port number associated with this host
.SH "DESCRIPTION"
Attach low-level ATA driver to system.
.SH "LOCKING"
PCI/etc. bus probe sem.
.SH "RETURNS"
New ata_port on success, for NULL on error.
.TH "ata_device_add" 9 "ata_device_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_device_add \-  Register hardware device with ATA and SCSI layers
.SH SYNOPSIS
.B "int" ata_device_add
.BI "(struct ata_probe_ent *" ent ");"
.SH ARGUMENTS
.IP "ent" 12
 Probe information describing hardware device to be registered
.SH "DESCRIPTION"
This function processes the information provided in the probe
information struct \fIent\fP, allocates the necessary ATA and SCSI
host information structures, initializes them, and registers
everything with requisite kernel subsystems.

This function requests irqs, probes the ATA bus, and probes
the SCSI bus.
.SH "LOCKING"
PCI/etc. bus probe sem.
.SH "RETURNS"
Number of ports registered.  Zero on error (no ports registered).
.TH "ata_host_set_remove" 9 "ata_host_set_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_host_set_remove \-  PCI layer callback for device removal
.SH SYNOPSIS
.B "void" ata_host_set_remove
.BI "(struct ata_host_set *" host_set ");"
.SH ARGUMENTS
.IP "host_set" 12
 ATA host set that was removed
.SH "DESCRIPTION"
Unregister all objects associated with this host set. Free those 
objects.
.SH "LOCKING"
Inherited from calling layer (may sleep).
.TH "ata_scsi_release" 9 "ata_scsi_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_release \-  SCSI layer callback hook for host unload
.SH SYNOPSIS
.B "int" ata_scsi_release
.BI "(struct Scsi_Host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 libata host to be unloaded
.SH "DESCRIPTION"
Performs all duties necessary to shut down a libata port...
Kill port kthread, disable port, and release resources.
.SH "LOCKING"
Inherited from SCSI layer.
.SH "RETURNS"
One.
.TH "ata_std_ports" 9 "ata_std_ports" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_std_ports \-  initialize ioaddr with standard port offsets.
.SH SYNOPSIS
.B "void" ata_std_ports
.BI "(struct ata_ioports *" ioaddr ");"
.SH ARGUMENTS
.IP "ioaddr" 12
 IO address structure to be initialized
.SH "DESCRIPTION"
Utility function which initializes data_addr, error_addr,
feature_addr, nsect_addr, lbal_addr, lbam_addr, lbah_addr,
device_addr, status_addr, and command_addr to standard offsets
relative to cmd_addr.

Does not set ctl_addr, altstatus_addr, bmdma_addr, or scr_addr.
.TH "ata_pci_init_native_mode" 9 "ata_pci_init_native_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pci_init_native_mode \-  Initialize native-mode driver
.SH SYNOPSIS
.B "struct ata_probe_ent *" ata_pci_init_native_mode
.BI "(struct pci_dev *" pdev ","
.BI "struct ata_port_info **" port ");"
.SH ARGUMENTS
.IP "pdev" 12
  pci device to be initialized
.IP "port" 12
  array[2] of pointers to port info structures.
.SH "DESCRIPTION"
Utility function which allocates and initializes an
ata_probe_ent structure for a standard dual-port
PIO-based IDE controller.  The returned ata_probe_ent
structure can be passed to \fBata_device_add\fP.  The returned
ata_probe_ent structure should then be freed with \fBkfree\fP.
.TH "ata_pci_init_one" 9 "ata_pci_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pci_init_one \-  Initialize/register PCI IDE host controller
.SH SYNOPSIS
.B "int" ata_pci_init_one
.BI "(struct pci_dev *" pdev ","
.BI "struct ata_port_info **" port_info ","
.BI "unsigned int " n_ports ");"
.SH ARGUMENTS
.IP "pdev" 12
 Controller to be initialized
.IP "port_info" 12
 Information from low-level host driver
.IP "n_ports" 12
 Number of ports attached to host controller
.SH "DESCRIPTION"
This is a helper function which can be called from a driver's
\fBxxx_init_one\fP probe function if the hardware uses traditional
IDE taskfile registers.

This function calls \fBpci_enable_device\fP, reserves its register
regions, sets the dma mask, enables bus master mode, and calls
\fBata_device_add\fP
.SH "LOCKING"
Inherited from PCI layer (may sleep).
.SH "RETURNS"
Zero on success, negative on errno-based value on error.
.TH "ata_pci_remove_one" 9 "ata_pci_remove_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_pci_remove_one \-  PCI layer callback for device removal
.SH SYNOPSIS
.B "void" ata_pci_remove_one
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device that was removed
.SH "DESCRIPTION"
PCI layer indicates to libata via this hook that
hot-unplug or module unload event has occured.
Handle this by unregistering all objects associated
with this PCI device.  Free those objects.  Then finally
release PCI resources and disable device.
.SH "LOCKING"
Inherited from PCI layer (may sleep).
.TH "sil_dev_config" 9 "sil_dev_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sil_dev_config \-  Apply device/host-specific errata fixups
.SH SYNOPSIS
.B "void" sil_dev_config
.BI "(struct ata_port *" ap ","
.BI "struct ata_device *" dev ");"
.SH ARGUMENTS
.IP "ap" 12
 Port containing device to be examined
.IP "dev" 12
 Device to be examined
.SH "DESCRIPTION"
After the IDENTIFY [PACKET] DEVICE step is complete, and a
device is known to be present, this function is called.
We apply two errata fixups which are specific to Silicon Image,
a Seagate and a Maxtor fixup.

For certain Seagate devices, we must limit the maximum sectors
to under 8K.

For certain Maxtor devices, we must not program the drive
beyond udma5.

Both fixups are unfairly pessimistic.  As soon as I get more
information on these errata, I will create a more exhaustive
list, and apply the fixups to only the specific
devices/hosts/firmwares that need it.

20040111 - Seagate drives affected by the Mod15Write bug are blacklisted
The Maxtor quirk is in the blacklist, but I'm keeping the original
pessimistic fix for the following reasons...
- There seems to be less info on it, only one device gleaned off the
Windows	driver, maybe only one is affected.  More info would be greatly
appreciated.
- But then again UDMA5 is hardly anything to complain about
.TH "k2_bmdma_setup_mmio" 9 "k2_bmdma_setup_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
k2_bmdma_setup_mmio \-  Set up PCI IDE BMDMA transaction (MMIO)
.SH SYNOPSIS
.B "void" k2_bmdma_setup_mmio
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "k2_bmdma_start_mmio" 9 "k2_bmdma_start_mmio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
k2_bmdma_start_mmio \-  Start a PCI IDE BMDMA transaction (MMIO)
.SH SYNOPSIS
.B "void" k2_bmdma_start_mmio
.BI "(struct ata_queued_cmd *" qc ");"
.SH ARGUMENTS
.IP "qc" 12
 Info associated with this ATA transaction.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "fib_map_alloc" 9 "fib_map_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_map_alloc \- 	allocate the fib objects
.SH SYNOPSIS
.B "int" fib_map_alloc
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter to allocate for
.SH "DESCRIPTION"
Allocate and map the shared PCI space for the FIB blocks used to
talk to the Adaptec firmware.
.TH "fib_map_free" 9 "fib_map_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_map_free \- 	free the fib objects
.SH SYNOPSIS
.B "void" fib_map_free
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter to free
.SH "DESCRIPTION"
Free the PCI mappings and the memory allocated for FIB blocks
on this adapter.
.TH "fib_setup" 9 "fib_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_setup \- 	setup the fibs
.SH SYNOPSIS
.B "int" fib_setup
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter to set up
.SH "DESCRIPTION"
Allocate the PCI space for the fibs, map it and then intialise the
fib area, the unmapped fib data and also the free list
.TH "fib_alloc" 9 "fib_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_alloc \- 	allocate a fib
.SH SYNOPSIS
.B "struct fib *" fib_alloc
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter to allocate the fib for
.SH "DESCRIPTION"
Allocate a fib from the adapter fib pool. If the pool is empty we
return NULL.
.TH "fib_free" 9 "fib_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_free \- 	free a fib
.SH SYNOPSIS
.B "void" fib_free
.BI "(struct fib *" fibptr ");"
.SH ARGUMENTS
.IP "fibptr" 12
 fib to free up
.SH "DESCRIPTION"
Frees up a fib and places it on the appropriate queue
(either free or timed out)
.TH "fib_init" 9 "fib_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_init \- 	initialise a fib
.SH SYNOPSIS
.B "void" fib_init
.BI "(struct fib *" fibptr ");"
.SH ARGUMENTS
.IP "fibptr" 12
 The fib to initialize
.SH "DESCRIPTION"
Set up the generic fib fields ready for use
.TH "fib_dealloc" 9 "fib_dealloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_dealloc \- 	deallocate a fib
.SH SYNOPSIS
.B "void" fib_dealloc
.BI "(struct fib *" fibptr ");"
.SH ARGUMENTS
.IP "fibptr" 12
 fib to deallocate
.SH "DESCRIPTION"
Will deallocate and return to the free pool the FIB pointed to by the
caller.
.TH "aac_get_entry" 9 "aac_get_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_get_entry \- 	get a queue entry
.SH SYNOPSIS
.B "int" aac_get_entry
.BI "(struct aac_dev *" dev ","
.BI "u32 " qid ","
.BI "struct aac_entry **" entry ","
.BI "u32 *" index ","
.BI "unsigned long *" nonotify ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "qid" 12
 Queue Number
.IP "entry" 12
 Entry return
.IP "index" 12
 Index return
.IP "nonotify" 12
 notification control
.SH "DESCRIPTION"
With a priority the routine returns a queue entry if the queue has free entries. If the queue
is full(no free entries) than no entry is returned and the function returns 0 otherwise 1 is
returned.
.TH "aac_queue_get" 9 "aac_queue_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_queue_get \- 	get the next free QE
.SH SYNOPSIS
.B "int" aac_queue_get
.BI "(struct aac_dev *" dev ","
.BI "u32 *" index ","
.BI "u32 " qid ","
.BI "struct hw_fib *" hw_fib ","
.BI "int " wait ","
.BI "struct fib *" fibptr ","
.BI "unsigned long *" nonotify ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "index" 12
 Returned index
.IP "qid" 12
-- undescribed --
.IP "hw_fib" 12
-- undescribed --
.IP "wait" 12
 Wait if queue full
.IP "fibptr" 12
 Driver fib object to go with fib
.IP "nonotify" 12
 Don't notify the adapter
.SH "DESCRIPTION"
Gets the next free QE off the requested priorty adapter command
queue and associates the Fib with the QE. The QE represented by
index is ready to insert on the queue when this routine returns
success.
.TH "fib_send" 9 "fib_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_send \- 	send a fib to the adapter
.SH SYNOPSIS
.B "int" fib_send
.BI "(u16 " command ","
.BI "struct fib *" fibptr ","
.BI "unsigned long " size ","
.BI "int " priority ","
.BI "int " wait ","
.BI "int " reply ","
.BI "fib_callback " callback ","
.BI "void *" callback_data ");"
.SH ARGUMENTS
.IP "command" 12
 Command to send
.IP "fibptr" 12
 The fib
.IP "size" 12
 Size of fib data area
.IP "priority" 12
 Priority of Fib
.IP "wait" 12
 Async/sync select
.IP "reply" 12
 True if a reply is wanted
.IP "callback" 12
 Called with reply
.IP "callback_data" 12
 Passed to callback
.SH "DESCRIPTION"
Sends the requested FIB to the adapter and optionally will wait for a
response FIB. If the caller does not wish to wait for a response than
an event to wait on must be supplied. This event will be set when a
response FIB is received from the adapter.
.TH "aac_consumer_get" 9 "aac_consumer_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_consumer_get \- 	get the top of the queue
.SH SYNOPSIS
.B "int" aac_consumer_get
.BI "(struct aac_dev *" dev ","
.BI "struct aac_queue *" q ","
.BI "struct aac_entry **" entry ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "q" 12
 Queue
.IP "entry" 12
 Return entry
.SH "DESCRIPTION"
Will return a pointer to the entry on the top of the queue requested that
we are a consumer of, and return the address of the queue entry. It does
not change the state of the queue. 
.TH "aac_consumer_free" 9 "aac_consumer_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_consumer_free \- 	free consumer entry
.SH SYNOPSIS
.B "void" aac_consumer_free
.BI "(struct aac_dev *" dev ","
.BI "struct aac_queue *" q ","
.BI "u32 " qid ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "q" 12
 Queue
.IP "qid" 12
 Queue ident
.SH "DESCRIPTION"
Frees up the current top of the queue we are a consumer of. If the
queue was full notify the producer that the queue is no longer full.
.TH "fib_adapter_complete" 9 "fib_adapter_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_adapter_complete \- 	complete adapter issued fib
.SH SYNOPSIS
.B "int" fib_adapter_complete
.BI "(struct fib *" fibptr ","
.BI "unsigned short " size ");"
.SH ARGUMENTS
.IP "fibptr" 12
 fib to complete
.IP "size" 12
 size of fib
.SH "DESCRIPTION"
Will do all necessary work to complete a FIB that was sent from
the adapter.
.TH "fib_complete" 9 "fib_complete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fib_complete \- 	fib completion handler
.SH SYNOPSIS
.B "int" fib_complete
.BI "(struct fib *" fibptr ");"
.SH ARGUMENTS
.IP "fibptr" 12
-- undescribed --
.SH "DESCRIPTION"
Will do all necessary work to complete a FIB.
.TH "aac_printf" 9 "aac_printf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_printf \- 	handle printf from firmware
.SH SYNOPSIS
.B "void" aac_printf
.BI "(struct aac_dev *" dev ","
.BI "u32 " val ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "val" 12
 Message info
.SH "DESCRIPTION"
Print a message passed to us by the controller firmware on the
Adaptec board
.TH "aac_handle_aif" 9 "aac_handle_aif" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_handle_aif \- 	Handle a message from the firmware
.SH SYNOPSIS
.B "void" aac_handle_aif
.BI "(struct aac_dev *" dev ","
.BI "struct fib *" fibptr ");"
.SH ARGUMENTS
.IP "dev" 12
 Which adapter this fib is from
.IP "fibptr" 12
 Pointer to fibptr from adapter
.SH "DESCRIPTION"
This routine handles a driver notify fib from the adapter and
dispatches it to the appropriate routine for handling.
.TH "aac_command_thread" 9 "aac_command_thread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_command_thread \- 	command processing thread
.SH SYNOPSIS
.B "int" aac_command_thread
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter to monitor
.SH "DESCRIPTION"
Waits on the commandready event in it's queue. When the event gets set
it will pull FIBs off it's queue. It will continue to pull FIBs off
until the queue is empty. When the queue is empty it will wait for
more FIBs.
.TH "aac_get_config_status" 9 "aac_get_config_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_get_config_status \- 	check the adapter configuration
.SH SYNOPSIS
.B "int" aac_get_config_status
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
Query config status, and commit the configuration if needed.
.TH "aac_get_containers" 9 "aac_get_containers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_get_containers \- 	list containers
.SH SYNOPSIS
.B "int" aac_get_containers
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
Make a list of all containers on this controller
.TH "aac_get_container_name" 9 "aac_get_container_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_get_container_name \- 	get container name, none blocking.
.SH SYNOPSIS
.B "int" aac_get_container_name
.BI "(struct scsi_cmnd *" scsicmd ","
.BI "int " cid ");"
.SH ARGUMENTS
.IP "scsicmd" 12
-- undescribed --
.IP "cid" 12
-- undescribed --
.TH "probe_container" 9 "probe_container" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_container \- 	query a logical volume
.SH SYNOPSIS
.B "int" probe_container
.BI "(struct aac_dev *" dev ","
.BI "int " cid ");"
.SH ARGUMENTS
.IP "dev" 12
 device to query
.IP "cid" 12
 container identifier
.SH "DESCRIPTION"
Queries the controller about the given volume. The volume information
is updated in the struct fsa_dev_info structure rather than returned.
.TH "inqstrcpy" 9 "inqstrcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inqstrcpy \- 	string merge
.SH SYNOPSIS
.B "void" inqstrcpy
.BI "(char *" a ","
.BI "char *" b ");"
.SH ARGUMENTS
.IP "a" 12
	string to copy from
.IP "b" 12
	string to copy to
.SH "DESCRIPTION"
Copy a String from one location to another
without copying \0
.TH "aac_scsi_cmd" 9 "aac_scsi_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_scsi_cmd \- 	Process SCSI command
.SH SYNOPSIS
.B "int" aac_scsi_cmd
.BI "(struct scsi_cmnd *" scsicmd ");"
.SH ARGUMENTS
.IP "scsicmd" 12
		SCSI command block
.SH "DESCRIPTION"
Emulate a SCSI command and queue the required request for the
aacraid firmware.
.TH "ioctl_send_fib" 9 "ioctl_send_fib" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioctl_send_fib \- 	send a FIB from userspace
.SH SYNOPSIS
.B "int" ioctl_send_fib
.BI "(struct aac_dev *" dev ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "dev" 12
	adapter is being processed
.IP "arg" 12
	arguments to the ioctl call
.SH "DESCRIPTION"
This routine sends a fib to the adapter on behalf of a user level
program.
.TH "open_getadapter_fib" 9 "open_getadapter_fib" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
open_getadapter_fib \- 	Get the next fib
.SH SYNOPSIS
.B "int" open_getadapter_fib
.BI "(struct aac_dev *" dev ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

This routine will get the next Fib, if available, from the AdapterFibContext
passed in from the user.
.TH "next_getadapter_fib" 9 "next_getadapter_fib" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
next_getadapter_fib \- 	get the next fib
.SH SYNOPSIS
.B "int" next_getadapter_fib
.BI "(struct aac_dev *" dev ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "dev" 12
 adapter to use
.IP "arg" 12
 ioctl argument
.SH "DESCRIPTION"
This routine will get the next Fib, if available, from the AdapterFibContext
passed in from the user.
.TH "close_getadapter_fib" 9 "close_getadapter_fib" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
close_getadapter_fib \- 	close down user fib context
.SH SYNOPSIS
.B "int" close_getadapter_fib
.BI "(struct aac_dev *" dev ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "dev" 12
 adapter
.IP "arg" 12
 ioctl arguments
.SH "DESCRIPTION"
This routine will close down the fibctx passed in from the user.
.TH "check_revision" 9 "check_revision" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_revision \- 	close down user fib context
.SH SYNOPSIS
.B "int" check_revision
.BI "(struct aac_dev *" dev ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "dev" 12
 adapter
.IP "arg" 12
 ioctl arguments
.SH "DESCRIPTION"
This routine returns the driver version.
Under Linux, there have been no version incompatibilities, so this is 
simple!
.TH "aac_rx_disable_interrupt" 9 "aac_rx_disable_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rx_disable_interrupt \- 	Disable interrupts
.SH SYNOPSIS
.B "void" aac_rx_disable_interrupt
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.TH "rx_sync_cmd" 9 "rx_sync_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rx_sync_cmd \- 	send a command and wait
.SH SYNOPSIS
.B "int" rx_sync_cmd
.BI "(struct aac_dev *" dev ","
.BI "u32 " command ","
.BI "u32 " p1 ","
.BI "u32 " p2 ","
.BI "u32 " p3 ","
.BI "u32 " p4 ","
.BI "u32 " p5 ","
.BI "u32 " p6 ","
.BI "u32 *" status ","
.BI "u32 *" r1 ","
.BI "u32 *" r2 ","
.BI "u32 *" r3 ","
.BI "u32 *" r4 ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "command" 12
 Command to execute
.IP "p1" 12
 first parameter
.IP "p2" 12
-- undescribed --
.IP "p3" 12
-- undescribed --
.IP "p4" 12
-- undescribed --
.IP "p5" 12
-- undescribed --
.IP "p6" 12
-- undescribed --
.IP "status" 12
-- undescribed --
.IP "r1" 12
-- undescribed --
.IP "r2" 12
-- undescribed --
.IP "r3" 12
-- undescribed --
.IP "r4" 12
-- undescribed --
.SH "DESCRIPTION"
This routine will send a synchronous command to the adapter and wait 
for its	completion.
.TH "aac_rx_interrupt_adapter" 9 "aac_rx_interrupt_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rx_interrupt_adapter \- 	interrupt adapter
.SH SYNOPSIS
.B "void" aac_rx_interrupt_adapter
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.SH "DESCRIPTION"
Send an interrupt to the i960 and breakpoint it.
.TH "aac_rx_notify_adapter" 9 "aac_rx_notify_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rx_notify_adapter \- 	send an event to the adapter
.SH SYNOPSIS
.B "void" aac_rx_notify_adapter
.BI "(struct aac_dev *" dev ","
.BI "u32 " event ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "event" 12
 Event to send
.SH "DESCRIPTION"
Notify the i960 that something it probably cares about has
happened.
.TH "aac_rx_start_adapter" 9 "aac_rx_start_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rx_start_adapter \- 	activate adapter
.SH SYNOPSIS
.B "void" aac_rx_start_adapter
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Adapter
.SH "DESCRIPTION"
Start up processing on an i960 based AAC adapter
.TH "aac_rx_check_health" 9 "aac_rx_check_health" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rx_check_health \- 
.SH SYNOPSIS
.B "int" aac_rx_check_health
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to check if healthy
.SH "DESCRIPTION"
Will attempt to determine if the specified adapter is alive and
capable of handling requests, returning 0 if alive.
.TH "aac_rx_init" 9 "aac_rx_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rx_init \- 	initialize an i960 based AAC card
.SH SYNOPSIS
.B "int" aac_rx_init
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to configure
.SH "DESCRIPTION"
Allocate and set up resources for the i960 based AAC variants. The 
device_interface in the commregion will be allocated and linked 
to the comm region.
.TH "aac_rkt_disable_interrupt" 9 "aac_rkt_disable_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rkt_disable_interrupt \- 	Disable interrupts
.SH SYNOPSIS
.B "void" aac_rkt_disable_interrupt
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.TH "rkt_sync_cmd" 9 "rkt_sync_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rkt_sync_cmd \- 	send a command and wait
.SH SYNOPSIS
.B "int" rkt_sync_cmd
.BI "(struct aac_dev *" dev ","
.BI "u32 " command ","
.BI "u32 " p1 ","
.BI "u32 " p2 ","
.BI "u32 " p3 ","
.BI "u32 " p4 ","
.BI "u32 " p5 ","
.BI "u32 " p6 ","
.BI "u32 *" status ","
.BI "u32 *" r1 ","
.BI "u32 *" r2 ","
.BI "u32 *" r3 ","
.BI "u32 *" r4 ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "command" 12
 Command to execute
.IP "p1" 12
 first parameter
.IP "p2" 12
-- undescribed --
.IP "p3" 12
-- undescribed --
.IP "p4" 12
-- undescribed --
.IP "p5" 12
-- undescribed --
.IP "p6" 12
-- undescribed --
.IP "status" 12
-- undescribed --
.IP "r1" 12
-- undescribed --
.IP "r2" 12
-- undescribed --
.IP "r3" 12
-- undescribed --
.IP "r4" 12
-- undescribed --
.SH "DESCRIPTION"
This routine will send a synchronous command to the adapter and wait 
for its	completion.
.TH "aac_rkt_interrupt_adapter" 9 "aac_rkt_interrupt_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rkt_interrupt_adapter \- 	interrupt adapter
.SH SYNOPSIS
.B "void" aac_rkt_interrupt_adapter
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.SH "DESCRIPTION"
Send an interrupt to the i960 and breakpoint it.
.TH "aac_rkt_notify_adapter" 9 "aac_rkt_notify_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rkt_notify_adapter \- 	send an event to the adapter
.SH SYNOPSIS
.B "void" aac_rkt_notify_adapter
.BI "(struct aac_dev *" dev ","
.BI "u32 " event ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "event" 12
 Event to send
.SH "DESCRIPTION"
Notify the i960 that something it probably cares about has
happened.
.TH "aac_rkt_start_adapter" 9 "aac_rkt_start_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rkt_start_adapter \- 	activate adapter
.SH SYNOPSIS
.B "void" aac_rkt_start_adapter
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Adapter
.SH "DESCRIPTION"
Start up processing on an i960 based AAC adapter
.TH "aac_rkt_check_health" 9 "aac_rkt_check_health" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rkt_check_health \- 
.SH SYNOPSIS
.B "int" aac_rkt_check_health
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to check if healthy
.SH "DESCRIPTION"
Will attempt to determine if the specified adapter is alive and
capable of handling requests, returning 0 if alive.
.TH "aac_rkt_init" 9 "aac_rkt_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_rkt_init \- 	initialize an i960 based AAC card
.SH SYNOPSIS
.B "int" aac_rkt_init
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to configure
.SH "DESCRIPTION"
Allocate and set up resources for the i960 based AAC variants. The 
device_interface in the commregion will be allocated and linked 
to the comm region.
.TH "aac_response_normal" 9 "aac_response_normal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_response_normal \- 	Handle command replies
.SH SYNOPSIS
.B "unsigned int" aac_response_normal
.BI "(struct aac_queue *" q ");"
.SH ARGUMENTS
.IP "q" 12
 Queue to read from
.SH "DESCRIPTION"
This DPC routine will be run when the adapter interrupts us to let us
know there is a response on our normal priority queue. We will pull off
all QE there are and wake up all the waiters before exiting. We will
take a spinlock out on the queue before operating on it.
.TH "aac_command_normal" 9 "aac_command_normal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_command_normal \- 	handle commands
.SH SYNOPSIS
.B "unsigned int" aac_command_normal
.BI "(struct aac_queue *" q ");"
.SH ARGUMENTS
.IP "q" 12
 queue to process
.SH "DESCRIPTION"
This DPC routine will be queued when the adapter interrupts us to 
let us know there is a command on our normal priority queue. We will 
pull off all QE there are and wake up all the waiters before exiting.
We will take a spinlock out on the queue before operating on it.
.TH "cap_to_cyls" 9 "cap_to_cyls" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cap_to_cyls \- 
.SH SYNOPSIS
.B "u32" cap_to_cyls
.BI "(sector_t " capacity ","
.BI "u32 " divisor ");"
.SH ARGUMENTS
.IP "capacity" 12
-- undescribed --
.IP "divisor" 12
-- undescribed --
.SH "DESCRIPTION"
accounting for the fact capacity could be a 64 bit value
.TH "aac_queuecommand" 9 "aac_queuecommand" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_queuecommand \- 	queue a SCSI command
.SH SYNOPSIS
.B "int" aac_queuecommand
.BI "(struct scsi_cmnd *" cmd ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "cmd" 12
		SCSI command to queue
.IP "done" 12
		Function to call on command completion
.SH "DESCRIPTION"
Queues a command for execution by the associated Host Adapter.
.SH "TODO"
 unify with \fBaac_scsi_cmd\fP.
.TH "aac_info" 9 "aac_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_info \- 	Returns the host adapter name
.SH SYNOPSIS
.B "const char *" aac_info
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
		Scsi host to report on
.SH "DESCRIPTION"
Returns a static string describing the device in question
.TH "aac_get_driver_ident" 9 "aac_get_driver_ident" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_get_driver_ident \- 
.SH SYNOPSIS
.B "struct aac_driver_ident*" aac_get_driver_ident
.BI "(int " devtype ");"
.SH ARGUMENTS
.IP "devtype" 12
 index into lookup table
.SH "DESCRIPTION"
Returns a pointer to the entry in the driver lookup table.
.TH "aac_biosparm" 9 "aac_biosparm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_biosparm \- 	return BIOS parameters for disk
.SH SYNOPSIS
.B "int" aac_biosparm
.BI "(struct scsi_device *" sdev ","
.BI "struct block_device *" bdev ","
.BI "sector_t " capacity ","
.BI "int *" geom ");"
.SH ARGUMENTS
.IP "sdev" 12
 The scsi device corresponding to the disk
.IP "bdev" 12
 the block device corresponding to the disk
.IP "capacity" 12
 the sector capacity of the disk
.IP "geom" 12
 geometry block to fill in
.SH "DESCRIPTION"
Return the Heads/Sectors/Cylinders BIOS Disk Parameters for Disk.  
The default disk geometry is 64 heads, 32 sectors, and the appropriate 
number of cylinders so as not to exceed drive capacity.  In order for 
disks equal to or larger than 1 GB to be addressable by the BIOS
without exceeding the BIOS limitation of 1024 cylinders, Extended 
Translation should be enabled.   With Extended Translation enabled, 
drives between 1 GB inclusive and 2 GB exclusive are given a disk 
geometry of 128 heads and 32 sectors, and drives above 2 GB inclusive 
are given a disk geometry of 255 heads and 63 sectors.  However, if 
the BIOS detects that the Extended Translation setting does not match 
the geometry in the partition table, then the translation inferred 
from the partition table will be used by the BIOS, and a warning may 
be displayed.
.TH "aac_slave_configure" 9 "aac_slave_configure" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_slave_configure \- 	compute queue depths
.SH SYNOPSIS
.B "int" aac_slave_configure
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	SCSI device we are considering
.SH "DESCRIPTION"
Selects queue depths for each target device based on the host adapter's
total capacity and the queue depth supported by the target device.
A queue depth of one automatically disables tagged queueing.
.TH "aac_cfg_open" 9 "aac_cfg_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_cfg_open \- 	open a configuration file
.SH SYNOPSIS
.B "int" aac_cfg_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
 inode being opened
.IP "file" 12
 file handle attached
.SH "DESCRIPTION"
Called when the configuration device is opened. Does the needed
set up on the handle and then returns
.SH "BUGS"
 This needs extending to check a given adapter is present
so we can support hot plugging, and to ref count adapters.
.TH "aac_cfg_ioctl" 9 "aac_cfg_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_cfg_ioctl \- 	AAC configuration request
.SH SYNOPSIS
.B "int" aac_cfg_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
 inode of device
.IP "file" 12
 file handle
.IP "cmd" 12
 ioctl command code
.IP "arg" 12
 argument
.SH "DESCRIPTION"
Handles a configuration ioctl. Currently this involves wrapping it
up and feeding it into the nasty windowsalike glue layer.
.SH "BUGS"
 Needs to handle hot plugging
.SH "BUGS"
 Needs to handle hot plugging
.TH "aac_sa_disable_interrupt" 9 "aac_sa_disable_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_sa_disable_interrupt \- 	disable interrupt
.SH SYNOPSIS
.B "void" aac_sa_disable_interrupt
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Which adapter to enable.
.TH "aac_sa_notify_adapter" 9 "aac_sa_notify_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_sa_notify_adapter \- 	handle adapter notification
.SH SYNOPSIS
.B "void" aac_sa_notify_adapter
.BI "(struct aac_dev *" dev ","
.BI "u32 " event ");"
.SH ARGUMENTS
.IP "dev" 12
	Adapter that notification is for
.IP "event" 12
	Event to notidy
.SH "DESCRIPTION"
Notify the adapter of an event
.TH "sa_sync_cmd" 9 "sa_sync_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa_sync_cmd \- 	send a command and wait
.SH SYNOPSIS
.B "int" sa_sync_cmd
.BI "(struct aac_dev *" dev ","
.BI "u32 " command ","
.BI "u32 " p1 ","
.BI "u32 " p2 ","
.BI "u32 " p3 ","
.BI "u32 " p4 ","
.BI "u32 " p5 ","
.BI "u32 " p6 ","
.BI "u32 *" ret ","
.BI "u32 *" r1 ","
.BI "u32 *" r2 ","
.BI "u32 *" r3 ","
.BI "u32 *" r4 ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter
.IP "command" 12
 Command to execute
.IP "p1" 12
 first parameter
.IP "p2" 12
-- undescribed --
.IP "p3" 12
-- undescribed --
.IP "p4" 12
-- undescribed --
.IP "p5" 12
-- undescribed --
.IP "p6" 12
-- undescribed --
.IP "ret" 12
 adapter status
.IP "r1" 12
-- undescribed --
.IP "r2" 12
-- undescribed --
.IP "r3" 12
-- undescribed --
.IP "r4" 12
-- undescribed --
.SH "DESCRIPTION"
This routine will send a synchronous command to the adapter and wait 
for its	completion.
.TH "aac_sa_interrupt_adapter" 9 "aac_sa_interrupt_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_sa_interrupt_adapter \- 	interrupt an adapter
.SH SYNOPSIS
.B "void" aac_sa_interrupt_adapter
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Which adapter to enable.
.SH "DESCRIPTION"
Breakpoint an adapter.
.TH "aac_sa_start_adapter" 9 "aac_sa_start_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_sa_start_adapter \- 	activate adapter
.SH SYNOPSIS
.B "void" aac_sa_start_adapter
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Adapter
.SH "DESCRIPTION"
Start up processing on an ARM based AAC adapter
.TH "aac_sa_check_health" 9 "aac_sa_check_health" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_sa_check_health \- 
.SH SYNOPSIS
.B "int" aac_sa_check_health
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to check if healthy
.SH "DESCRIPTION"
Will attempt to determine if the specified adapter is alive and
capable of handling requests, returning 0 if alive.
.TH "aac_sa_init" 9 "aac_sa_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_sa_init \- 	initialize an ARM based AAC card
.SH SYNOPSIS
.B "int" aac_sa_init
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to configure
.SH "DESCRIPTION"
Allocate and set up resources for the ARM based AAC variants. The 
device_interface in the commregion will be allocated and linked 
to the comm region.
.TH "aac_send_shutdown" 9 "aac_send_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_send_shutdown \- 	shutdown an adapter
.SH SYNOPSIS
.B "int" aac_send_shutdown
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Adapter to shutdown
.SH "DESCRIPTION"
This routine will send a VM_CloseAll (shutdown) request to the adapter.
.TH "aac_comm_init" 9 "aac_comm_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aac_comm_init \- 	Initialise FSA data structures
.SH SYNOPSIS
.B "int" aac_comm_init
.BI "(struct aac_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Adapter to initialise
.SH "DESCRIPTION"
Initializes the data structures that are required for the FSA commuication
interface to operate. 
Returns
1 - if we were able to init the commuication interface.
0 - If there were errors initing. This is a fatal error.
.TH "dc390_slave_alloc" 9 "dc390_slave_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc390_slave_alloc \-  Called by the scsi mid layer to tell us about a new
.SH SYNOPSIS
.B "int" dc390_slave_alloc
.BI "(struct scsi_device *" scsi_device ");"
.SH ARGUMENTS
.IP "scsi_device" 12
 The new scsi device that we need to handle.
.SH "DESCRIPTION"
scsi device that we need to deal with.
.TH "dc390_slave_destroy" 9 "dc390_slave_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc390_slave_destroy \-  Called by the scsi mid layer to tell us about a
.SH SYNOPSIS
.B "void" dc390_slave_destroy
.BI "(struct scsi_device *" scsi_device ");"
.SH ARGUMENTS
.IP "scsi_device" 12
 The scsi device that we need to remove.
.SH "DESCRIPTION"
device that is going away.
.TH "dc390_remove_one" 9 "dc390_remove_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dc390_remove_one \-  Called to remove a single instance of the adapter.
.SH SYNOPSIS
.B "void __devexit" dc390_remove_one
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The PCI device to remove.
.SH "DESCRIPTION"
.TH "scsi_done" 9 "scsi_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_done \-  Enqueue the finished SCSI command into the done queue.
.SH SYNOPSIS
.B "void" scsi_done
.BI "(struct scsi_cmnd *" cmd ");"
.SH ARGUMENTS
.IP "cmd" 12
 The SCSI Command for which a low-level device driver (LLDD) gives
ownership back to SCSI Core -- i.e. the LLDD has finished with it.
.SH "DESCRIPTION"
This function is the mid-level's (SCSI Core) interrupt routine, which
regains ownership of the SCSI command (de facto) from a LLDD, and enqueues
the command to the done queue for further processing.

This is the producer of the done queue who enqueues at the tail.

This function is interrupt context safe.
.TH "scsi_softirq" 9 "scsi_softirq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_softirq \-  Perform post-interrupt processing of finished SCSI commands.
.SH SYNOPSIS
.B "void" scsi_softirq
.BI "(struct softirq_action *" h ");"
.SH ARGUMENTS
.IP "h" 12
-- undescribed --
.SH "DESCRIPTION"

This is the consumer of the done queue.

This is called with all interrupts enabled.  This should reduce
interrupt latency, stack depth, and reentrancy of the low-level
drivers.
.TH "scsi_device_get" 9 "scsi_device_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_get \-   get an addition reference to a scsi_device
.SH SYNOPSIS
.B "int" scsi_device_get
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	device to get a reference to
.SH "DESCRIPTION"
Gets a reference to the scsi_device and increments the use count
of the underlying LLDD module.  You must hold host_lock of the
parent Scsi_Host or already have a reference when calling this.
.TH "scsi_device_put" 9 "scsi_device_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_put \-   release a reference to a scsi_device
.SH SYNOPSIS
.B "void" scsi_device_put
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
	device to release a reference on.
.SH "DESCRIPTION"
Release a reference to the scsi_device and decrements the use count
of the underlying LLDD module.  The device is freed once the last
user vanishes.
.TH "starget_for_each_device" 9 "starget_for_each_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
starget_for_each_device \-   helper to walk all devices of a target
.SH SYNOPSIS
.B "void" starget_for_each_device
.BI "(struct scsi_target *" starget ","
.BI "void *" data ","
.BI "void (*" fn ") (struct scsi_device *, void *));"
.SH ARGUMENTS
.IP "starget" 12
	target whose devices we want to iterate over.
.IP "data" 12
-- undescribed --
.IP "fn" 12
-- undescribed --
.SH "DESCRIPTION"
This traverses over each devices of \fIshost\fP.  The devices have
a reference that must be released by scsi_host_put when breaking
out of the loop.
.TH "__scsi_device_lookup_by_target" 9 "__scsi_device_lookup_by_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__scsi_device_lookup_by_target \-  find a device given the target (UNLOCKED)
.SH SYNOPSIS
.B "struct scsi_device *" __scsi_device_lookup_by_target
.BI "(struct scsi_target *" starget ","
.BI "uint " lun ");"
.SH ARGUMENTS
.IP "starget" 12
	SCSI target pointer
.IP "lun" 12
	SCSI Logical Unit Number
.SH "DESCRIPTION"
Looks up the scsi_device with the specified \fIlun\fP for a give
\fIstarget\fP. The returned scsi_device does not have an additional
reference.  You must hold the host's host_lock over this call and
any access to the returned scsi_device.
.SH "NOTE"
  The only reason why drivers would want to use this is because
they're need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup_by_target instead.
.TH "scsi_device_lookup_by_target" 9 "scsi_device_lookup_by_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_lookup_by_target \-  find a device given the target
.SH SYNOPSIS
.B "struct scsi_device *" scsi_device_lookup_by_target
.BI "(struct scsi_target *" starget ","
.BI "uint " lun ");"
.SH ARGUMENTS
.IP "starget" 12
	SCSI target pointer
.IP "lun" 12
	SCSI Logical Unit Number
.SH "DESCRIPTION"
Looks up the scsi_device with the specified \fIchannel\fP, \fIid\fP, \fIlun\fP for a
give host.  The returned scsi_device has an additional reference that
needs to be release with scsi_host_put once you're done with it.
.TH "__scsi_device_lookup" 9 "__scsi_device_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__scsi_device_lookup \-  find a device given the host (UNLOCKED)
.SH SYNOPSIS
.B "struct scsi_device *" __scsi_device_lookup
.BI "(struct Scsi_Host *" shost ","
.BI "uint " channel ","
.BI "uint " id ","
.BI "uint " lun ");"
.SH ARGUMENTS
.IP "shost" 12
	SCSI host pointer
.IP "channel" 12
	SCSI channel (zero if only one channel)
.IP "id" 12
-- undescribed --
.IP "lun" 12
	SCSI Logical Unit Number
.SH "DESCRIPTION"
Looks up the scsi_device with the specified \fIchannel\fP, \fIid\fP, \fIlun\fP for a
give host. The returned scsi_device does not have an additional reference.
You must hold the host's host_lock over this call and any access to the
returned scsi_device.
.SH "NOTE"
  The only reason why drivers would want to use this is because
they're need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup instead.
.TH "scsi_device_lookup" 9 "scsi_device_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_lookup \-  find a device given the host
.SH SYNOPSIS
.B "struct scsi_device *" scsi_device_lookup
.BI "(struct Scsi_Host *" shost ","
.BI "uint " channel ","
.BI "uint " id ","
.BI "uint " lun ");"
.SH ARGUMENTS
.IP "shost" 12
	SCSI host pointer
.IP "channel" 12
	SCSI channel (zero if only one channel)
.IP "id" 12
		SCSI target number (physical unit number)
.IP "lun" 12
	SCSI Logical Unit Number
.SH "DESCRIPTION"
Looks up the scsi_device with the specified \fIchannel\fP, \fIid\fP, \fIlun\fP for a
give host.  The returned scsi_device has an additional reference that
needs to be release with scsi_host_put once you're done with it.
.TH "scsi_device_cancel" 9 "scsi_device_cancel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_device_cancel \-  cancel outstanding IO to this device
.SH SYNOPSIS
.B "int" scsi_device_cancel
.BI "(struct scsi_device *" sdev ","
.BI "int " recovery ");"
.SH ARGUMENTS
.IP "sdev" 12
	Pointer to struct scsi_device
.IP "recovery" 12
	Boolean instructing function to recover device or not.
.TH "ipr_is_ioa_resource" 9 "ipr_is_ioa_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipr_is_ioa_resource \-  Determine if a resource is the IOA
.SH SYNOPSIS
.B "int" ipr_is_ioa_resource
.BI "(struct ipr_resource_entry *" res ");"
.SH ARGUMENTS
.IP "res" 12
	resource entry struct
.SH "RETURN VALUE"
1 if IOA / 0 if not IOA
.TH "ipr_is_af_dasd_device" 9 "ipr_is_af_dasd_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipr_is_af_dasd_device \-  Determine if a resource is an AF DASD
.SH SYNOPSIS
.B "int" ipr_is_af_dasd_device
.BI "(struct ipr_resource_entry *" res ");"
.SH ARGUMENTS
.IP "res" 12
	resource entry struct
.SH "RETURN VALUE"
1 if AF DASD / 0 if not AF DASD
.TH "ipr_is_vset_device" 9 "ipr_is_vset_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipr_is_vset_device \-  Determine if a resource is a VSET
.SH SYNOPSIS
.B "int" ipr_is_vset_device
.BI "(struct ipr_resource_entry *" res ");"
.SH ARGUMENTS
.IP "res" 12
	resource entry struct
.SH "RETURN VALUE"
1 if VSET / 0 if not VSET
.TH "ipr_is_gscsi" 9 "ipr_is_gscsi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipr_is_gscsi \-  Determine if a resource is a generic scsi resource
.SH SYNOPSIS
.B "int" ipr_is_gscsi
.BI "(struct ipr_resource_entry *" res ");"
.SH ARGUMENTS
.IP "res" 12
	resource entry struct
.SH "RETURN VALUE"
1 if GSCSI / 0 if not GSCSI
.TH "ipr_is_device" 9 "ipr_is_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipr_is_device \-  Determine if resource address is that of a device
.SH SYNOPSIS
.B "int" ipr_is_device
.BI "(struct ipr_res_addr *" res_addr ");"
.SH ARGUMENTS
.IP "res_addr" 12
	resource address struct
.SH "RETURN VALUE"
1 if AF / 0 if not AF
.TH "ipr_sdt_is_fmt2" 9 "ipr_sdt_is_fmt2" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipr_sdt_is_fmt2 \-  Determine if a SDT address is in format 2
.SH SYNOPSIS
.B "int" ipr_sdt_is_fmt2
.BI "(u32 " sdt_word ");"
.SH ARGUMENTS
.IP "sdt_word" 12
	SDT address
.SH "RETURN VALUE"
1 if format 2 / 0 if not
.TH "scsi_dev_info_list_add" 9 "scsi_dev_info_list_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_dev_info_list_add \- 
.SH SYNOPSIS
.B "int" scsi_dev_info_list_add
.BI "(int " compatible ","
.BI "char *" vendor ","
.BI "char *" model ","
.BI "char *" strflags ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "compatible" 12
-- undescribed --
.IP "vendor" 12
	vendor string
.IP "model" 12
	model (product) string
.IP "strflags" 12
	integer string
.IP "flags" 12
-- undescribed --
.SH "DESCRIPTION"
Create and add one dev_info entry for \fIvendor\fP, \fImodel\fP, \fIstrflags\fP or
\fIflag\fP. If \fIcompatible\fP, add to the tail of the list, do not space
pad, and set devinfo-&gt;compatible. The scsi_static_device_list entries
are added with \fIcompatible\fP 1 and \fIclfags\fP NULL.
.SH "RETURNS"
 0 OK, -error on failure.
.TH "scsi_dev_info_list_add_str" 9 "scsi_dev_info_list_add_str" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_dev_info_list_add_str \- 
.SH SYNOPSIS
.B "int" scsi_dev_info_list_add_str
.BI "(char *" dev_list ");"
.SH ARGUMENTS
.IP "dev_list" 12
	string of device flags to add
.SH "DESCRIPTION"
Parse dev_list, and add entries to the scsi_dev_info_list.
dev_list is of the form "vendor:product:flag,vendor:product:flag".
dev_list is modified via strsep. Can be called for command line
addition, for proc or mabye a sysfs interface.
.SH "DESCRIPTION"
Parse dev_list, and add entries to the scsi_dev_info_list.
dev_list is of the form "vendor:product:flag,vendor:product:flag".
dev_list is modified via strsep. Can be called for command line
addition, for proc or mabye a sysfs interface.
.SH "RETURNS"
 0 if OK, -error on failure.
.TH "scsi_get_device_flags" 9 "scsi_get_device_flags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_get_device_flags \-  get device specific flags from the dynamic device
.SH SYNOPSIS
.B "int" scsi_get_device_flags
.BI "(struct scsi_device *" sdev ","
.BI "unsigned char *" vendor ","
.BI "unsigned char *" model ");"
.SH ARGUMENTS
.IP "sdev" 12
-- undescribed --
.IP "vendor" 12
	vendor name
.IP "model" 12
	model name
.SH "DESCRIPTION"
Search the scsi_dev_info_list for an entry matching \fIvendor\fP and
\fImodel\fP, if found, return the matching flags value, else return
the host or global default settings.
.SH "DESCRIPTION"
Search the scsi_dev_info_list for an entry matching \fIvendor\fP and
\fImodel\fP, if found, return the matching flags value, else return
the host or global default settings.
.TH "scsi_exit_devinfo" 9 "scsi_exit_devinfo" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_exit_devinfo \- 
.SH SYNOPSIS
.B "void" scsi_exit_devinfo
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
the scsi_dev_info_list.
.TH "scsi_init_devinfo" 9 "scsi_init_devinfo" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_init_devinfo \- 
.SH SYNOPSIS
.B "int __init" scsi_init_devinfo
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
Add command line \fIdev_list\fP entries, then add
scsi_static_device_list entries to the scsi device info list.
.TH "NCR5380_pc_dma_setup" 9 "NCR5380_pc_dma_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_pc_dma_setup \- 	setup ISA DMA
.SH SYNOPSIS
.B "int" NCR5380_pc_dma_setup
.BI "(struct Scsi_Host *" instance ","
.BI "unsigned char *" ptr ","
.BI "unsigned int " count ","
.BI "unsigned char " mode ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter to set up
.IP "ptr" 12
 block to transfer (virtual address)
.IP "count" 12
 number of bytes to transfer
.IP "mode" 12
 DMA controller mode to use
.SH "DESCRIPTION"
Program the DMA controller ready to perform an ISA DMA transfer
on this chip.
.SH "LOCKS"
 takes and releases the ISA DMA lock.
.TH "NCR5380_pc_dma_write_setup" 9 "NCR5380_pc_dma_write_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_pc_dma_write_setup \- 	setup ISA DMA write
.SH SYNOPSIS
.B "int" NCR5380_pc_dma_write_setup
.BI "(struct Scsi_Host *" instance ","
.BI "unsigned char *" src ","
.BI "unsigned int " count ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter to set up
.IP "src" 12
-- undescribed --
.IP "count" 12
 number of bytes to transfer
.SH "DESCRIPTION"
Program the DMA controller ready to perform an ISA DMA write to the
SCSI controller.
.SH "LOCKS"
 called routines take and release the ISA DMA lock.
.TH "NCR5380_pc_dma_read_setup" 9 "NCR5380_pc_dma_read_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_pc_dma_read_setup \- 	setup ISA DMA read
.SH SYNOPSIS
.B "int" NCR5380_pc_dma_read_setup
.BI "(struct Scsi_Host *" instance ","
.BI "unsigned char *" src ","
.BI "unsigned int " count ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter to set up
.IP "src" 12
-- undescribed --
.IP "count" 12
 number of bytes to transfer
.SH "DESCRIPTION"
Program the DMA controller ready to perform an ISA DMA read from the
SCSI controller.
.SH "LOCKS"
 called routines take and release the ISA DMA lock.
.TH "NCR5380_pc_dma_residual" 9 "NCR5380_pc_dma_residual" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NCR5380_pc_dma_residual \- 	return bytes left 
.SH SYNOPSIS
.B "int" NCR5380_pc_dma_residual
.BI "(struct Scsi_Host *" instance ");"
.SH ARGUMENTS
.IP "instance" 12
 adapter
.SH "DESCRIPTION"
Reports the number of bytes left over after the DMA was terminated.
.SH "LOCKS"
 takes and releases the ISA DMA lock.
.TH "scsi_tape_release" 9 "scsi_tape_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_tape_release \-  Called to free the Scsi_Tape structure
.SH SYNOPSIS
.B "void" scsi_tape_release
.BI "(struct kref *" kref ");"
.SH ARGUMENTS
.IP "kref" 12
 pointer to embedded kref
.SH "DESCRIPTION"
st_ref_sem must be held entering this routine.  Because it is
called on last put, you should always use the \fBscsi_tape_get\fP
\fBscsi_tape_put\fP helpers which manipulate the semaphore directly
and never do a direct \fBkref_put\fP.
.TH "fc_remove_host" 9 "fc_remove_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_remove_host \-  called to terminate any fc_transport-related elements
.SH SYNOPSIS
.B "void" fc_remove_host
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
-- undescribed --
.SH "DESCRIPTION"
This routine is expected to be called immediately preceeding the
a driver's call to \fBscsi_remove_host\fP.
.SH "DESCRIPTION"
This routine is expected to be called immediately preceeding the
a driver's call to \fBscsi_remove_host\fP.
.SH "WARNING"
 A driver utilizing the fc_transport, which fails to call
this routine prior to \fBscsi_remote_host\fP, will leave dangling
objects in /sys/class/fc_remote_ports. Access to any of these
objects can result in a system crash !!!
.SH "NOTES"
This routine assumes no locks are held on entry.
.TH "fc_rport_create" 9 "fc_rport_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_rport_create \-  allocates and creates a remote FC port.
.SH SYNOPSIS
.B "struct fc_rport *" fc_rport_create
.BI "(struct Scsi_Host *" shost ","
.BI "int " channel ","
.BI "struct fc_rport_identifiers *" ids ");"
.SH ARGUMENTS
.IP "shost" 12
	scsi host the remote port is connected to.
.IP "channel" 12
	Channel on shost port connected to.
.IP "ids" 12
	The world wide names, fc address, and FC4 port
roles for the remote port.
.SH "DESCRIPTION"
Allocates and creates the remoter port structure, including the
class and sysfs creation.
.SH "NOTES"
This routine assumes no locks are held on entry.
.TH "fc_remote_port_add" 9 "fc_remote_port_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_remote_port_add \-  notifies the fc transport of the existence
.SH SYNOPSIS
.B "struct fc_rport *" fc_remote_port_add
.BI "(struct Scsi_Host *" shost ","
.BI "int " channel ","
.BI "struct fc_rport_identifiers *" ids ");"
.SH ARGUMENTS
.IP "shost" 12
	scsi host the remote port is connected to.
.IP "channel" 12
	Channel on shost port connected to.
.IP "ids" 12
	The world wide names, fc address, and FC4 port
roles for the remote port.
.SH "DESCRIPTION"
The LLDD calls this routine to notify the transport of the existence
of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)
of the port, it's FC address (port_id), and the FC4 roles that are
active for the port.

For ports that are FCP targets (aka scsi targets), the FC transport
maintains consistent target id bindings on behalf of the LLDD.
A consistent target id binding is an assignment of a target id to
a remote port identifier, which persists while the scsi host is
attached. The remote port can disappear, then later reappear, and
it's target id assignment remains the same. This allows for shifts
in FC addressing (if binding by wwpn or wwnn) with no apparent
changes to the scsi subsystem which is based on scsi host number and
target id values.  Bindings are only valid during the attachment of
the scsi host. If the host detaches, then later re-attaches, target
id bindings may change.

This routine is responsible for returning a remote port structure.
The routine will search the list of remote ports it maintains
internally on behalf of consistent target id mappings. If found, the
remote port structure will be reused. Otherwise, a new remote port
structure will be allocated.

Whenever a remote port is allocated, a new fc_remote_port class
device is created.

Should not be called from interrupt context.
.SH "DESCRIPTION"
The LLDD calls this routine to notify the transport of the existence
of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)
of the port, it's FC address (port_id), and the FC4 roles that are
active for the port.

For ports that are FCP targets (aka scsi targets), the FC transport
maintains consistent target id bindings on behalf of the LLDD.
A consistent target id binding is an assignment of a target id to
a remote port identifier, which persists while the scsi host is
attached. The remote port can disappear, then later reappear, and
it's target id assignment remains the same. This allows for shifts
in FC addressing (if binding by wwpn or wwnn) with no apparent
changes to the scsi subsystem which is based on scsi host number and
target id values.  Bindings are only valid during the attachment of
the scsi host. If the host detaches, then later re-attaches, target
id bindings may change.

This routine is responsible for returning a remote port structure.
The routine will search the list of remote ports it maintains
internally on behalf of consistent target id mappings. If found, the
remote port structure will be reused. Otherwise, a new remote port
structure will be allocated.

Whenever a remote port is allocated, a new fc_remote_port class
device is created.

Should not be called from interrupt context.
.SH "NOTES"
This routine assumes no locks are held on entry.
.TH "fc_remote_port_delete" 9 "fc_remote_port_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_remote_port_delete \-  notifies the fc transport that a remote
.SH SYNOPSIS
.B "void" fc_remote_port_delete
.BI "(struct fc_rport *" rport ");"
.SH ARGUMENTS
.IP "rport" 12
	The remote port that no longer exists
.SH "DESCRIPTION"
The LLDD calls this routine to notify the transport that a remote
port is no longer part of the topology. Note: Although a port
may no longer be part of the topology, it may persist in the remote
ports displayed by the fc_host. This is done so that target id
mappings (managed via the remote port structures), are always visible
as long as the mapping is valid, regardless of port state,

If the remote port is not an FCP Target, it will be fully torn down
and deallocated, including the fc_remote_port class device.

If the remote port is an FCP Target, the port structure will be
marked as Not Present, but will remain as long as there is a valid
SCSI target id mapping associated with the port structure. Validity
is determined by the binding type. If binding by wwpn, then the port
structure is always valid and will not be deallocated until the host
is removed.  If binding by wwnn, then the port structure is valid
until another port with the same node name is found in the topology.
If binding by port id (fc address), then the port structure is valid
valid until another port with the same address is identified.

Called from interrupt or normal process context.
.SH "DESCRIPTION"
The LLDD calls this routine to notify the transport that a remote
port is no longer part of the topology. Note: Although a port
may no longer be part of the topology, it may persist in the remote
ports displayed by the fc_host. This is done so that target id
mappings (managed via the remote port structures), are always visible
as long as the mapping is valid, regardless of port state,

If the remote port is not an FCP Target, it will be fully torn down
and deallocated, including the fc_remote_port class device.

If the remote port is an FCP Target, the port structure will be
marked as Not Present, but will remain as long as there is a valid
SCSI target id mapping associated with the port structure. Validity
is determined by the binding type. If binding by wwpn, then the port
structure is always valid and will not be deallocated until the host
is removed.  If binding by wwnn, then the port structure is valid
until another port with the same node name is found in the topology.
If binding by port id (fc address), then the port structure is valid
valid until another port with the same address is identified.

Called from interrupt or normal process context.
.SH "NOTES"
This routine assumes no locks are held on entry.
.TH "fc_remote_port_rolechg" 9 "fc_remote_port_rolechg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_remote_port_rolechg \-  notifies the fc transport that the roles
.SH SYNOPSIS
.B "void" fc_remote_port_rolechg
.BI "(struct fc_rport *" rport ","
.BI "u32 " roles ");"
.SH ARGUMENTS
.IP "rport" 12
	The remote port that changed.
.IP "roles" 12
-- undescribed --
.SH "DESCRIPTION"
The LLDD calls this routine to notify the transport that the roles
on a remote port may have changed. The largest effect of this is
if a port now becomes a FCP Target, it must be allocated a
scsi target id.  If the port is no longer a FCP target, any
scsi target id value assigned to it will persist in case the
role changes back to include FCP Target. No changes in the scsi
midlayer will be invoked if the role changes (in the expectation
that the role will be resumed. If it doesn't normal error processing
will take place).

Should not be called from interrupt context.
.SH "DESCRIPTION"
The LLDD calls this routine to notify the transport that the roles
on a remote port may have changed. The largest effect of this is
if a port now becomes a FCP Target, it must be allocated a
scsi target id.  If the port is no longer a FCP target, any
scsi target id value assigned to it will persist in case the
role changes back to include FCP Target. No changes in the scsi
midlayer will be invoked if the role changes (in the expectation
that the role will be resumed. If it doesn't normal error processing
will take place).

Should not be called from interrupt context.
.SH "NOTES"
This routine assumes no locks are held on entry.
.TH "fc_timeout_blocked_rport" 9 "fc_timeout_blocked_rport" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_timeout_blocked_rport \-  Timeout handler for blocked remote port
.SH SYNOPSIS
.B "void" fc_timeout_blocked_rport
.BI "(void *" data ");"
.SH ARGUMENTS
.IP "data" 12
	scsi target that failed to reappear in the alloted time.
.SH "DESCRIPTION"
that fails to return in the alloted time.
.TH "fc_remote_port_block" 9 "fc_remote_port_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_remote_port_block \-  temporarily block any scsi traffic to a remote port.
.SH SYNOPSIS
.B "int" fc_remote_port_block
.BI "(struct fc_rport *" rport ");"
.SH ARGUMENTS
.IP "rport" 12
	remote port to be blocked.
.SH "DESCRIPTION"
scsi lldd's with a FC transport call this routine to temporarily stop
all scsi traffic to a remote port. If the port is not a SCSI target,
no action is taken. If the port is a SCSI target, all attached devices
are placed into a SDEV_BLOCK state and a timer is started. The timer is
represents the maximum amount of time the port may be blocked. If the
timer expires, the port is considered non-existent and the attached
scsi devices will be removed.

Called from interrupt or normal process context.

Returns zero if successful or error if not
.SH "NOTES"
This routine assumes no locks are held on entry.

The timeout and timer types are extracted from the fc transport 
attributes from the caller's rport pointer.
.TH "fc_remote_port_unblock" 9 "fc_remote_port_unblock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_remote_port_unblock \-  restart any blocked scsi traffic to a remote port.
.SH SYNOPSIS
.B "void" fc_remote_port_unblock
.BI "(struct fc_rport *" rport ");"
.SH ARGUMENTS
.IP "rport" 12
	remote port to be unblocked.
.SH "DESCRIPTION"
scsi lld's with a FC transport call this routine to restart IO to all
devices associated with the caller's scsi target following a fc_target_block
request.  Called from interrupt or normal process context.
.SH "NOTES"
This routine assumes no locks are held on entry.
.TH "fc_scsi_scan_rport" 9 "fc_scsi_scan_rport" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fc_scsi_scan_rport \-  called to perform a scsi scan on a remote port.
.SH SYNOPSIS
.B "void" fc_scsi_scan_rport
.BI "(void *" data ");"
.SH ARGUMENTS
.IP "data" 12
	remote port to be scanned.
.TH "sas_remove_host" 9 "sas_remove_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_remove_host \- -  tear down a Scsi_Host's SAS data structures
.SH SYNOPSIS
.B "void" sas_remove_host
.BI "(struct Scsi_Host *" shost ");"
.SH ARGUMENTS
.IP "shost" 12
	Scsi Host that is torn down
.SH "DESCRIPTION"
Removes all SAS PHYs and remote PHYs for a given Scsi_Host.
Must be called just before scsi_remove_host for SAS HBAs.
.TH "sas_phy_alloc" 9 "sas_phy_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_phy_alloc \- -  allocates and initialize a SAS PHY structure
.SH SYNOPSIS
.B "struct sas_phy *" sas_phy_alloc
.BI "(struct device *" parent ","
.BI "int " number ");"
.SH ARGUMENTS
.IP "parent" 12
	Parent device
.IP "number" 12
	Port number
.SH "DESCRIPTION"
Allocates an SAS PHY structure.  It will be added in the device tree
below the device specified by \fIparent\fP, which has to be either a Scsi_Host
or sas_rphy.
.SH "RETURNS"
SAS PHY allocated or NULL if the allocation failed.
.TH "sas_phy_add" 9 "sas_phy_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_phy_add \- -  add a SAS PHY to the device hierachy
.SH SYNOPSIS
.B "int" sas_phy_add
.BI "(struct sas_phy *" phy ");"
.SH ARGUMENTS
.IP "phy" 12
	The PHY to be added
.SH "DESCRIPTION"
Publishes a SAS PHY to the rest of the system.
.TH "sas_phy_free" 9 "sas_phy_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_phy_free \- -  free a SAS PHY
.SH SYNOPSIS
.B "void" sas_phy_free
.BI "(struct sas_phy *" phy ");"
.SH ARGUMENTS
.IP "phy" 12
	SAS PHY to free
.SH "DESCRIPTION"
Frees the specified SAS PHY.
.SH "NOTE"
This function must only be called on a PHY that has not
sucessfully been added using \fBsas_phy_add\fP.
.TH "sas_phy_delete" 9 "sas_phy_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_phy_delete \- -  remove SAS PHY
.SH SYNOPSIS
.B "void" sas_phy_delete
.BI "(struct sas_phy *" phy ");"
.SH ARGUMENTS
.IP "phy" 12
	SAS PHY to remove
.SH "DESCRIPTION"
Removes the specified SAS PHY.  If the SAS PHY has an
associated remote PHY it is removed before.
.TH "scsi_is_sas_phy" 9 "scsi_is_sas_phy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_is_sas_phy \- -  check if a struct device represents a SAS PHY
.SH SYNOPSIS
.B "int" scsi_is_sas_phy
.BI "(const struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device to check
.SH "RETURNS"
1 if the device represents a SAS PHY, 0 else
.TH "sas_rphy_alloc" 9 "sas_rphy_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_rphy_alloc \- -  allocates and initialize a SAS remote PHY structure
.SH SYNOPSIS
.B "struct sas_rphy *" sas_rphy_alloc
.BI "(struct sas_phy *" parent ");"
.SH ARGUMENTS
.IP "parent" 12
		SAS PHY this remote PHY is conneted to
.SH "DESCRIPTION"
Allocates an SAS remote PHY structure, connected to \fIparent\fP.
.SH "RETURNS"
SAS PHY allocated or NULL if the allocation failed.
.TH "sas_rphy_add" 9 "sas_rphy_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_rphy_add \- -  add a SAS remote PHY to the device hierachy
.SH SYNOPSIS
.B "int" sas_rphy_add
.BI "(struct sas_rphy *" rphy ");"
.SH ARGUMENTS
.IP "rphy" 12
	The remote PHY to be added
.SH "DESCRIPTION"
Publishes a SAS remote PHY to the rest of the system.
.TH "sas_rphy_free" 9 "sas_rphy_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_rphy_free \- -  free a SAS remote PHY
.SH SYNOPSIS
.B "void" sas_rphy_free
.BI "(struct sas_rphy *" rphy ");"
.SH ARGUMENTS
.IP "rphy" 12
-- undescribed --
.SH "DESCRIPTION"
\fIrphy\fP	SAS remote PHY to free

Frees the specified SAS remote PHY.
.SH "NOTE"
This function must only be called on a remote
PHY that has not sucessfully been added using
\fBsas_rphy_add\fP.
.TH "sas_rphy_delete" 9 "sas_rphy_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_rphy_delete \- -  remove SAS remote PHY
.SH SYNOPSIS
.B "void" sas_rphy_delete
.BI "(struct sas_rphy *" rphy ");"
.SH ARGUMENTS
.IP "rphy" 12
	SAS remote PHY to remove
.SH "DESCRIPTION"
Removes the specified SAS remote PHY.
.TH "scsi_is_sas_rphy" 9 "scsi_is_sas_rphy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
scsi_is_sas_rphy \- -  check if a struct device represents a SAS remote PHY
.SH SYNOPSIS
.B "int" scsi_is_sas_rphy
.BI "(const struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device to check
.SH "RETURNS"
1 if the device represents a SAS remote PHY, 0 else
.TH "sas_attach_transport" 9 "sas_attach_transport" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_attach_transport \- -  instantiate SAS transport template
.SH SYNOPSIS
.B "struct scsi_transport_template *" sas_attach_transport
.BI "(struct sas_function_template *" ft ");"
.SH ARGUMENTS
.IP "ft" 12
		SAS transport class function template
.TH "sas_release_transport" 9 "sas_release_transport" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sas_release_transport \- -  release SAS transport template instance
.SH SYNOPSIS
.B "void" sas_release_transport
.BI "(struct scsi_transport_template *" t ");"
.SH ARGUMENTS
.IP "t" 12
		transport template instance
.TH "fas216_get_last_msg" 9 "fas216_get_last_msg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_get_last_msg \-  retrive last message from the list
.SH SYNOPSIS
.B "unsigned short" fas216_get_last_msg
.BI "(FAS216_Info *" info ","
.BI "int " pos ");"
.SH ARGUMENTS
.IP "info" 12
 interface to search
.IP "pos" 12
 current fifo position
.SH "DESCRIPTION"
Retrieve a last message from the list, using position in fifo.
.TH "fas216_syncperiod" 9 "fas216_syncperiod" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_syncperiod \-  calculate STP register value
.SH SYNOPSIS
.B "int" fas216_syncperiod
.BI "(FAS216_Info *" info ","
.BI "int " ns ");"
.SH ARGUMENTS
.IP "info" 12
 state structure for interface connected to device
.IP "ns" 12
 period in ns (between subsequent bytes)
.SH "DESCRIPTION"
Calculate value to be loaded into the STP register for a given period
in ns. Returns a value suitable for REG_STP.
.TH "fas216_set_sync" 9 "fas216_set_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_set_sync \-  setup FAS216 chip for specified transfer period.
.SH SYNOPSIS
.B "void" fas216_set_sync
.BI "(FAS216_Info *" info ","
.BI "int " target ");"
.SH ARGUMENTS
.IP "info" 12
 state structure for interface connected to device
.IP "target" 12
 target
.SH "DESCRIPTION"
Correctly setup FAS216 chip for specified transfer period.
.SH "NOTES   "
 we need to switch the chip out of FASTSCSI mode if we have
a transfer period &gt;= 200ns - otherwise the chip will violate
the SCSI timings.
.TH "fas216_handlesync" 9 "fas216_handlesync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_handlesync \-  Handle a synchronous transfer message
.SH SYNOPSIS
.B "void" fas216_handlesync
.BI "(FAS216_Info *" info ","
.BI "char *" msg ");"
.SH ARGUMENTS
.IP "info" 12
 state structure for interface
.IP "msg" 12
 message from target
.SH "DESCRIPTION"
Handle a synchronous transfer message from the target
.TH "fas216_updateptrs" 9 "fas216_updateptrs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_updateptrs \-  update data pointers after transfer suspended/paused
.SH SYNOPSIS
.B "void" fas216_updateptrs
.BI "(FAS216_Info *" info ","
.BI "int " bytes_transferred ");"
.SH ARGUMENTS
.IP "info" 12
 interface's local pointer to update
.IP "bytes_transferred" 12
 number of bytes transferred
.SH "DESCRIPTION"
Update data pointers after transfer suspended/paused
.TH "fas216_pio" 9 "fas216_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_pio \-  transfer data off of/on to card using programmed IO
.SH SYNOPSIS
.B "void" fas216_pio
.BI "(FAS216_Info *" info ","
.BI "fasdmadir_t " direction ");"
.SH ARGUMENTS
.IP "info" 12
 interface to transfer data to/from
.IP "direction" 12
 direction to transfer data (DMA_OUT/DMA_IN)
.SH "DESCRIPTION"
Transfer data off of/on to card using programmed IO.
.SH "NOTES"
 this is incredibly slow.
.TH "fas216_cleanuptransfer" 9 "fas216_cleanuptransfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_cleanuptransfer \-  clean up after a transfer has completed.
.SH SYNOPSIS
.B "void" fas216_cleanuptransfer
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface to clean up
.SH "DESCRIPTION"
Update the data pointers according to the number of bytes transferred
on the SCSI bus.
.TH "fas216_transfer" 9 "fas216_transfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_transfer \-  Perform a DMA/PIO transfer off of/on to card
.SH SYNOPSIS
.B "void" fas216_transfer
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface from which device disconnected from
.SH "DESCRIPTION"
Start a DMA/PIO transfer off of/on to card
.TH "fas216_stoptransfer" 9 "fas216_stoptransfer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_stoptransfer \-  Stop a DMA transfer onto / off of the card
.SH SYNOPSIS
.B "void" fas216_stoptransfer
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface from which device disconnected from
.SH "DESCRIPTION"
Called when we switch away from DATA IN or DATA OUT phases.
.TH "fas216_disconnect_intr" 9 "fas216_disconnect_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_disconnect_intr \-  handle device disconnection
.SH SYNOPSIS
.B "void" fas216_disconnect_intr
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface from which device disconnected from
.SH "DESCRIPTION"
Handle device disconnection
.TH "fas216_reselected_intr" 9 "fas216_reselected_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_reselected_intr \-  start reconnection of a device
.SH SYNOPSIS
.B "void" fas216_reselected_intr
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface which was reselected
.SH "DESCRIPTION"
Start reconnection of a device
.TH "fas216_message" 9 "fas216_message" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_message \-  handle a function done interrupt from FAS216 chip
.SH SYNOPSIS
.B "void" fas216_message
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface which caused function done interrupt
.SH "DESCRIPTION"
Handle a function done interrupt from FAS216 chip
.TH "fas216_send_command" 9 "fas216_send_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_send_command \-  send command after all message bytes have been sent
.SH SYNOPSIS
.B "void" fas216_send_command
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface which caused bus service
.SH "DESCRIPTION"
Send a command to a target after all message bytes have been sent
.TH "fas216_send_messageout" 9 "fas216_send_messageout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_send_messageout \-  handle bus service to send a message
.SH SYNOPSIS
.B "void" fas216_send_messageout
.BI "(FAS216_Info *" info ","
.BI "int " start ");"
.SH ARGUMENTS
.IP "info" 12
 interface which caused bus service
.IP "start" 12
-- undescribed --
.SH "DESCRIPTION"
Handle bus service to send a message.
.SH "NOTE"
 We do not allow the device to change the data direction!
.TH "fas216_busservice_intr" 9 "fas216_busservice_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_busservice_intr \-  handle bus service interrupt from FAS216 chip
.SH SYNOPSIS
.B "void" fas216_busservice_intr
.BI "(FAS216_Info *" info ","
.BI "unsigned int " stat ","
.BI "unsigned int " is ");"
.SH ARGUMENTS
.IP "info" 12
 interface which caused bus service interrupt
.IP "stat" 12
 Status register contents
.IP "is" 12
 SCSI Status register contents
.SH "DESCRIPTION"
Handle a bus service interrupt from FAS216 chip
.TH "fas216_funcdone_intr" 9 "fas216_funcdone_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_funcdone_intr \-  handle a function done interrupt from FAS216 chip
.SH SYNOPSIS
.B "void" fas216_funcdone_intr
.BI "(FAS216_Info *" info ","
.BI "unsigned int " stat ","
.BI "unsigned int " is ");"
.SH ARGUMENTS
.IP "info" 12
 interface which caused function done interrupt
.IP "stat" 12
 Status register contents
.IP "is" 12
 SCSI Status register contents
.SH "DESCRIPTION"
Handle a function done interrupt from FAS216 chip
.TH "fas216_intr" 9 "fas216_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_intr \-  handle interrupts to progress a command
.SH SYNOPSIS
.B "irqreturn_t" fas216_intr
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 interface to service
.SH "DESCRIPTION"
Handle interrupts from the interface to progress a command
.TH "fas216_kick" 9 "fas216_kick" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_kick \-  kick a command to the interface
.SH SYNOPSIS
.B "void" fas216_kick
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 our host interface to kick
.SH "DESCRIPTION"
Kick a command to the interface, interface should be idle.
.SH "NOTES"
 Interrupts are always disabled!
.TH "fas216_rq_sns_done" 9 "fas216_rq_sns_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_rq_sns_done \-  Finish processing automatic request sense command
.SH SYNOPSIS
.B "void" fas216_rq_sns_done
.BI "(FAS216_Info *" info ","
.BI "Scsi_Cmnd *" SCpnt ","
.BI "unsigned int " result ");"
.SH ARGUMENTS
.IP "info" 12
 interface that completed
.IP "SCpnt" 12
 command that completed
.IP "result" 12
 driver byte of result
.SH "DESCRIPTION"
Finish processing automatic request sense command
.TH "fas216_std_done" 9 "fas216_std_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_std_done \-  finish processing of standard command
.SH SYNOPSIS
.B "void" fas216_std_done
.BI "(FAS216_Info *" info ","
.BI "Scsi_Cmnd *" SCpnt ","
.BI "unsigned int " result ");"
.SH ARGUMENTS
.IP "info" 12
 interface that completed
.IP "SCpnt" 12
 command that completed
.IP "result" 12
 driver byte of result
.SH "DESCRIPTION"
Finish processing of standard command
.TH "fas216_done" 9 "fas216_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_done \-  complete processing for current command
.SH SYNOPSIS
.B "void" fas216_done
.BI "(FAS216_Info *" info ","
.BI "unsigned int " result ");"
.SH ARGUMENTS
.IP "info" 12
 interface that completed
.IP "result" 12
 driver byte of result
.SH "DESCRIPTION"
Complete processing for current command
.TH "fas216_queue_command" 9 "fas216_queue_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_queue_command \-  queue a command for adapter to process.
.SH SYNOPSIS
.B "int" fas216_queue_command
.BI "(Scsi_Cmnd *" SCpnt ","
.BI "void (*" done ") (Scsi_Cmnd *));"
.SH ARGUMENTS
.IP "SCpnt" 12
 Command to queue
.IP "done" 12
 done function to call once command is complete
.SH "DESCRIPTION"
Queue a command for adapter to process.
.SH "RETURNS"
 0 on success, else error.
.SH "NOTES"
 io_request_lock is held, interrupts are disabled.
.TH "fas216_internal_done" 9 "fas216_internal_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_internal_done \-  trigger restart of a waiting thread in fas216_noqueue_command
.SH SYNOPSIS
.B "void" fas216_internal_done
.BI "(Scsi_Cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 Command to wake
.SH "DESCRIPTION"
Trigger restart of a waiting thread in fas216_command
.TH "fas216_noqueue_command" 9 "fas216_noqueue_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_noqueue_command \-  process a command for the adapter.
.SH SYNOPSIS
.B "int" fas216_noqueue_command
.BI "(Scsi_Cmnd *" SCpnt ","
.BI "void (*" done ") (Scsi_Cmnd *));"
.SH ARGUMENTS
.IP "SCpnt" 12
 Command to queue
.IP "done" 12
-- undescribed --
.SH "DESCRIPTION"
Queue a command for adapter to process.
.SH "RETURNS"
 scsi result code.
.SH "NOTES"
 io_request_lock is held, interrupts are disabled.
.TH "fas216_find_command" 9 "fas216_find_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_find_command \-  decide how to abort a command
.SH SYNOPSIS
.B "enum res_find" fas216_find_command
.BI "(FAS216_Info *" info ","
.BI "Scsi_Cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.IP "SCpnt" 12
 command to abort
.SH "DESCRIPTION"
Decide how to abort a command.
.SH "RETURNS"
 abort status
.TH "fas216_eh_abort" 9 "fas216_eh_abort" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_eh_abort \-  abort this command
.SH SYNOPSIS
.B "int" fas216_eh_abort
.BI "(Scsi_Cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 command to abort
.SH "DESCRIPTION"
Abort this command.
.SH "RETURNS"
 FAILED if unable to abort
.SH "NOTES"
 io_request_lock is taken, and irqs are disabled
.TH "fas216_eh_device_reset" 9 "fas216_eh_device_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_eh_device_reset \-  Reset the device associated with this command
.SH SYNOPSIS
.B "int" fas216_eh_device_reset
.BI "(Scsi_Cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 command specifing device to reset
.SH "DESCRIPTION"
Reset the device associated with this command.
.SH "RETURNS"
 FAILED if unable to reset.
.SH "NOTES"
 We won't be re-entered, so we'll only have one device
reset on the go at one time.
.TH "fas216_eh_bus_reset" 9 "fas216_eh_bus_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_eh_bus_reset \-  Reset the bus associated with the command
.SH SYNOPSIS
.B "int" fas216_eh_bus_reset
.BI "(Scsi_Cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 command specifing bus to reset
.SH "DESCRIPTION"
Reset the bus associated with the command.
.SH "RETURNS"
 FAILED if unable to reset.
.SH "NOTES"
 Further commands are blocked.
.TH "fas216_init_chip" 9 "fas216_init_chip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_init_chip \-  Initialise FAS216 state after reset
.SH SYNOPSIS
.B "void" fas216_init_chip
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 state structure for interface
.SH "DESCRIPTION"
Initialise FAS216 state after reset
.TH "fas216_eh_host_reset" 9 "fas216_eh_host_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_eh_host_reset \-  Reset the host associated with this command
.SH SYNOPSIS
.B "int" fas216_eh_host_reset
.BI "(Scsi_Cmnd *" SCpnt ");"
.SH ARGUMENTS
.IP "SCpnt" 12
 command specifing host to reset
.SH "DESCRIPTION"
Reset the host associated with this command.
.SH "RETURNS"
 FAILED if unable to reset.
.SH "NOTES"
 io_request_lock is taken, and irqs are disabled
.TH "fas216_reset_state" 9 "fas216_reset_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_reset_state \-  Initialise driver internal state
.SH SYNOPSIS
.B "void" fas216_reset_state
.BI "(FAS216_Info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 state to initialise
.SH "DESCRIPTION"
Initialise driver internal state
.TH "fas216_init" 9 "fas216_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_init \-  initialise FAS/NCR/AMD SCSI structures.
.SH SYNOPSIS
.B "int" fas216_init
.BI "(struct Scsi_Host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 a driver-specific filled-out structure
.SH "DESCRIPTION"
Initialise FAS/NCR/AMD SCSI structures.
.SH "RETURNS"
 0 on success
.TH "fas216_add" 9 "fas216_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_add \-  initialise FAS/NCR/AMD SCSI ic.
.SH SYNOPSIS
.B "int" fas216_add
.BI "(struct Scsi_Host *" host ","
.BI "struct device *" dev ");"
.SH ARGUMENTS
.IP "host" 12
 a driver-specific filled-out structure
.IP "dev" 12
 parent device
.SH "DESCRIPTION"
Initialise FAS/NCR/AMD SCSI ic.
.SH "RETURNS"
 0 on success
.TH "fas216_release" 9 "fas216_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fas216_release \-  release all resources for FAS/NCR/AMD SCSI ic.
.SH SYNOPSIS
.B "void" fas216_release
.BI "(struct Scsi_Host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 a driver-specific filled-out structure
.SH "DESCRIPTION"
release all resources and put everything to bed for FAS/NCR/AMD SCSI ic.
.TH "ata_std_bios_param" 9 "ata_std_bios_param" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_std_bios_param \-  generic bios head/sector/cylinder calculator used by sd.
.SH SYNOPSIS
.B "int" ata_std_bios_param
.BI "(struct scsi_device *" sdev ","
.BI "struct block_device *" bdev ","
.BI "sector_t " capacity ","
.BI "int " geom[] ");"
.SH ARGUMENTS
.IP "sdev" 12
 SCSI device for which BIOS geometry is to be determined
.IP "bdev" 12
 block device associated with \fIsdev\fP
.IP "capacity" 12
 capacity of SCSI device
.IP "geom[]" 12
 location to which geometry will be output
.SH "DESCRIPTION"
Generic bios head/sector/cylinder calculator
used by sd. Most BIOSes nowadays expect a XXX/255/16  (CHS)
mapping. Some situations may arise where the disk is not
bootable if this is not used.
.SH "LOCKING"
Defined by the SCSI layer.  We don't really care.
.SH "RETURNS"
Zero.
.TH "ata_scsi_qc_new" 9 "ata_scsi_qc_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_qc_new \-  acquire new ata_queued_cmd reference
.SH SYNOPSIS
.B "struct ata_queued_cmd *" ata_scsi_qc_new
.BI "(struct ata_port *" ap ","
.BI "struct ata_device *" dev ","
.BI "struct scsi_cmnd *" cmd ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "ap" 12
 ATA port to which the new command is attached
.IP "dev" 12
 ATA device to which the new command is attached
.IP "cmd" 12
 SCSI command that originated this ATA command
.IP "done" 12
 SCSI command completion function
.SH "DESCRIPTION"
Obtain a reference to an unused ata_queued_cmd structure,
which is the basic libata structure representing a single
ATA command sent to the hardware.

If a command was available, fill in the SCSI-specific
portions of the structure with information on the
current command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Command allocated, or NULL if none available.
.TH "ata_to_sense_error" 9 "ata_to_sense_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_to_sense_error \-  convert ATA error to SCSI error
.SH SYNOPSIS
.B "void" ata_to_sense_error
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 " drv_stat ");"
.SH ARGUMENTS
.IP "qc" 12
 Command that we are erroring out
.IP "drv_stat" 12
 value contained in ATA status register
.SH "DESCRIPTION"
Converts an ATA error into a SCSI error. While we are at it
we decode and dump the ATA error for the user so that they
have some idea what really happened at the non make-believe
layer.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsi_slave_config" 9 "ata_scsi_slave_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_slave_config \-  Set SCSI device attributes
.SH SYNOPSIS
.B "int" ata_scsi_slave_config
.BI "(struct scsi_device *" sdev ");"
.SH ARGUMENTS
.IP "sdev" 12
 SCSI device to examine
.SH "DESCRIPTION"
This is called before we actually start reading
and writing to the device, to configure certain
SCSI mid-layer behaviors.
.SH "LOCKING"
Defined by SCSI layer.  We don't really care.
.TH "ata_scsi_error" 9 "ata_scsi_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_error \-  SCSI layer error handler callback
.SH SYNOPSIS
.B "int" ata_scsi_error
.BI "(struct Scsi_Host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 SCSI host on which error occurred
.SH "DESCRIPTION"
Handles SCSI-layer-thrown error events.
.SH "LOCKING"
Inherited from SCSI layer (none, can sleep)
.SH "RETURNS"
Zero.
.TH "ata_scsi_start_stop_xlat" 9 "ata_scsi_start_stop_xlat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_start_stop_xlat \-  Translate SCSI START STOP UNIT command
.SH SYNOPSIS
.B "unsigned int" ata_scsi_start_stop_xlat
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 *" scsicmd ");"
.SH ARGUMENTS
.IP "qc" 12
 Storage for translated ATA taskfile
.IP "scsicmd" 12
 SCSI command to translate
.SH "DESCRIPTION"
Sets up an ATA taskfile to issue STANDBY (to stop) or READ VERIFY
(to start). Perhaps these commands should be preceded by
CHECK POWER MODE to see what power mode the device is already in.
[See SAT revision 5 at www.t10.org]
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, non-zero on error.
.TH "ata_scsi_flush_xlat" 9 "ata_scsi_flush_xlat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_flush_xlat \-  Translate SCSI SYNCHRONIZE CACHE command
.SH SYNOPSIS
.B "unsigned int" ata_scsi_flush_xlat
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 *" scsicmd ");"
.SH ARGUMENTS
.IP "qc" 12
 Storage for translated ATA taskfile
.IP "scsicmd" 12
 SCSI command to translate (ignored)
.SH "DESCRIPTION"
Sets up an ATA taskfile to issue FLUSH CACHE or
FLUSH CACHE EXT.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, non-zero on error.
.TH "ata_scsi_verify_xlat" 9 "ata_scsi_verify_xlat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_verify_xlat \-  Translate SCSI VERIFY command into an ATA one
.SH SYNOPSIS
.B "unsigned int" ata_scsi_verify_xlat
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 *" scsicmd ");"
.SH ARGUMENTS
.IP "qc" 12
 Storage for translated ATA taskfile
.IP "scsicmd" 12
 SCSI command to translate
.SH "DESCRIPTION"
Converts SCSI VERIFY command to an ATA READ VERIFY command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, non-zero on error.
.TH "ata_scsi_rw_xlat" 9 "ata_scsi_rw_xlat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_rw_xlat \-  Translate SCSI r/w command into an ATA one
.SH SYNOPSIS
.B "unsigned int" ata_scsi_rw_xlat
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 *" scsicmd ");"
.SH ARGUMENTS
.IP "qc" 12
 Storage for translated ATA taskfile
.IP "scsicmd" 12
 SCSI command to translate
.SH "DESCRIPTION"
Converts any of six SCSI read/write commands into the
ATA counterpart, including starting sector (LBA),
sector count, and taking into account the device's LBA48
support.

Commands READ_6, READ_10, READ_16, WRITE_6, WRITE_10, and
WRITE_16 are currently supported.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, non-zero on error.
.TH "ata_scsi_translate" 9 "ata_scsi_translate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_translate \-  Translate then issue SCSI command to ATA device
.SH SYNOPSIS
.B "void" ata_scsi_translate
.BI "(struct ata_port *" ap ","
.BI "struct ata_device *" dev ","
.BI "struct scsi_cmnd *" cmd ","
.BI "void (*" done ") (struct scsi_cmnd *),"
.BI "ata_xlat_func_t " xlat_func ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA port to which the command is addressed
.IP "dev" 12
 ATA device to which the command is addressed
.IP "cmd" 12
 SCSI command to execute
.IP "done" 12
 SCSI command completion function
.IP "xlat_func" 12
 Actor which translates \fIcmd\fP to an ATA taskfile
.SH "DESCRIPTION"
Our -&gt;\fBqueuecommand\fP function has decided that the SCSI
command issued can be directly translated into an ATA
command, rather than handled internally.

This function sets up an ata_queued_cmd structure for the
SCSI command, and sends that ata_queued_cmd to the hardware.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsi_rbuf_get" 9 "ata_scsi_rbuf_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_rbuf_get \-  Map response buffer.
.SH SYNOPSIS
.B "unsigned int" ata_scsi_rbuf_get
.BI "(struct scsi_cmnd *" cmd ","
.BI "u8 **" buf_out ");"
.SH ARGUMENTS
.IP "cmd" 12
 SCSI command containing buffer to be mapped.
.IP "buf_out" 12
 Pointer to mapped area.
.SH "DESCRIPTION"
Maps buffer contained within SCSI command \fIcmd\fP.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Length of response buffer.
.TH "ata_scsi_rbuf_put" 9 "ata_scsi_rbuf_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_rbuf_put \-  Unmap response buffer.
.SH SYNOPSIS
.B "void" ata_scsi_rbuf_put
.BI "(struct scsi_cmnd *" cmd ","
.BI "u8 *" buf ");"
.SH ARGUMENTS
.IP "cmd" 12
 SCSI command containing buffer to be unmapped.
.IP "buf" 12
 buffer to unmap
.SH "DESCRIPTION"
Unmaps response buffer contained within \fIcmd\fP.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsi_rbuf_fill" 9 "ata_scsi_rbuf_fill" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_rbuf_fill \-  wrapper for SCSI command simulators
.SH SYNOPSIS
.B "void" ata_scsi_rbuf_fill
.BI "(struct ata_scsi_args *" args ","
.BI "unsigned int (*" actor ") (struct ata_scsi_args *args, 			     		   u8 *rbuf, unsigned int buflen));"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "actor" 12
 Callback hook for desired SCSI command simulator
.SH "DESCRIPTION"
Takes care of the hard work of simulating a SCSI command...
Mapping the response buffer, calling the command's handler,
and handling the handler's return value.  This return value
indicates whether the handler wishes the SCSI command to be
completed successfully, or not.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsiop_inq_std" 9 "ata_scsiop_inq_std" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_inq_std \-  Simulate INQUIRY command
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_inq_std
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
Returns standard device identification data associated
with non-EVPD INQUIRY command output.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsiop_inq_00" 9 "ata_scsiop_inq_00" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_inq_00 \-  Simulate INQUIRY EVPD page 0, list of pages
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_inq_00
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
Returns list of inquiry EVPD pages available.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsiop_inq_80" 9 "ata_scsiop_inq_80" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_inq_80 \-  Simulate INQUIRY EVPD page 80, device serial number
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_inq_80
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
Returns ATA device serial number.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsiop_inq_83" 9 "ata_scsiop_inq_83" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_inq_83 \-  Simulate INQUIRY EVPD page 83, device identity
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_inq_83
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
Returns device identification.  Currently hardcoded to
return "Linux ATA-SCSI simulator".
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsiop_noop" 9 "ata_scsiop_noop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_noop \-  Command handler that simply returns success.
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_noop
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
No operation.  Simply returns success to caller, to indicate
that the caller should successfully complete this SCSI command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_msense_push" 9 "ata_msense_push" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_msense_push \-  Push data onto MODE SENSE data output buffer
.SH SYNOPSIS
.B "void" ata_msense_push
.BI "(u8 **" ptr_io ","
.BI "const u8 *" last ","
.BI "const u8 *" buf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "ptr_io" 12
 (input/output) Location to store more output data
.IP "last" 12
 End of output data buffer
.IP "buf" 12
 Pointer to BLOB being added to output buffer
.IP "buflen" 12
 Length of BLOB
.SH "DESCRIPTION"
Store MODE SENSE data on an output buffer.
.SH "LOCKING"
None.
.TH "ata_msense_caching" 9 "ata_msense_caching" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_msense_caching \-  Simulate MODE SENSE caching info page
.SH SYNOPSIS
.B "unsigned int" ata_msense_caching
.BI "(u16 *" id ","
.BI "u8 **" ptr_io ","
.BI "const u8 *" last ");"
.SH ARGUMENTS
.IP "id" 12
 device IDENTIFY data
.IP "ptr_io" 12
 (input/output) Location to store more output data
.IP "last" 12
 End of output data buffer
.SH "DESCRIPTION"
Generate a caching info page, which conditionally indicates
write caching to the SCSI layer, depending on device
capabilities.
.SH "LOCKING"
None.
.TH "ata_msense_ctl_mode" 9 "ata_msense_ctl_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_msense_ctl_mode \-  Simulate MODE SENSE control mode page
.SH SYNOPSIS
.B "unsigned int" ata_msense_ctl_mode
.BI "(u8 **" ptr_io ","
.BI "const u8 *" last ");"
.SH ARGUMENTS
.IP "ptr_io" 12
 (input/output) Location to store more output data
.IP "last" 12
 End of output data buffer
.SH "DESCRIPTION"
Generate a generic MODE SENSE control mode page.
.SH "LOCKING"
None.
.TH "ata_msense_rw_recovery" 9 "ata_msense_rw_recovery" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_msense_rw_recovery \-  Simulate MODE SENSE r/w error recovery page
.SH SYNOPSIS
.B "unsigned int" ata_msense_rw_recovery
.BI "(u8 **" ptr_io ","
.BI "const u8 *" last ");"
.SH ARGUMENTS
.IP "ptr_io" 12
 (input/output) Location to store more output data
.IP "last" 12
 End of output data buffer
.SH "DESCRIPTION"
Generate a generic MODE SENSE r/w error recovery page.
.SH "LOCKING"
None.
.TH "ata_scsiop_mode_sense" 9 "ata_scsiop_mode_sense" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_mode_sense \-  Simulate MODE SENSE 6, 10 commands
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_mode_sense
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
Simulate MODE SENSE commands.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsiop_read_cap" 9 "ata_scsiop_read_cap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_read_cap \-  Simulate READ CAPACITY[ 16] commands
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_read_cap
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
Simulate READ CAPACITY commands.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsiop_report_luns" 9 "ata_scsiop_report_luns" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsiop_report_luns \-  Simulate REPORT LUNS command
.SH SYNOPSIS
.B "unsigned int" ata_scsiop_report_luns
.BI "(struct ata_scsi_args *" args ","
.BI "u8 *" rbuf ","
.BI "unsigned int " buflen ");"
.SH ARGUMENTS
.IP "args" 12
 device IDENTIFY data / SCSI command of interest.
.IP "rbuf" 12
 Response buffer, to which simulated SCSI cmd output is sent.
.IP "buflen" 12
 Response buffer length.
.SH "DESCRIPTION"
Simulate REPORT LUNS command.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ata_scsi_badcmd" 9 "ata_scsi_badcmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_badcmd \-  End a SCSI request with an error
.SH SYNOPSIS
.B "void" ata_scsi_badcmd
.BI "(struct scsi_cmnd *" cmd ","
.BI "void (*" done ") (struct scsi_cmnd *),"
.BI "u8 " asc ","
.BI "u8 " ascq ");"
.SH ARGUMENTS
.IP "cmd" 12
 SCSI request to be handled
.IP "done" 12
 SCSI command completion function
.IP "asc" 12
 SCSI-defined additional sense code
.IP "ascq" 12
 SCSI-defined additional sense code qualifier
.SH "DESCRIPTION"
Helper function that completes a SCSI command with
SAM_STAT_CHECK_CONDITION, with a sense key ILLEGAL_REQUEST
and the specified additional sense codes.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "atapi_xlat" 9 "atapi_xlat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atapi_xlat \-  Initialize PACKET taskfile
.SH SYNOPSIS
.B "unsigned int" atapi_xlat
.BI "(struct ata_queued_cmd *" qc ","
.BI "u8 *" scsicmd ");"
.SH ARGUMENTS
.IP "qc" 12
 command structure to be initialized
.IP "scsicmd" 12
 SCSI CDB associated with this PACKET command
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Zero on success, non-zero on failure.
.TH "ata_scsi_find_dev" 9 "ata_scsi_find_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_find_dev \-  lookup ata_device from scsi_cmnd
.SH SYNOPSIS
.B "struct ata_device *" ata_scsi_find_dev
.BI "(struct ata_port *" ap ","
.BI "struct scsi_device *" scsidev ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA port to which the device is attached
.IP "scsidev" 12
 SCSI device from which we derive the ATA device
.SH "DESCRIPTION"
Given various information provided in struct scsi_cmnd,
map that onto an ATA bus, and using that mapping
determine which ata_device is associated with the
SCSI command to be sent.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.SH "RETURNS"
Associated ATA device, or NULL if not found.
.TH "ata_get_xlat_func" 9 "ata_get_xlat_func" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_get_xlat_func \-  check if SCSI to ATA translation is possible
.SH SYNOPSIS
.B "ata_xlat_func_t" ata_get_xlat_func
.BI "(struct ata_device *" dev ","
.BI "u8 " cmd ");"
.SH ARGUMENTS
.IP "dev" 12
 ATA device
.IP "cmd" 12
 SCSI command opcode to consider
.SH "DESCRIPTION"
Look up the SCSI command given, and determine whether the
SCSI command is to be translated or simulated.
.SH "RETURNS"
Pointer to translation function if possible, NULL if not.
.TH "ata_scsi_dump_cdb" 9 "ata_scsi_dump_cdb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_dump_cdb \-  dump SCSI command contents to dmesg
.SH SYNOPSIS
.B "void" ata_scsi_dump_cdb
.BI "(struct ata_port *" ap ","
.BI "struct scsi_cmnd *" cmd ");"
.SH ARGUMENTS
.IP "ap" 12
 ATA port to which the command was being sent
.IP "cmd" 12
 SCSI command to dump
.SH "DESCRIPTION"
Prints the contents of a SCSI command via \fBprintk\fP.
.TH "ata_scsi_queuecmd" 9 "ata_scsi_queuecmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_queuecmd \-  Issue SCSI cdb to libata-managed device
.SH SYNOPSIS
.B "int" ata_scsi_queuecmd
.BI "(struct scsi_cmnd *" cmd ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "cmd" 12
 SCSI command to be sent
.IP "done" 12
 Completion function, called when command is complete
.SH "DESCRIPTION"
In some cases, this function translates SCSI commands into
ATA taskfiles, and queues the taskfiles to be sent to
hardware.  In other cases, this function simulates a
SCSI device by evaluating and responding to certain
SCSI commands.  This creates the overall effect of
ATA and ATAPI devices appearing as SCSI devices.
.SH "LOCKING"
Releases scsi-layer-held lock, and obtains host_set lock.
.SH "RETURNS"
Zero.
.TH "ata_scsi_simulate" 9 "ata_scsi_simulate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata_scsi_simulate \-  simulate SCSI command on ATA device
.SH SYNOPSIS
.B "void" ata_scsi_simulate
.BI "(u16 *" id ","
.BI "struct scsi_cmnd *" cmd ","
.BI "void (*" done ") (struct scsi_cmnd *));"
.SH ARGUMENTS
.IP "id" 12
 current IDENTIFY data for target device.
.IP "cmd" 12
 SCSI command being sent to device.
.IP "done" 12
 SCSI command completion function.
.SH "DESCRIPTION"
Interprets and directly executes a select list of SCSI commands
that can be handled internally.
.SH "LOCKING"
spin_lock_irqsave(host_set lock)
.TH "ide_system_bus_speed" 9 "ide_system_bus_speed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_system_bus_speed \- 	guess bus speed
.SH SYNOPSIS
.B "int" ide_system_bus_speed
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

\fBide_system_bus_speed\fP returns what we think is the system VESA/PCI
bus speed (in MHz). This is used for calculating interface PIO timings.
The default is 40 for known PCI systems, 50 otherwise.
The "idebus=xx" parameter can be used to override this value.
The actual value to be used is computed/displayed the first time
through. Drivers should only use this as a last resort.

Returns a guessed speed in MHz.
.TH "ide_hwif_request_regions" 9 "ide_hwif_request_regions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_hwif_request_regions \-  request resources for IDE
.SH SYNOPSIS
.B "int" ide_hwif_request_regions
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to use
.SH "DESCRIPTION"
Requests all the needed resources for an interface.
Right now core IDE code does this work which is deeply wrong.
MMIO leaves it to the controller driver,
PIO will migrate this way over time.
.TH "ide_hwif_release_regions" 9 "ide_hwif_release_regions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_hwif_release_regions \-  free IDE resources
.SH SYNOPSIS
.B "void" ide_hwif_release_regions
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
-- undescribed --
.SH "DESCRIPTION"

Note that we only release the standard ports,
and do not even try to handle any extra ports
allocated for weird IDE interface chipsets.

Note also that we don't yet handle mmio resources here. More
importantly our caller should be doing this so we need to 
restructure this as a helper function for drivers.
.TH "ide_hwif_restore" 9 "ide_hwif_restore" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_hwif_restore \- 	restore hwif to template
.SH SYNOPSIS
.B "void" ide_hwif_restore
.BI "(ide_hwif_t *" hwif ","
.BI "ide_hwif_t *" tmp_hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 hwif to update
.IP "tmp_hwif" 12
 template
.SH "DESCRIPTION"
Restore hwif to a previous state by copying most settngs
from the template.
.TH "ide_unregister" 9 "ide_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_unregister \- 	free an ide interface
.SH SYNOPSIS
.B "void" ide_unregister
.BI "(unsigned int " index ");"
.SH ARGUMENTS
.IP "index" 12
 index of interface (will change soon to a pointer)
.SH "DESCRIPTION"
Perform the final unregister of an IDE interface. At the moment
we don't refcount interfaces so this will also get split up.
.SH "LOCKING"
The caller must not hold the IDE locks
The drive present/vanishing is not yet properly locked
Take care with the callbacks. These have been split to avoid
deadlocking the IDE layer. The shutdown callback is called
before we take the lock and free resources. It is up to the
caller to be sure there is no pending I/O here, and that
the interfce will not be reopened (present/vanishing locking
isnt yet done btw). After we commit to the final kill we
call the cleanup callback with the ide locks held.

Unregister restores the hwif structures to the default state.
This is raving bonkers.
.TH "ide_setup_ports" 9 "ide_setup_ports" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_setup_ports \- 	set up IDE interface ports
.SH SYNOPSIS
.B "void" ide_setup_ports
.BI "(hw_regs_t *" hw ","
.BI "unsigned long " base ","
.BI "int *" offsets ","
.BI "unsigned long " ctrl ","
.BI "unsigned long " intr ","
.BI "ide_ack_intr_t *" ack_intr ","
.BI "int " irq ");"
.SH ARGUMENTS
.IP "hw" 12
 register descriptions
.IP "base" 12
 base register
.IP "offsets" 12
 table of register offsets
.IP "ctrl" 12
 control register
.IP "intr" 12
-- undescribed --
.IP "ack_intr" 12
-- undescribed --
.IP "irq" 12
 interrupt lie
.SH "DESCRIPTION"
Setup hw_regs_t structure described by parameters.  You
may set up the hw structure yourself OR use this routine to
do it for you. This is basically a helper
.TH "ide_register_hw_with_fixup" 9 "ide_register_hw_with_fixup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_register_hw_with_fixup \- 	register IDE interface
.SH SYNOPSIS
.B "int" ide_register_hw_with_fixup
.BI "(hw_regs_t *" hw ","
.BI "ide_hwif_t **" hwifp ","
.BI "void(*" fixup ") (ide_hwif_t *hwif));"
.SH ARGUMENTS
.IP "hw" 12
 hardware registers
.IP "hwifp" 12
 pointer to returned hwif
.IP "fixup" 12
 fixup function
.SH "DESCRIPTION"
Register an IDE interface, specifying exactly the registers etc.
Set init=1 iff calling before probes have taken place.

Returns -1 on error.
.TH "__ide_add_setting" 9 "__ide_add_setting" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_add_setting \- 	add an ide setting option
.SH SYNOPSIS
.B "int" __ide_add_setting
.BI "(ide_drive_t *" drive ","
.BI "const char *" name ","
.BI "int " rw ","
.BI "int " read_ioctl ","
.BI "int " write_ioctl ","
.BI "int " data_type ","
.BI "int " min ","
.BI "int " max ","
.BI "int " mul_factor ","
.BI "int " div_factor ","
.BI "void *" data ","
.BI "ide_procset_t *" set ","
.BI "int " auto_remove ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to use
.IP "name" 12
 setting name
.IP "rw" 12
 true if the function is read write
.IP "read_ioctl" 12
 function to call on read
.IP "write_ioctl" 12
 function to call on write
.IP "data_type" 12
 type of data
.IP "min" 12
 range minimum
.IP "max" 12
 range maximum
.IP "mul_factor" 12
 multiplication scale
.IP "div_factor" 12
 divison scale
.IP "data" 12
 private data field
.IP "set" 12
 setting
.IP "auto_remove" 12
 setting auto removal flag
.SH "DESCRIPTION"
Removes the setting named from the device if it is present.
The function takes the settings_lock to protect against 
parallel changes. This function must not be called from IRQ
context. Returns 0 on success or -1 on failure.
.SH "BUGS"
 This code is seriously over-engineered. There is also
magic about how the driver specific features are setup. If
a driver is attached we assume the driver settings are auto
remove.
.TH "__ide_remove_setting" 9 "__ide_remove_setting" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_remove_setting \- 	remove an ide setting option
.SH SYNOPSIS
.B "void" __ide_remove_setting
.BI "(ide_drive_t *" drive ","
.BI "char *" name ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to use
.IP "name" 12
 setting name
.SH "DESCRIPTION"
Removes the setting named from the device if it is present.
The caller must hold the setting semaphore.
.TH "ide_find_setting_by_ioctl" 9 "ide_find_setting_by_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_find_setting_by_ioctl \- 	find a drive specific ioctl
.SH SYNOPSIS
.B "ide_settings_t *" ide_find_setting_by_ioctl
.BI "(ide_drive_t *" drive ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to scan
.IP "cmd" 12
 ioctl command to handle
.SH "DESCRIPTION"
Scan's the device setting table for a matching entry and returns
this or NULL if no entry is found. The caller must hold the
setting semaphore
.TH "ide_find_setting_by_name" 9 "ide_find_setting_by_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_find_setting_by_name \- 	find a drive specific setting
.SH SYNOPSIS
.B "ide_settings_t *" ide_find_setting_by_name
.BI "(ide_drive_t *" drive ","
.BI "char *" name ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to scan
.IP "name" 12
 setting name
.SH "DESCRIPTION"
Scan's the device setting table for a matching entry and returns
this or NULL if no entry is found. The caller must hold the
setting semaphore
.TH "auto_remove_settings" 9 "auto_remove_settings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
auto_remove_settings \- 	remove driver specific settings
.SH SYNOPSIS
.B "void" auto_remove_settings
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive
.SH "DESCRIPTION"
Automatically remove all the driver specific settings for this
drive. This function may sleep and must not be called from IRQ
context. The caller must hold ide_setting_sem.
.TH "ide_read_setting" 9 "ide_read_setting" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_read_setting \- 	read an IDE setting
.SH SYNOPSIS
.B "int" ide_read_setting
.BI "(ide_drive_t *" drive ","
.BI "ide_settings_t *" setting ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to read from
.IP "setting" 12
 drive setting
.SH "DESCRIPTION"
Read a drive setting and return the value. The caller
must hold the ide_setting_sem when making this call.
.SH "BUGS"
 the data return and error are the same return value
so an error -EINVAL and true return of the same value cannot
be told apart
.TH "ide_spin_wait_hwgroup" 9 "ide_spin_wait_hwgroup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_spin_wait_hwgroup \- 	wait for group
.SH SYNOPSIS
.B "int" ide_spin_wait_hwgroup
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive in the group
.SH "DESCRIPTION"
Wait for an IDE device group to go non busy and then return
holding the ide_lock which guards the hwgroup-&gt;busy status
and right to use it.
.TH "ide_write_setting" 9 "ide_write_setting" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_write_setting \- 	read an IDE setting
.SH SYNOPSIS
.B "int" ide_write_setting
.BI "(ide_drive_t *" drive ","
.BI "ide_settings_t *" setting ","
.BI "int " val ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to read from
.IP "setting" 12
 drive setting
.IP "val" 12
 value
.SH "DESCRIPTION"
Write a drive setting if it is possible. The caller
must hold the ide_setting_sem when making this call.
.SH "BUGS"
 the data return and error are the same return value
so an error -EINVAL and true return of the same value cannot
be told apart
.SH "FIXME"
  This should be changed to enqueue a special request
to the driver to change settings, and then wait on a sema for completion.
The current scheme of polling is kludgy, though safe enough.
.TH "ide_add_generic_settings" 9 "ide_add_generic_settings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_add_generic_settings \- 	generic ide settings
.SH SYNOPSIS
.B "void" ide_add_generic_settings
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive being configured
.SH "DESCRIPTION"
Add the generic parts of the system settings to the /proc files and
ioctls for this IDE device. The caller must not be holding the
ide_setting_sem.
.TH "system_bus_clock" 9 "system_bus_clock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
system_bus_clock \- 	clock guess
.SH SYNOPSIS
.B "int" system_bus_clock
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

External version of the bus clock guess used by very old IDE drivers
for things like VLB timings. Should not be used.
.TH "ide_unregister_subdriver" 9 "ide_unregister_subdriver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_unregister_subdriver \- 	disconnect drive from driver
.SH SYNOPSIS
.B "void" ide_unregister_subdriver
.BI "(ide_drive_t *" drive ","
.BI "ide_driver_t *" driver ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to unplug
.IP "driver" 12
 driver
.SH "DESCRIPTION"
Disconnect a drive from the driver it was attached to and then
clean up the various proc files and other objects attached to it.

Takes ide_setting_sem and ide_lock.
Caller must hold none of the locks.
.TH "generic_init_one" 9 "generic_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_init_one \- 	called when a PIIX is found
.SH SYNOPSIS
.B "int __devinit" generic_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the generic device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "via_get_info" 9 "via_get_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_get_info \- 	generate via /proc file 
.SH SYNOPSIS
.B "int" via_get_info
.BI "(char *" buffer ","
.BI "char **" addr ","
.BI "off_t " offset ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "buffer" 12
 buffer for data
.IP "addr" 12
 set to start of data to use
.IP "offset" 12
 current file offset
.IP "count" 12
 size of read
.SH "DESCRIPTION"
Fills in buffer with the debugging/configuration information for
the VIA chipset tuning and attached drives
.TH "via_set_speed" 9 "via_set_speed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_set_speed \- 	write timing registers
.SH SYNOPSIS
.B "void" via_set_speed
.BI "(struct pci_dev *" dev ","
.BI "u8 " dn ","
.BI "struct ide_timing *" timing ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "dn" 12
 device
.IP "timing" 12
 IDE timing data to use
.SH "DESCRIPTION"
via_set_speed writes timing values to the chipset registers
.TH "via_set_drive" 9 "via_set_drive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_set_drive \- 	configure transfer mode
.SH SYNOPSIS
.B "int" via_set_drive
.BI "(ide_drive_t *" drive ","
.BI "u8 " speed ");"
.SH ARGUMENTS
.IP "drive" 12
 Drive to set up
.IP "speed" 12
 desired speed
.SH "DESCRIPTION"
\fBvia_set_drive\fP computes timing values configures the drive and
the chipset to a desired transfer mode. It also can be called
by upper layers.
.TH "via82cxxx_tune_drive" 9 "via82cxxx_tune_drive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via82cxxx_tune_drive \- 	PIO setup
.SH SYNOPSIS
.B "void" via82cxxx_tune_drive
.BI "(ide_drive_t *" drive ","
.BI "u8 " pio ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to set up
.IP "pio" 12
 mode to use (255 for 'best possible')
.SH "DESCRIPTION"
A callback from the upper layers for PIO-only tuning.
.TH "via82cxxx_ide_dma_check" 9 "via82cxxx_ide_dma_check" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via82cxxx_ide_dma_check \- 	set up for DMA if possible
.SH SYNOPSIS
.B "int" via82cxxx_ide_dma_check
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to set up
.SH "DESCRIPTION"
Set up the drive for the highest supported speed considering the
driver, controller and cable
.TH "init_chipset_via82cxxx" 9 "init_chipset_via82cxxx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_chipset_via82cxxx \- 	initialization handler
.SH SYNOPSIS
.B "unsigned int __devinit" init_chipset_via82cxxx
.BI "(struct pci_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "name" 12
 Name of interface
.SH "DESCRIPTION"
The initialization callback. Here we determine the IDE chip type
and initialize its drive independent registers.
.TH "piix_ratemask" 9 "piix_ratemask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_ratemask \- 	compute rate mask for PIIX IDE
.SH SYNOPSIS
.B "u8" piix_ratemask
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to compute for
.SH "DESCRIPTION"
Returns the available modes for the PIIX IDE controller.
.TH "piix_dma_2_pio" 9 "piix_dma_2_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_dma_2_pio \- 	return the PIO mode matching DMA
.SH SYNOPSIS
.B "u8" piix_dma_2_pio
.BI "(u8 " xfer_rate ");"
.SH ARGUMENTS
.IP "xfer_rate" 12
 transfer speed
.SH "DESCRIPTION"
Returns the nearest equivalent PIO timing for the PIO or DMA
mode requested by the controller.
.TH "piix_tune_drive" 9 "piix_tune_drive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_tune_drive \- 	tune a drive attached to a PIIX
.SH SYNOPSIS
.B "void" piix_tune_drive
.BI "(ide_drive_t *" drive ","
.BI "u8 " pio ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "pio" 12
 desired PIO mode
.SH "DESCRIPTION"
Set the interface PIO mode based upon  the settings done by AMI BIOS
(might be useful if drive is not registered in CMOS for any reason).
.TH "piix_tune_chipset" 9 "piix_tune_chipset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_tune_chipset \- 	tune a PIIX interface
.SH SYNOPSIS
.B "int" piix_tune_chipset
.BI "(ide_drive_t *" drive ","
.BI "u8 " xferspeed ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to tune
.IP "xferspeed" 12
 speed to configure
.SH "DESCRIPTION"
Set a PIIX interface channel to the desired speeds. This involves
requires the right timing data into the PIIX configuration space
then setting the drive parameters appropriately
.TH "piix_faulty_dma0" 9 "piix_faulty_dma0" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_faulty_dma0 \- 	check for DMA0 errata
.SH SYNOPSIS
.B "int" piix_faulty_dma0
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 IDE interface to check
.SH "DESCRIPTION"
If an ICH/ICH0/ICH2 interface is is operating in multi-word
DMA mode with 600nS cycle time the IDE PIO prefetch buffer will
inadvertently provide an extra piece of secondary data to the primary
device resulting in data corruption.

With such a device this test function returns true. This allows
our tuning code to follow Intel recommendations and use PIO on
such devices.
.TH "piix_config_drive_for_dma" 9 "piix_config_drive_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_config_drive_for_dma \- 	configure drive for DMA
.SH SYNOPSIS
.B "int" piix_config_drive_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to configure
.SH "DESCRIPTION"
Set up a PIIX interface channel for the best available speed.
We prefer UDMA if it is available and then MWDMA. If DMA is 
not available we switch to PIO and return 0. 
.TH "piix_config_drive_xfer_rate" 9 "piix_config_drive_xfer_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_config_drive_xfer_rate \- 	set up an IDE device
.SH SYNOPSIS
.B "int" piix_config_drive_xfer_rate
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to configure
.SH "DESCRIPTION"
Set up the PIIX interface for the best available speed on this
interface, preferring DMA to PIO.
.TH "init_chipset_piix" 9 "init_chipset_piix" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_chipset_piix \- 	set up the PIIX chipset
.SH SYNOPSIS
.B "unsigned int __devinit" init_chipset_piix
.BI "(struct pci_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to set up
.IP "name" 12
 Name of the device
.SH "DESCRIPTION"
Initialize the PCI device as required. For the PIIX this turns
out to be nice and simple
.TH "init_hwif_piix" 9 "init_hwif_piix" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_hwif_piix \- 	fill in the hwif for the PIIX
.SH SYNOPSIS
.B "void __devinit" init_hwif_piix
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 IDE interface
.SH "DESCRIPTION"
Set up the ide_hwif_t for the PIIX interface according to the
capabilities of the hardware.
.TH "piix_init_one" 9 "piix_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_init_one \- 	called when a PIIX is found
.SH SYNOPSIS
.B "int __devinit" piix_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the piix device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "piix_check_450nx" 9 "piix_check_450nx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
piix_check_450nx \- 	Check for problem 450NX setup
.SH SYNOPSIS
.B "void __devinit" piix_check_450nx
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Check for the present of 450NX errata #19 and errata #25. If
they are found, disable use of DMA IDE
.TH "aec62xx_init_one" 9 "aec62xx_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aec62xx_init_one \- 	called when a AEC is found
.SH SYNOPSIS
.B "int __devinit" aec62xx_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the aec62xx device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "pdev_is_sata" 9 "pdev_is_sata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdev_is_sata \- 	check if device is SATA
.SH SYNOPSIS
.B "int" pdev_is_sata
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
	PCI device to check
.SH "DESCRIPTION"
Returns true if this is a SATA controller
.TH "is_sata" 9 "is_sata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_sata \- 	check if hwif is SATA
.SH SYNOPSIS
.B "int" is_sata
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
	interface to check
.SH "DESCRIPTION"
Returns true if this is a SATA controller
.TH "siimage_selreg" 9 "siimage_selreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_selreg \- 	return register base
.SH SYNOPSIS
.B "unsigned long" siimage_selreg
.BI "(ide_hwif_t *" hwif ","
.BI "int " r ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface
.IP "r" 12
 config offset
.SH "DESCRIPTION"
Turn a config register offset into the right address in either
PCI space or MMIO space to access the control register in question
Thankfully this is a configuration operation so isnt performance
criticial. 
.TH "siimage_seldev" 9 "siimage_seldev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_seldev \- 	return register base
.SH SYNOPSIS
.B "unsigned long" siimage_seldev
.BI "(ide_drive_t *" drive ","
.BI "int " r ");"
.SH ARGUMENTS
.IP "drive" 12
-- undescribed --
.IP "r" 12
 config offset
.SH "DESCRIPTION"
Turn a config register offset into the right address in either
PCI space or MMIO space to access the control register in question
including accounting for the unit shift.
.TH "siimage_ratemask" 9 "siimage_ratemask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_ratemask \- 	Compute available modes
.SH SYNOPSIS
.B "byte" siimage_ratemask
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive
.SH "DESCRIPTION"
Compute the available speeds for the devices on the interface.
For the CMD680 this depends on the clocking mode (scsc), for the
SI3312 SATA controller life is a bit simpler. Enforce UDMA33
as a limit if there is no 80pin cable present.
.TH "siimage_taskfile_timing" 9 "siimage_taskfile_timing" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_taskfile_timing \- 	turn timing data to a mode
.SH SYNOPSIS
.B "byte" siimage_taskfile_timing
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to query
.SH "DESCRIPTION"
Read the timing data for the interface and return the 
mode that is being used.
.TH "siimage_tuneproc" 9 "siimage_tuneproc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_tuneproc \- 	tune a drive
.SH SYNOPSIS
.B "void" siimage_tuneproc
.BI "(ide_drive_t *" drive ","
.BI "byte " mode_wanted ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "mode_wanted" 12
 the target operating mode
.SH "DESCRIPTION"
Load the timing settings for this device mode into the
controller. If we are in PIO mode 3 or 4 turn on IORDY
monitoring (bit 9). The TF timing is bits 31:16
.TH "config_siimage_chipset_for_pio" 9 "config_siimage_chipset_for_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
config_siimage_chipset_for_pio \- 	set drive timings
.SH SYNOPSIS
.B "void" config_siimage_chipset_for_pio
.BI "(ide_drive_t *" drive ","
.BI "byte " set_speed ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
\fIspeed\fP we want
.IP "set_speed" 12
-- undescribed --
.SH "DESCRIPTION"
Compute the best pio mode we can for a given device. Also honour
the timings for the driver when dealing with mixed devices. Some
of this is ugly but its all wrapped up here

The SI680 can also do VDMA - we need to start using that
.SH "FIXME"
 we use the BIOS channel timings to avoid driving the task
files too fast at the disk. We need to compute the master/slave
drive PIO mode properly so that we can up the speed on a hotplug
system.
.TH "siimage_tune_chipset" 9 "siimage_tune_chipset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_tune_chipset \- 	set controller timings
.SH SYNOPSIS
.B "int" siimage_tune_chipset
.BI "(ide_drive_t *" drive ","
.BI "byte " xferspeed ");"
.SH ARGUMENTS
.IP "drive" 12
 Drive to set up
.IP "xferspeed" 12
 speed we want to achieve
.SH "DESCRIPTION"
Tune the SII chipset for the desired mode. If we can't achieve
the desired mode then tune for a lower one, but ultimately
make the thing work.
.TH "config_chipset_for_dma" 9 "config_chipset_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
config_chipset_for_dma \- 	configure for DMA
.SH SYNOPSIS
.B "int" config_chipset_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to configure
.SH "DESCRIPTION"
Called by the IDE layer when it wants the timings set up.
For the CMD680 we also need to set up the PIO timings and
enable DMA.
.TH "siimage_config_drive_for_dma" 9 "siimage_config_drive_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_config_drive_for_dma \- 	set up for DMA transfers
.SH SYNOPSIS
.B "int" siimage_config_drive_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive we are going to set up
.SH "DESCRIPTION"
Set up the drive for DMA, tune the controller and drive as 
required. If the drive isn't suitable for DMA or we hit
other problems then we will drop down to PIO and set up
PIO appropriately
.TH "siimage_mmio_ide_dma_count" 9 "siimage_mmio_ide_dma_count" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_mmio_ide_dma_count \- 	DMA bytes done
.SH SYNOPSIS
.B "int" siimage_mmio_ide_dma_count
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
-- undescribed --
.SH "DESCRIPTION"
\fIdrive\fP

If we are doing VDMA the CMD680 requires a little bit
of more careful handling and we have to read the counts
off ourselves. For non VDMA life is normal.
.TH "siimage_mmio_ide_dma_test_irq" 9 "siimage_mmio_ide_dma_test_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_mmio_ide_dma_test_irq \- 	check we caused an IRQ
.SH SYNOPSIS
.B "int" siimage_mmio_ide_dma_test_irq
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive we are testing
.SH "DESCRIPTION"
Check if we caused an IDE DMA interrupt. We may also have caused
SATA status interrupts, if so we clean them up and continue.
.TH "siimage_busproc" 9 "siimage_busproc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_busproc \- 	bus isolation ioctl
.SH SYNOPSIS
.B "int" siimage_busproc
.BI "(ide_drive_t *" drive ","
.BI "int " state ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to isolate/restore
.IP "state" 12
 bus state to set
.SH "DESCRIPTION"
Used by the SII3112 to handle bus isolation. As this is a 
SATA controller the work required is quite limited, we 
just have to clean up the statistics
.TH "siimage_reset_poll" 9 "siimage_reset_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_reset_poll \- 	wait for sata reset
.SH SYNOPSIS
.B "int" siimage_reset_poll
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive we are resetting
.SH "DESCRIPTION"
Poll the SATA phy and see whether it has come back from the dead
yet.
.TH "siimage_pre_reset" 9 "siimage_pre_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_pre_reset \- 	reset hook
.SH SYNOPSIS
.B "void" siimage_pre_reset
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE device being reset
.SH "DESCRIPTION"
For the SATA devices we need to handle recalibration/geometry
differently
.TH "siimage_reset" 9 "siimage_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_reset \- 	reset a device on an siimage controller
.SH SYNOPSIS
.B "void" siimage_reset
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to reset
.SH "DESCRIPTION"
Perform a controller level reset fo the device. For
SATA we must also check the PHY.
.TH "proc_reports_siimage" 9 "proc_reports_siimage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_reports_siimage \- 	add siimage controller to proc
.SH SYNOPSIS
.B "void" proc_reports_siimage
.BI "(struct pci_dev *" dev ","
.BI "u8 " clocking ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "clocking" 12
 SCSC value
.IP "name" 12
 controller name
.SH "DESCRIPTION"
Report the clocking mode of the controller and add it to
the /proc interface layer
.TH "setup_mmio_siimage" 9 "setup_mmio_siimage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
setup_mmio_siimage \- 	switch an SI controller into MMIO
.SH SYNOPSIS
.B "unsigned int" setup_mmio_siimage
.BI "(struct pci_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device we are configuring
.IP "name" 12
 device name
.SH "DESCRIPTION"
Attempt to put the device into mmio mode. There are some slight
complications here with certain systems where the mmio bar isnt
mapped so we have to be sure we can fall back to I/O.
.TH "init_chipset_siimage" 9 "init_chipset_siimage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_chipset_siimage \- 	set up an SI device
.SH SYNOPSIS
.B "unsigned int __devinit" init_chipset_siimage
.BI "(struct pci_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "name" 12
 device name
.SH "DESCRIPTION"
Perform the initial PCI set up for this device. Attempt to switch
to 133MHz clocking if the system isn't already set up to do it.
.TH "init_mmio_iops_siimage" 9 "init_mmio_iops_siimage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_mmio_iops_siimage \- 	set up the iops for MMIO
.SH SYNOPSIS
.B "void __devinit" init_mmio_iops_siimage
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to set up
.SH "DESCRIPTION"
The basic setup here is fairly simple, we can use standard MMIO
operations. However we do have to set the taskfile register offsets
by hand as there isnt a standard defined layout for them this
time.

The hardware supports buffered taskfiles and also some rather nice
extended PRD tables. Unfortunately right now we don't.
.TH "siimage_fixup" 9 "siimage_fixup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_fixup \- 	post probe fixups
.SH SYNOPSIS
.B "void __devinit" siimage_fixup
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to fix up
.SH "DESCRIPTION"
Called after drive probe we use this to decide whether the
Seagate fixup must be applied. This used to be in init_iops but
that can occur before we know what drives are present.
.TH "init_iops_siimage" 9 "init_iops_siimage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_iops_siimage \- 	set up iops
.SH SYNOPSIS
.B "void __devinit" init_iops_siimage
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to set up
.SH "DESCRIPTION"
Do the basic setup for the SIIMAGE hardware interface
and then do the MMIO setup if we can. This is the first
look in we get for setting up the hwif so that we
can get the iops right before using them.
.TH "ata66_siimage" 9 "ata66_siimage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata66_siimage \- 	check for 80 pin cable
.SH SYNOPSIS
.B "unsigned int __devinit" ata66_siimage
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to check
.SH "DESCRIPTION"
Check for the presence of an ATA66 capable cable on the
interface.
.TH "init_hwif_siimage" 9 "init_hwif_siimage" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_hwif_siimage \- 	set up hwif structs
.SH SYNOPSIS
.B "void __devinit" init_hwif_siimage
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to set up
.SH "DESCRIPTION"
We do the basic set up of the interface structure. The SIIMAGE
requires several custom handlers so we override the default
ide DMA handlers appropriately
.TH "siimage_init_one" 9 "siimage_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
siimage_init_one \- 	pci layer discovery entry
.SH SYNOPSIS
.B "int __devinit" siimage_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "id" 12
 ident table entry
.SH "DESCRIPTION"
Called by the PCI code when it finds an SI680 or SI3112 controller.
We then use the IDE PCI generic helper to do most of the work.
.TH "pdc202xx_init_one" 9 "pdc202xx_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc202xx_init_one \- 	called when a PDC202xx is found
.SH SYNOPSIS
.B "int __devinit" pdc202xx_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the pdc202xx device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "atiixp_ratemask" 9 "atiixp_ratemask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atiixp_ratemask \- 	compute rate mask for ATIIXP IDE
.SH SYNOPSIS
.B "u8" atiixp_ratemask
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to compute for
.SH "DESCRIPTION"
Returns the available modes for the ATIIXP IDE controller.
.TH "atiixp_dma_2_pio" 9 "atiixp_dma_2_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atiixp_dma_2_pio \- 	return the PIO mode matching DMA
.SH SYNOPSIS
.B "u8" atiixp_dma_2_pio
.BI "(u8 " xfer_rate ");"
.SH ARGUMENTS
.IP "xfer_rate" 12
 transfer speed
.SH "DESCRIPTION"
Returns the nearest equivalent PIO timing for the PIO or DMA
mode requested by the controller.
.TH "atiixp_tuneproc" 9 "atiixp_tuneproc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atiixp_tuneproc \- 	tune a drive attached to a ATIIXP
.SH SYNOPSIS
.B "void" atiixp_tuneproc
.BI "(ide_drive_t *" drive ","
.BI "u8 " pio ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "pio" 12
 desired PIO mode
.SH "DESCRIPTION"
Set the interface PIO mode.
.TH "atiixp_speedproc" 9 "atiixp_speedproc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atiixp_speedproc \- 	tune a ATIIXP interface
.SH SYNOPSIS
.B "int" atiixp_speedproc
.BI "(ide_drive_t *" drive ","
.BI "u8 " xferspeed ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to tune
.IP "xferspeed" 12
 speed to configure
.SH "DESCRIPTION"
Set a ATIIXP interface channel to the desired speeds. This involves
requires the right timing data into the ATIIXP configuration space
then setting the drive parameters appropriately
.TH "atiixp_config_drive_for_dma" 9 "atiixp_config_drive_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atiixp_config_drive_for_dma \- 	configure drive for DMA
.SH SYNOPSIS
.B "int" atiixp_config_drive_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to configure
.SH "DESCRIPTION"
Set up a ATIIXP interface channel for the best available speed.
We prefer UDMA if it is available and then MWDMA. If DMA is
not available we switch to PIO and return 0.
.TH "atiixp_dma_check" 9 "atiixp_dma_check" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atiixp_dma_check \- 	set up an IDE device
.SH SYNOPSIS
.B "int" atiixp_dma_check
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to configure
.SH "DESCRIPTION"
Set up the ATIIXP interface for the best available speed on this
interface, preferring DMA to PIO.
.TH "init_hwif_atiixp" 9 "init_hwif_atiixp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_hwif_atiixp \- 	fill in the hwif for the ATIIXP
.SH SYNOPSIS
.B "void __devinit" init_hwif_atiixp
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 IDE interface
.SH "DESCRIPTION"
Set up the ide_hwif_t for the ATIIXP interface according to the
capabilities of the hardware.
.TH "atiixp_init_one" 9 "atiixp_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atiixp_init_one \- 	called when a ATIIXP is found
.SH SYNOPSIS
.B "int __devinit" atiixp_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the atiixp device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "pdc202new_init_one" 9 "pdc202new_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc202new_init_one \- 	called when a pdc202xx is found
.SH SYNOPSIS
.B "int __devinit" pdc202new_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the pdc202new device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "hpt372n_set_clock" 9 "hpt372n_set_clock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpt372n_set_clock \- 	perform clock switching dance
.SH SYNOPSIS
.B "void" hpt372n_set_clock
.BI "(ide_drive_t *" drive ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "drive" 12
 Drive to switch
.IP "mode" 12
 Switching mode (0x21 for write, 0x23 otherwise)
.SH "DESCRIPTION"
Switch the DPLL clock on the HPT372N devices. This is a
right mess.
.TH "hpt372n_rw_disk" 9 "hpt372n_rw_disk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpt372n_rw_disk \- 	prepare for I/O
.SH SYNOPSIS
.B "void" hpt372n_rw_disk
.BI "(ide_drive_t *" drive ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "drive" 12
 drive for command
.IP "rq" 12
 block request structure
.SH "DESCRIPTION"
This is called when a disk I/O is issued to the 372N.
We need it because of the clock switching.
.TH "hpt366_init_one" 9 "hpt366_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hpt366_init_one \- 	called when an HPT366 is found
.SH SYNOPSIS
.B "int __devinit" hpt366_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the hpt366 device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "cs5530_set_xfer_mode" 9 "cs5530_set_xfer_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cs5530_set_xfer_mode \- 	set a new transfer mode at the drive
.SH SYNOPSIS
.B "int" cs5530_set_xfer_mode
.BI "(ide_drive_t *" drive ","
.BI "u8 " mode ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "mode" 12
 new mode
.SH "DESCRIPTION"
Logging wrapper to the IDE driver speed configuration. This can
probably go away now.
.TH "cs5530_tuneproc" 9 "cs5530_tuneproc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cs5530_tuneproc \- 	select/set PIO modes
.SH SYNOPSIS
.B "void" cs5530_tuneproc
.BI "(ide_drive_t *" drive ","
.BI "u8 " pio ");"
.SH ARGUMENTS
.IP "drive" 12
-- undescribed --
.IP "pio" 12
-- undescribed --
.SH "DESCRIPTION"

\fBcs5530_tuneproc\fP handles selection/setting of PIO modes
for both the chipset and drive.

The \fBide_init_cs5530\fP routine guarantees that all drives
will have valid default PIO timings set up before we get here.
.TH "cs5530_config_dma" 9 "cs5530_config_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cs5530_config_dma \- 	select/set DMA and UDMA modes
.SH SYNOPSIS
.B "int" cs5530_config_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.SH "DESCRIPTION"
\fBcs5530_config_dma\fP handles selection/setting of DMA/UDMA modes
for both the chipset and drive. The CS5530 has limitations about
mixing DMA/UDMA on the same cable.
.TH "init_chipset_cs5530" 9 "init_chipset_cs5530" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_chipset_cs5530 \- 	set up 5530 bridge
.SH SYNOPSIS
.B "unsigned int __devinit" init_chipset_cs5530
.BI "(struct pci_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "name" 12
 device name
.SH "DESCRIPTION"
Initialize the cs5530 bridge for reliable IDE DMA operation.
.TH "init_hwif_cs5530" 9 "init_hwif_cs5530" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_hwif_cs5530 \- 	initialise an IDE channel
.SH SYNOPSIS
.B "void __devinit" init_hwif_cs5530
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 IDE to initialize
.SH "DESCRIPTION"
This gets invoked by the IDE driver once for each channel. It
performs channel-specific pre-initialization before drive probing.
.TH "svwks_init_one" 9 "svwks_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
svwks_init_one \- 	called when a OSB/CSB is found
.SH SYNOPSIS
.B "int __devinit" svwks_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 the svwks device
.IP "id" 12
 the matching pci id
.SH "DESCRIPTION"
Called when the PCI registration layer (or the IDE initialization)
finds a device matching our IDE device tables.
.TH "ali_get_info" 9 "ali_get_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ali_get_info \- 	generate proc file for ALi IDE
.SH SYNOPSIS
.B "int" ali_get_info
.BI "(char *" buffer ","
.BI "char **" addr ","
.BI "off_t " offset ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "buffer" 12
 buffer to fill
.IP "addr" 12
 address of user start in buffer
.IP "offset" 12
 offset into 'file'
.IP "count" 12
 buffer count
.SH "DESCRIPTION"
Walks the Ali devices and outputs summary data on the tuning and
anything else that will help with debugging
.TH "ali15x3_tune_drive" 9 "ali15x3_tune_drive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ali15x3_tune_drive \- 	set up a drive
.SH SYNOPSIS
.B "void" ali15x3_tune_drive
.BI "(ide_drive_t *" drive ","
.BI "u8 " pio ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "pio" 12
 unused
.SH "DESCRIPTION"
Select the best PIO timing for the drive in question. Then
program the controller for this drive set up
.TH "ali15x3_can_ultra" 9 "ali15x3_can_ultra" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ali15x3_can_ultra \- 	check for ultra DMA support
.SH SYNOPSIS
.B "u8" ali15x3_can_ultra
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to do the check
.SH "DESCRIPTION"
Check the drive and controller revisions. Return 0 if UDMA is
not available, or 1 if UDMA can be used. The actual rules for
the ALi are
No UDMA on revisions &lt;= 0x20
Disk only for revisions &lt; 0xC2
Not WDC drives for revisions &lt; 0xC2
.SH "FIXME"
 WDC ifdef needs to die
.TH "ali15x3_ratemask" 9 "ali15x3_ratemask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ali15x3_ratemask \- 	generate DMA mode list
.SH SYNOPSIS
.B "u8" ali15x3_ratemask
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to compute against
.SH "DESCRIPTION"
Generate a list of the available DMA modes for the drive. 
.SH "FIXME"
 this function contains lots of bogus masking we can dump

Return the highest available mode (UDMA33, UDMA66, UDMA100,..)
.TH "ali15x3_tune_chipset" 9 "ali15x3_tune_chipset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ali15x3_tune_chipset \- 	set up chiset for new speed
.SH SYNOPSIS
.B "int" ali15x3_tune_chipset
.BI "(ide_drive_t *" drive ","
.BI "u8 " xferspeed ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to configure for
.IP "xferspeed" 12
 desired speed
.SH "DESCRIPTION"
Configure the hardware for the desired IDE transfer mode.
We also do the needed drive configuration through helpers
.TH "config_chipset_for_dma" 9 "config_chipset_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
config_chipset_for_dma \- 	set up DMA mode
.SH SYNOPSIS
.B "int" config_chipset_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to configure for
.SH "DESCRIPTION"
Place a drive into DMA mode and tune the chipset for
the selected speed.

Returns true if DMA mode can be used
.TH "ali15x3_config_drive_for_dma" 9 "ali15x3_config_drive_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ali15x3_config_drive_for_dma \- 	configure for DMA
.SH SYNOPSIS
.B "int" ali15x3_config_drive_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to configure
.SH "DESCRIPTION"
Configure a drive for DMA operation. If DMA is not possible we
drop the drive into PIO mode instead.
.SH "FIXME"
 exactly what are we trying to return here
.TH "ali15x3_dma_setup" 9 "ali15x3_dma_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ali15x3_dma_setup \- 	begin a DMA phase
.SH SYNOPSIS
.B "int" ali15x3_dma_setup
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
	target device
.SH "DESCRIPTION"
Returns 1 if the DMA cannot be performed, zero on success.
.TH "init_chipset_ali15x3" 9 "init_chipset_ali15x3" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_chipset_ali15x3 \- 	Initialise an ALi IDE controller
.SH SYNOPSIS
.B "unsigned int __devinit" init_chipset_ali15x3
.BI "(struct pci_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "name" 12
 Name of the controller
.SH "DESCRIPTION"
This function initializes the ALI IDE controller and where 
appropriate also sets up the 1533 southbridge.
.TH "ata66_ali15x3" 9 "ata66_ali15x3" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata66_ali15x3 \- 	check for UDMA 66 support
.SH SYNOPSIS
.B "unsigned int __devinit" ata66_ali15x3
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 IDE interface
.SH "DESCRIPTION"
This checks if the controller and the cable are capable
of UDMA66 transfers. It doesn't check the drives.
But see note 2 below!
.SH "FIXME"
 frobs bits that are not defined on newer ALi devicea
.TH "init_hwif_common_ali15x3" 9 "init_hwif_common_ali15x3" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_hwif_common_ali15x3 \- 	Set up ALI IDE hardware
.SH SYNOPSIS
.B "void __devinit" init_hwif_common_ali15x3
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 IDE interface
.SH "DESCRIPTION"
Initialize the IDE structure side of the ALi 15x3 driver.
.TH "init_hwif_ali15x3" 9 "init_hwif_ali15x3" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_hwif_ali15x3 \- 	Initialize the ALI IDE x86 stuff
.SH SYNOPSIS
.B "void __devinit" init_hwif_ali15x3
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to configure
.SH "DESCRIPTION"
Obtain the IRQ tables for an ALi based IDE solution on the PC
class platforms. This part of the code isn't applicable to the
Sparc systems
.TH "init_dma_ali15x3" 9 "init_dma_ali15x3" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_dma_ali15x3 \- 	set up DMA on ALi15x3
.SH SYNOPSIS
.B "void __devinit" init_dma_ali15x3
.BI "(ide_hwif_t *" hwif ","
.BI "unsigned long " dmabase ");"
.SH ARGUMENTS
.IP "hwif" 12
 IDE interface
.IP "dmabase" 12
 DMA interface base PCI address
.SH "DESCRIPTION"
Set up the DMA functionality on the ALi 15x3. For the ALi
controllers this is generic so we can let the generic code do
the actual work.
.TH "alim15x3_init_one" 9 "alim15x3_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alim15x3_init_one \- 	set up an ALi15x3 IDE controller
.SH SYNOPSIS
.B "int __devinit" alim15x3_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to set up
.IP "id" 12
-- undescribed --
.SH "DESCRIPTION"
Perform the actual set up for an ALi15x3 that has been found by the
hot plug layer.
.TH "it821x_program" 9 "it821x_program" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_program \- 	program the PIO/MWDMA registers
.SH SYNOPSIS
.B "void" it821x_program
.BI "(ide_drive_t *" drive ","
.BI "u16 " timing ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "timing" 12
-- undescribed --
.SH "DESCRIPTION"
Program the PIO/MWDMA timing for this channel according to the
current clock.
.TH "it821x_program_udma" 9 "it821x_program_udma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_program_udma \- 	program the UDMA registers
.SH SYNOPSIS
.B "void" it821x_program_udma
.BI "(ide_drive_t *" drive ","
.BI "u16 " timing ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "timing" 12
-- undescribed --
.SH "DESCRIPTION"
Program the UDMA timing for this drive according to the
current clock.
.TH "it821x_clock_strategy" 9 "it821x_clock_strategy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_clock_strategy \- 
.SH SYNOPSIS
.B "void" it821x_clock_strategy
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
-- undescribed --
.SH "DESCRIPTION"
Select between the 50 and 66Mhz base clocks to get the best
results for this interface.
.TH "it821x_ratemask" 9 "it821x_ratemask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_ratemask \- 	Compute available modes
.SH SYNOPSIS
.B "u8" it821x_ratemask
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive
.SH "DESCRIPTION"
Compute the available speeds for the devices on the interface. This
is all modes to ATA133 clipped by drive cable setup.
.TH "it821x_tuneproc" 9 "it821x_tuneproc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_tuneproc \- 	tune a drive
.SH SYNOPSIS
.B "void" it821x_tuneproc
.BI "(ide_drive_t *" drive ","
.BI "byte " mode_wanted ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
.IP "mode_wanted" 12
 the target operating mode
.SH "DESCRIPTION"
Load the timing settings for this device mode into the
controller. By the time we are called the mode has been
modified as neccessary to handle the absence of seperate
master/slave timers for MWDMA/PIO.

This code is only used in pass through mode.
.TH "it821x_tune_mwdma" 9 "it821x_tune_mwdma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_tune_mwdma \- 	tune a channel for MWDMA
.SH SYNOPSIS
.B "void" it821x_tune_mwdma
.BI "(ide_drive_t *" drive ","
.BI "byte " mode_wanted ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to set up
.IP "mode_wanted" 12
 the target operating mode
.SH "DESCRIPTION"
Load the timing settings for this device mode into the
controller when doing MWDMA in pass through mode. The caller
must manage the whole lack of per device MWDMA/PIO timings and
the shared MWDMA/PIO timing register.
.TH "it821x_tune_udma" 9 "it821x_tune_udma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_tune_udma \- 	tune a channel for UDMA
.SH SYNOPSIS
.B "void" it821x_tune_udma
.BI "(ide_drive_t *" drive ","
.BI "byte " mode_wanted ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to set up
.IP "mode_wanted" 12
 the target operating mode
.SH "DESCRIPTION"
Load the timing settings for this device mode into the
controller when doing UDMA modes in pass through.
.TH "config_it821x_chipset_for_pio" 9 "config_it821x_chipset_for_pio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
config_it821x_chipset_for_pio \- 	set drive timings
.SH SYNOPSIS
.B "void" config_it821x_chipset_for_pio
.BI "(ide_drive_t *" drive ","
.BI "byte " set_speed ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to tune
\fIspeed\fP we want
.IP "set_speed" 12
-- undescribed --
.SH "DESCRIPTION"
Compute the best pio mode we can for a given device. We must
pick a speed that does not cause problems with the other device
on the cable.
.TH "it821x_dma_start" 9 "it821x_dma_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_dma_start \- 	DMA hook
.SH SYNOPSIS
.B "void" it821x_dma_start
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive for DMA
.SH "DESCRIPTION"
The IT821x has a single timing register for MWDMA and for PIO
operations. As we flip back and forth we have to reload the
clock. In addition the rev 0x10 device only works if the same
timing value is loaded into the master and slave UDMA clock
so we must also reload that.
.SH "FIXME"
 we could figure out in advance if we need to do reloads
.TH "it821x_dma_end" 9 "it821x_dma_end" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_dma_end \- 	DMA hook
.SH SYNOPSIS
.B "int" it821x_dma_end
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive for DMA stop
.SH "DESCRIPTION"
The IT821x has a single timing register for MWDMA and for PIO
operations. As we flip back and forth we have to reload the
clock.
.TH "it821x_tune_chipset" 9 "it821x_tune_chipset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_tune_chipset \- 	set controller timings
.SH SYNOPSIS
.B "int" it821x_tune_chipset
.BI "(ide_drive_t *" drive ","
.BI "byte " xferspeed ");"
.SH ARGUMENTS
.IP "drive" 12
 Drive to set up
.IP "xferspeed" 12
 speed we want to achieve
.SH "DESCRIPTION"
Tune the ITE chipset for the desired mode. If we can't achieve
the desired mode then tune for a lower one, but ultimately
make the thing work.
.TH "config_chipset_for_dma" 9 "config_chipset_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
config_chipset_for_dma \- 	configure for DMA
.SH SYNOPSIS
.B "int" config_chipset_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to configure
.SH "DESCRIPTION"
Called by the IDE layer when it wants the timings set up.
.TH "it821x_config_drive_for_dma" 9 "it821x_config_drive_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_config_drive_for_dma \- 	set up for DMA transfers
.SH SYNOPSIS
.B "int" it821x_config_drive_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive we are going to set up
.SH "DESCRIPTION"
Set up the drive for DMA, tune the controller and drive as
required. If the drive isn't suitable for DMA or we hit
other problems then we will drop down to PIO and set up
PIO appropriately
.TH "ata66_it821x" 9 "ata66_it821x" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ata66_it821x \- 	check for 80 pin cable
.SH SYNOPSIS
.B "unsigned int __devinit" ata66_it821x
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to check
.SH "DESCRIPTION"
Check for the presence of an ATA66 capable cable on the
interface. Problematic as it seems some cards don't have
the needed logic onboard.
.TH "it821x_fixups" 9 "it821x_fixups" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_fixups \- 	post init callback
.SH SYNOPSIS
.B "void __devinit" it821x_fixups
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface
.SH "DESCRIPTION"
This callback is run after the drives have been probed but
before anything gets attached. It allows drivers to do any
final tuning that is needed, or fixups to work around bugs.
.TH "init_hwif_it821x" 9 "init_hwif_it821x" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_hwif_it821x \- 	set up hwif structs
.SH SYNOPSIS
.B "void __devinit" init_hwif_it821x
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface to set up
.SH "DESCRIPTION"
We do the basic set up of the interface structure. The IT8212
requires several custom handlers so we override the default
ide DMA handlers appropriately
.TH "it821x_init_one" 9 "it821x_init_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
it821x_init_one \- 	pci layer discovery entry
.SH SYNOPSIS
.B "int __devinit" it821x_init_one
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "id" 12
 ident table entry
.SH "DESCRIPTION"
Called by the PCI code when it finds an ITE821x controller.
We then use the IDE PCI generic helper to do most of the work.
.TH "idefloppy_should_report_error" 9 "idefloppy_should_report_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idefloppy_should_report_error \- 
.SH SYNOPSIS
.B "int" idefloppy_should_report_error
.BI "(idefloppy_floppy_t *" floppy ");"
.SH ARGUMENTS
.IP "floppy" 12
-- undescribed --
.SH "DESCRIPTION"

Supresses error messages resulting from Medium not present
.TH "ide_execute_command" 9 "ide_execute_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_execute_command \- 	execute an IDE command
.SH SYNOPSIS
.B "void" ide_execute_command
.BI "(ide_drive_t *" drive ","
.BI "task_ioreg_t " cmd ","
.BI "ide_handler_t *" handler ","
.BI "unsigned " timeout ","
.BI "ide_expiry_t *" expiry ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE drive to issue the command against
.IP "cmd" 12
-- undescribed --
.IP "handler" 12
 handler for next phase
.IP "timeout" 12
 timeout for command
.IP "expiry" 12
  handler to run on timeout
.SH "DESCRIPTION"
Helper function to issue an IDE command. This handles the
atomicity requirements, command timing and ensures that the 
handler and IRQ setup do not race. All IDE command kick off
should go via this function or do equivalent locking.
.TH "ide_match_hwif" 9 "ide_match_hwif" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_match_hwif \- 	match a PCI IDE against an ide_hwif
.SH SYNOPSIS
.B "ide_hwif_t *" ide_match_hwif
.BI "(unsigned long " io_base ","
.BI "u8 " bootable ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "io_base" 12
 I/O base of device
.IP "bootable" 12
 set if its bootable
.IP "name" 12
 name of device
.SH "DESCRIPTION"
Match a PCI IDE port against an entry in ide_hwifs[],
based on io_base port if possible. Return the matching hwif,
or a new hwif. If we find an error (clashing, out of devices, etc)
return NULL
.SH "FIXME"
 we need to handle mmio matches here too
.TH "ide_setup_pci_baseregs" 9 "ide_setup_pci_baseregs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_setup_pci_baseregs \- 	place a PCI IDE controller native
.SH SYNOPSIS
.B "int" ide_setup_pci_baseregs
.BI "(struct pci_dev *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device of interface to switch native
.IP "name" 12
 Name of interface
.SH "DESCRIPTION"
We attempt to place the PCI interface into PCI native mode. If
we succeed the BARs are ok and the controller is in PCI mode.
Returns 0 on success or an errno code. 
.SH "FIXME"
 if we program the interface and then fail to set the BARS
we don't switch it back to legacy mode. Do we actually care ??
.TH "ide_get_or_set_dma_base" 9 "ide_get_or_set_dma_base" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_get_or_set_dma_base \- 	setup BMIBA
.SH SYNOPSIS
.B "unsigned long" ide_get_or_set_dma_base
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 Interface
.SH "DESCRIPTION"
Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space:
If need be we set up the DMA base. Where a device has a partner that
is already in DMA mode we check and enforce IDE simplex rules.
.TH "ide_pci_enable" 9 "ide_pci_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_pci_enable \- 	do PCI enables
.SH SYNOPSIS
.B "int" ide_pci_enable
.BI "(struct pci_dev *" dev ","
.BI "ide_pci_device_t *" d ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "d" 12
 IDE pci device data
.SH "DESCRIPTION"
Enable the IDE PCI device. We attempt to enable the device in full
but if that fails then we only need BAR4 so we will enable that.

Returns zero on success or an error code
.TH "ide_pci_configure" 9 "ide_pci_configure" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_pci_configure \- 	configure an unconfigured device
.SH SYNOPSIS
.B "int" ide_pci_configure
.BI "(struct pci_dev *" dev ","
.BI "ide_pci_device_t *" d ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "d" 12
 IDE pci device data
.SH "DESCRIPTION"
Enable and configure the PCI device we have been passed.
Returns zero on success or an error code.
.TH "ide_pci_check_iomem" 9 "ide_pci_check_iomem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_pci_check_iomem \- 	check a register is I/O
.SH SYNOPSIS
.B "int" ide_pci_check_iomem
.BI "(struct pci_dev *" dev ","
.BI "ide_pci_device_t *" d ","
.BI "int " bar ");"
.SH ARGUMENTS
.IP "dev" 12
 pci device
.IP "d" 12
 ide_pci_device
.IP "bar" 12
 bar number
.SH "DESCRIPTION"
Checks if a BAR is configured and points to MMIO space. If so
print an error and return an error code. Otherwise return 0
.TH "ide_hwif_configure" 9 "ide_hwif_configure" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_hwif_configure \- 	configure an IDE interface
.SH SYNOPSIS
.B "ide_hwif_t *" ide_hwif_configure
.BI "(struct pci_dev *" dev ","
.BI "ide_pci_device_t *" d ","
.BI "ide_hwif_t *" mate ","
.BI "int " port ","
.BI "int " irq ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device holding interface
.IP "d" 12
 IDE pci data
.IP "mate" 12
 Paired interface if any
.IP "port" 12
-- undescribed --
.IP "irq" 12
-- undescribed --
.SH "DESCRIPTION"
Perform the initial set up for the hardware interface structure. This
is done per interface port rather than per PCI device. There may be
more than one port per device.

Returns the new hardware interface structure, or NULL on a failure
.TH "ide_hwif_setup_dma" 9 "ide_hwif_setup_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_hwif_setup_dma \- 	configure DMA interface
.SH SYNOPSIS
.B "void" ide_hwif_setup_dma
.BI "(struct pci_dev *" dev ","
.BI "ide_pci_device_t *" d ","
.BI "ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "d" 12
 IDE pci data
.IP "hwif" 12
 Hardware interface we are configuring
.SH "DESCRIPTION"
Set up the DMA base for the interface. Enable the master bits as
necessary and attempt to bring the device DMA into a ready to use
state
.TH "ide_setup_pci_controller" 9 "ide_setup_pci_controller" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_setup_pci_controller \- 	set up IDE PCI
.SH SYNOPSIS
.B "int" ide_setup_pci_controller
.BI "(struct pci_dev *" dev ","
.BI "ide_pci_device_t *" d ","
.BI "int " noisy ","
.BI "int *" config ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "d" 12
 IDE PCI data
.IP "noisy" 12
 verbose flag
.IP "config" 12
 returned as 1 if we configured the hardware
.SH "DESCRIPTION"
Set up the PCI and controller side of the IDE interface. This brings
up the PCI side of the device, checks that the device is enabled
and enables it if need be
.TH "ide_pci_setup_ports" 9 "ide_pci_setup_ports" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_pci_setup_ports \- 	configure ports/devices on PCI IDE
.SH SYNOPSIS
.B "void" ide_pci_setup_ports
.BI "(struct pci_dev *" dev ","
.BI "ide_pci_device_t *" d ","
.BI "int " pciirq ","
.BI "ata_index_t *" index ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device
.IP "d" 12
 IDE pci device info
.IP "pciirq" 12
 IRQ line
.IP "index" 12
 ata index to update
.SH "DESCRIPTION"
Scan the interfaces attached to this device and do any
necessary per port setup. Attach the devices and ask the
generic DMA layer to do its work for us.

Normally called automaticall from do_ide_pci_setup_device,
but is also used directly as a helper function by some controllers
where the chipset setup is not the default PCI IDE one.
.TH "ide_pci_unregister_driver" 9 "ide_pci_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_pci_unregister_driver \- 	unregister an IDE driver
.SH SYNOPSIS
.B "void" ide_pci_unregister_driver
.BI "(struct pci_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
 driver to remove
.SH "DESCRIPTION"
Unregister a currently installed IDE driver. Returns are the same
as for pci_unregister_driver
.TH "ide_scan_pcidev" 9 "ide_scan_pcidev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_scan_pcidev \- 	find an IDE driver for a device
.SH SYNOPSIS
.B "int __init" ide_scan_pcidev
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to check
.SH "DESCRIPTION"
Look for an IDE driver to handle the device we are considering.
This is only used during boot up to get the ordering correct. After
boot up the pci layer takes over the job.
.TH "ide_scan_pcibus" 9 "ide_scan_pcibus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_scan_pcibus \- 	perform the initial IDE driver scan
.SH SYNOPSIS
.B "void __init" ide_scan_pcibus
.BI "(int " scan_direction ");"
.SH ARGUMENTS
.IP "scan_direction" 12
 set for reverse order scanning
.SH "DESCRIPTION"
Perform the initial bus rather than driver ordered scan of the
PCI drivers. After this all IDE pci handling becomes standard
module ordering not traditionally ordered.
.TH "ide_xfer_verbose" 9 "ide_xfer_verbose" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_xfer_verbose \- 	return IDE mode names
.SH SYNOPSIS
.B "char *" ide_xfer_verbose
.BI "(u8 " xfer_rate ");"
.SH ARGUMENTS
.IP "xfer_rate" 12
 rate to name
.SH "DESCRIPTION"
Returns a constant string giving the name of the mode
requested.
.TH "ide_dma_speed" 9 "ide_dma_speed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_dma_speed \- 	compute DMA speed
.SH SYNOPSIS
.B "u8" ide_dma_speed
.BI "(ide_drive_t *" drive ","
.BI "u8 " mode ");"
.SH ARGUMENTS
.IP "drive" 12
 drive
\fImode\fP; intended mode
.IP "mode" 12
-- undescribed --
.SH "DESCRIPTION"
Checks the drive capabilities and returns the speed to use
for the transfer. Returns -1 if the requested mode is unknown
(eg PIO)
.TH "ide_rate_filter" 9 "ide_rate_filter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_rate_filter \- 	return best speed for mode
.SH SYNOPSIS
.B "u8" ide_rate_filter
.BI "(u8 " mode ","
.BI "u8 " speed ");"
.SH ARGUMENTS
.IP "mode" 12
 modes available
.IP "speed" 12
 desired speed
.SH "DESCRIPTION"
Given the available DMA/UDMA mode this function returns
the best available speed at or below the speed requested.
.TH "ide_scan_pio_blacklist" 9 "ide_scan_pio_blacklist" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_scan_pio_blacklist \- 	check for a blacklisted drive
.SH SYNOPSIS
.B "int" ide_scan_pio_blacklist
.BI "(char *" model ");"
.SH ARGUMENTS
.IP "model" 12
 Drive model string
.SH "DESCRIPTION"
This routine searches the ide_pio_blacklist for an entry
matching the start/whole of the supplied model name.

Returns -1 if no match found.
Otherwise returns the recommended PIO mode from ide_pio_blacklist[].
.TH "ide_get_best_pio_mode" 9 "ide_get_best_pio_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_get_best_pio_mode \- 	get PIO mode from drive
.SH SYNOPSIS
.B "u8" ide_get_best_pio_mode
.BI "(ide_drive_t *" drive ","
.BI "u8 " mode_wanted ","
.BI "u8 " max_mode ","
.BI "ide_pio_data_t *" d ");"
.SH ARGUMENTS
.IP "drive" 12
-- undescribed --
.IP "mode_wanted" 12
 preferred mode
.IP "max_mode" 12
 highest allowed
.IP "d" 12
 pio data
.SH "DESCRIPTION"
This routine returns the recommended PIO settings for a given drive,
based on the drive-&gt;id information and the ide_pio_blacklist[].
This is used by most chipset support modules when "auto-tuning".

Drive PIO mode auto selection
.TH "ide_toggle_bounce" 9 "ide_toggle_bounce" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_toggle_bounce \- 	handle bounce buffering
.SH SYNOPSIS
.B "void" ide_toggle_bounce
.BI "(ide_drive_t *" drive ","
.BI "int " on ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to update
.IP "on" 12
 on/off boolean
.SH "DESCRIPTION"
Enable or disable bounce buffering for the device. Drives move
between PIO and DMA and that changes the rules we need.
.TH "ide_set_xfer_rate" 9 "ide_set_xfer_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_set_xfer_rate \- 	set transfer rate
.SH SYNOPSIS
.B "int" ide_set_xfer_rate
.BI "(ide_drive_t *" drive ","
.BI "u8 " rate ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to set
.IP "rate" 12
-- undescribed --
.SH "DESCRIPTION"
General helper for setting the speed of an IDE device. This
function knows about user enforced limits from the configuration
which \fBspeedproc\fP does not.  High level drivers should never
invoke \fBspeedproc\fP directly.
.TH "ide_dump_atapi_status" 9 "ide_dump_atapi_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_dump_atapi_status \-        print human readable atapi status
.SH SYNOPSIS
.B "u8" ide_dump_atapi_status
.BI "(ide_drive_t *" drive ","
.BI "const char *" msg ","
.BI "u8 " stat ");"
.SH ARGUMENTS
.IP "drive" 12
 drive that status applies to
.IP "msg" 12
 text message to print
.IP "stat" 12
 status byte to decode
.SH "DESCRIPTION"
Error reporting, in human readable form (luxurious, but a memory hog).
.TH "ide_dump_status" 9 "ide_dump_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_dump_status \- 	translate ATA/ATAPI error
.SH SYNOPSIS
.B "u8" ide_dump_status
.BI "(ide_drive_t *" drive ","
.BI "const char *" msg ","
.BI "u8 " stat ");"
.SH ARGUMENTS
.IP "drive" 12
 drive the error occured on
.IP "msg" 12
 information string
.IP "stat" 12
 status byte
.SH "DESCRIPTION"
Error reporting, in human readable form (luxurious, but a memory hog).
Combines the drive name, message and status byte to provide a
user understandable explanation of the device error.
.TH "generic_id" 9 "generic_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_id \- 	add a generic drive id
.SH SYNOPSIS
.B "void" generic_id
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
	drive to make an ID block for
.SH "DESCRIPTION"
Add a fake id field to the drive we are passed. This allows
use to skip a ton of NULL checks (which people always miss) 
and make drive properties unconditional outside of this file
.TH "drive_is_flashcard" 9 "drive_is_flashcard" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drive_is_flashcard \- 	check for compact flash
.SH SYNOPSIS
.B "int" drive_is_flashcard
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to check
.SH "DESCRIPTION"
CompactFlash cards and their brethern pretend to be removable
hard disks, except:
(1) they never have a slave unit, and
(2) they don't have doorlock mechanisms.
This test catches them, and is invoked elsewhere when setting
appropriate config bits.
.SH "FIXME"
 This treatment is probably applicable for *all* PCMCIA (PC CARD)
devices, so in linux 2.3.x we should change this to just treat all
PCMCIA  drives this way, and get rid of the model-name tests below
(too big of an interface change for 2.4.x).
At that time, we might also consider parameterizing the timeouts and
retries, since these are MUCH faster than mechanical drives. -M.Lord
.TH "do_identify" 9 "do_identify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_identify \- 	identify a drive
.SH SYNOPSIS
.B "void" do_identify
.BI "(ide_drive_t *" drive ","
.BI "u8 " cmd ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to identify 
.IP "cmd" 12
 command used
.SH "DESCRIPTION"
Called when we have issued a drive identify command to
read and parse the results. This function is run with
interrupts disabled. 
.TH "actual_try_to_identify" 9 "actual_try_to_identify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
actual_try_to_identify \- 	send ata/atapi identify
.SH SYNOPSIS
.B "int" actual_try_to_identify
.BI "(ide_drive_t *" drive ","
.BI "u8 " cmd ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to identify
.IP "cmd" 12
 command to use
.SH "DESCRIPTION"
\fBtry_to_identify\fP sends an ATA(PI) IDENTIFY request to a drive
and waits for a response.  It also monitors irqs while this is
happening, in hope of automatically determining which one is
being used by the interface.
.SH "RETURNS"
	0  device was identified
1  device timed-out (no response to identify request)
2  device aborted the command (refused to identify itself)
.TH "try_to_identify" 9 "try_to_identify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
try_to_identify \- 	try to identify a drive
.SH SYNOPSIS
.B "int" try_to_identify
.BI "(ide_drive_t *" drive ","
.BI "u8 " cmd ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to probe
.IP "cmd" 12
 command to use
.SH "DESCRIPTION"
Issue the identify command and then do IRQ probing to
complete the identification when needed by finding the
IRQ the drive is attached to
.TH "do_probe" 9 "do_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_probe \- 	probe an IDE device
.SH SYNOPSIS
.B "int" do_probe
.BI "(ide_drive_t *" drive ","
.BI "u8 " cmd ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to probe
.IP "cmd" 12
 command to use
.SH "DESCRIPTION"
\fBdo_probe\fP has the difficult job of finding a drive if it exists,
without getting hung up if it doesn't exist, without trampling on
ethernet cards, and without leaving any IRQs dangling to haunt us later.

If a drive is "known" to exist (from CMOS or kernel parameters),
but does not respond right away, the probe will "hang in there"
for the maximum wait time (about 30 seconds), otherwise it will
exit much more quickly.
.SH "RETURNS"
	0  device was identified
1  device timed-out (no response to identify request)
2  device aborted the command (refused to identify itself)
3  bad status from device (possible for ATAPI drives)
4  probe was not attempted because failure was obvious
.TH "probe_for_drive" 9 "probe_for_drive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_for_drive \- 	upper level drive probe
.SH SYNOPSIS
.B "u8" probe_for_drive
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to probe for
.SH "DESCRIPTION"
\fBprobe_for_drive\fP tests for existence of a given drive using \fBdo_probe\fP
and presents things to the user as needed.
.SH "RETURNS"
	0  no device was found
1  device was found (note: drive-&gt;present might
still be 0)
.TH "ide_undecoded_slave" 9 "ide_undecoded_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_undecoded_slave \- 	look for bad CF adapters
.SH SYNOPSIS
.B "void" ide_undecoded_slave
.BI "(ide_hwif_t *" hwif ");"
.SH ARGUMENTS
.IP "hwif" 12
 interface
.SH "DESCRIPTION"
Analyse the drives on the interface and attempt to decide if we
have the same drive viewed twice. This occurs with crap CF adapters
and PCMCIA sometimes.
.TH "in_drive_list" 9 "in_drive_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
in_drive_list \- 	look for drive in black/white list
.SH SYNOPSIS
.B "int" in_drive_list
.BI "(struct hd_driveid *" id ","
.BI "const struct drive_list_entry *" drive_table ");"
.SH ARGUMENTS
.IP "id" 12
 drive identifier
.IP "drive_table" 12
 list to inspect
.SH "DESCRIPTION"
Look for a drive in the blacklist and the whitelist tables
Returns 1 if the drive is found in the table.
.TH "ide_dma_intr" 9 "ide_dma_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_dma_intr \- 	IDE DMA interrupt handler
.SH SYNOPSIS
.B "ide_startstop_t" ide_dma_intr
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 the drive the interrupt is for
.SH "DESCRIPTION"
Handle an interrupt completing a read/write DMA transfer on an 
IDE device
.TH "ide_build_sglist" 9 "ide_build_sglist" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_build_sglist \- 	map IDE scatter gather for DMA I/O
.SH SYNOPSIS
.B "int" ide_build_sglist
.BI "(ide_drive_t *" drive ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "drive" 12
 the drive to build the DMA table for
.IP "rq" 12
 the request holding the sg list
.SH "DESCRIPTION"
Perform the PCI mapping magic necessary to access the source or
target buffers of a request via PCI DMA. The lower layers of the
kernel provide the necessary cache management so that we can
operate in a portable fashion
.TH "ide_build_dmatable" 9 "ide_build_dmatable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_build_dmatable \- 	build IDE DMA table
.SH SYNOPSIS
.B "int" ide_build_dmatable
.BI "(ide_drive_t *" drive ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "drive" 12
-- undescribed --
.IP "rq" 12
-- undescribed --
.SH "DESCRIPTION"

\fBide_build_dmatable\fP prepares a dma request. We map the command
to get the pci bus addresses of the buffers and then build up
the PRD table that the IDE layer wants to be fed. The code
knows about the 64K wrap bug in the CS5530.

Returns the number of built PRD entries if all went okay,
returns 0 otherwise.

May also be invoked from trm290.c
.TH "ide_destroy_dmatable" 9 "ide_destroy_dmatable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_destroy_dmatable \- 	clean up DMA mapping
.SH SYNOPSIS
.B "void" ide_destroy_dmatable
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 The drive to unmap
.SH "DESCRIPTION"
Teardown mappings after DMA has completed. This must be called
after the completion of each use of ide_build_dmatable and before
the next use of ide_build_dmatable. Failure to do so will cause
an oops as only one mapping can be live for each target at a given
time.
.TH "config_drive_for_dma" 9 "config_drive_for_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
config_drive_for_dma \- 	attempt to activate IDE DMA
.SH SYNOPSIS
.B "int" config_drive_for_dma
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 the drive to place in DMA mode
.SH "DESCRIPTION"
If the drive supports at least mode 2 DMA or UDMA of any kind
then attempt to place it into DMA mode. Drives that are known to
support DMA but predate the DMA properties or that are known
to have DMA handling bugs are also set up appropriately based
on the good/bad drive lists.
.TH "dma_timer_expiry" 9 "dma_timer_expiry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_timer_expiry \- 	handle a DMA timeout
.SH SYNOPSIS
.B "int" dma_timer_expiry
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 Drive that timed out
.SH "DESCRIPTION"
An IDE DMA transfer timed out. In the event of an error we ask
the driver to resolve the problem, if a DMA transfer is still
in progress we continue to wait (arguably we need to add a 
secondary 'I don't care what the drive thinks' timeout here)
Finally if we have an interrupt we let it complete the I/O.
But only one time - we clear expiry and if it's still not
completed after WAIT_CMD, we error and retry in PIO.
This can occur if an interrupt is lost or due to hang or bugs.
.TH "__ide_dma_host_off" 9 "__ide_dma_host_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_dma_host_off \- 	Generic DMA kill
.SH SYNOPSIS
.B "int" __ide_dma_host_off
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to control
.SH "DESCRIPTION"
Perform the generic IDE controller DMA off operation. This
works for most IDE bus mastering controllers
.TH "__ide_dma_off_quietly" 9 "__ide_dma_off_quietly" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_dma_off_quietly \- 	Generic DMA kill
.SH SYNOPSIS
.B "int" __ide_dma_off_quietly
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to control
.SH "DESCRIPTION"
Turn off the current DMA on this IDE controller. 
.TH "__ide_dma_off" 9 "__ide_dma_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_dma_off \- 	disable DMA on a device
.SH SYNOPSIS
.B "int" __ide_dma_off
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to disable DMA on
.SH "DESCRIPTION"
Disable IDE DMA for a device on this IDE controller.
Inform the user that DMA has been disabled.
.TH "__ide_dma_host_on" 9 "__ide_dma_host_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_dma_host_on \- 	Enable DMA on a host
.SH SYNOPSIS
.B "int" __ide_dma_host_on
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to enable for DMA
.SH "DESCRIPTION"
Enable DMA on an IDE controller following generic bus mastering
IDE controller behaviour
.TH "__ide_dma_on" 9 "__ide_dma_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_dma_on \- 	Enable DMA on a device
.SH SYNOPSIS
.B "int" __ide_dma_on
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to enable DMA on
.SH "DESCRIPTION"
Enable IDE DMA for a device on this IDE controller.
.TH "__ide_dma_check" 9 "__ide_dma_check" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ide_dma_check \- 	check DMA setup
.SH SYNOPSIS
.B "int" __ide_dma_check
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to check
.SH "DESCRIPTION"
Don't use - due for extermination
.TH "ide_dma_setup" 9 "ide_dma_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_dma_setup \- 	begin a DMA phase
.SH SYNOPSIS
.B "int" ide_dma_setup
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 target device
.SH "DESCRIPTION"
Build an IDE DMA PRD (IDE speak for scatter gather table)
and then set up the DMA transfer registers for a device
that follows generic IDE PCI DMA behaviour. Controllers can
override this function if they need to

Returns 0 on success. If a PIO fallback is required then 1
is returned. 
.TH "ide_end_request" 9 "ide_end_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_end_request \- 	complete an IDE I/O
.SH SYNOPSIS
.B "int" ide_end_request
.BI "(ide_drive_t *" drive ","
.BI "int " uptodate ","
.BI "int " nr_sectors ");"
.SH ARGUMENTS
.IP "drive" 12
 IDE device for the I/O
.IP "uptodate" 12
-- undescribed --
.IP "nr_sectors" 12
 number of sectors completed
.SH "DESCRIPTION"
This is our end_request wrapper function. We complete the I/O
update random number input and dequeue the request, which if
it was tagged may be out of order.
.TH "ide_complete_pm_request" 9 "ide_complete_pm_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_complete_pm_request \-  end the current Power Management request
.SH SYNOPSIS
.B "void" ide_complete_pm_request
.BI "(ide_drive_t *" drive ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "drive" 12
 target drive
.IP "rq" 12
 request
.SH "DESCRIPTION"
This function cleans up the current PM request and stops the queue
if necessary.
.TH "ide_end_drive_cmd" 9 "ide_end_drive_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_end_drive_cmd \- 	end an explicit drive command
.SH SYNOPSIS
.B "void" ide_end_drive_cmd
.BI "(ide_drive_t *" drive ","
.BI "u8 " stat ","
.BI "u8 " err ");"
.SH ARGUMENTS
.IP "drive" 12
 command 
.IP "stat" 12
 status bits
.IP "err" 12
 error bits
.SH "DESCRIPTION"
Clean up after success/failure of an explicit drive command.
These get thrown onto the queue so they are synchronized with
real I/O operations on the drive.

In LBA48 mode we have to read the register set twice to get
all the extra information out.
.TH "try_to_flush_leftover_data" 9 "try_to_flush_leftover_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
try_to_flush_leftover_data \- 	flush junk
.SH SYNOPSIS
.B "void" try_to_flush_leftover_data
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to flush
.SH "DESCRIPTION"
\fBtry_to_flush_leftover_data\fP is invoked in response to a drive
unexpectedly having its DRQ_STAT bit set.  As an alternative to
resetting the drive, this routine tries to clear the condition
by read a sector's worth of data from the drive.  Of course,
this may not help if the drive is *waiting* for data from *us*.
.TH "ide_error" 9 "ide_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_error \- 	handle an error on the IDE
.SH SYNOPSIS
.B "ide_startstop_t" ide_error
.BI "(ide_drive_t *" drive ","
.BI "const char *" msg ","
.BI "u8 " stat ");"
.SH ARGUMENTS
.IP "drive" 12
 drive the error occurred on
.IP "msg" 12
 message to report
.IP "stat" 12
 status bits
.SH "DESCRIPTION"
\fBide_error\fP takes action based on the error returned by the drive.
For normal I/O that may well include retries. We deal with
both new-style (taskfile) and old style command handling here.
In the case of taskfile command handling there is work left to
do
.TH "ide_abort" 9 "ide_abort" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_abort \- 	abort pending IDE operations
.SH SYNOPSIS
.B "ide_startstop_t" ide_abort
.BI "(ide_drive_t *" drive ","
.BI "const char *" msg ");"
.SH ARGUMENTS
.IP "drive" 12
 drive the error occurred on
.IP "msg" 12
 message to report
.SH "DESCRIPTION"
ide_abort kills and cleans up when we are about to do a 
host initiated reset on active commands. Longer term we
want handlers to have sensible abort handling themselves

This differs fundamentally from ide_error because in 
this case the command is doing just fine when we
blow it away.
.TH "ide_cmd" 9 "ide_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_cmd \- 	issue a simple drive command
.SH SYNOPSIS
.B "void" ide_cmd
.BI "(ide_drive_t *" drive ","
.BI "u8 " cmd ","
.BI "u8 " nsect ","
.BI "ide_handler_t *" handler ");"
.SH ARGUMENTS
.IP "drive" 12
 drive the command is for
.IP "cmd" 12
 command byte
.IP "nsect" 12
 sector byte
.IP "handler" 12
 handler for the command completion
.SH "DESCRIPTION"
Issue a simple drive command with interrupts.
The drive must be selected beforehand.
.TH "drive_cmd_intr" 9 "drive_cmd_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
drive_cmd_intr \-  	drive command completion interrupt
.SH SYNOPSIS
.B "ide_startstop_t" drive_cmd_intr
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive the completion interrupt occurred on
.SH "DESCRIPTION"
\fBdrive_cmd_intr\fP is invoked on completion of a special DRIVE_CMD.
We do any necessary data reading and then wait for the drive to
go non busy. At that point we may read the error data and complete
the request
.TH "do_special" 9 "do_special" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_special \- 	issue some special commands
.SH SYNOPSIS
.B "ide_startstop_t" do_special
.BI "(ide_drive_t *" drive ");"
.SH ARGUMENTS
.IP "drive" 12
 drive the command is for
.SH "DESCRIPTION"
\fBdo_special\fP is used to issue WIN_SPECIFY, WIN_RESTORE, and WIN_SETMULT
commands to a drive.  It used to do much more, but has been scaled
back.
.TH "execute_drive_cmd" 9 "execute_drive_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
execute_drive_cmd \- 	issue special drive command
.SH SYNOPSIS
.B "ide_startstop_t" execute_drive_cmd
.BI "(ide_drive_t *" drive ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "drive" 12
 the drive to issue the command on
.IP "rq" 12
 the request structure holding the command
.SH "DESCRIPTION"
\fBexecute_drive_cmd\fP issues a special drive command,  usually 
initiated by \fBioctl\fP from the external hdparm program. The
command can be a drive command, drive task or taskfile 
operation. Weirdly you can call it with NULL to wait for
all commands to finish. Don't do this as that is due to change
.TH "start_request" 9 "start_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
start_request \- 	start of I/O and command issuing for IDE
.SH SYNOPSIS
.B "ide_startstop_t" start_request
.BI "(ide_drive_t *" drive ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "drive" 12
-- undescribed --
.IP "rq" 12
-- undescribed --
.SH "DESCRIPTION"

\fBstart_request\fP initiates handling of a new I/O request. It
accepts commands and I/O (read/write) requests. It also does
the final remapping for weird stuff like EZDrive. Once 
device mapper can work sector level the EZDrive stuff can go away
.SH "FIXME"
 this function needs a rename
.TH "ide_stall_queue" 9 "ide_stall_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_stall_queue \- 	pause an IDE device
.SH SYNOPSIS
.B "void" ide_stall_queue
.BI "(ide_drive_t *" drive ","
.BI "unsigned long " timeout ");"
.SH ARGUMENTS
.IP "drive" 12
 drive to stall
.IP "timeout" 12
 time to stall for (jiffies)
.SH "DESCRIPTION"
\fBide_stall_queue\fP can be used by a drive to give excess bandwidth back
to the hwgroup by sleeping for timeout jiffies.
.TH "choose_drive" 9 "choose_drive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
choose_drive \- 	select a drive to service
.SH SYNOPSIS
.B "ide_drive_t *" choose_drive
.BI "(ide_hwgroup_t *" hwgroup ");"
.SH ARGUMENTS
.IP "hwgroup" 12
 hardware group to select on
.SH "DESCRIPTION"
\fBchoose_drive\fP selects the next drive which will be serviced.
This is necessary because the IDE layer can't issue commands
to both drives on the same cable, unlike SCSI.
.TH "ide_timer_expiry" 9 "ide_timer_expiry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_timer_expiry \- 	handle lack of an IDE interrupt
.SH SYNOPSIS
.B "void" ide_timer_expiry
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 timer callback magic (hwgroup)
.SH "DESCRIPTION"
An IDE command has timed out before the expected drive return
occurred. At this point we attempt to clean up the current
mess. If the current handler includes an expiry handler then
we invoke the expiry handler, and providing it is happy the
work is done. If that fails we apply generic recovery rules
invoking the handler and checking the drive DMA status. We
have an excessively incestuous relationship with the DMA
logic that wants cleaning up.
.TH "unexpected_intr" 9 "unexpected_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unexpected_intr \- 	handle an unexpected IDE interrupt
.SH SYNOPSIS
.B "void" unexpected_intr
.BI "(int " irq ","
.BI "ide_hwgroup_t *" hwgroup ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt line
.IP "hwgroup" 12
 hwgroup being processed
.SH "DESCRIPTION"
There's nothing really useful we can do with an unexpected interrupt,
other than reading the status register (to clear it), and logging it.
There should be no way that an irq can happen before we're ready for it,
so we needn't worry much about losing an "important" interrupt here.

On laptops (and "green" PCs), an unexpected interrupt occurs whenever
the drive enters "idle", "standby", or "sleep" mode, so if the status
looks "good", we just ignore the interrupt completely.

This routine assumes \fB__cli\fP is in effect when called.

If an unexpected interrupt happens on irq15 while we are handling irq14
and if the two interfaces are "serialized" (CMD640), then it looks like
we could screw up by interfering with a new request being set up for 
irq15.

In reality, this is a non-issue.  The new command is not sent unless 
the drive is ready to accept one, in which case we know the drive is
not trying to interrupt us.  And \fBide_set_handler\fP is always invoked
before completing the issuance of any new drive command, so we will not
be accidentally invoked as a result of any valid command completion
interrupt.

Note that we must walk the entire hwgroup here. We know which hwif
is doing the current command, but we don't know which hwif burped
mysteriously.
.TH "ide_intr" 9 "ide_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_intr \- 	default IDE interrupt handler
.SH SYNOPSIS
.B "irqreturn_t" ide_intr
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt number
.IP "dev_id" 12
 hwif group
.IP "regs" 12
 unused weirdness from the kernel irq layer
.SH "DESCRIPTION"
This is the default IRQ handler for the IDE layer. You should
not need to override it. If you do be aware it is subtle in
places

hwgroup-&gt;hwif is the interface in the group currently performing
a command. hwgroup-&gt;drive is the drive and hwgroup-&gt;handler is
the IRQ handler to call. As we issue a command the handlers
step through multiple states, reassigning the handler to the
next step in the process. Unlike a smart SCSI controller IDE
expects the main processor to sequence the various transfer
stages. We also manage a poll timer to catch up with most
timeout situations. There are still a few where the handlers
don't ever decide to give up.

The handler eventually returns ide_stopped to indicate the
request completed. At this point we issue the next request
on the hwgroup and the process begins again.
.TH "ide_init_drive_cmd" 9 "ide_init_drive_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_init_drive_cmd \- 	initialize a drive command request
.SH SYNOPSIS
.B "void" ide_init_drive_cmd
.BI "(struct request *" rq ");"
.SH ARGUMENTS
.IP "rq" 12
 request object
.SH "DESCRIPTION"
Initialize a request before we fill it in and send it down to
ide_do_drive_cmd. Commands must be set up by this function. Right
now it doesn't do a lot, but if that changes abusers will have a
nasty suprise.
.TH "ide_do_drive_cmd" 9 "ide_do_drive_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ide_do_drive_cmd \- 	issue IDE special command
.SH SYNOPSIS
.B "int" ide_do_drive_cmd
.BI "(ide_drive_t *" drive ","
.BI "struct request *" rq ","
.BI "ide_action_t " action ");"
.SH ARGUMENTS
.IP "drive" 12
 device to issue command
.IP "rq" 12
 request to issue
.IP "action" 12
 action for processing
.SH "DESCRIPTION"
This function issues a special IDE device request
onto the request queue.

If action is ide_wait, then the rq is queued at the end of the
request queue, and the function sleeps until it has been processed.
This is for use when invoked from an ioctl handler.

If action is ide_preempt, then the rq is queued at the head of
the request queue, displacing the currently-being-processed
request and this function returns immediately without waiting
for the new rq to be completed.  This is VERY DANGEROUS, and is
intended for careful use by the ATAPI tape/cdrom driver code.

If action is ide_next, then the rq is queued immediately after
the currently-being-processed-request (if any), and the function
returns without waiting for the new rq to be completed.  As above,
This is VERY DANGEROUS, and is intended for careful use by the
ATAPI tape/cdrom driver code.

If action is ide_end, then the rq is queued at the end of the
request queue, and the function returns immediately without waiting
for the new rq to be completed. This is again intended for careful
use by the ATAPI tape/cdrom driver code.
.TH "ibmasm_receive_message" 9 "ibmasm_receive_message" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_receive_message \- 
.SH SYNOPSIS
.B "void" ibmasm_receive_message
.BI "(struct service_processor *" sp ","
.BI "void *" message ","
.BI "int " message_size ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.IP "message" 12
-- undescribed --
.IP "message_size" 12
-- undescribed --
.SH "DESCRIPTION"
Called from interrupt context.
.TH "ibmasm_send_driver_vpd" 9 "ibmasm_send_driver_vpd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_send_driver_vpd \- 
.SH SYNOPSIS
.B "int" ibmasm_send_driver_vpd
.BI "(struct service_processor *" sp ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.TH "ibmasm_send_os_state" 9 "ibmasm_send_os_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_send_os_state \- 
.SH SYNOPSIS
.B "int" ibmasm_send_os_state
.BI "(struct service_processor *" sp ","
.BI "int " os_state ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.IP "os_state" 12
-- undescribed --
.SH "DESCRIPTION"
During driver init this function is called with os state "up".
This causes the service processor to start sending heartbeats the
driver.
During driver exit the function is called with os state "down", 
causing the service processor to stop the heartbeats.
.TH "ibmasm_exec_command" 9 "ibmasm_exec_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_exec_command \- 
.SH SYNOPSIS
.B "void" ibmasm_exec_command
.BI "(struct service_processor *" sp ","
.BI "struct command *" cmd ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.SH "DESCRIPTION"
send a command to a service processor
Commands are executed sequentially. One command (sp-&gt;current_command)
is sent to the service processor. Once the interrupt handler gets a
message of type command_response, the message is copied into
the current commands buffer, 
.TH "ibmasm_wait_for_response" 9 "ibmasm_wait_for_response" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_wait_for_response \- 
.SH SYNOPSIS
.B "void" ibmasm_wait_for_response
.BI "(struct command *" cmd ","
.BI "int " timeout ");"
.SH ARGUMENTS
.IP "cmd" 12
-- undescribed --
.IP "timeout" 12
-- undescribed --
.SH "DESCRIPTION"
and the command status been updated by the interrupt handler.
(see receive_response).
.TH "ibmasm_receive_command_response" 9 "ibmasm_receive_command_response" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_receive_command_response \- 
.SH SYNOPSIS
.B "void" ibmasm_receive_command_response
.BI "(struct service_processor *" sp ","
.BI "void *" response ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.IP "response" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
called by the interrupt handler when a dot command of type command_response
was received.
.TH "ibmasm_start_reverse_heartbeat" 9 "ibmasm_start_reverse_heartbeat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_start_reverse_heartbeat \- 
.SH SYNOPSIS
.B "int" ibmasm_start_reverse_heartbeat
.BI "(struct service_processor *" sp ","
.BI "struct reverse_heartbeat *" rhb ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.IP "rhb" 12
-- undescribed --
.SH "DESCRIPTION"
Loop forever, sending a reverse heartbeat dot command to the service
processor, then sleeping. The loop comes to an end if the service
processor fails to respond 3 times or we were interrupted.
.TH "ibmasm_receive_event" 9 "ibmasm_receive_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_receive_event \- 
.SH SYNOPSIS
.B "void" ibmasm_receive_event
.BI "(struct service_processor *" sp ","
.BI "void *" data ","
.BI "unsigned int " data_size ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "data_size" 12
-- undescribed --
.SH "DESCRIPTION"
Called by the interrupt handler when a dot command of type sp_event is
received.
Store the event in the circular event buffer, wake up any sleeping
event readers.
There is no reader marker in the buffer, therefore readers are
responsible for keeping up with the writer, or they will loose events.
.TH "ibmasm_get_next_event" 9 "ibmasm_get_next_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibmasm_get_next_event \- 
.SH SYNOPSIS
.B "int" ibmasm_get_next_event
.BI "(struct service_processor *" sp ","
.BI "struct event_reader *" reader ");"
.SH ARGUMENTS
.IP "sp" 12
-- undescribed --
.IP "reader" 12
-- undescribed --
.SH "DESCRIPTION"
Called by event readers (initiated from user space through the file
system). 
Sleeps until a new event is available.
.TH "gscps2_interrupt" 9 "gscps2_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gscps2_interrupt \-  Interruption service routine
.SH SYNOPSIS
.B "irqreturn_t" gscps2_interrupt
.BI "(int " irq ","
.BI "void *" dev ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.SH "DESCRIPTION"

This function reads received PS/2 bytes and processes them on
all interfaces.
The problematic part here is, that the keyboard and mouse PS/2 port
share the same interrupt and it's not possible to send data if any
one of them holds input data. To solve this problem we try to receive
the data as fast as possible and handle the reporting to the upper layer
later.
.TH "gscps2_probe" 9 "gscps2_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gscps2_probe \-  Probes PS2 devices
.SH SYNOPSIS
.B "int __init" gscps2_probe
.BI "(struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.TH "gscps2_remove" 9 "gscps2_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gscps2_remove \-  Removes PS2 devices
.SH SYNOPSIS
.B "int __devexit" gscps2_remove
.BI "(struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.TH "spider_net_read_reg" 9 "spider_net_read_reg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_read_reg \-  reads an SMMIO register of a card
.SH SYNOPSIS
.B "u32" spider_net_read_reg
.BI "(struct spider_net_card *" card ","
.BI "u32 " reg ");"
.SH ARGUMENTS
.IP "card" 12
 device structure
.IP "reg" 12
 register to read from
.SH "DESCRIPTION"
returns the content of the specified SMMIO register.
.TH "spider_net_write_reg" 9 "spider_net_write_reg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_write_reg \-  writes to an SMMIO register of a card
.SH SYNOPSIS
.B "void" spider_net_write_reg
.BI "(struct spider_net_card *" card ","
.BI "u32 " reg ","
.BI "u32 " value ");"
.SH ARGUMENTS
.IP "card" 12
 device structure
.IP "reg" 12
 register to write to
.IP "value" 12
 value to write into the specified SMMIO register
.TH "spider_net_write_reg_sync" 9 "spider_net_write_reg_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_write_reg_sync \-  writes to an SMMIO register of a card
.SH SYNOPSIS
.B "void" spider_net_write_reg_sync
.BI "(struct spider_net_card *" card ","
.BI "u32 " reg ","
.BI "u32 " value ");"
.SH ARGUMENTS
.IP "card" 12
 device structure
.IP "reg" 12
 register to write to
.IP "value" 12
 value to write into the specified SMMIO register
.SH "DESCRIPTION"
Unlike spider_net_write_reg, this will also make sure the
data arrives on the card by reading the reg again.
.TH "spider_net_rx_irq_off" 9 "spider_net_rx_irq_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_rx_irq_off \-  switch off rx irq on this spider card
.SH SYNOPSIS
.B "void" spider_net_rx_irq_off
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 device structure
.SH "DESCRIPTION"
switches off rx irq by masking them out in the GHIINTnMSK register
.TH "spider_net_rx_irq_on" 9 "spider_net_rx_irq_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_rx_irq_on \-  switch on rx irq on this spider card
.SH SYNOPSIS
.B "void" spider_net_rx_irq_on
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 device structure
.SH "DESCRIPTION"
switches on rx irq by enabling them in the GHIINTnMSK register
.TH "spider_net_tx_irq_off" 9 "spider_net_tx_irq_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_tx_irq_off \-  switch off tx irq on this spider card
.SH SYNOPSIS
.B "void" spider_net_tx_irq_off
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 device structure
.SH "DESCRIPTION"
switches off tx irq by masking them out in the GHIINTnMSK register
.TH "spider_net_tx_irq_on" 9 "spider_net_tx_irq_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_tx_irq_on \-  switch on tx irq on this spider card
.SH SYNOPSIS
.B "void" spider_net_tx_irq_on
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 device structure
.SH "DESCRIPTION"
switches on tx irq by enabling them in the GHIINTnMSK register
.TH "spider_net_set_promisc" 9 "spider_net_set_promisc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_set_promisc \-  sets the unicast address or the promiscuous mode
.SH SYNOPSIS
.B "void" spider_net_set_promisc
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_set_promisc sets the unicast destination address filter and
thus either allows for non-promisc mode or promisc mode
.TH "spider_net_get_mac_address" 9 "spider_net_get_mac_address" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_get_mac_address \-  read mac address from spider card
.SH SYNOPSIS
.B "int" spider_net_get_mac_address
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
-- undescribed --
.SH "DESCRIPTION"
reads MAC address from GMACUNIMACU and GMACUNIMACL registers
.TH "spider_net_get_descr_status" 9 "spider_net_get_descr_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_get_descr_status \- - returns the status of a descriptor
.SH SYNOPSIS
.B "enum spider_net_descr_status" spider_net_get_descr_status
.BI "(struct spider_net_descr *" descr ");"
.SH ARGUMENTS
.IP "descr" 12
 descriptor to look at
.SH "DESCRIPTION"
returns the status as in the dmac_cmd_status field of the descriptor
.TH "spider_net_set_descr_status" 9 "spider_net_set_descr_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_set_descr_status \- - sets the status of a descriptor
.SH SYNOPSIS
.B "void" spider_net_set_descr_status
.BI "(struct spider_net_descr *" descr ","
.BI "enum spider_net_descr_status " status ");"
.SH ARGUMENTS
.IP "descr" 12
 descriptor to change
.IP "status" 12
 status to set in the descriptor
.SH "DESCRIPTION"
changes the status to the specified value. Doesn't change other bits
in the status
.TH "spider_net_free_chain" 9 "spider_net_free_chain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_free_chain \-  free descriptor chain
.SH SYNOPSIS
.B "void" spider_net_free_chain
.BI "(struct spider_net_card *" card ","
.BI "struct spider_net_descr_chain *" chain ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "chain" 12
 address of chain
.TH "spider_net_init_chain" 9 "spider_net_init_chain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_init_chain \-  links descriptor chain
.SH SYNOPSIS
.B "int" spider_net_init_chain
.BI "(struct spider_net_card *" card ","
.BI "struct spider_net_descr_chain *" chain ","
.BI "struct spider_net_descr *" start_descr ","
.BI "int " no ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "chain" 12
 address of chain
.IP "start_descr" 12
 address of descriptor array
.IP "no" 12
 number of descriptors
.SH "DESCRIPTION"
we manage a circular list that mirrors the hardware structure,
except that the hardware uses bus addresses.

returns 0 on success, &lt;0 on failure
.TH "spider_net_free_rx_chain_contents" 9 "spider_net_free_rx_chain_contents" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_free_rx_chain_contents \-  frees descr contents in rx chain
.SH SYNOPSIS
.B "void" spider_net_free_rx_chain_contents
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure
.TH "spider_net_prepare_rx_descr" 9 "spider_net_prepare_rx_descr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_prepare_rx_descr \-  reinitializes a rx descriptor
.SH SYNOPSIS
.B "int" spider_net_prepare_rx_descr
.BI "(struct spider_net_card *" card ","
.BI "struct spider_net_descr *" descr ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "descr" 12
 descriptor to re-init
.SH "DESCRIPTION"
return 0 on succes, &lt;0 on failure

allocates a new rx skb, iommu-maps it and attaches it to the descriptor.
Activate the descriptor state-wise
.TH "spider_net_enable_rxchtails" 9 "spider_net_enable_rxchtails" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_enable_rxchtails \-  sets RX dmac chain tail addresses
.SH SYNOPSIS
.B "void" spider_net_enable_rxchtails
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_enable_rxctails sets the RX DMAC chain tail adresses in the
chip by writing to the appropriate register. DMA is enabled in
spider_net_enable_rxdmac.
.TH "spider_net_enable_rxdmac" 9 "spider_net_enable_rxdmac" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_enable_rxdmac \-  enables a receive DMA controller
.SH SYNOPSIS
.B "void" spider_net_enable_rxdmac
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_enable_rxdmac enables the DMA controller by setting RX_DMA_EN
in the GDADMACCNTR register
.TH "spider_net_refill_rx_chain" 9 "spider_net_refill_rx_chain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_refill_rx_chain \-  refills descriptors/skbs in the rx chains
.SH SYNOPSIS
.B "void" spider_net_refill_rx_chain
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
refills descriptors in all chains (last used chain first): allocates skbs
and iommu-maps them.
.TH "spider_net_alloc_rx_skbs" 9 "spider_net_alloc_rx_skbs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_alloc_rx_skbs \-  allocates rx skbs in rx descriptor chains
.SH SYNOPSIS
.B "int" spider_net_alloc_rx_skbs
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure
.TH "spider_net_release_tx_descr" 9 "spider_net_release_tx_descr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_release_tx_descr \-  processes a used tx descriptor
.SH SYNOPSIS
.B "void" spider_net_release_tx_descr
.BI "(struct spider_net_card *" card ","
.BI "struct spider_net_descr *" descr ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "descr" 12
 descriptor to release
.SH "DESCRIPTION"
releases a used tx descriptor (unmapping, freeing of skb)
.TH "spider_net_release_tx_chain" 9 "spider_net_release_tx_chain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_release_tx_chain \-  processes sent tx descriptors
.SH SYNOPSIS
.B "void" spider_net_release_tx_chain
.BI "(struct spider_net_card *" card ","
.BI "int " brutal ");"
.SH ARGUMENTS
.IP "card" 12
 adapter structure
.IP "brutal" 12
 if set, don't care about whether descriptor seems to be in use
.SH "DESCRIPTION"
releases the tx descriptors that spider has finished with (if non-brutal)
or simply release tx descriptors (if brutal)
.TH "spider_net_get_multicast_hash" 9 "spider_net_get_multicast_hash" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_get_multicast_hash \-  generates hash for multicast filter table
.SH SYNOPSIS
.B "u8" spider_net_get_multicast_hash
.BI "(struct net_device *" netdev ","
.BI "__u8 *" addr ");"
.SH ARGUMENTS
.IP "netdev" 12
-- undescribed --
.IP "addr" 12
 multicast address
.SH "DESCRIPTION"
returns the hash value.

spider_net_get_multicast_hash calculates a hash value for a given multicast
address, that is used to set the multicast filter tables
.TH "spider_net_set_multi" 9 "spider_net_set_multi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_set_multi \-  sets multicast addresses and promisc flags
.SH SYNOPSIS
.B "void" spider_net_set_multi
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.SH "DESCRIPTION"
spider_net_set_multi configures multicast addresses as needed for the
netdev interface. It also sets up multicast, allmulti and promisc
flags appropriately
.TH "spider_net_disable_rxdmac" 9 "spider_net_disable_rxdmac" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_disable_rxdmac \-  disables the receive DMA controller
.SH SYNOPSIS
.B "void" spider_net_disable_rxdmac
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_disable_rxdmac terminates processing on the DMA controller by
turing off DMA and issueing a force end
.TH "spider_net_stop" 9 "spider_net_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_stop \-  called upon ifconfig down
.SH SYNOPSIS
.B "int" spider_net_stop
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.SH "DESCRIPTION"
always returns 0
.TH "spider_net_get_next_tx_descr" 9 "spider_net_get_next_tx_descr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_get_next_tx_descr \-  returns the next available tx descriptor
.SH SYNOPSIS
.B "struct spider_net_descr *" spider_net_get_next_tx_descr
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 device structure to get descriptor from
.SH "DESCRIPTION"
returns the address of the next descriptor, or NULL if not available.
.TH "spider_net_set_txdescr_cmdstat" 9 "spider_net_set_txdescr_cmdstat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_set_txdescr_cmdstat \-  sets the tx descriptor command field
.SH SYNOPSIS
.B "void" spider_net_set_txdescr_cmdstat
.BI "(struct spider_net_descr *" descr ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "descr" 12
 descriptor structure to fill out
.IP "skb" 12
 packet to consider
.SH "DESCRIPTION"
fills out the command and status field of the descriptor structure,
depending on hardware checksum settings. This function assumes a \fBwmb\fP
has executed before.
.TH "spider_net_prepare_tx_descr" 9 "spider_net_prepare_tx_descr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_prepare_tx_descr \-  fill tx descriptor with skb data
.SH SYNOPSIS
.B "int" spider_net_prepare_tx_descr
.BI "(struct spider_net_card *" card ","
.BI "struct spider_net_descr *" descr ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "descr" 12
 descriptor structure to fill out
.IP "skb" 12
 packet to use
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure.

fills out the descriptor structure with skb data and len. Copies data,
if needed (32bit DMA!)
.TH "spider_net_kick_tx_dma" 9 "spider_net_kick_tx_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_kick_tx_dma \-  enables TX DMA processing
.SH SYNOPSIS
.B "void" spider_net_kick_tx_dma
.BI "(struct spider_net_card *" card ","
.BI "struct spider_net_descr *" descr ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "descr" 12
 descriptor address to enable TX processing at
.SH "DESCRIPTION"
spider_net_kick_tx_dma writes the current tx chain head as start address
of the tx descriptor chain and enables the transmission DMA engine
.TH "spider_net_xmit" 9 "spider_net_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_xmit \-  transmits a frame over the device
.SH SYNOPSIS
.B "int" spider_net_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "skb" 12
 packet to send out
.IP "netdev" 12
 interface device structure
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure
.TH "spider_net_do_ioctl" 9 "spider_net_do_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_do_ioctl \-  called for device ioctls
.SH SYNOPSIS
.B "int" spider_net_do_ioctl
.BI "(struct net_device *" netdev ","
.BI "struct ifreq *" ifr ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.IP "ifr" 12
 request parameter structure for ioctl
.IP "cmd" 12
 command code for ioctl
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure. Currently, we have no special ioctls.
-EOPNOTSUPP is returned, if an unknown ioctl was requested
.TH "spider_net_pass_skb_up" 9 "spider_net_pass_skb_up" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_pass_skb_up \-  takes an skb from a descriptor and passes it on
.SH SYNOPSIS
.B "int" spider_net_pass_skb_up
.BI "(struct spider_net_descr *" descr ","
.BI "struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "descr" 12
 descriptor to process
.IP "card" 12
 card structure
.SH "DESCRIPTION"
returns 1 on success, 0 if no packet was passed to the stack

iommu-unmaps the skb, fills out skb structure and passes the data to the
stack. The descriptor state is not changed.
.TH "spider_net_decode_one_descr" 9 "spider_net_decode_one_descr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_decode_one_descr \-  processes an rx descriptor
.SH SYNOPSIS
.B "int" spider_net_decode_one_descr
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
returns 1 if a packet has been sent to the stack, otherwise 0

processes an rx descriptor by iommu-unmapping the data buffer and passing
the packet up to the stack
.TH "spider_net_poll" 9 "spider_net_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_poll \-  NAPI poll function called by the stack to return packets
.SH SYNOPSIS
.B "int" spider_net_poll
.BI "(struct net_device *" netdev ","
.BI "int *" budget ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.IP "budget" 12
 number of packets we can pass to the stack at most
.SH "DESCRIPTION"
returns 0 if no more packets available to the driver/stack. Returns 1,
if the quota is exceeded, but the driver has still packets.

spider_net_poll returns all packets from the rx descriptors to the stack
(using netif_receive_skb). If all/enough packets are up, the driver
reenables interrupts and returns 0. If not, 1 is returned.
.TH "spider_net_vlan_rx_reg" 9 "spider_net_vlan_rx_reg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_vlan_rx_reg \-  initializes VLAN structures in the driver and card
.SH SYNOPSIS
.B "void" spider_net_vlan_rx_reg
.BI "(struct net_device *" netdev ","
.BI "struct vlan_group *" grp ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.IP "grp" 12
 vlan_group structure that is registered (NULL on destroying interface)
.TH "spider_net_vlan_rx_add" 9 "spider_net_vlan_rx_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_vlan_rx_add \-  adds VLAN id to the card filter
.SH SYNOPSIS
.B "void" spider_net_vlan_rx_add
.BI "(struct net_device *" netdev ","
.BI "uint16_t " vid ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.IP "vid" 12
 VLAN id to add
.TH "spider_net_vlan_rx_kill" 9 "spider_net_vlan_rx_kill" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_vlan_rx_kill \-  removes VLAN id to the card filter
.SH SYNOPSIS
.B "void" spider_net_vlan_rx_kill
.BI "(struct net_device *" netdev ","
.BI "uint16_t " vid ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.IP "vid" 12
 VLAN id to remove
.TH "spider_net_get_stats" 9 "spider_net_get_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_get_stats \-  get interface statistics
.SH SYNOPSIS
.B "struct net_device_stats *" spider_net_get_stats
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.SH "DESCRIPTION"
returns the interface statistics residing in the spider_net_card struct
.TH "spider_net_change_mtu" 9 "spider_net_change_mtu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_change_mtu \-  changes the MTU of an interface
.SH SYNOPSIS
.B "int" spider_net_change_mtu
.BI "(struct net_device *" netdev ","
.BI "int " new_mtu ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.IP "new_mtu" 12
 new MTU value
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure
.TH "spider_net_set_mac" 9 "spider_net_set_mac" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_set_mac \-  sets the MAC of an interface
.SH SYNOPSIS
.B "int" spider_net_set_mac
.BI "(struct net_device *" netdev ","
.BI "void *" p ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.IP "p" 12
-- undescribed --
.SH "DESCRIPTION"
Returns 0 on success, &lt;0 on failure. Currently, we don't support this
and will always return EOPNOTSUPP.
.TH "spider_net_enable_txdmac" 9 "spider_net_enable_txdmac" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_enable_txdmac \-  enables a TX DMA controller
.SH SYNOPSIS
.B "void" spider_net_enable_txdmac
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_enable_txdmac enables the TX DMA controller by setting the
descriptor chain tail address
.TH "spider_net_handle_error_irq" 9 "spider_net_handle_error_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_handle_error_irq \-  handles errors raised by an interrupt
.SH SYNOPSIS
.B "void" spider_net_handle_error_irq
.BI "(struct spider_net_card *" card ","
.BI "u32 " status_reg ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "status_reg" 12
 interrupt status register 0 (GHIINT0STS)
.SH "DESCRIPTION"
spider_net_handle_error_irq treats or ignores all error conditions
found when an interrupt is presented
.TH "spider_net_interrupt" 9 "spider_net_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_interrupt \-  interrupt handler for spider_net
.SH SYNOPSIS
.B "irqreturn_t" spider_net_interrupt
.BI "(int " irq ","
.BI "void *" ptr ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interupt number
.IP "ptr" 12
 pointer to net_device
.IP "regs" 12
 PU registers
.SH "DESCRIPTION"
returns IRQ_HANDLED, if interrupt was for driver, or IRQ_NONE, if no
interrupt found raised by card.

This is the interrupt handler, that turns off
interrupts for this device and makes the stack poll the driver
.TH "spider_net_poll_controller" 9 "spider_net_poll_controller" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_poll_controller \-  artificial interrupt for netconsole etc.
.SH SYNOPSIS
.B "void" spider_net_poll_controller
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.SH "DESCRIPTION"
see Documentation/networking/netconsole.txt
.TH "spider_net_init_card" 9 "spider_net_init_card" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_init_card \-  initializes the card
.SH SYNOPSIS
.B "void" spider_net_init_card
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_init_card initializes the card so that other registers can
be used
.TH "spider_net_enable_card" 9 "spider_net_enable_card" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_enable_card \-  enables the card by setting all kinds of regs
.SH SYNOPSIS
.B "void" spider_net_enable_card
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_enable_card sets a lot of SMMIO registers to enable the device
.TH "spider_net_open" 9 "spider_net_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_open \-  called upon ifonfig up
.SH SYNOPSIS
.B "int" spider_net_open
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure

spider_net_open allocates all the descriptors and memory needed for
operation, sets up multicast list and enables interrupts
.TH "spider_net_setup_phy" 9 "spider_net_setup_phy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_setup_phy \-  setup PHY
.SH SYNOPSIS
.B "int" spider_net_setup_phy
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
returns 0 on success, &lt;0 on failure

spider_net_setup_phy is used as part of spider_net_probe. Sets
the PHY to 1000 Mbps
.TH "spider_net_download_firmware" 9 "spider_net_download_firmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_download_firmware \-  loads firmware into the adapter
.SH SYNOPSIS
.B "void" spider_net_download_firmware
.BI "(struct spider_net_card *" card ","
.BI "const struct firmware *" firmware ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.IP "firmware" 12
 firmware pointer
.SH "DESCRIPTION"
spider_net_download_firmware loads the firmware opened by
spider_net_init_firmware into the adapter.
.TH "spider_net_init_firmware" 9 "spider_net_init_firmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_init_firmware \-  reads in firmware parts
.SH SYNOPSIS
.B "int" spider_net_init_firmware
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
Returns 0 on success, &lt;0 on failure

spider_net_init_firmware opens the sequencer firmware and does some basic
checks. This function opens and releases the firmware structure. A call
to download the firmware is performed before the release.

Firmware format
===============
spider_fw.bin is expected to be a file containing 6*1024*4 bytes, 4k being
the program for each sequencer. Use the command
tail -q -n +2 Seq_code1_0x088.txt Seq_code2_0x090.txt              \
Seq_code3_0x098.txt Seq_code4_0x0A0.txt Seq_code5_0x0A8.txt   \
Seq_code6_0x0B0.txt | xxd -r -p -c4 &gt; spider_fw.bin

to generate spider_fw.bin, if you have sequencer programs with something
.SH "LIKE THE FOLLOWING CONTENTS FOR EACH SEQUENCER"
&lt;ONE LINE COMMENT&gt;
&lt;FIRST 4-BYTES-WORD FOR SEQUENCER&gt;
&lt;SECOND 4-BYTES-WORD FOR SEQUENCER&gt;
...
&lt;1024th 4-BYTES-WORD FOR SEQUENCER&gt;
.TH "spider_net_workaround_rxramfull" 9 "spider_net_workaround_rxramfull" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_workaround_rxramfull \-  work around firmware bug
.SH SYNOPSIS
.B "void" spider_net_workaround_rxramfull
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
no return value
.TH "spider_net_tx_timeout_task" 9 "spider_net_tx_timeout_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_tx_timeout_task \-  task scheduled by the watchdog timeout
.SH SYNOPSIS
.B "void" spider_net_tx_timeout_task
.BI "(void *" data ");"
.SH ARGUMENTS
.IP "data" 12
 data, is interface device structure
.SH "DESCRIPTION"
called as task when tx hangs, resets interface (if interface is up)
.SH "DESCRIPTION"
called as task when tx hangs, resets interface (if interface is up)
.TH "spider_net_tx_timeout" 9 "spider_net_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_tx_timeout \-  called when the tx timeout watchdog kicks in.
.SH SYNOPSIS
.B "void" spider_net_tx_timeout
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 interface device structure
.SH "DESCRIPTION"
called, if tx hangs. Schedules a task that resets the interface
.TH "spider_net_setup_netdev_ops" 9 "spider_net_setup_netdev_ops" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_setup_netdev_ops \-  initialization of net_device operations
.SH SYNOPSIS
.B "void" spider_net_setup_netdev_ops
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 net_device structure
.SH "DESCRIPTION"
fills out function pointers in the net_device structure
.TH "spider_net_setup_netdev" 9 "spider_net_setup_netdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_setup_netdev \-  initialization of net_device
.SH SYNOPSIS
.B "int" spider_net_setup_netdev
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
Returns 0 on success or &lt;0 on failure

spider_net_setup_netdev initializes the net_device structure
.TH "spider_net_alloc_card" 9 "spider_net_alloc_card" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_alloc_card \-  allocates net_device and card structure
.SH SYNOPSIS
.B "struct spider_net_card *" spider_net_alloc_card
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

returns the card structure or NULL in case of errors

the card and net_device structures are linked to each other
.TH "spider_net_undo_pci_setup" 9 "spider_net_undo_pci_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_undo_pci_setup \-  releases PCI ressources
.SH SYNOPSIS
.B "void" spider_net_undo_pci_setup
.BI "(struct spider_net_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 card structure
.SH "DESCRIPTION"
spider_net_undo_pci_setup releases the mapped regions
.TH "spider_net_setup_pci_dev" 9 "spider_net_setup_pci_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_setup_pci_dev \-  sets up the device in terms of PCI operations
.SH SYNOPSIS
.B "struct spider_net_card *" spider_net_setup_pci_dev
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device
.SH "DESCRIPTION"
Returns the card structure or NULL if any errors occur

spider_net_setup_pci_dev initializes pdev and together with the
functions called in spider_net_open configures the device so that
data can be transferred over it
The net_device structure is attached to the card structure, if the
function returns without error.
.TH "spider_net_probe" 9 "spider_net_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_probe \-  initialization of a device
.SH SYNOPSIS
.B "int __devinit" spider_net_probe
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" ent ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device
.IP "ent" 12
 entry in the device id list
.SH "DESCRIPTION"
Returns 0 on success, &lt;0 on failure

spider_net_probe initializes pdev and registers a net_device
structure for it. After that, the device can be ifconfig'ed up
.TH "spider_net_remove" 9 "spider_net_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_remove \-  removal of a device
.SH SYNOPSIS
.B "void __devexit" spider_net_remove
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device
.SH "DESCRIPTION"
Returns 0 on success, &lt;0 on failure

spider_net_remove is called to remove the device and unregisters the
net_device
.TH "spider_net_init" 9 "spider_net_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_init \-  init function when the driver is loaded
.SH SYNOPSIS
.B "int __init" spider_net_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

spider_net_init registers the device driver
.TH "spider_net_cleanup" 9 "spider_net_cleanup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spider_net_cleanup \-  exit function when driver is unloaded
.SH SYNOPSIS
.B "void __exit" spider_net_cleanup
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

spider_net_cleanup unregisters the device driver
.TH "rtl8169_get_stats" 9 "rtl8169_get_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rtl8169_get_stats \-  Get rtl8169 read/write statistics
.SH SYNOPSIS
.B "struct net_device_stats *" rtl8169_get_stats
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The Ethernet Device to get statistics for
.SH "DESCRIPTION"
Get TX/RX statistics for rtl8169
.TH "isl38xx_disable_interrupts" 9 "isl38xx_disable_interrupts" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
isl38xx_disable_interrupts \-  disable all interrupts
.SH SYNOPSIS
.B "void" isl38xx_disable_interrupts
.BI "(void __iomem *" device ");"
.SH ARGUMENTS
.IP "device" 12
 pci memory base address
.SH "DESCRIPTION"
Instructs the device to disable all interrupt reporting by asserting 
the IRQ line. New events may still show up in the interrupt identification
register located at offset ISL38XX_INT_IDENT_REG.
.TH "prism54_mib_mode_helper" 9 "prism54_mib_mode_helper" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
prism54_mib_mode_helper \-  MIB change mode helper function
.SH SYNOPSIS
.B "int" prism54_mib_mode_helper
.BI "(islpci_private *" priv ","
.BI "u32 " iw_mode ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.IP "iw_mode" 12
 new mode (IW_MODE_*)
.SH "DESCRIPTION"
This is a helper function, hence it does not lock. Make sure
caller deals with locking *if* necessary. This function sets the 
mode-dependent mib values and does the mapping of the Linux 
Wireless API modes to Device firmware modes. It also checks for 
correct valid Linux wireless modes. 
.TH "prism54_mib_init" 9 "prism54_mib_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
prism54_mib_init \-  fill MIB cache with defaults
.SH SYNOPSIS
.B "void" prism54_mib_init
.BI "(islpci_private *" priv ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.SH "DESCRIPTION"

this function initializes the struct given as \fImib\fP with defaults,
of which many are retrieved from the global module parameter
variables.  
.TH "isl38xx_w32_flush" 9 "isl38xx_w32_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
isl38xx_w32_flush \-  PCI iomem write helper
.SH SYNOPSIS
.B "void" isl38xx_w32_flush
.BI "(void __iomem *" base ","
.BI "u32 " val ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "base" 12
 (host) memory base address of the device
.IP "val" 12
 32bit value (host order) to write
.IP "offset" 12
 byte offset into \fIbase\fP to write value to
.SH "DESCRIPTION"
This helper takes care of writing a 32bit datum to the
specified offset into the device's pci memory space, and making sure 
the pci memory buffers get flushed by performing one harmless read 
from the ISL38XX_PCI_POSTING_FLUSH offset.
.TH "ipw2100_set_key" 9 "ipw2100_set_key" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw2100_set_key \- 
.SH SYNOPSIS
.B "int" ipw2100_set_key
.BI "(struct ipw2100_priv *" priv ","
.BI "int " idx ","
.BI "char *" key ","
.BI "int " len ","
.BI "int " batch_mode ");"
.SH ARGUMENTS
.IP "priv" 12
 struct to work on
.IP "idx" 12
 index of the key we want to set
.IP "key" 12
 ptr to the key data to set
.IP "len" 12
 length of the buffer at \fIkey\fP
.IP "batch_mode" 12
 FIXME perform the operation in batch mode, not
disabling the device.
.SH "DESCRIPTION"
\fIreturns\fP 0 if OK, &lt; 0 errno code on error.

Fill out a command structure with the new wep key, length an
index and send it down the wire.
.SH "DESCRIPTION"
\fIreturns\fP 0 if OK, &lt; 0 errno code on error.

Fill out a command structure with the new wep key, length an
index and send it down the wire.
.TH "ipw2100_init" 9 "ipw2100_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw2100_init \- 
.SH SYNOPSIS
.B "int __init" ipw2100_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

\fIreturns\fP 0 if ok, &lt; 0 errno node con error.
.SH "NOTE"
 we cannot init the /proc stuff until the PCI driver is there,
or we risk an unlikely race condition on someone accessing
uninitialized data in the PCI dev struct through /proc.
.TH "ipw2100_exit" 9 "ipw2100_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw2100_exit \- 
.SH SYNOPSIS
.B "void __exit" ipw2100_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "__hostap_cmd_queue_free" 9 "__hostap_cmd_queue_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__hostap_cmd_queue_free \-  Free Prism2 command queue entry (private)
.SH SYNOPSIS
.B "void" __hostap_cmd_queue_free
.BI "(local_info_t *" local ","
.BI "struct hostap_cmd_queue *" entry ","
.BI "int " del_req ");"
.SH ARGUMENTS
.IP "local" 12
 pointer to private Host AP driver data
.IP "entry" 12
 Prism2 command queue entry to be freed
.IP "del_req" 12
 request the entry to be removed
.SH "DESCRIPTION"
Internal helper function for freeing Prism2 command queue entries.
Caller must have acquired local-&gt;cmdlock before calling this function.
.TH "hostap_cmd_queue_free" 9 "hostap_cmd_queue_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hostap_cmd_queue_free \-  Free Prism2 command queue entry
.SH SYNOPSIS
.B "void" hostap_cmd_queue_free
.BI "(local_info_t *" local ","
.BI "struct hostap_cmd_queue *" entry ","
.BI "int " del_req ");"
.SH ARGUMENTS
.IP "local" 12
 pointer to private Host AP driver data
.IP "entry" 12
 Prism2 command queue entry to be freed
.IP "del_req" 12
 request the entry to be removed
.SH "DESCRIPTION"
Free a Prism2 command queue entry.
.TH "prism2_clear_cmd_queue" 9 "prism2_clear_cmd_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
prism2_clear_cmd_queue \-  Free all pending Prism2 command queue entries
.SH SYNOPSIS
.B "void" prism2_clear_cmd_queue
.BI "(local_info_t *" local ");"
.SH ARGUMENTS
.IP "local" 12
 pointer to private Host AP driver data
.TH "hfa384x_cmd_issue" 9 "hfa384x_cmd_issue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hfa384x_cmd_issue \-  Issue a Prism2 command to the hardware
.SH SYNOPSIS
.B "int" hfa384x_cmd_issue
.BI "(struct net_device *" dev ","
.BI "struct hostap_cmd_queue *" entry ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to net_device
.IP "entry" 12
 Prism2 command queue entry to be issued
.TH "hfa384x_cmd" 9 "hfa384x_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hfa384x_cmd \-  Issue a Prism2 command and wait (sleep) for completion
.SH SYNOPSIS
.B "int" hfa384x_cmd
.BI "(struct net_device *" dev ","
.BI "u16 " cmd ","
.BI "u16 " param0 ","
.BI "u16 *" param1 ","
.BI "u16 *" resp0 ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to net_device
.IP "cmd" 12
 Prism2 command code (HFA384X_CMD_CODE_*)
.IP "param0" 12
 value for Param0 register
.IP "param1" 12
 value for Param1 register (pointer; NULL if not used)
.IP "resp0" 12
 pointer for Resp0 data or NULL if Resp0 is not needed
.SH "DESCRIPTION"
Issue given command (possibly after waiting in command queue) and sleep
until the command is completed (or timed out or interrupted). This can be
called only from user process context.
.TH "hfa384x_cmd_callback" 9 "hfa384x_cmd_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hfa384x_cmd_callback \-  Issue a Prism2 command; callback when completed
.SH SYNOPSIS
.B "int" hfa384x_cmd_callback
.BI "(struct net_device *" dev ","
.BI "u16 " cmd ","
.BI "u16 " param0 ","
.BI "void (*" callback ") (struct net_device *dev, 						 long context, u16 resp0, 						 u16 status),"
.BI "long " context ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to net_device
.IP "cmd" 12
 Prism2 command code (HFA384X_CMD_CODE_*)
.IP "param0" 12
 value for Param0 register
.IP "callback" 12
 command completion callback function (NULL = no callback)
.IP "context" 12
 context data to be given to the callback function
.SH "DESCRIPTION"
Issue given command (possibly after waiting in command queue) and use
callback function to indicate command completion. This can be called both
from user and interrupt context. The callback function will be called in
hardware IRQ context. It can be NULL, when no function is called when
command is completed.
.TH "__hfa384x_cmd_no_wait" 9 "__hfa384x_cmd_no_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__hfa384x_cmd_no_wait \-  Issue a Prism2 command (private)
.SH SYNOPSIS
.B "int" __hfa384x_cmd_no_wait
.BI "(struct net_device *" dev ","
.BI "u16 " cmd ","
.BI "u16 " param0 ","
.BI "int " io_debug_num ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to net_device
.IP "cmd" 12
 Prism2 command code (HFA384X_CMD_CODE_*)
.IP "param0" 12
 value for Param0 register
.IP "io_debug_num" 12
 I/O debug error number
.SH "DESCRIPTION"
Shared helper function for \fBhfa384x_cmd_wait\fP and \fBhfa384x_cmd_no_wait\fP.
.TH "hfa384x_cmd_wait" 9 "hfa384x_cmd_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hfa384x_cmd_wait \-  Issue a Prism2 command and busy wait for completion
.SH SYNOPSIS
.B "int" hfa384x_cmd_wait
.BI "(struct net_device *" dev ","
.BI "u16 " cmd ","
.BI "u16 " param0 ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to net_device
.IP "cmd" 12
 Prism2 command code (HFA384X_CMD_CODE_*)
.IP "param0" 12
 value for Param0 register
.TH "hfa384x_cmd_no_wait" 9 "hfa384x_cmd_no_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hfa384x_cmd_no_wait \-  Issue a Prism2 command; do not wait for completion
.SH SYNOPSIS
.B "int" hfa384x_cmd_no_wait
.BI "(struct net_device *" dev ","
.BI "u16 " cmd ","
.BI "u16 " param0 ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to net_device
.IP "cmd" 12
 Prism2 command code (HFA384X_CMD_CODE_*)
.IP "param0" 12
 value for Param0 register
.TH "prism2_cmd_ev" 9 "prism2_cmd_ev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
prism2_cmd_ev \-  Prism2 command completion event handler
.SH SYNOPSIS
.B "void" prism2_cmd_ev
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to net_device
.SH "DESCRIPTION"
Interrupt handler for command completion events. Called by the main
interrupt handler in hardware IRQ context. Read Resp0 and status registers
from the hardware and ACK the event. Depending on the issued command type
either wake up the sleeping process that is waiting for command completion
or call the callback function. Issue the next command, if one is pending.
.TH "iw_valid_channel" 9 "iw_valid_channel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iw_valid_channel \-  validate channel in regulatory domain
.SH SYNOPSIS
.B "int" iw_valid_channel
.BI "(int " reg_domain ","
.BI "int " channel ");"
.SH ARGUMENTS
.IP "reg_domain" 12
-- undescribed --
.IP "channel" 12
-- undescribed --
.SH "DESCRIPTION"
\fIreg_comain\fP - regulatory domain
\fIchannel\fP - channel to validate

Returns 0 if invalid in the specified regulatory domain, non-zero if valid.
.TH "iw_default_channel" 9 "iw_default_channel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
iw_default_channel \-  get default channel for a regulatory domain
.SH SYNOPSIS
.B "int" iw_default_channel
.BI "(int " reg_domain ");"
.SH ARGUMENTS
.IP "reg_domain" 12
-- undescribed --
.SH "DESCRIPTION"
\fIreg_comain\fP - regulatory domain

Returns the default channel for a regulatory domain
.TH "wl3501_set_to_wla" 9 "wl3501_set_to_wla" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_set_to_wla \-  Move 'size' bytes from PC to card
.SH SYNOPSIS
.B "void" wl3501_set_to_wla
.BI "(struct wl3501_card *" this ","
.BI "u16 " dest ","
.BI "void *" src ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.IP "dest" 12
 Card addressing space
.IP "src" 12
 PC addressing space
.IP "size" 12
 Bytes to move
.SH "DESCRIPTION"
Move 'size' bytes from PC to card. (Shouldn't be interrupted)
.TH "wl3501_get_from_wla" 9 "wl3501_get_from_wla" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_get_from_wla \-  Move 'size' bytes from card to PC
.SH SYNOPSIS
.B "void" wl3501_get_from_wla
.BI "(struct wl3501_card *" this ","
.BI "u16 " src ","
.BI "void *" dest ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.IP "src" 12
 Card addressing space
.IP "dest" 12
 PC addressing space
.IP "size" 12
 Bytes to move
.SH "DESCRIPTION"
Move 'size' bytes from card to PC. (Shouldn't be interrupted)
.TH "wl3501_send_pkt" 9 "wl3501_send_pkt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_send_pkt \-  Send a packet.
.SH SYNOPSIS
.B "int" wl3501_send_pkt
.BI "(struct wl3501_card *" this ","
.BI "u8 *" data ","
.BI "u16 " len ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"
\fIthis\fP - card

Send a packet.

data = Ethernet raw frame.  (e.g. data[0] - data[5] is Dest MAC Addr,
data[6] - data[11] is Src MAC Addr)
.SH "REF"
 IEEE 802.11
.TH "wl3501_block_interrupt" 9 "wl3501_block_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_block_interrupt \-  Mask interrupt from SUTRO
.SH SYNOPSIS
.B "int" wl3501_block_interrupt
.BI "(struct wl3501_card *" this ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.SH "DESCRIPTION"
\fIthis\fP - card

Mask interrupt from SUTRO. (i.e. SUTRO cannot interrupt the HOST)
.SH "RETURN"
 1 if interrupt is originally enabled
.TH "wl3501_unblock_interrupt" 9 "wl3501_unblock_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_unblock_interrupt \-  Enable interrupt from SUTRO
.SH SYNOPSIS
.B "int" wl3501_unblock_interrupt
.BI "(struct wl3501_card *" this ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.SH "DESCRIPTION"
\fIthis\fP - card

Enable interrupt from SUTRO. (i.e. SUTRO can interrupt the HOST)
.SH "RETURN"
 1 if interrupt is originally enabled
.TH "wl3501_receive" 9 "wl3501_receive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_receive \-  Receive data from Receive Queue.
.SH SYNOPSIS
.B "u16" wl3501_receive
.BI "(struct wl3501_card *" this ","
.BI "u8 *" bf ","
.BI "u16 " size ");"
.SH ARGUMENTS
.IP "this" 12
 card
.IP "bf" 12
 address of host
.IP "size" 12
 size of buffer.
.SH "DESCRIPTION"

Receive data from Receive Queue.
.TH "wl3501_interrupt" 9 "wl3501_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_interrupt \-  Hardware interrupt from card.
.SH SYNOPSIS
.B "irqreturn_t" wl3501_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "dev_id" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.SH "DESCRIPTION"
\fIirq\fP - Interrupt number
\fIdev_id\fP - net_device
\fIregs\fP - registers

We must acknowledge the interrupt as soon as possible, and block the
interrupt from the same card immediately to prevent re-entry.

Before accessing the Control_Status_Block, we must lock SUTRO first.
On the other hand, to prevent SUTRO from malfunctioning, we must
unlock the SUTRO as soon as possible.
.TH "wl3501_reset" 9 "wl3501_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_reset \-  Reset the SUTRO.
.SH SYNOPSIS
.B "int" wl3501_reset
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
\fIdev\fP - network device

It is almost the same as \fBwl3501_open\fP. In fact, we may just \fBwl3501_close\fP
and \fBwl3501_open\fP again, but I wouldn't like to \fBfree_irq\fP when the driver
is running. It seems to be dangerous.
.TH "wl3501_detach" 9 "wl3501_detach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_detach \-  deletes a driver "instance"
.SH SYNOPSIS
.B "void" wl3501_detach
.BI "(dev_link_t *" link ");"
.SH ARGUMENTS
.IP "link" 12
-- undescribed --
.SH "DESCRIPTION"
\fIlink\fP - FILL_IN

This deletes a driver "instance". The device is de-registered with Card
Services. If it has been released, all local data structures are freed.
Otherwise, the structures will be freed when the device is released.
.TH "wl3501_attach" 9 "wl3501_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_attach \-  creates an "instance" of the driver
.SH SYNOPSIS
.B "dev_link_t *" wl3501_attach
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Creates an "instance" of the driver, allocating local data structures for
one device.  The device is registered with Card Services.

The dev_link structure is initialized, but we don't actually configure the
card at this point -- we wait until we receive a card insertion event.
.TH "wl3501_config" 9 "wl3501_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_config \-  configure the PCMCIA socket and make eth device available
.SH SYNOPSIS
.B "void" wl3501_config
.BI "(dev_link_t *" link ");"
.SH ARGUMENTS
.IP "link" 12
-- undescribed --
.SH "DESCRIPTION"
\fIlink\fP - FILL_IN

\fBwl3501_config\fP is scheduled to run after a CARD_INSERTION event is
received, to configure the PCMCIA socket, and to make the ethernet device
available to the system.
.TH "wl3501_release" 9 "wl3501_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_release \-  unregister the net, release PCMCIA configuration
.SH SYNOPSIS
.B "void" wl3501_release
.BI "(dev_link_t *" link ");"
.SH ARGUMENTS
.IP "link" 12
-- undescribed --
.SH "DESCRIPTION"
\fIarg\fP - link

After a card is removed, \fBwl3501_release\fP will unregister the net device,
and release the PCMCIA configuration.  If the device is still open, this
will be postponed until it is closed.
.TH "wl3501_event" 9 "wl3501_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wl3501_event \-  The card status event handler
.SH SYNOPSIS
.B "int" wl3501_event
.BI "(event_t " event ","
.BI "int " pri ","
.BI "event_callback_args_t *" args ");"
.SH ARGUMENTS
.IP "event" 12
-- undescribed --
.IP "pri" 12
-- undescribed --
.IP "args" 12
-- undescribed --
.SH "DESCRIPTION"
\fIevent\fP - event
\fIpri\fP - priority
\fIargs\fP - arguments for this event

The card status event handler. Mostly, this schedules other stuff to run
after an event is received. A CARD_REMOVAL event also sets some flags to
discourage the net drivers from trying to talk to the card any more.

When a CARD_REMOVAL event is received, we immediately set a flag to block
future accesses to this device. All the functions that actually access the
device should check this flag to make sure the card is still present.
.TH "ipw_alive" 9 "ipw_alive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_alive \- 
.SH SYNOPSIS
.B "int" ipw_alive
.BI "(struct ipw_priv *" priv ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.SH "DESCRIPTION"
Reads debug register from domain0.
If card is present, pre-defined value should
be found there.

\fIparam\fP priv
\fIreturn\fP 1 if card is present, 0 otherwise
.TH "ipw_queue_space" 9 "ipw_queue_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_queue_space \- 
.SH SYNOPSIS
.B "int" ipw_queue_space
.BI "(const struct clx2_queue *" q ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.SH "DESCRIPTION"

Theory of operation

A queue is a circular buffers with 'Read' and 'Write' pointers.
2 empty entries always kept in the buffer to protect from overflow.

For Tx queue, there are low mark and high mark limits. If, after queuing
the packet for Tx, free space become &lt; low mark, Tx queue stopped. When
reclaiming packets (on 'tx done IRQ), if free space become &gt; high mark,
Tx queue resumed.

The IPW operates with six queues, one receive queue in the device's
sram, one transmit queue for sending commands to the device firmware,
and four transmit queues for data.

The four transmit queues allow for performing quality of service (qos)
transmissions as per the 802.11 protocol.  Currently Linux does not
provide a mechanism to the user for utilizing prioritized queues, so
we only utilize the first data transmit queue (queue1).
.TH "ipw_queue_init" 9 "ipw_queue_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_queue_init \- 
.SH SYNOPSIS
.B "void" ipw_queue_init
.BI "(struct ipw_priv *" priv ","
.BI "struct clx2_queue *" q ","
.BI "int " count ","
.BI "u32 " read ","
.BI "u32 " write ","
.BI "u32 " base ","
.BI "u32 " size ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.IP "q" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "read" 12
-- undescribed --
.IP "write" 12
-- undescribed --
.IP "base" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP q                queue to init
\fIparam\fP count            Number of BD's to allocate. Should be power of 2
\fIparam\fP read_register    Address for 'read' register
(not offset within BAR, full address)
\fIparam\fP write_register   Address for 'write' register
(not offset within BAR, full address)
\fIparam\fP base_register    Address for 'base' register
(not offset within BAR, full address)
\fIparam\fP size             Address for 'size' register
(not offset within BAR, full address)
.TH "ipw_queue_tx_free_tfd" 9 "ipw_queue_tx_free_tfd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_queue_tx_free_tfd \- \\\gt;q.last_used].
.SH SYNOPSIS
.B "void" ipw_queue_tx_free_tfd
.BI "(struct ipw_priv *" priv ","
.BI "struct clx2_tx_queue *" txq ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.IP "txq" 12
-- undescribed --
.SH "DESCRIPTION"
Do NOT advance any indexes

\fIparam\fP dev
\fIparam\fP txq
.TH "ipw_queue_tx_free" 9 "ipw_queue_tx_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_queue_tx_free \- 
.SH SYNOPSIS
.B "void" ipw_queue_tx_free
.BI "(struct ipw_priv *" priv ","
.BI "struct clx2_tx_queue *" txq ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.IP "txq" 12
-- undescribed --
.SH "DESCRIPTION"

Empty queue by removing and destroying all BD's.
Free all buffers.

\fIparam\fP dev
\fIparam\fP q
.TH "ipw_tx_queue_free" 9 "ipw_tx_queue_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_tx_queue_free \- 
.SH SYNOPSIS
.B "void" ipw_tx_queue_free
.BI "(struct ipw_priv *" priv ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP priv
.TH "ipw_rx_notification" 9 "ipw_rx_notification" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_rx_notification \- 
.SH SYNOPSIS
.B "void" ipw_rx_notification
.BI "(struct ipw_priv *" priv ","
.BI "struct ipw_rx_notification *" notif ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.IP "notif" 12
-- undescribed --
.SH "DESCRIPTION"
Called from interrupt routine
.TH "ipw_queue_reset" 9 "ipw_queue_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_queue_reset \- 
.SH SYNOPSIS
.B "int" ipw_queue_reset
.BI "(struct ipw_priv *" priv ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP priv
\fIreturn\fP error code
.TH "ipw_queue_tx_reclaim" 9 "ipw_queue_tx_reclaim" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipw_queue_tx_reclaim \- 
.SH SYNOPSIS
.B "int" ipw_queue_tx_reclaim
.BI "(struct ipw_priv *" priv ","
.BI "struct clx2_tx_queue *" txq ","
.BI "int " qindex ");"
.SH ARGUMENTS
.IP "priv" 12
-- undescribed --
.IP "txq" 12
-- undescribed --
.IP "qindex" 12
-- undescribed --
.SH "DESCRIPTION"

When FW adwances 'R' index, all entries between old and
new 'R' index need to be reclaimed. As result, some free space
forms. If there is enough free space (&gt; low mark), wake Tx queue.

\fInote\fP Need to protect against garbage in 'R' index
\fIparam\fP priv
\fIparam\fP txq
\fIparam\fP qindex
\fIreturn\fP Number of used entries remains in the queue
.TH "t1_wait_op_done" 9 "t1_wait_op_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
t1_wait_op_done \-  wait until an operation is completed
.SH SYNOPSIS
.B "int" t1_wait_op_done
.BI "(adapter_t *" adapter ","
.BI "int " reg ","
.BI "u32 " mask ","
.BI "int " polarity ","
.BI "int " attempts ","
.BI "int " delay ");"
.SH ARGUMENTS
.IP "adapter" 12
 the adapter performing the operation
.IP "reg" 12
 the register to check for completion
.IP "mask" 12
 a single-bit field within \fIreg\fP that indicates completion
.IP "polarity" 12
 the value of the field when the operation is completed
.IP "attempts" 12
 number of check iterations
.IP "delay" 12
 delay in usecs between iterations
.SH "DESCRIPTION"
Wait until an operation is completed by checking a bit in a register
up to \fIattempts\fP times.  Returns 0 if the operation completes and 1
otherwise.
.TH "recycle_fl_buf" 9 "recycle_fl_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
recycle_fl_buf \-  recycle a free list buffer
.SH SYNOPSIS
.B "void" recycle_fl_buf
.BI "(struct freelQ *" fl ","
.BI "int " idx ");"
.SH ARGUMENTS
.IP "fl" 12
 the free list
.IP "idx" 12
 index of buffer to recycle
.SH "DESCRIPTION"
Recycles the specified buffer on the given free list by adding it at
the next available slot on the list.
.TH "get_packet" 9 "get_packet" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_packet \-  return the next ingress packet buffer
.SH SYNOPSIS
.B "struct sk_buff *" get_packet
.BI "(struct pci_dev *" pdev ","
.BI "struct freelQ *" fl ","
.BI "unsigned int " len ","
.BI "int " dma_pad ","
.BI "int " skb_pad ","
.BI "unsigned int " copy_thres ","
.BI "unsigned int " drop_thres ");"
.SH ARGUMENTS
.IP "pdev" 12
 the PCI device that received the packet
.IP "fl" 12
 the SGE free list holding the packet
.IP "len" 12
 the actual packet length, excluding any SGE padding
.IP "dma_pad" 12
 padding at beginning of buffer left by SGE DMA
.IP "skb_pad" 12
 padding to be used if the packet is copied
.IP "copy_thres" 12
 length threshold under which a packet should be copied
.IP "drop_thres" 12
 # of remaining buffers before we start dropping packets
.SH "DESCRIPTION"
Get the next packet from a free list and complete setup of the
sk_buff.  If the packet is small we make a copy and recycle the
original buffer, otherwise we use the original buffer itself.  If a
positive drop threshold is supplied packets are dropped and their
buffers recycled if (a) the number of remaining buffers is under the
threshold and the packet is too big to copy, or (b) the packet should
be copied but there is no memory for the copy.
.TH "unexpected_offload" 9 "unexpected_offload" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unexpected_offload \-  handle an unexpected offload packet
.SH SYNOPSIS
.B "void" unexpected_offload
.BI "(struct adapter *" adapter ","
.BI "struct freelQ *" fl ");"
.SH ARGUMENTS
.IP "adapter" 12
 the adapter
.IP "fl" 12
 the free list that received the packet
.SH "DESCRIPTION"
Called when we receive an unexpected offload packet (e.g., the TOE
function is disabled or the card is a NIC).  Prints a message and
recycles the buffer.
.TH "sge_rx" 9 "sge_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sge_rx \-  process an ingress ethernet packet
.SH SYNOPSIS
.B "int" sge_rx
.BI "(struct sge *" sge ","
.BI "struct freelQ *" fl ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "sge" 12
 the sge structure
.IP "fl" 12
 the free list that contains the packet buffer
.IP "len" 12
 the packet length
.SH "DESCRIPTION"
Process an ingress ethernet pakcet and deliver it to the stack.
.TH "tulip_build_fake_mediatable" 9 "tulip_build_fake_mediatable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tulip_build_fake_mediatable \-  Build a fake mediatable entry.
.SH SYNOPSIS
.B "void __devinit" tulip_build_fake_mediatable
.BI "(struct tulip_private *" tp ");"
.SH ARGUMENTS
.IP "tp" 12
 Ptr to the tulip private data.
.SH "DESCRIPTION"
Some cards like the 3x5 HSC cards (J3514A) do not have a standard 
srom and can not be handled under the fixup routine.  These cards
still need a valid mediatable entry for correct csr12 setup and 
mii handling.

Since this is currently a parisc-linux specific function, the
#ifdef __hppa__ should completely optimize this function away for
non-parisc hardware.
.TH "sis900_get_mac_addr" 9 "sis900_get_mac_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_get_mac_addr \-  Get MAC address for stand alone SiS900 model
.SH SYNOPSIS
.B "int __devinit" sis900_get_mac_addr
.BI "(struct pci_dev *" pci_dev ","
.BI "struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "pci_dev" 12
 the sis900 pci device
.IP "net_dev" 12
 the net device to get address for 
.SH "DESCRIPTION"
Older SiS900 and friends, use EEPROM to store MAC address.
MAC address is read from \fBread_eeprom\fP into \fInet_dev\fP-&gt;dev_addr.
.TH "sis630e_get_mac_addr" 9 "sis630e_get_mac_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis630e_get_mac_addr \-  Get MAC address for SiS630E model
.SH SYNOPSIS
.B "int __devinit" sis630e_get_mac_addr
.BI "(struct pci_dev *" pci_dev ","
.BI "struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "pci_dev" 12
 the sis900 pci device
.IP "net_dev" 12
 the net device to get address for 
.SH "DESCRIPTION"
SiS630E model, use APC CMOS RAM to store MAC address.
APC CMOS RAM is accessed through ISA bridge.
MAC address is read into \fInet_dev\fP-&gt;dev_addr.
.TH "sis635_get_mac_addr" 9 "sis635_get_mac_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis635_get_mac_addr \-  Get MAC address for SIS635 model
.SH SYNOPSIS
.B "int __devinit" sis635_get_mac_addr
.BI "(struct pci_dev *" pci_dev ","
.BI "struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "pci_dev" 12
 the sis900 pci device
.IP "net_dev" 12
 the net device to get address for 
.SH "DESCRIPTION"
SiS635 model, set MAC Reload Bit to load Mac address from APC
to rfdr. rfdr is accessed through rfcr. MAC address is read into 
\fInet_dev\fP-&gt;dev_addr.
.TH "sis96x_get_mac_addr" 9 "sis96x_get_mac_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis96x_get_mac_addr \-  Get MAC address for SiS962 or SiS963 model
.SH SYNOPSIS
.B "int __devinit" sis96x_get_mac_addr
.BI "(struct pci_dev *" pci_dev ","
.BI "struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "pci_dev" 12
 the sis900 pci device
.IP "net_dev" 12
 the net device to get address for 
.SH "DESCRIPTION"
SiS962 or SiS963 model, use EEPROM to store MAC address. And EEPROM 
is shared by
LAN and 1394. When access EEPROM, send EEREQ signal to hardware first 
and wait for EEGNT. If EEGNT is ON, EEPROM is permitted to be access 
by LAN, otherwise is not. After MAC address is read from EEPROM, send
EEDONE signal to refuse EEPROM access by LAN. 
The EEPROM map of SiS962 or SiS963 is different to SiS900. 
The signature field in SiS962 or SiS963 spec is meaningless. 
MAC address is read into \fInet_dev\fP-&gt;dev_addr.
.TH "sis900_probe" 9 "sis900_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_probe \-  Probe for sis900 device
.SH SYNOPSIS
.B "int __devinit" sis900_probe
.BI "(struct pci_dev *" pci_dev ","
.BI "const struct pci_device_id *" pci_id ");"
.SH ARGUMENTS
.IP "pci_dev" 12
 the sis900 pci device
.IP "pci_id" 12
 the pci device ID
.SH "DESCRIPTION"
Check and probe sis900 net device for \fIpci_dev\fP.
Get mac address according to the chip revision, 
and assign SiS900-specific entries in the device structure.
.SH "IE"
 \fBsis900_open\fP, \fBsis900_start_xmit\fP, \fBsis900_close\fP, etc.
.TH "sis900_mii_probe" 9 "sis900_mii_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_mii_probe \-  Probe MII PHY for sis900
.SH SYNOPSIS
.B "int __init" sis900_mii_probe
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to probe for
.SH "DESCRIPTION"
Search for total of 32 possible mii phy addresses.
Identify and set current phy if found one,
return error if it failed to found.
.TH "sis900_default_phy" 9 "sis900_default_phy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_default_phy \-  Select default PHY for sis900 mac.
.SH SYNOPSIS
.B "u16" sis900_default_phy
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to probe for
.SH "DESCRIPTION"
Select first detected PHY with link as default.
If no one is link on, select PHY whose types is HOME as default.
If HOME doesn't exist, select LAN.
.TH "sis900_set_capability" 9 "sis900_set_capability" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_set_capability \-  set the media capability of network adapter.
.SH SYNOPSIS
.B "void" sis900_set_capability
.BI "(struct net_device *" net_dev ","
.BI "struct mii_phy *" phy ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to probe for
.IP "phy" 12
 default PHY
.SH "DESCRIPTION"
Set the media capability of network adapter according to
mii status register. It's necessary before auto-negotiate.
.TH "read_eeprom" 9 "read_eeprom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_eeprom \-  Read Serial EEPROM
.SH SYNOPSIS
.B "u16 __devinit" read_eeprom
.BI "(long " ioaddr ","
.BI "int " location ");"
.SH ARGUMENTS
.IP "ioaddr" 12
 base i/o address
.IP "location" 12
 the EEPROM location to read
.SH "DESCRIPTION"
Read Serial EEPROM through EEPROM Access Register.
Note that location is in word (16 bits) unit
.TH "mdio_read" 9 "mdio_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mdio_read \-  read MII PHY register
.SH SYNOPSIS
.B "int" mdio_read
.BI "(struct net_device *" net_dev ","
.BI "int " phy_id ","
.BI "int " location ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to read
.IP "phy_id" 12
 the phy address to read
.IP "location" 12
 the phy regiester id to read
.SH "DESCRIPTION"
Read MII registers through MDIO and MDC
using MDIO management frame structure and protocol(defined by ISO/IEC).
Please see SiS7014 or ICS spec
.TH "mdio_write" 9 "mdio_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mdio_write \-  write MII PHY register
.SH SYNOPSIS
.B "void" mdio_write
.BI "(struct net_device *" net_dev ","
.BI "int " phy_id ","
.BI "int " location ","
.BI "int " value ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to write
.IP "phy_id" 12
 the phy address to write
.IP "location" 12
 the phy regiester id to write
.IP "value" 12
 the register value to write with
.SH "DESCRIPTION"
Write MII registers with \fIvalue\fP through MDIO and MDC
using MDIO management frame structure and protocol(defined by ISO/IEC)
please see SiS7014 or ICS spec
.TH "sis900_reset_phy" 9 "sis900_reset_phy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_reset_phy \-  reset sis900 mii phy.
.SH SYNOPSIS
.B "u16" sis900_reset_phy
.BI "(struct net_device *" net_dev ","
.BI "int " phy_addr ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to write
.IP "phy_addr" 12
 default phy address
.SH "DESCRIPTION"
Some specific phy can't work properly without reset.
This function will be called during initialization and
link status change from ON to DOWN.
.TH "sis900_open" 9 "sis900_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_open \-  open sis900 device
.SH SYNOPSIS
.B "int" sis900_open
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to open
.SH "DESCRIPTION"
Do some initialization and start net interface.
enable interrupts and set sis900 timer.
.TH "sis900_init_rxfilter" 9 "sis900_init_rxfilter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_init_rxfilter \-  Initialize the Rx filter
.SH SYNOPSIS
.B "void" sis900_init_rxfilter
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to initialize for
.SH "DESCRIPTION"
Set receive filter address to our MAC address
and enable packet filtering.
.TH "sis900_init_tx_ring" 9 "sis900_init_tx_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_init_tx_ring \-  Initialize the Tx descriptor ring
.SH SYNOPSIS
.B "void" sis900_init_tx_ring
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to initialize for
.SH "DESCRIPTION"
Initialize the Tx descriptor ring, 
.TH "sis900_init_rx_ring" 9 "sis900_init_rx_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_init_rx_ring \-  Initialize the Rx descriptor ring
.SH SYNOPSIS
.B "void" sis900_init_rx_ring
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to initialize for
.SH "DESCRIPTION"
Initialize the Rx descriptor ring, 
and pre-allocate recevie buffers (socket buffer)
.TH "sis630_set_eq" 9 "sis630_set_eq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis630_set_eq \-  set phy equalizer value for 630 LAN
.SH SYNOPSIS
.B "void" sis630_set_eq
.BI "(struct net_device *" net_dev ","
.BI "u8 " revision ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to set equalizer value
.IP "revision" 12
 630 LAN revision number
.SH "DESCRIPTION"
630E equalizer workaround rule(Cyrus Huang 08/15)
PHY register 14h(Test)
.SH "BIT 14"
 0 -- Automatically dectect (default)
1 -- Manually set Equalizer filter
.SH "BIT 13"
 0 -- (Default)
1 -- Speed up convergence of equalizer setting
.SH "BIT 9 "
 0 -- (Default)
1 -- Disable Baseline Wander
Bit 3~7   -- Equalizer filter setting
.SH "LINK ON"
 Set Bit 9, 13 to 1, Bit 14 to 0
Then calculate equalizer value
Then set equalizer value, and set Bit 14 to 1, Bit 9 to 0
.SH "LINK OFF"
Set Bit 13 to 1, Bit 14 to 0
.SH "CALCULATE EQUALIZER VALUE"
When Link is ON and Bit 14 is 0, SIS900PHY will auto-dectect proper equalizer value.
When the equalizer is stable, this value is not a fixed value. It will be within
a small range(eg. 7~9). Then we get a minimum and a maximum value(eg. min=7, max=9)
0 &lt;= max &lt;= 4  --&gt; set equalizer to max
5 &lt;= max &lt;= 14 --&gt; set equalizer to max+1 or set equalizer to max+2 if max == min
max &gt;= 15      --&gt; set equalizer to max+5 or set equalizer to max+6 if max == min
.TH "sis900_timer" 9 "sis900_timer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_timer \-  sis900 timer routine
.SH SYNOPSIS
.B "void" sis900_timer
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 pointer to sis900 net device
.SH "DESCRIPTION"
On each timer ticks we check two things, 
link status (ON/OFF) and link mode (10/100/Full/Half)
.TH "sis900_check_mode" 9 "sis900_check_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_check_mode \-  check the media mode for sis900
.SH SYNOPSIS
.B "void" sis900_check_mode
.BI "(struct net_device *" net_dev ","
.BI "struct mii_phy *" mii_phy ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to be checked
.IP "mii_phy" 12
 the mii phy
.SH "DESCRIPTION"
Older driver gets the media mode from mii status output
register. Now we set our media capability and auto-negotiate
to get the upper bound of speed and duplex between two ends.
If the types of mii phy is HOME, it doesn't need to auto-negotiate
and autong_complete should be set to 1.
.TH "sis900_set_mode" 9 "sis900_set_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_set_mode \-  Set the media mode of mac register.
.SH SYNOPSIS
.B "void" sis900_set_mode
.BI "(long " ioaddr ","
.BI "int " speed ","
.BI "int " duplex ");"
.SH ARGUMENTS
.IP "ioaddr" 12
 the address of the device
.IP "speed" 12
 the transmit speed to be determined
.IP "duplex" 12
 the duplex mode to be determined
.SH "DESCRIPTION"
Set the media mode of mac register txcfg/rxcfg according to
speed and duplex of phy. Bit EDB_MASTER_EN indicates the EDB
bus is used instead of PCI bus. When this bit is set 1, the
Max DMA Burst Size for TX/RX DMA should be no larger than 16
double words.
.TH "sis900_auto_negotiate" 9 "sis900_auto_negotiate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_auto_negotiate \-  Set the Auto-Negotiation Enable/Reset bit.
.SH SYNOPSIS
.B "void" sis900_auto_negotiate
.BI "(struct net_device *" net_dev ","
.BI "int " phy_addr ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to read mode for
.IP "phy_addr" 12
 mii phy address
.SH "DESCRIPTION"
If the adapter is link-on, set the auto-negotiate enable/reset bit.
autong_complete should be set to 0 when starting auto-negotiation.
autong_complete should be set to 1 if we didn't start auto-negotiation.
sis900_timer will wait for link on again if autong_complete = 0.
.TH "sis900_read_mode" 9 "sis900_read_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_read_mode \-  read media mode for sis900 internal phy
.SH SYNOPSIS
.B "void" sis900_read_mode
.BI "(struct net_device *" net_dev ","
.BI "int *" speed ","
.BI "int *" duplex ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to read mode for
.IP "speed" 12
 the transmit speed to be determined
.IP "duplex" 12
 the duplex mode to be determined
.SH "DESCRIPTION"
The capability of remote end will be put in mii register autorec
after auto-negotiation. Use AND operation to get the upper bound
of speed and duplex between two ends.
.TH "sis900_tx_timeout" 9 "sis900_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_tx_timeout \-  sis900 transmit timeout routine
.SH SYNOPSIS
.B "void" sis900_tx_timeout
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to transmit
.SH "DESCRIPTION"
print transmit timeout status
disable interrupts and do some tasks
.TH "sis900_start_xmit" 9 "sis900_start_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_start_xmit \-  sis900 start transmit routine
.SH SYNOPSIS
.B "int" sis900_start_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "skb" 12
 socket buffer pointer to put the data being transmitted
.IP "net_dev" 12
 the net device to transmit with
.SH "DESCRIPTION"
Set the transmit buffer descriptor, 
and write TxENA to enable transmit state machine.
tell upper layer if the buffer is full
.TH "sis900_interrupt" 9 "sis900_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_interrupt \-  sis900 interrupt handler
.SH SYNOPSIS
.B "irqreturn_t" sis900_interrupt
.BI "(int " irq ","
.BI "void *" dev_instance ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 the irq number
.IP "dev_instance" 12
 the client data object
.IP "regs" 12
 snapshot of processor context
.SH "DESCRIPTION"
The interrupt handler does all of the Rx thread work, 
and cleans up after the Tx thread
.TH "sis900_rx" 9 "sis900_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_rx \-  sis900 receive routine
.SH SYNOPSIS
.B "int" sis900_rx
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device which receives data
.SH "DESCRIPTION"
Process receive interrupt events, 
put buffer to higher layer and refill buffer pool
.SH "NOTE"
 This fucntion is called by interrupt handler, 
don't do "too much" work here
.TH "sis900_finish_xmit" 9 "sis900_finish_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_finish_xmit \-  finish up transmission of packets
.SH SYNOPSIS
.B "void" sis900_finish_xmit
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to be transmitted on
.SH "DESCRIPTION"
Check for error condition and free socket buffer etc 
schedule for more transmission as needed
.SH "NOTE"
 This fucntion is called by interrupt handler, 
don't do "too much" work here
.TH "sis900_close" 9 "sis900_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_close \-  close sis900 device 
.SH SYNOPSIS
.B "int" sis900_close
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to be closed
.SH "DESCRIPTION"
Disable interrupts, stop the Tx and Rx Status Machine 
free Tx and RX socket buffer
.TH "sis900_get_drvinfo" 9 "sis900_get_drvinfo" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_get_drvinfo \-  Return information about driver
.SH SYNOPSIS
.B "void" sis900_get_drvinfo
.BI "(struct net_device *" net_dev ","
.BI "struct ethtool_drvinfo *" info ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to probe
.IP "info" 12
 container for info returned
.SH "DESCRIPTION"
Process ethtool command such as "ehtool -i" to show information
.TH "mii_ioctl" 9 "mii_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mii_ioctl \-  process MII i/o control command 
.SH SYNOPSIS
.B "int" mii_ioctl
.BI "(struct net_device *" net_dev ","
.BI "struct ifreq *" rq ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to command for
.IP "rq" 12
 parameter for command
.IP "cmd" 12
 the i/o command
.SH "DESCRIPTION"
Process MII command like read/write MII register
.TH "sis900_get_stats" 9 "sis900_get_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_get_stats \-  Get sis900 read/write statistics 
.SH SYNOPSIS
.B "struct net_device_stats *" sis900_get_stats
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to get statistics for
.SH "DESCRIPTION"
get tx/rx statistics for sis900
.TH "sis900_set_config" 9 "sis900_set_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_set_config \-  Set media type by net_device.set_config 
.SH SYNOPSIS
.B "int" sis900_set_config
.BI "(struct net_device *" dev ","
.BI "struct ifmap *" map ");"
.SH ARGUMENTS
.IP "dev" 12
 the net device for media type change
.IP "map" 12
 ifmap passed by ifconfig
.SH "DESCRIPTION"
Set media type to 10baseT, 100baseT or 0(for auto) by ifconfig
we support only port changes. All other runtime configuration
changes will be ignored
.TH "sis900_mcast_bitnr" 9 "sis900_mcast_bitnr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_mcast_bitnr \-  compute hashtable index 
.SH SYNOPSIS
.B "u16" sis900_mcast_bitnr
.BI "(u8 *" addr ","
.BI "u8 " revision ");"
.SH ARGUMENTS
.IP "addr" 12
 multicast address
.IP "revision" 12
 revision id of chip
.SH "DESCRIPTION"
SiS 900 uses the most sigificant 7 bits to index a 128 bits multicast
hash table, which makes this function a little bit different from other drivers
SiS 900 B0 &amp; 635 M/B uses the most significat 8 bits to index 256 bits
multicast hash table. 
.TH "set_rx_mode" 9 "set_rx_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_rx_mode \-  Set SiS900 receive mode 
.SH SYNOPSIS
.B "void" set_rx_mode
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to be set
.SH "DESCRIPTION"
Set SiS900 receive mode for promiscuous, multicast, or broadcast mode.
And set the appropriate multicast filter.
Multicast hash table changes from 128 to 256 bits for 635M/B &amp; 900B0.
.TH "sis900_reset" 9 "sis900_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_reset \-  Reset sis900 MAC 
.SH SYNOPSIS
.B "void" sis900_reset
.BI "(struct net_device *" net_dev ");"
.SH ARGUMENTS
.IP "net_dev" 12
 the net device to reset
.SH "DESCRIPTION"
reset sis900 MAC and wait until finished
reset through command register
change backoff algorithm for 900B0 &amp; 635 M/B
.TH "sis900_remove" 9 "sis900_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis900_remove \-  Remove sis900 device 
.SH SYNOPSIS
.B "void __devexit" sis900_remove
.BI "(struct pci_dev *" pci_dev ");"
.SH ARGUMENTS
.IP "pci_dev" 12
 the pci device to be removed
.SH "DESCRIPTION"
remove and release SiS900 net device
.TH "ixgb_init_module" 9 "ixgb_init_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_init_module \-  Driver Registration Routine
.SH SYNOPSIS
.B "int __init" ixgb_init_module
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

ixgb_init_module is the first routine called when the driver is
loaded. All it does is register with the PCI subsystem.
.TH "ixgb_exit_module" 9 "ixgb_exit_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_exit_module \-  Driver Exit Cleanup Routine
.SH SYNOPSIS
.B "void __exit" ixgb_exit_module
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

ixgb_exit_module is called just before the driver is removed
from memory.
.TH "ixgb_irq_disable" 9 "ixgb_irq_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_irq_disable \-  Mask off interrupt generation on the NIC
.SH SYNOPSIS
.B "void" ixgb_irq_disable
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.TH "ixgb_irq_enable" 9 "ixgb_irq_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_irq_enable \-  Enable default interrupt generation settings
.SH SYNOPSIS
.B "void" ixgb_irq_enable
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.TH "ixgb_probe" 9 "ixgb_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_probe \-  Device Initialization Routine
.SH SYNOPSIS
.B "int __devinit" ixgb_probe
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" ent ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device information struct
.IP "ent" 12
 entry in ixgb_pci_tbl
.SH "DESCRIPTION"
Returns 0 on success, negative on failure

ixgb_probe initializes an adapter identified by a pci_dev structure.
The OS initialization, configuring of the adapter private structure,
and a hardware reset occur.
.TH "ixgb_remove" 9 "ixgb_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_remove \-  Device Removal Routine
.SH SYNOPSIS
.B "void __devexit" ixgb_remove
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device information struct
.SH "DESCRIPTION"
ixgb_remove is called by the PCI subsystem to alert the driver
that it should release a PCI device.  The could be caused by a
Hot-Plug event, or because the driver is going to be removed from
memory.
.TH "ixgb_sw_init" 9 "ixgb_sw_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_sw_init \-  Initialize general software structures (struct ixgb_adapter)
.SH SYNOPSIS
.B "int __devinit" ixgb_sw_init
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure to initialize
.SH "DESCRIPTION"
ixgb_sw_init initializes the Adapter private data structure.
Fields are initialized based on PCI device information and
OS network device settings (MTU size).
.TH "ixgb_open" 9 "ixgb_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_open \-  Called when a network interface is made active
.SH SYNOPSIS
.B "int" ixgb_open
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 network interface device structure
.SH "DESCRIPTION"
Returns 0 on success, negative value on failure

The open entry point is called when a network interface is made
active by the system (IFF_UP).  At this point all resources needed
for transmit and receive operations are allocated, the interrupt
handler is registered with the OS, the watchdog timer is started,
and the stack is notified that the interface is ready.
.TH "ixgb_close" 9 "ixgb_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_close \-  Disables a network interface
.SH SYNOPSIS
.B "int" ixgb_close
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 network interface device structure
.SH "DESCRIPTION"
Returns 0, this is not allowed to fail

The close entry point is called when an interface is de-activated
by the OS.  The hardware is still under the drivers control, but
needs to be disabled.  A global MAC reset is issued to stop the
hardware, and all transmit and receive resources are freed.
.TH "ixgb_setup_tx_resources" 9 "ixgb_setup_tx_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_setup_tx_resources \-  allocate Tx resources (Descriptors)
.SH SYNOPSIS
.B "int" ixgb_setup_tx_resources
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Return 0 on success, negative on failure
.TH "ixgb_configure_tx" 9 "ixgb_configure_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_configure_tx \-  Configure 82597 Transmit Unit after Reset.
.SH SYNOPSIS
.B "void" ixgb_configure_tx
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Configure the Tx unit of the MAC after a reset.
.TH "ixgb_setup_rx_resources" 9 "ixgb_setup_rx_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_setup_rx_resources \-  allocate Rx resources (Descriptors)
.SH SYNOPSIS
.B "int" ixgb_setup_rx_resources
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Returns 0 on success, negative on failure
.TH "ixgb_setup_rctl" 9 "ixgb_setup_rctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_setup_rctl \-  configure the receive control register
.SH SYNOPSIS
.B "void" ixgb_setup_rctl
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 Board private structure
.TH "ixgb_configure_rx" 9 "ixgb_configure_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_configure_rx \-  Configure 82597 Receive Unit after Reset.
.SH SYNOPSIS
.B "void" ixgb_configure_rx
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Configure the Rx unit of the MAC after a reset.
.TH "ixgb_free_tx_resources" 9 "ixgb_free_tx_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_free_tx_resources \-  Free Tx Resources
.SH SYNOPSIS
.B "void" ixgb_free_tx_resources
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Free all transmit software resources
.TH "ixgb_clean_tx_ring" 9 "ixgb_clean_tx_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_clean_tx_ring \-  Free Tx Buffers
.SH SYNOPSIS
.B "void" ixgb_clean_tx_ring
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.TH "ixgb_free_rx_resources" 9 "ixgb_free_rx_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_free_rx_resources \-  Free Rx Resources
.SH SYNOPSIS
.B "void" ixgb_free_rx_resources
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Free all receive software resources
.TH "ixgb_clean_rx_ring" 9 "ixgb_clean_rx_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_clean_rx_ring \-  Free Rx Buffers
.SH SYNOPSIS
.B "void" ixgb_clean_rx_ring
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.TH "ixgb_set_mac" 9 "ixgb_set_mac" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_set_mac \-  Change the Ethernet Address of the NIC
.SH SYNOPSIS
.B "int" ixgb_set_mac
.BI "(struct net_device *" netdev ","
.BI "void *" p ");"
.SH ARGUMENTS
.IP "netdev" 12
 network interface device structure
.IP "p" 12
 pointer to an address structure
.SH "DESCRIPTION"
Returns 0 on success, negative on failure
.TH "ixgb_set_multi" 9 "ixgb_set_multi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_set_multi \-  Multicast and Promiscuous mode set
.SH SYNOPSIS
.B "void" ixgb_set_multi
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 network interface device structure
.SH "DESCRIPTION"
The set_multi entry point is called whenever the multicast address
list or the network interface flags are updated.  This routine is
responsible for configuring the hardware for proper multicast,
promiscuous mode, and all-multi behavior.
.TH "ixgb_watchdog" 9 "ixgb_watchdog" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_watchdog \-  Timer Call-back
.SH SYNOPSIS
.B "void" ixgb_watchdog
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 pointer to netdev cast into an unsigned long
.TH "ixgb_tx_timeout" 9 "ixgb_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_tx_timeout \-  Respond to a Tx Hang
.SH SYNOPSIS
.B "void" ixgb_tx_timeout
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 network interface device structure
.TH "ixgb_get_stats" 9 "ixgb_get_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_get_stats \-  Get System Network Statistics
.SH SYNOPSIS
.B "struct net_device_stats *" ixgb_get_stats
.BI "(struct net_device *" netdev ");"
.SH ARGUMENTS
.IP "netdev" 12
 network interface device structure
.SH "DESCRIPTION"
Returns the address of the device statistics structure.
The statistics are actually updated from the timer callback.
.TH "ixgb_change_mtu" 9 "ixgb_change_mtu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_change_mtu \-  Change the Maximum Transfer Unit
.SH SYNOPSIS
.B "int" ixgb_change_mtu
.BI "(struct net_device *" netdev ","
.BI "int " new_mtu ");"
.SH ARGUMENTS
.IP "netdev" 12
 network interface device structure
.IP "new_mtu" 12
 new value for maximum frame size
.SH "DESCRIPTION"
Returns 0 on success, negative on failure
.TH "ixgb_update_stats" 9 "ixgb_update_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_update_stats \-  Update the board statistics counters.
.SH SYNOPSIS
.B "void" ixgb_update_stats
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.TH "ixgb_intr" 9 "ixgb_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_intr \-  Interrupt Handler
.SH SYNOPSIS
.B "irqreturn_t" ixgb_intr
.BI "(int " irq ","
.BI "void *" data ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt number
.IP "data" 12
 pointer to a network interface device structure
.IP "regs" 12
-- undescribed --
.TH "ixgb_clean" 9 "ixgb_clean" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_clean \-  NAPI Rx polling callback
.SH SYNOPSIS
.B "int" ixgb_clean
.BI "(struct net_device *" netdev ","
.BI "int *" budget ");"
.SH ARGUMENTS
.IP "netdev" 12
-- undescribed --
.IP "budget" 12
-- undescribed --
.TH "ixgb_clean_tx_irq" 9 "ixgb_clean_tx_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_clean_tx_irq \-  Reclaim resources after transmit completes
.SH SYNOPSIS
.B "boolean_t" ixgb_clean_tx_irq
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.TH "ixgb_rx_checksum" 9 "ixgb_rx_checksum" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_rx_checksum \-  Receive Checksum Offload for 82597.
.SH SYNOPSIS
.B "void" ixgb_rx_checksum
.BI "(struct ixgb_adapter *" adapter ","
.BI "struct ixgb_rx_desc *" rx_desc ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.IP "rx_desc" 12
 receive descriptor
.IP "skb" 12
-- undescribed --
.TH "ixgb_clean_rx_irq" 9 "ixgb_clean_rx_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_clean_rx_irq \-  Send received data up the network stack,
.SH SYNOPSIS
.B "boolean_t" ixgb_clean_rx_irq
.BI "(struct ixgb_adapter *" adapter ","
.BI "int *" work_done ","
.BI "int " work_to_do ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.IP "work_done" 12
-- undescribed --
.IP "work_to_do" 12
-- undescribed --
.TH "ixgb_alloc_rx_buffers" 9 "ixgb_alloc_rx_buffers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_alloc_rx_buffers \-  Replace used receive buffers
.SH SYNOPSIS
.B "void" ixgb_alloc_rx_buffers
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 address of board private structure
.TH "ixgb_vlan_rx_register" 9 "ixgb_vlan_rx_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_vlan_rx_register \-  enables or disables vlan tagging/stripping.
.SH SYNOPSIS
.B "void" ixgb_vlan_rx_register
.BI "(struct net_device *" netdev ","
.BI "struct vlan_group *" grp ");"
.SH ARGUMENTS
.IP "netdev" 12
-- undescribed --
.IP "grp" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP netdev network interface device structure
\fIparam\fP grp indicates to enable or disable tagging/stripping
.TH "ixgb_check_options" 9 "ixgb_check_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ixgb_check_options \-  Range Checking for Command Line Parameters
.SH SYNOPSIS
.B "void __devinit" ixgb_check_options
.BI "(struct ixgb_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
This routine checks all command line parameters for valid user
input.  If an invalid value is given, or if no user specified
value exists, a default value is used.  The final value is stored
in a variable in the adapter structure.
.TH "alloc_rd_info" 9 "alloc_rd_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_rd_info \- 	allocate an rd info block
.SH SYNOPSIS
.B "struct velocity_rd_info *" alloc_rd_info
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Alocate and initialize a receive info structure used for keeping
track of kernel side information related to each receive
descriptor we are using
.TH "mac_get_cam_mask" 9 "mac_get_cam_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_get_cam_mask \- 	Read a CAM mask
.SH SYNOPSIS
.B "void" mac_get_cam_mask
.BI "(struct mac_regs __iomem *" regs ","
.BI "u8 *" mask ","
.BI "enum velocity_cam_type " cam_type ");"
.SH ARGUMENTS
.IP "regs" 12
 register block for this velocity
.IP "mask" 12
 buffer to store mask
.IP "cam_type" 12
 CAM to fetch
.SH "DESCRIPTION"
Fetch the mask bits of the selected CAM and store them into the
provided mask buffer.
.TH "mac_set_cam_mask" 9 "mac_set_cam_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_set_cam_mask \- 	Set a CAM mask
.SH SYNOPSIS
.B "void" mac_set_cam_mask
.BI "(struct mac_regs __iomem *" regs ","
.BI "u8 *" mask ","
.BI "enum velocity_cam_type " cam_type ");"
.SH ARGUMENTS
.IP "regs" 12
 register block for this velocity
.IP "mask" 12
 CAM mask to load
.IP "cam_type" 12
 CAM to store
.SH "DESCRIPTION"
Store a new mask into a CAM
.TH "mac_set_cam" 9 "mac_set_cam" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_set_cam \- 	set CAM data
.SH SYNOPSIS
.B "void" mac_set_cam
.BI "(struct mac_regs __iomem *" regs ","
.BI "int " idx ","
.BI "u8 *" addr ","
.BI "enum velocity_cam_type " cam_type ");"
.SH ARGUMENTS
.IP "regs" 12
 register block of this velocity
.IP "idx" 12
 Cam index
.IP "addr" 12
 2 or 6 bytes of CAM data
.IP "cam_type" 12
 CAM to load
.SH "DESCRIPTION"
Load an address or vlan tag into a CAM
.TH "mac_get_cam" 9 "mac_get_cam" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_get_cam \- 	fetch CAM data
.SH SYNOPSIS
.B "void" mac_get_cam
.BI "(struct mac_regs __iomem *" regs ","
.BI "int " idx ","
.BI "u8 *" addr ","
.BI "enum velocity_cam_type " cam_type ");"
.SH ARGUMENTS
.IP "regs" 12
 register block of this velocity
.IP "idx" 12
 Cam index
.IP "addr" 12
 buffer to hold up to 6 bytes of CAM data
.IP "cam_type" 12
 CAM to load
.SH "DESCRIPTION"
Load an address or vlan tag from a CAM into the buffer provided by
the caller. VLAN tags are 2 bytes the address cam entries are 6.
.TH "mac_wol_reset" 9 "mac_wol_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_wol_reset \- 	reset WOL after exiting low power
.SH SYNOPSIS
.B "void" mac_wol_reset
.BI "(struct mac_regs __iomem *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 register block of this velocity
.SH "DESCRIPTION"
Called after we drop out of wake on lan mode in order to
reset the Wake on lan features. This function doesn't restore
the rest of the logic from the result of sleep/wakeup
.TH "velocity_get_ip" 9 "velocity_get_ip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_get_ip \- 	find an IP address for the device
.SH SYNOPSIS
.B "int" velocity_get_ip
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 Velocity to query
.SH "DESCRIPTION"
Dig out an IP address for this interface so that we can
configure wakeup with WOL for ARP. If there are multiple IP
addresses on this chain then we use the first - multi-IP WOL is not
supported.
.SH "CHECK ME"
 locking
.TH "velocity_update_hw_mibs" 9 "velocity_update_hw_mibs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_update_hw_mibs \- 	fetch MIB counters from chip
.SH SYNOPSIS
.B "void" velocity_update_hw_mibs
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to update
.SH "DESCRIPTION"
The velocity hardware keeps certain counters in the hardware
side. We need to read these when the user asks for statistics
or when they overflow (causing an interrupt). The read of the
statistic clears it, so we keep running master counters in user
space.
.TH "init_flow_control_register" 9 "init_flow_control_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_flow_control_register \- 	set up flow control
.SH SYNOPSIS
.B "void" init_flow_control_register
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to configure
.SH "DESCRIPTION"
Configure the flow control registers for this velocity device.
.TH "z8530_read_port" 9 "z8530_read_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_read_port \-  Architecture specific interface function
.SH SYNOPSIS
.B "int" z8530_read_port
.BI "(unsigned long " p ");"
.SH ARGUMENTS
.IP "p" 12
 port to read
.SH "DESCRIPTION"
Provided port access methods. The Comtrol SV11 requires no delays
between accesses and uses PC I/O. Some drivers may need a 5uS delay

In the longer term this should become an architecture specific
section so that this can become a generic driver interface for all
platforms. For now we only handle PC I/O ports with or without the
dread 5uS sanity delay.

The caller must hold sufficient locks to avoid violating the horrible
5uS delay rule.
.TH "z8530_write_port" 9 "z8530_write_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_write_port \-  Architecture specific interface function
.SH SYNOPSIS
.B "void" z8530_write_port
.BI "(unsigned long " p ","
.BI "u8 " d ");"
.SH ARGUMENTS
.IP "p" 12
 port to write
.IP "d" 12
 value to write
.SH "DESCRIPTION"
Write a value to a port with delays if need be. Note that the
caller must hold locks to avoid read/writes from other contexts
violating the 5uS rule

In the longer term this should become an architecture specific
section so that this can become a generic driver interface for all
platforms. For now we only handle PC I/O ports with or without the
dread 5uS sanity delay.
.TH "read_zsreg" 9 "read_zsreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_zsreg \-  Read a register from a Z85230 
.SH SYNOPSIS
.B "u8" read_zsreg
.BI "(struct z8530_channel *" c ","
.BI "u8 " reg ");"
.SH ARGUMENTS
.IP "c" 12
 Z8530 channel to read from (2 per chip)
.IP "reg" 12
 Register to read
.SH "FIXME"
 Use a spinlock.

Most of the Z8530 registers are indexed off the control registers.
A read is done by writing to the control register and reading the
register back.  The caller must hold the lock
.TH "read_zsdata" 9 "read_zsdata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_zsdata \-  Read the data port of a Z8530 channel
.SH SYNOPSIS
.B "u8" read_zsdata
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 The Z8530 channel to read the data port from
.SH "DESCRIPTION"
The data port provides fast access to some things. We still
have all the 5uS delays to worry about.
.TH "write_zsreg" 9 "write_zsreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_zsreg \-  Write to a Z8530 channel register
.SH SYNOPSIS
.B "void" write_zsreg
.BI "(struct z8530_channel *" c ","
.BI "u8 " reg ","
.BI "u8 " val ");"
.SH ARGUMENTS
.IP "c" 12
 The Z8530 channel
.IP "reg" 12
 Register number
.IP "val" 12
 Value to write
.SH "DESCRIPTION"
Write a value to an indexed register. The caller must hold the lock
to honour the irritating delay rules. We know about register 0
being fast to access.

Assumes c-&gt;lock is held.
.TH "write_zsctrl" 9 "write_zsctrl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_zsctrl \-  Write to a Z8530 control register
.SH SYNOPSIS
.B "void" write_zsctrl
.BI "(struct z8530_channel *" c ","
.BI "u8 " val ");"
.SH ARGUMENTS
.IP "c" 12
 The Z8530 channel
.IP "val" 12
 Value to write
.SH "DESCRIPTION"
Write directly to the control register on the Z8530
.TH "write_zsdata" 9 "write_zsdata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_zsdata \-  Write to a Z8530 control register
.SH SYNOPSIS
.B "void" write_zsdata
.BI "(struct z8530_channel *" c ","
.BI "u8 " val ");"
.SH ARGUMENTS
.IP "c" 12
 The Z8530 channel
.IP "val" 12
 Value to write
.SH "DESCRIPTION"
Write directly to the data register on the Z8530
.TH "z8530_flush_fifo" 9 "z8530_flush_fifo" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_flush_fifo \-  Flush on chip RX FIFO
.SH SYNOPSIS
.B "void" z8530_flush_fifo
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 Channel to flush
.SH "DESCRIPTION"
Flush the receive FIFO. There is no specific option for this, we 
blindly read bytes and discard them. Reading when there is no data
is harmless. The 8530 has a 4 byte FIFO, the 85230 has 8 bytes.

All locking is handled for the caller. On return data may still be
present if it arrived during the flush.
.TH "z8530_rtsdtr" 9 "z8530_rtsdtr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_rtsdtr \-  Control the outgoing DTS/RTS line
.SH SYNOPSIS
.B "void" z8530_rtsdtr
.BI "(struct z8530_channel *" c ","
.BI "int " set ");"
.SH ARGUMENTS
.IP "c" 12
 The Z8530 channel to control;
.IP "set" 12
 1 to set, 0 to clear
.SH "DESCRIPTION"
Sets or clears DTR/RTS on the requested line. All locking is handled
by the caller. For now we assume all boards use the actual RTS/DTR
on the chip. Apparently one or two don't. We'll scream about them
later.
.TH "z8530_rx" 9 "z8530_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_rx \-  Handle a PIO receive event
.SH SYNOPSIS
.B "void" z8530_rx
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 Z8530 channel to process
.SH "DESCRIPTION"
Receive handler for receiving in PIO mode. This is much like the 
async one but not quite the same or as complex
.SH "NOTE"
 Its intended that this handler can easily be separated from
the main code to run realtime. That'll be needed for some machines
(eg to ever clock 64kbits on a sparc ;)).

The RT_LOCK macros don't do anything now. Keep the code covered
by them as short as possible in all circumstances - clocks cost
baud. The interrupt handler is assumed to be atomic w.r.t. to
other code - this is true in the RT case too.

We only cover the sync cases for this. If you want 2Mbit async
do it yourself but consider medical assistance first. This non DMA 
synchronous mode is portable code. The DMA mode assumes PCI like 
ISA DMA

Called with the device lock held
.TH "z8530_tx" 9 "z8530_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_tx \-  Handle a PIO transmit event
.SH SYNOPSIS
.B "void" z8530_tx
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 Z8530 channel to process
.SH "DESCRIPTION"
Z8530 transmit interrupt handler for the PIO mode. The basic
idea is to attempt to keep the FIFO fed. We fill as many bytes
in as possible, its quite possible that we won't keep up with the
data rate otherwise.
.TH "z8530_status" 9 "z8530_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_status \-  Handle a PIO status exception
.SH SYNOPSIS
.B "void" z8530_status
.BI "(struct z8530_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Z8530 channel to process
.SH "DESCRIPTION"
A status event occurred in PIO synchronous mode. There are several
reasons the chip will bother us here. A transmit underrun means we
failed to feed the chip fast enough and just broke a packet. A DCD
change is a line up or down. We communicate that back to the protocol
layer for synchronous PPP to renegotiate.
.TH "z8530_dma_rx" 9 "z8530_dma_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_dma_rx \-  Handle a DMA RX event
.SH SYNOPSIS
.B "void" z8530_dma_rx
.BI "(struct z8530_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Channel to handle
.SH "DESCRIPTION"
Non bus mastering DMA interfaces for the Z8x30 devices. This
is really pretty PC specific. The DMA mode means that most receive
events are handled by the DMA hardware. We get a kick here only if
a frame ended.
.TH "z8530_dma_tx" 9 "z8530_dma_tx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_dma_tx \-  Handle a DMA TX event
.SH SYNOPSIS
.B "void" z8530_dma_tx
.BI "(struct z8530_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
	The Z8530 channel to handle
.SH "DESCRIPTION"
We have received an interrupt while doing DMA transmissions. It
shouldn't happen. Scream loudly if it does.
.TH "z8530_dma_status" 9 "z8530_dma_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_dma_status \-  Handle a DMA status exception
.SH SYNOPSIS
.B "void" z8530_dma_status
.BI "(struct z8530_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Z8530 channel to process
.SH "DESCRIPTION"
A status event occurred on the Z8530. We receive these for two reasons
when in DMA mode. Firstly if we finished a packet transfer we get one
and kick the next packet out. Secondly we may see a DCD change and
have to poke the protocol layer.
.TH "z8530_rx_clear" 9 "z8530_rx_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_rx_clear \-  Handle RX events from a stopped chip
.SH SYNOPSIS
.B "void" z8530_rx_clear
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 Z8530 channel to shut up
.SH "DESCRIPTION"
Receive interrupt vectors for a Z8530 that is in 'parked' mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.
.TH "z8530_tx_clear" 9 "z8530_tx_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_tx_clear \-  Handle TX events from a stopped chip
.SH SYNOPSIS
.B "void" z8530_tx_clear
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 Z8530 channel to shut up
.SH "DESCRIPTION"
Transmit interrupt vectors for a Z8530 that is in 'parked' mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.
.TH "z8530_status_clear" 9 "z8530_status_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_status_clear \-  Handle status events from a stopped chip
.SH SYNOPSIS
.B "void" z8530_status_clear
.BI "(struct z8530_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Z8530 channel to shut up
.SH "DESCRIPTION"
Status interrupt vectors for a Z8530 that is in 'parked' mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.
.TH "z8530_interrupt" 9 "z8530_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_interrupt \-  Handle an interrupt from a Z8530
.SH SYNOPSIS
.B "irqreturn_t" z8530_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 	Interrupt number
.IP "dev_id" 12
 The Z8530 device that is interrupting.
.IP "regs" 12
 unused
.SH "DESCRIPTION"
A Z85[2]30 device has stuck its hand in the air for attention.
We scan both the channels on the chip for events and then call
the channel specific call backs for each channel that has events.
We have to use callback functions because the two channels can be
in different modes.

Locking is done for the handlers. Note that locking is done
at the chip level (the 5uS delay issue is per chip not per
channel). c-&gt;lock for both channels points to dev-&gt;lock
.TH "z8530_sync_open" 9 "z8530_sync_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_sync_open \-  Open a Z8530 channel for PIO
.SH SYNOPSIS
.B "int" z8530_sync_open
.BI "(struct net_device *" dev ","
.BI "struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "dev" 12
	The network interface we are using
.IP "c" 12
	The Z8530 channel to open in synchronous PIO mode
.SH "DESCRIPTION"
Switch a Z8530 into synchronous mode without DMA assist. We
raise the RTS/DTR and commence network operation.
.TH "z8530_sync_close" 9 "z8530_sync_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_sync_close \-  Close a PIO Z8530 channel
.SH SYNOPSIS
.B "int" z8530_sync_close
.BI "(struct net_device *" dev ","
.BI "struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "dev" 12
 Network device to close
.IP "c" 12
 Z8530 channel to disassociate and move to idle
.SH "DESCRIPTION"
Close down a Z8530 interface and switch its interrupt handlers
to discard future events.
.TH "z8530_sync_dma_open" 9 "z8530_sync_dma_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_sync_dma_open \-  Open a Z8530 for DMA I/O
.SH SYNOPSIS
.B "int" z8530_sync_dma_open
.BI "(struct net_device *" dev ","
.BI "struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "dev" 12
 The network device to attach
.IP "c" 12
 The Z8530 channel to configure in sync DMA mode.
.SH "DESCRIPTION"
Set up a Z85x30 device for synchronous DMA in both directions. Two
ISA DMA channels must be available for this to work. We assume ISA
DMA driven I/O and PC limits on access.
.TH "z8530_sync_dma_close" 9 "z8530_sync_dma_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_sync_dma_close \-  Close down DMA I/O
.SH SYNOPSIS
.B "int" z8530_sync_dma_close
.BI "(struct net_device *" dev ","
.BI "struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "dev" 12
 Network device to detach
.IP "c" 12
 Z8530 channel to move into discard mode
.SH "DESCRIPTION"
Shut down a DMA mode synchronous interface. Halt the DMA, and
free the buffers.
.TH "z8530_sync_txdma_open" 9 "z8530_sync_txdma_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_sync_txdma_open \-  Open a Z8530 for TX driven DMA
.SH SYNOPSIS
.B "int" z8530_sync_txdma_open
.BI "(struct net_device *" dev ","
.BI "struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "dev" 12
 The network device to attach
.IP "c" 12
 The Z8530 channel to configure in sync DMA mode.
.SH "DESCRIPTION"
Set up a Z85x30 device for synchronous DMA tranmission. One
ISA DMA channel must be available for this to work. The receive
side is run in PIO mode, but then it has the bigger FIFO.
.TH "z8530_sync_txdma_close" 9 "z8530_sync_txdma_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_sync_txdma_close \-  Close down a TX driven DMA channel
.SH SYNOPSIS
.B "int" z8530_sync_txdma_close
.BI "(struct net_device *" dev ","
.BI "struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "dev" 12
 Network device to detach
.IP "c" 12
 Z8530 channel to move into discard mode
.SH "DESCRIPTION"
Shut down a DMA/PIO split mode synchronous interface. Halt the DMA, 
and  free the buffers.
.TH "z8530_describe" 9 "z8530_describe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_describe \-  Uniformly describe a Z8530 port
.SH SYNOPSIS
.B "void" z8530_describe
.BI "(struct z8530_dev *" dev ","
.BI "char *" mapping ","
.BI "unsigned long " io ");"
.SH ARGUMENTS
.IP "dev" 12
 Z8530 device to describe
.IP "mapping" 12
 string holding mapping type (eg "I/O" or "Mem")
.IP "io" 12
 the port value in question
.SH "DESCRIPTION"
Describe a Z8530 in a standard format. We must pass the I/O as
the port offset isnt predictable. The main reason for this function
is to try and get a common format of report.
.TH "z8530_init" 9 "z8530_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_init \-  Initialise a Z8530 device
.SH SYNOPSIS
.B "int" z8530_init
.BI "(struct z8530_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Z8530 device to initialise.
.SH "DESCRIPTION"
Configure up a Z8530/Z85C30 or Z85230 chip. We check the device
is present, identify the type and then program it to hopefully
keep quite and behave. This matters a lot, a Z8530 in the wrong
state will sometimes get into stupid modes generating 10Khz
interrupt streams and the like.

We set the interrupt handler up to discard any events, in case
we get them during reset or setp.

Return 0 for success, or a negative value indicating the problem
in errno form.
.TH "z8530_shutdown" 9 "z8530_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_shutdown \-  Shutdown a Z8530 device
.SH SYNOPSIS
.B "int" z8530_shutdown
.BI "(struct z8530_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The Z8530 chip to shutdown
.SH "DESCRIPTION"
We set the interrupt handlers to silence any interrupts. We then 
reset the chip and wait 100uS to be sure the reset completed. Just
in case the caller then tries to do stuff.

This is called without the lock held
.TH "z8530_channel_load" 9 "z8530_channel_load" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_channel_load \-  Load channel data
.SH SYNOPSIS
.B "int" z8530_channel_load
.BI "(struct z8530_channel *" c ","
.BI "u8 *" rtable ");"
.SH ARGUMENTS
.IP "c" 12
 Z8530 channel to configure
.IP "rtable" 12
 table of register, value pairs
.SH "FIXME"
 ioctl to allow user uploaded tables

Load a Z8530 channel up from the system data. We use +16 to 
indicate the "prime" registers. The value 255 terminates the
table.
.TH "z8530_tx_begin" 9 "z8530_tx_begin" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_tx_begin \-  Begin packet transmission
.SH SYNOPSIS
.B "void" z8530_tx_begin
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 The Z8530 channel to kick
.SH "DESCRIPTION"
This is the speed sensitive side of transmission. If we are called
and no buffer is being transmitted we commence the next buffer. If
nothing is queued we idle the sync. 
.SH "NOTE"
 We are handling this code path in the interrupt path, keep it
fast or bad things will happen.

Called with the lock held.
.TH "z8530_tx_done" 9 "z8530_tx_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_tx_done \-  TX complete callback
.SH SYNOPSIS
.B "void" z8530_tx_done
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 The channel that completed a transmit.
.SH "DESCRIPTION"
This is called when we complete a packet send. We wake the queue,
start the next packet going and then free the buffer of the existing
packet. This code is fairly timing sensitive.

Called with the register lock held.
.TH "z8530_null_rx" 9 "z8530_null_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_null_rx \-  Discard a packet
.SH SYNOPSIS
.B "void" z8530_null_rx
.BI "(struct z8530_channel *" c ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "c" 12
 The channel the packet arrived on
.IP "skb" 12
 The buffer
.SH "DESCRIPTION"
We point the receive handler at this function when idle. Instead
of syncppp processing the frames we get to throw them away.
.TH "z8530_rx_done" 9 "z8530_rx_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_rx_done \-  Receive completion callback
.SH SYNOPSIS
.B "void" z8530_rx_done
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 The channel that completed a receive
.SH "DESCRIPTION"
A new packet is complete. Our goal here is to get back into receive
mode as fast as possible. On the Z85230 we could change to using
ESCC mode, but on the older chips we have no choice. We flip to the
new buffer immediately in DMA mode so that the DMA of the next
frame can occur while we are copying the previous buffer to an sk_buff

Called with the lock held
.TH "spans_boundary" 9 "spans_boundary" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spans_boundary \-  Check a packet can be ISA DMA'd
.SH SYNOPSIS
.B "int" spans_boundary
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 The buffer to check
.SH "DESCRIPTION"
Returns true if the buffer cross a DMA boundary on a PC. The poor
thing can only DMA within a 64K block not across the edges of it.
.TH "z8530_queue_xmit" 9 "z8530_queue_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_queue_xmit \-  Queue a packet
.SH SYNOPSIS
.B "int" z8530_queue_xmit
.BI "(struct z8530_channel *" c ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "c" 12
 The channel to use
.IP "skb" 12
 The packet to kick down the channel
.SH "DESCRIPTION"
Queue a packet for transmission. Because we have rather
hard to hit interrupt latencies for the Z85230 per packet 
even in DMA mode we do the flip to DMA buffer if needed here
not in the IRQ.

Called from the network code. The lock is not held at this 
point.
.TH "z8530_get_stats" 9 "z8530_get_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z8530_get_stats \-  Get network statistics
.SH SYNOPSIS
.B "struct net_device_stats *" z8530_get_stats
.BI "(struct z8530_channel *" c ");"
.SH ARGUMENTS
.IP "c" 12
 The channel to use
.SH "DESCRIPTION"
Get the statistics block. We keep the statistics in software as
the chip doesn't do it for us.

Locking is ignored here - we could lock for a copy but its
not likely to be that big an issue
.TH "sppp_input" 9 "sppp_input" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_input \- 	receive and process a WAN PPP frame
.SH SYNOPSIS
.B "void" sppp_input
.BI "(struct net_device *" dev ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "dev" 12
	The device it arrived on
.IP "skb" 12
	The buffer to process
.SH "DESCRIPTION"
This can be called directly by cards that do not have
timing constraints but is normally called from the network layer
after interrupt servicing to process frames queued via \fBnetif_rx\fP.

We process the options in the card. If the frame is destined for
the protocol stacks then it requeues the frame for the upper level
protocol. If it is a control from it is processed and discarded
here.
.TH "sppp_close" 9 "sppp_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_close \-  close down a synchronous PPP or Cisco HDLC link
.SH SYNOPSIS
.B "int" sppp_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The network device to drop the link of
.SH "DESCRIPTION"
This drops the logical interface to the channel. It is not
done politely as we assume we will also be dropping DTR. Any
timeouts are killed.
.TH "sppp_open" 9 "sppp_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_open \-  open a synchronous PPP or Cisco HDLC link
.SH SYNOPSIS
.B "int" sppp_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Network device to activate
.SH "DESCRIPTION"
Close down any existing synchronous session and commence
from scratch. In the PPP case this means negotiating LCP/IPCP
and friends, while for Cisco HDLC we simply need to start sending
keepalives
.TH "sppp_reopen" 9 "sppp_reopen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_reopen \-  notify of physical link loss
.SH SYNOPSIS
.B "int" sppp_reopen
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 Device that lost the link
.SH "DESCRIPTION"
This function informs the synchronous protocol code that
the underlying link died (for example a carrier drop on X.21)

We increment the magic numbers to ensure that if the other end
failed to notice we will correctly start a new session. It happens
do to the nature of telco circuits is that you can lose carrier on
one endonly.

Having done this we go back to negotiating. This function may
be called from an interrupt context.
.TH "sppp_change_mtu" 9 "sppp_change_mtu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_change_mtu \-  Change the link MTU
.SH SYNOPSIS
.B "int" sppp_change_mtu
.BI "(struct net_device *" dev ","
.BI "int " new_mtu ");"
.SH ARGUMENTS
.IP "dev" 12
	Device to change MTU on
.IP "new_mtu" 12
 New MTU
.SH "DESCRIPTION"
Change the MTU on the link. This can only be called with
the link down. It returns an error if the link is up or
the mtu is out of range.
.TH "sppp_do_ioctl" 9 "sppp_do_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_do_ioctl \-  Ioctl handler for ppp/hdlc
.SH SYNOPSIS
.B "int" sppp_do_ioctl
.BI "(struct net_device *" dev ","
.BI "struct ifreq *" ifr ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "dev" 12
 Device subject to ioctl
.IP "ifr" 12
 Interface request block from the user
.IP "cmd" 12
 Command that is being issued
.SH "DESCRIPTION"
This function handles the ioctls that may be issued by the user
to control the settings of a PPP/HDLC link. It does both busy
and security checks. This function is intended to be wrapped by
callers who wish to add additional ioctl calls of their own.
.TH "sppp_attach" 9 "sppp_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_attach \-  attach synchronous PPP/HDLC to a device
.SH SYNOPSIS
.B "void" sppp_attach
.BI "(struct ppp_device *" pd ");"
.SH ARGUMENTS
.IP "pd" 12
	PPP device to initialise
.SH "DESCRIPTION"
This initialises the PPP/HDLC support on an interface. At the
time of calling the dev element must point to the network device
that this interface is attached to. The interface should not yet
be registered. 
.TH "sppp_detach" 9 "sppp_detach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_detach \-  release PPP resources from a device
.SH SYNOPSIS
.B "void" sppp_detach
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Network device to release
.SH "DESCRIPTION"
Stop and free up any PPP/HDLC resources used by this
interface. This must be called before the device is
freed.
.TH "sppp_rcv" 9 "sppp_rcv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sppp_rcv \- 	receive and process a WAN PPP frame
.SH SYNOPSIS
.B "int" sppp_rcv
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ","
.BI "struct packet_type *" p ","
.BI "struct net_device *" orig_dev ");"
.SH ARGUMENTS
.IP "skb" 12
	The buffer to process
.IP "dev" 12
	The device it arrived on
.IP "p" 12
 Unused
.IP "orig_dev" 12
 Unused
.SH "DESCRIPTION"
Protocol glue. This drives the deferred processing mode the poorer
cards use. This can be called directly by cards that do not have
timing constraints but is normally called from the network layer
after interrupt servicing to process frames queued via netif_rx.
.TH "ax_open" 9 "ax_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ax_open \-  Open/initialize the board.
.SH SYNOPSIS
.B "int" ax_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device to initialize
.SH "DESCRIPTION"
This routine goes all-out, setting everything
up anew at each open, even though many of these registers should only
need to be set once at boot.
.TH "ax_close" 9 "ax_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ax_close \-  shut down network device
.SH SYNOPSIS
.B "int" ax_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device to close
.SH "DESCRIPTION"
Opposite of \fBax_open\fP. Only used when "ifconfig &lt;devname&gt; down" is done.
.TH "ei_tx_timeout" 9 "ei_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_tx_timeout \-  handle transmit time out condition
.SH SYNOPSIS
.B "void" ei_tx_timeout
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device which has apparently fallen asleep
.SH "DESCRIPTION"
Called by kernel when device never acknowledges a transmit has
completed (or failed) - i.e. never posted a Tx related interrupt.
.TH "ei_start_xmit" 9 "ei_start_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_start_xmit \-  begin packet transmission
.SH SYNOPSIS
.B "int" ei_start_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "skb" 12
 packet to be sent
.IP "dev" 12
 network device to which packet is sent
.SH "DESCRIPTION"
Sends a packet to an 8390 network device.
.TH "ax_interrupt" 9 "ax_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ax_interrupt \-  handle the interrupts from an 8390
.SH SYNOPSIS
.B "irqreturn_t" ax_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt number
.IP "dev_id" 12
 a pointer to the net_device
.IP "regs" 12
 unused
.SH "DESCRIPTION"
Handle the ether interface interrupts. We pull packets from
the 8390 via the card specific functions and fire them at the networking
stack. We also handle transmit completions and wake the transmit path if
necessary. We also update the counters and do other housekeeping as
needed.
.TH "ei_tx_err" 9 "ei_tx_err" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_tx_err \-  handle transmitter error
.SH SYNOPSIS
.B "void" ei_tx_err
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device which threw the exception
.SH "DESCRIPTION"
A transmitter error has happened. Most likely excess collisions (which
is a fairly normal condition). If the error is one where the Tx will
have been aborted, we try and send another one right away, instead of
letting the failed packet sit and collect dust in the Tx buffer. This
is a much better solution as it avoids kernel based Tx timeouts, and
an unnecessary card reset.

Called with lock held.
.TH "ei_tx_intr" 9 "ei_tx_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_tx_intr \-  transmit interrupt handler
.SH SYNOPSIS
.B "void" ei_tx_intr
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device for which tx intr is handled
.SH "WE HAVE FINISHED A TRANSMIT"
 check for errors and then trigger the next
packet to be sent. Called with lock held.
.TH "ei_receive" 9 "ei_receive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_receive \-  receive some packets
.SH SYNOPSIS
.B "void" ei_receive
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device with which receive will be run
.SH "DESCRIPTION"
We have a good packet(s), get it/them out of the buffers. 
Called with lock held.
.TH "ei_rx_overrun" 9 "ei_rx_overrun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_rx_overrun \-  handle receiver overrun
.SH SYNOPSIS
.B "void" ei_rx_overrun
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device which threw exception
.SH "WE HAVE A RECEIVER OVERRUN"
 we have to kick the 8390 to get it started
again. Problem is that you have to kick it exactly as NS prescribes in
the updated datasheets, or "the NIC may act in an unpredictable manner."
This includes causing "the NIC to defer indefinitely when it is stopped
on a busy network."  Ugh.
Called with lock held. Don't call this with the interrupts off or your
computer will hate you - it takes 10ms or so. 
.TH "do_set_multicast_list" 9 "do_set_multicast_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_set_multicast_list \-  set/clear multicast filter
.SH SYNOPSIS
.B "void" do_set_multicast_list
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 net device for which multicast filter is adjusted
.SH "DESCRIPTION"
Set or clear the multicast filter for this adaptor. May be called
from a BH in 2.1.x. Must be called with lock held. 
.TH "axdev_setup" 9 "axdev_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
axdev_setup \-  init rest of 8390 device struct
.SH SYNOPSIS
.B "void" axdev_setup
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device structure to init
.SH "DESCRIPTION"
Initialize the rest of the 8390 device structure.  Do NOT __init
this, as it is used by 8390 based modular drivers too.
.TH "AX88190_init" 9 "AX88190_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
AX88190_init \-  initialize 8390 hardware
.SH SYNOPSIS
.B "void" AX88190_init
.BI "(struct net_device *" dev ","
.BI "int " startp ");"
.SH ARGUMENTS
.IP "dev" 12
 network device to initialize
.IP "startp" 12
 boolean.  non-zero value to initiate chip processing
.SH "DESCRIPTION"
Must be called with lock held.
.TH "z_comp_free" 9 "z_comp_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_comp_free \-  free the memory used by a compressor
.SH SYNOPSIS
.B "void" z_comp_free
.BI "(void *" arg ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to the private state for the compressor.
.TH "z_comp_alloc" 9 "z_comp_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_comp_alloc \-  allocate space for a compressor.
.SH SYNOPSIS
.B "void *" z_comp_alloc
.BI "(unsigned char *" options ","
.BI "int " opt_len ");"
.SH ARGUMENTS
.IP "options" 12
 pointer to CCP option data
.IP "opt_len" 12
 length of the CCP option at \fIoptions\fP.
.SH "DESCRIPTION"
The \fIoptions\fP pointer points to the a buffer containing the
CCP option data for the compression being negotiated.  It is
formatted according to RFC1979, and describes the window
size that the peer is requesting that we use in compressing
data to be sent to it.

Returns the pointer to the private state for the compressor,
or NULL if we could not allocate enough memory.
.TH "z_comp_init" 9 "z_comp_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_comp_init \-  initialize a previously-allocated compressor.
.SH SYNOPSIS
.B "int" z_comp_init
.BI "(void *" arg ","
.BI "unsigned char *" options ","
.BI "int " opt_len ","
.BI "int " unit ","
.BI "int " hdrlen ","
.BI "int " debug ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to the private state for the compressor
.IP "options" 12
 pointer to the CCP option data describing the
compression that was negotiated with the peer
.IP "opt_len" 12
 length of the CCP option data at \fIoptions\fP
.IP "unit" 12
	PPP unit number for diagnostic messages
.IP "hdrlen" 12
 ignored (present for backwards compatibility)
.IP "debug" 12
	debug flag; if non-zero, debug messages are printed.
.SH "DESCRIPTION"
The CCP options described by \fIoptions\fP must match the options
specified when the compressor was allocated.  The compressor
history is reset.  Returns 0 for failure (CCP options don't
match) or 1 for success.
.TH "z_comp_reset" 9 "z_comp_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_comp_reset \-  reset a previously-allocated compressor.
.SH SYNOPSIS
.B "void" z_comp_reset
.BI "(void *" arg ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to private state for the compressor.
.SH "DESCRIPTION"
This clears the history for the compressor and makes it
ready to start emitting a new compressed stream.
.TH "z_compress" 9 "z_compress" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_compress \-  compress a PPP packet with Deflate compression.
.SH SYNOPSIS
.B "int" z_compress
.BI "(void *" arg ","
.BI "unsigned char *" rptr ","
.BI "unsigned char *" obuf ","
.BI "int " isize ","
.BI "int " osize ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to private state for the compressor
.IP "rptr" 12
	uncompressed packet (input)
.IP "obuf" 12
	compressed packet (output)
.IP "isize" 12
	size of uncompressed packet
.IP "osize" 12
	space available at \fIobuf\fP
.SH "DESCRIPTION"
Returns the length of the compressed packet, or 0 if the
packet is incompressible.
.TH "z_comp_stats" 9 "z_comp_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_comp_stats \-  return compression statistics for a compressor
.SH SYNOPSIS
.B "void" z_comp_stats
.BI "(void *" arg ","
.BI "struct compstat *" stats ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to private space for the (de)compressor
.IP "stats" 12
	pointer to a struct compstat to receive the result.
.SH "DESCRIPTION"
or decompressor.
.TH "z_decomp_free" 9 "z_decomp_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_decomp_free \-  Free the memory used by a decompressor.
.SH SYNOPSIS
.B "void" z_decomp_free
.BI "(void *" arg ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to private space for the decompressor.
.TH "z_decomp_alloc" 9 "z_decomp_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_decomp_alloc \-  allocate space for a decompressor.
.SH SYNOPSIS
.B "void *" z_decomp_alloc
.BI "(unsigned char *" options ","
.BI "int " opt_len ");"
.SH ARGUMENTS
.IP "options" 12
 pointer to CCP option data
.IP "opt_len" 12
 length of the CCP option at \fIoptions\fP.
.SH "DESCRIPTION"
The \fIoptions\fP pointer points to the a buffer containing the
CCP option data for the compression being negotiated.  It is
formatted according to RFC1979, and describes the window
size that we are requesting the peer to use in compressing
data to be sent to us.

Returns the pointer to the private state for the decompressor,
or NULL if we could not allocate enough memory.
.TH "z_decomp_init" 9 "z_decomp_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_decomp_init \-  initialize a previously-allocated decompressor.
.SH SYNOPSIS
.B "int" z_decomp_init
.BI "(void *" arg ","
.BI "unsigned char *" options ","
.BI "int " opt_len ","
.BI "int " unit ","
.BI "int " hdrlen ","
.BI "int " mru ","
.BI "int " debug ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to the private state for the decompressor
.IP "options" 12
 pointer to the CCP option data describing the
compression that was negotiated with the peer
.IP "opt_len" 12
 length of the CCP option data at \fIoptions\fP
.IP "unit" 12
	PPP unit number for diagnostic messages
.IP "hdrlen" 12
 ignored (present for backwards compatibility)
.IP "mru" 12
	maximum length of decompressed packets
.IP "debug" 12
	debug flag; if non-zero, debug messages are printed.
.SH "DESCRIPTION"
The CCP options described by \fIoptions\fP must match the options
specified when the decompressor was allocated.  The decompressor
history is reset.  Returns 0 for failure (CCP options don't
match) or 1 for success.
.TH "z_decomp_reset" 9 "z_decomp_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_decomp_reset \-  reset a previously-allocated decompressor.
.SH SYNOPSIS
.B "void" z_decomp_reset
.BI "(void *" arg ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to private state for the decompressor.
.SH "DESCRIPTION"
This clears the history for the decompressor and makes it
ready to receive a new compressed stream.
.TH "z_decompress" 9 "z_decompress" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_decompress \-  decompress a Deflate-compressed packet.
.SH SYNOPSIS
.B "int" z_decompress
.BI "(void *" arg ","
.BI "unsigned char *" ibuf ","
.BI "int " isize ","
.BI "unsigned char *" obuf ","
.BI "int " osize ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to private state for the decompressor
.IP "ibuf" 12
	pointer to input (compressed) packet data
.IP "isize" 12
	length of input packet
.IP "obuf" 12
	pointer to space for output (decompressed) packet
.IP "osize" 12
	amount of space available at \fIobuf\fP
.SH "DESCRIPTION"
Because of patent problems, we return DECOMP_ERROR for errors
found by inspecting the input data and for system problems, but
DECOMP_FATALERROR for any errors which could possibly be said to
be being detected "after" decompression.  For DECOMP_ERROR,
we can issue a CCP reset-request; for DECOMP_FATALERROR, we may be
infringing a patent of Motorola's if we do, so we take CCP down
instead.

Given that the frame has the correct sequence number and a good FCS,
errors such as invalid codes in the input most likely indicate a
bug, so we return DECOMP_FATALERROR for them in order to turn off
compression, even though they are detected by inspecting the input.
.TH "z_incomp" 9 "z_incomp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
z_incomp \-  add incompressible input data to the history.
.SH SYNOPSIS
.B "void" z_incomp
.BI "(void *" arg ","
.BI "unsigned char *" ibuf ","
.BI "int " icnt ");"
.SH ARGUMENTS
.IP "arg" 12
	pointer to private state for the decompressor
.IP "ibuf" 12
	pointer to input packet data
.IP "icnt" 12
	length of input data.
.TH "sis190_default_phy" 9 "sis190_default_phy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis190_default_phy \-  Select default PHY for sis190 mac.
.SH SYNOPSIS
.B "u16" sis190_default_phy
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the net device to probe for
.SH "DESCRIPTION"
Select first detected PHY with link as default.
If no one is link on, select PHY whose types is HOME as default.
If HOME doesn't exist, select LAN.
.TH "sis190_mii_probe" 9 "sis190_mii_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis190_mii_probe \-  Probe MII PHY for sis190
.SH SYNOPSIS
.B "int __devinit" sis190_mii_probe
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the net device to probe for
.SH "DESCRIPTION"
Search for total of 32 possible mii phy addresses.
Identify and set current phy if found one,
return error if it failed to found.
.TH "sis190_get_mac_addr_from_apc" 9 "sis190_get_mac_addr_from_apc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis190_get_mac_addr_from_apc \-  Get MAC address for SiS965 model
.SH SYNOPSIS
.B "int __devinit" sis190_get_mac_addr_from_apc
.BI "(struct pci_dev *" pdev ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device
.IP "dev" 12
  network device to get address for
.SH "DESCRIPTION"
SiS965 model, use APC CMOS RAM to store MAC address.
APC CMOS RAM is accessed through ISA bridge.
MAC address is read into \fInet_dev\fP-&gt;dev_addr.
.TH "sis190_init_rxfilter" 9 "sis190_init_rxfilter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sis190_init_rxfilter \-  Initialize the Rx filter
.SH SYNOPSIS
.B "void" sis190_init_rxfilter
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device to initialize
.SH "DESCRIPTION"
Set receive filter address to our MAC address
and enable packet filtering.
.TH "get_chip_name" 9 "get_chip_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_chip_name \-  	identifier to name
.SH SYNOPSIS
.B "char __devinit *" get_chip_name
.BI "(enum chip_type " chip_id ");"
.SH ARGUMENTS
.IP "chip_id" 12
-- undescribed --
.SH "DESCRIPTION"
Given a chip identifier return a suitable description. Returns
a pointer a static string valid while the driver is loaded.
.TH "velocity_remove1" 9 "velocity_remove1" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_remove1 \- 	device unplug
.SH SYNOPSIS
.B "void __devexit" velocity_remove1
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device being removed
.SH "DESCRIPTION"
Device unload callback. Called on an unplug or on module
unload for each active device that is present. Disconnects
the device from the network layer and frees all the resources
.TH "velocity_set_int_opt" 9 "velocity_set_int_opt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_set_int_opt \- 	parser for integer options
.SH SYNOPSIS
.B "void __devinit" velocity_set_int_opt
.BI "(int *" opt ","
.BI "int " val ","
.BI "int " min ","
.BI "int " max ","
.BI "int " def ","
.BI "char *" name ","
.BI "char *" devname ");"
.SH ARGUMENTS
.IP "opt" 12
 pointer to option value
.IP "val" 12
 value the user requested (or -1 for default)
.IP "min" 12
 lowest value allowed
.IP "max" 12
 highest value allowed
.IP "def" 12
 default value
.IP "name" 12
 property name
.IP "devname" 12
-- undescribed --
.SH "DESCRIPTION"
Set an integer property in the module options. This function does
all the verification and checking as well as reporting so that
we don't duplicate code for each option.
.TH "velocity_set_bool_opt" 9 "velocity_set_bool_opt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_set_bool_opt \- 	parser for boolean options
.SH SYNOPSIS
.B "void __devinit" velocity_set_bool_opt
.BI "(u32 *" opt ","
.BI "int " val ","
.BI "int " def ","
.BI "u32 " flag ","
.BI "char *" name ","
.BI "char *" devname ");"
.SH ARGUMENTS
.IP "opt" 12
 pointer to option value
.IP "val" 12
 value the user requested (or -1 for default)
.IP "def" 12
 default value (yes/no)
.IP "flag" 12
 numeric value to set for true.
.IP "name" 12
 property name
.IP "devname" 12
-- undescribed --
.SH "DESCRIPTION"
Set a boolean property in the module options. This function does
all the verification and checking as well as reporting so that
we don't duplicate code for each option.
.TH "velocity_get_options" 9 "velocity_get_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_get_options \- 	set options on device
.SH SYNOPSIS
.B "void __devinit" velocity_get_options
.BI "(struct velocity_opt *" opts ","
.BI "int " index ","
.BI "char *" devname ");"
.SH ARGUMENTS
.IP "opts" 12
 option structure for the device
.IP "index" 12
 index of option to use in module options array
.IP "devname" 12
 device name
.SH "DESCRIPTION"
Turn the module and command options into a single structure
for the current device
.TH "velocity_init_cam_filter" 9 "velocity_init_cam_filter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_init_cam_filter \- 	initialise CAM
.SH SYNOPSIS
.B "void" velocity_init_cam_filter
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to program
.SH "DESCRIPTION"
Initialize the content addressable memory used for filters. Load
appropriately according to the presence of VLAN
.TH "velocity_rx_reset" 9 "velocity_rx_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_rx_reset \- 	handle a receive reset
.SH SYNOPSIS
.B "void" velocity_rx_reset
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity we are resetting
.SH "DESCRIPTION"
Reset the ownership and status for the receive ring side.
Hand all the receive queue to the NIC.
.TH "velocity_init_registers" 9 "velocity_init_registers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_init_registers \- 	initialise MAC registers
.SH SYNOPSIS
.B "void" velocity_init_registers
.BI "(struct velocity_info *" vptr ","
.BI "enum velocity_init_type " type ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to init
.IP "type" 12
 type of initialisation (hot or cold)
.SH "DESCRIPTION"
Initialise the MAC on a reset or on first set up on the
hardware.
.TH "velocity_soft_reset" 9 "velocity_soft_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_soft_reset \- 	soft reset
.SH SYNOPSIS
.B "int" velocity_soft_reset
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to reset
.SH "DESCRIPTION"
Kick off a soft reset of the velocity adapter and then poll
until the reset sequence has completed before returning.
.TH "velocity_found1" 9 "velocity_found1" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_found1 \- 	set up discovered velocity card
.SH SYNOPSIS
.B "int __devinit" velocity_found1
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" ent ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device
.IP "ent" 12
 PCI device table entry that matched
.SH "DESCRIPTION"
Configure a discovered adapter from scratch. Return a negative
errno error code on failure paths.
.TH "velocity_print_info" 9 "velocity_print_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_print_info \- 	per driver data
.SH SYNOPSIS
.B "void __devinit" velocity_print_info
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity
.SH "DESCRIPTION"
Print per driver data as the kernel driver finds Velocity
hardware
.TH "velocity_init_info" 9 "velocity_init_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_init_info \- 	init private data
.SH SYNOPSIS
.B "void __devinit" velocity_init_info
.BI "(struct pci_dev *" pdev ","
.BI "struct velocity_info *" vptr ","
.BI "struct velocity_info_tbl *" info ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device
.IP "vptr" 12
 Velocity info
.IP "info" 12
 Board type
.SH "DESCRIPTION"
Set up the initial velocity_info struct for the device that has been
discovered.
.TH "velocity_get_pci_info" 9 "velocity_get_pci_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_get_pci_info \- 	retrieve PCI info for device
.SH SYNOPSIS
.B "int __devinit" velocity_get_pci_info
.BI "(struct velocity_info *" vptr ","
.BI "struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity device
.IP "pdev" 12
 PCI device it matches
.SH "DESCRIPTION"
Retrieve the PCI configuration space data that interests us from
the kernel PCI layer
.TH "velocity_init_rings" 9 "velocity_init_rings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_init_rings \- 	set up DMA rings
.SH SYNOPSIS
.B "int" velocity_init_rings
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 Velocity to set up
.SH "DESCRIPTION"
Allocate PCI mapped DMA rings for the receive and transmit layer
to use.
.TH "velocity_free_rings" 9 "velocity_free_rings" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_free_rings \- 	free PCI ring pointers
.SH SYNOPSIS
.B "void" velocity_free_rings
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 Velocity to free from
.SH "DESCRIPTION"
Clean up the PCI ring buffers allocated to this velocity.
.TH "velocity_init_rd_ring" 9 "velocity_init_rd_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_init_rd_ring \- 	set up receive ring
.SH SYNOPSIS
.B "int" velocity_init_rd_ring
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to configure
.SH "DESCRIPTION"
Allocate and set up the receive buffers for each ring slot and
assign them to the network adapter.
.TH "velocity_free_rd_ring" 9 "velocity_free_rd_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_free_rd_ring \- 	free receive ring
.SH SYNOPSIS
.B "void" velocity_free_rd_ring
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to clean up
.SH "DESCRIPTION"
Free the receive buffers for each ring slot and any
attached socket buffers that need to go away.
.TH "velocity_init_td_ring" 9 "velocity_init_td_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_init_td_ring \- 	set up transmit ring
.SH SYNOPSIS
.B "int" velocity_init_td_ring
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
	velocity
.SH "DESCRIPTION"
Set up the transmit ring and chain the ring pointers together.
Returns zero on success or a negative posix errno code for
failure.
.TH "velocity_free_td_ring" 9 "velocity_free_td_ring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_free_td_ring \- 	free td ring
.SH SYNOPSIS
.B "void" velocity_free_td_ring
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity
.SH "DESCRIPTION"
Free up the transmit ring for this particular velocity adapter.
We free the ring contents but not the ring itself.
.TH "velocity_rx_srv" 9 "velocity_rx_srv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_rx_srv \- 	service RX interrupt
.SH SYNOPSIS
.B "int" velocity_rx_srv
.BI "(struct velocity_info *" vptr ","
.BI "int " status ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity
.IP "status" 12
 adapter status (unused)
.SH "DESCRIPTION"
Walk the receive ring of the velocity adapter and remove
any received packets from the receive queue. Hand the ring
slots back to the adapter for reuse.
.TH "velocity_rx_csum" 9 "velocity_rx_csum" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_rx_csum \- 	checksum process
.SH SYNOPSIS
.B "void" velocity_rx_csum
.BI "(struct rx_desc *" rd ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "rd" 12
 receive packet descriptor
.IP "skb" 12
 network layer packet buffer
.SH "DESCRIPTION"
Process the status bits for the received packet and determine
if the checksum was computed and verified by the hardware
.TH "velocity_rx_copy" 9 "velocity_rx_copy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_rx_copy \- 	in place Rx copy for small packets
.SH SYNOPSIS
.B "int" velocity_rx_copy
.BI "(struct sk_buff **" rx_skb ","
.BI "int " pkt_size ","
.BI "struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "rx_skb" 12
 network layer packet buffer candidate
.IP "pkt_size" 12
 received data size
.IP "vptr" 12
-- undescribed --
.SH "DESCRIPTION"
Replace the current skb that is scheduled for Rx processing by a
shorter, immediatly allocated skb, if the received packet is small
enough. This function returns a negative value if the received
packet is too big or if memory is exhausted.
.TH "velocity_iph_realign" 9 "velocity_iph_realign" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_iph_realign \- 	IP header alignment
.SH SYNOPSIS
.B "void" velocity_iph_realign
.BI "(struct velocity_info *" vptr ","
.BI "struct sk_buff *" skb ","
.BI "int " pkt_size ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity we are handling
.IP "skb" 12
 network layer packet buffer
.IP "pkt_size" 12
 received data size
.SH "DESCRIPTION"
Align IP header on a 2 bytes boundary. This behavior can be
configured by the user.
.TH "velocity_receive_frame" 9 "velocity_receive_frame" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_receive_frame \- 	received packet processor
.SH SYNOPSIS
.B "int" velocity_receive_frame
.BI "(struct velocity_info *" vptr ","
.BI "int " idx ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity we are handling
.IP "idx" 12
 ring index
.SH "DESCRIPTION"
A packet has arrived. We process the packet and if appropriate
pass the frame up the network stack
.TH "velocity_alloc_rx_buf" 9 "velocity_alloc_rx_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_alloc_rx_buf \- 	allocate aligned receive buffer
.SH SYNOPSIS
.B "int" velocity_alloc_rx_buf
.BI "(struct velocity_info *" vptr ","
.BI "int " idx ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity
.IP "idx" 12
 ring index
.SH "DESCRIPTION"
Allocate a new full sized buffer for the reception of a frame and
map it into PCI space for the hardware to use. The hardware
requires *64* byte alignment of the buffer which makes life
less fun than would be ideal.
.TH "velocity_tx_srv" 9 "velocity_tx_srv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_tx_srv \- 	transmit interrupt service
.SH SYNOPSIS
.B "int" velocity_tx_srv
.BI "(struct velocity_info *" vptr ","
.BI "u32 " status ");"
.SH ARGUMENTS
.IP "vptr" 12
-- undescribed --
.IP "status" 12
.SH "DESCRIPTION"
Scan the queues looking for transmitted packets that
we can complete and clean up. Update any statistics as
neccessary/
.SH "DESCRIPTION"
Scan the queues looking for transmitted packets that
we can complete and clean up. Update any statistics as
neccessary/
.TH "velocity_print_link_status" 9 "velocity_print_link_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_print_link_status \- 	link status reporting
.SH SYNOPSIS
.B "void" velocity_print_link_status
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to report on
.SH "DESCRIPTION"
Turn the link status of the velocity card into a kernel log
description of the new link state, detailing speed and duplex
status
.TH "velocity_error" 9 "velocity_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_error \- 	handle error from controller
.SH SYNOPSIS
.B "void" velocity_error
.BI "(struct velocity_info *" vptr ","
.BI "int " status ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity
.IP "status" 12
 card status
.SH "DESCRIPTION"
Process an error report from the hardware and attempt to recover
the card itself. At the moment we cannot recover from some 
theoretically impossible errors but this could be fixed using
the pci_device_failed logic to bounce the hardware
.TH "velocity_free_tx_buf" 9 "velocity_free_tx_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_free_tx_buf \- 	free transmit buffer
.SH SYNOPSIS
.B "void" velocity_free_tx_buf
.BI "(struct velocity_info *" vptr ","
.BI "struct velocity_td_info *" tdinfo ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity
.IP "tdinfo" 12
 buffer
.SH "DESCRIPTION"
Release an transmit buffer. If the buffer was preallocated then
recycle it, if not then unmap the buffer.
.TH "velocity_open" 9 "velocity_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_open \- 	interface activation callback
.SH SYNOPSIS
.B "int" velocity_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network layer device to open
.SH "DESCRIPTION"
Called when the network layer brings the interface up. Returns
a negative posix error code on failure, or zero on success.

All the ring allocation and set up is done on open for this
adapter to minimise memory usage when inactive
.TH "velocity_change_mtu" 9 "velocity_change_mtu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_change_mtu \- 	MTU change callback
.SH SYNOPSIS
.B "int" velocity_change_mtu
.BI "(struct net_device *" dev ","
.BI "int " new_mtu ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.IP "new_mtu" 12
 desired MTU
.SH "DESCRIPTION"
Handle requests from the networking layer for MTU change on
this interface. It gets called on a change by the network layer.
Return zero for success or negative posix error code.
.TH "velocity_shutdown" 9 "velocity_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_shutdown \- 	shut down the chip
.SH SYNOPSIS
.B "void" velocity_shutdown
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to deactivate
.SH "DESCRIPTION"
Shuts down the internal operations of the velocity and
disables interrupts, autopolling, transmit and receive
.TH "velocity_close" 9 "velocity_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_close \- 	close adapter callback
.SH SYNOPSIS
.B "int" velocity_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.SH "DESCRIPTION"
Callback from the network layer when the velocity is being
deactivated by the network layer
.TH "velocity_xmit" 9 "velocity_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_xmit \- 	transmit packet callback
.SH SYNOPSIS
.B "int" velocity_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to transmit
.IP "dev" 12
 network device
.SH "DESCRIPTION"
Called by the networ layer to request a packet is queued to
the velocity. Returns zero on success.
.TH "velocity_intr" 9 "velocity_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_intr \- 	interrupt callback
.SH SYNOPSIS
.B "int" velocity_intr
.BI "(int " irq ","
.BI "void *" dev_instance ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt number
.IP "dev_instance" 12
 interrupting device
.IP "regs" 12
-- undescribed --
.SH "DESCRIPTION"
Called whenever an interrupt is generated by the velocity
adapter IRQ line. We may not be the source of the interrupt
and need to identify initially if we are, and if not exit as
efficiently as possible.
.TH "velocity_set_multi" 9 "velocity_set_multi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_set_multi \- 	filter list change callback
.SH SYNOPSIS
.B "void" velocity_set_multi
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.SH "DESCRIPTION"
Called by the network layer when the filter lists need to change
for a velocity adapter. Reload the CAMs with the new address
filter ruleset.
.TH "velocity_get_stats" 9 "velocity_get_stats" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_get_stats \- 	statistics callback
.SH SYNOPSIS
.B "struct net_device_stats *" velocity_get_stats
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.SH "DESCRIPTION"
Callback from the network layer to allow driver statistics
to be resynchronized with hardware collected state. In the
case of the velocity we need to pull the MIB counters from
the hardware into the counters before letting the network
layer display them.
.TH "velocity_ioctl" 9 "velocity_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_ioctl \- 	ioctl entry point
.SH SYNOPSIS
.B "int" velocity_ioctl
.BI "(struct net_device *" dev ","
.BI "struct ifreq *" rq ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.IP "rq" 12
 interface request ioctl
.IP "cmd" 12
 command code
.SH "DESCRIPTION"
Called when the user issues an ioctl request to the network
device in question. The velocity interface supports MII.
.TH "velocity_init_module" 9 "velocity_init_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_init_module \- 	load time function
.SH SYNOPSIS
.B "int __init" velocity_init_module
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Called when the velocity module is loaded. The PCI driver
is registered with the PCI layer, and in turn will call
the probe functions for each velocity adapter installed
in the system.
.TH "velocity_cleanup_module" 9 "velocity_cleanup_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_cleanup_module \- 	module unload
.SH SYNOPSIS
.B "void __exit" velocity_cleanup_module
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

When the velocity hardware is unloaded this function is called.
It will clean up the notifiers and the unregister the PCI 
driver interface for this hardware. This in turn cleans up
all discovered interfaces before returning from the function
.TH "mii_init" 9 "mii_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mii_init \- 	set up MII
.SH SYNOPSIS
.B "void" mii_init
.BI "(struct velocity_info *" vptr ","
.BI "u32 " mii_status ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity adapter
.IP "mii_status" 12
  links tatus
.SH "DESCRIPTION"
Set up the PHY for the current link state.
.TH "safe_disable_mii_autopoll" 9 "safe_disable_mii_autopoll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
safe_disable_mii_autopoll \- 	autopoll off
.SH SYNOPSIS
.B "void" safe_disable_mii_autopoll
.BI "(struct mac_regs __iomem *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 velocity registers
.SH "DESCRIPTION"
Turn off the autopoll and wait for it to disable on the chip
.TH "enable_mii_autopoll" 9 "enable_mii_autopoll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_mii_autopoll \- 	turn on autopolling
.SH SYNOPSIS
.B "void" enable_mii_autopoll
.BI "(struct mac_regs __iomem *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 velocity registers
.SH "DESCRIPTION"
Enable the MII link status autopoll feature on the Velocity
hardware. Wait for it to enable.
.TH "velocity_mii_read" 9 "velocity_mii_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_mii_read \- 	read MII data
.SH SYNOPSIS
.B "int" velocity_mii_read
.BI "(struct mac_regs __iomem *" regs ","
.BI "u8 " index ","
.BI "u16 *" data ");"
.SH ARGUMENTS
.IP "regs" 12
 velocity registers
.IP "index" 12
 MII register index
.IP "data" 12
 buffer for received data
.SH "DESCRIPTION"
Perform a single read of an MII 16bit register. Returns zero
on success or -ETIMEDOUT if the PHY did not respond.
.TH "velocity_mii_write" 9 "velocity_mii_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_mii_write \- 	write MII data
.SH SYNOPSIS
.B "int" velocity_mii_write
.BI "(struct mac_regs __iomem *" regs ","
.BI "u8 " mii_addr ","
.BI "u16 " data ");"
.SH ARGUMENTS
.IP "regs" 12
 velocity registers
.IP "mii_addr" 12
-- undescribed --
.IP "data" 12
 16bit data for the MII register
.SH "DESCRIPTION"
Perform a single write to an MII 16bit register. Returns zero
on success or -ETIMEDOUT if the PHY did not respond.
.TH "velocity_get_opt_media_mode" 9 "velocity_get_opt_media_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_get_opt_media_mode \- 	get media selection
.SH SYNOPSIS
.B "u32" velocity_get_opt_media_mode
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity adapter
.SH "DESCRIPTION"
Get the media mode stored in EEPROM or module options and load
mii_status accordingly. The requested link state information
is also returned.
.TH "mii_set_auto_on" 9 "mii_set_auto_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mii_set_auto_on \- 	autonegotiate on
.SH SYNOPSIS
.B "void" mii_set_auto_on
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity
.SH "DESCRIPTION"
Enable autonegotation on this interface
.TH "set_mii_flow_control" 9 "set_mii_flow_control" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_mii_flow_control \- 	flow control setup
.SH SYNOPSIS
.B "void" set_mii_flow_control
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity interface
.SH "DESCRIPTION"
Set up the flow control on this interface according to
the supplied user/eeprom options.
.TH "velocity_set_media_mode" 9 "velocity_set_media_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_set_media_mode \- 	set media mode
.SH SYNOPSIS
.B "int" velocity_set_media_mode
.BI "(struct velocity_info *" vptr ","
.BI "u32 " mii_status ");"
.SH ARGUMENTS
.IP "vptr" 12
-- undescribed --
.IP "mii_status" 12
 old MII link state
.SH "DESCRIPTION"
Check the media link state and configure the flow control
PHY and also velocity hardware setup accordingly. In particular
we need to set up CD polling and frame bursting.
.TH "mii_check_media_mode" 9 "mii_check_media_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mii_check_media_mode \- 	check media state
.SH SYNOPSIS
.B "u32" mii_check_media_mode
.BI "(struct mac_regs __iomem *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 velocity registers
.SH "DESCRIPTION"
Check the current MII status and determine the link status
accordingly
.TH "enable_flow_control_ability" 9 "enable_flow_control_ability" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_flow_control_ability \- 	flow control
.SH SYNOPSIS
.B "void" enable_flow_control_ability
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 veloity to configure
.SH "DESCRIPTION"
Set up flow control according to the flow control options
determined by the eeprom/configuration.
.TH "velocity_ethtool_up" 9 "velocity_ethtool_up" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_ethtool_up \- 	pre hook for ethtool
.SH SYNOPSIS
.B "int" velocity_ethtool_up
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.SH "DESCRIPTION"
Called before an ethtool operation. We need to make sure the
chip is out of D3 state before we poke at it.
.TH "velocity_ethtool_down" 9 "velocity_ethtool_down" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_ethtool_down \- 	post hook for ethtool
.SH SYNOPSIS
.B "void" velocity_ethtool_down
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.SH "DESCRIPTION"
Called after an ethtool operation. Restore the chip back to D3
state if it isn't running.
.TH "velocity_mii_ioctl" 9 "velocity_mii_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_mii_ioctl \- 	MII ioctl handler
.SH SYNOPSIS
.B "int" velocity_mii_ioctl
.BI "(struct net_device *" dev ","
.BI "struct ifreq *" ifr ","
.BI "int " cmd ");"
.SH ARGUMENTS
.IP "dev" 12
 network device
.IP "ifr" 12
 the ifreq block for the ioctl
.IP "cmd" 12
 the command
.SH "DESCRIPTION"
Process MII requests made via ioctl from the network layer. These
are used by tools like kudzu to interrogate the link state of the
hardware
.TH "velocity_save_context" 9 "velocity_save_context" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_save_context \- 	save registers
.SH SYNOPSIS
.B "void" velocity_save_context
.BI "(struct velocity_info *" vptr ","
.BI "struct velocity_context *" context ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity 
.IP "context" 12
 buffer for stored context
.SH "DESCRIPTION"
Retrieve the current configuration from the velocity hardware
and stash it in the context structure, for use by the context
restore functions. This allows us to save things we need across
power down states
.TH "velocity_restore_context" 9 "velocity_restore_context" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_restore_context \- 	restore registers
.SH SYNOPSIS
.B "void" velocity_restore_context
.BI "(struct velocity_info *" vptr ","
.BI "struct velocity_context *" context ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity 
.IP "context" 12
 buffer for stored context
.SH "DESCRIPTION"
Reload the register configuration from the velocity context 
created by velocity_save_context.
.TH "wol_calc_crc" 9 "wol_calc_crc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wol_calc_crc \- 	WOL CRC
.SH SYNOPSIS
.B "u16" wol_calc_crc
.BI "(int " size ","
.BI "u8 *" pattern ","
.BI "u8 *" mask_pattern ");"
.SH ARGUMENTS
.IP "size" 12
-- undescribed --
.IP "pattern" 12
 data pattern
.IP "mask_pattern" 12
 mask
.SH "DESCRIPTION"
Compute the wake on lan crc hashes for the packet header
we are interested in.
.TH "velocity_set_wol" 9 "velocity_set_wol" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
velocity_set_wol \- 	set up for wake on lan
.SH SYNOPSIS
.B "int" velocity_set_wol
.BI "(struct velocity_info *" vptr ");"
.SH ARGUMENTS
.IP "vptr" 12
 velocity to set WOL status on
.SH "DESCRIPTION"
Set a card up for wake on lan either by unicast or by
ARP packet.
.SH "FIXME"
 check static buffer is safe here
.TH "e1000_check_options" 9 "e1000_check_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
e1000_check_options \-  Range Checking for Command Line Parameters
.SH SYNOPSIS
.B "void __devinit" e1000_check_options
.BI "(struct e1000_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
This routine checks all command line parameters for valid user
input.  If an invalid value is given, or if no user specified
value exists, a default value is used.  The final value is stored
in a variable in the adapter structure.
.TH "e1000_check_fiber_options" 9 "e1000_check_fiber_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
e1000_check_fiber_options \-  Range Checking for Link Options, Fiber Version
.SH SYNOPSIS
.B "void __devinit" e1000_check_fiber_options
.BI "(struct e1000_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Handles speed and duplex options on fiber adapters
.TH "e1000_check_copper_options" 9 "e1000_check_copper_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
e1000_check_copper_options \-  Range Checking for Link Options, Copper Version
.SH SYNOPSIS
.B "void __devinit" e1000_check_copper_options
.BI "(struct e1000_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 board private structure
.SH "DESCRIPTION"
Handles speed and duplex options on copper adapters
.TH "alb_change_hw_addr_on_detach" 9 "alb_change_hw_addr_on_detach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alb_change_hw_addr_on_detach \- 
.SH SYNOPSIS
.B "void" alb_change_hw_addr_on_detach
.BI "(struct bonding *" bond ","
.BI "struct slave *" slave ");"
.SH ARGUMENTS
.IP "bond" 12
 bonding we're working on
.IP "slave" 12
 the slave that was just detached
.SH "DESCRIPTION"
We assume that \fIslave\fP was already detached from the slave list.

If \fIslave\fP's permanent hw address is different both from its current
address and from \fIbond\fP's address, then somewhere in the bond there's
a slave that has \fIslave\fP's permanet address as its current address.
We'll make sure that that slave no longer uses \fIslave\fP's permanent address.

Caller must hold bond lock
.TH "alb_handle_addr_collision_on_attach" 9 "alb_handle_addr_collision_on_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alb_handle_addr_collision_on_attach \- 
.SH SYNOPSIS
.B "int" alb_handle_addr_collision_on_attach
.BI "(struct bonding *" bond ","
.BI "struct slave *" slave ");"
.SH ARGUMENTS
.IP "bond" 12
 bonding we're working on
.IP "slave" 12
 the slave that was just attached
.SH "DESCRIPTION"
checks uniqueness of slave's mac address and handles the case the
new slave uses the bonds mac address.

If the permanent hw address of \fIslave\fP is \fIbond\fP's hw address, we need to
find a different hw address to give \fIslave\fP, that isn't in use by any other
slave in the bond. This address must be, of course, one of the premanent
addresses of the other slaves.

We go over the slave list, and for each slave there we compare its
permanent hw address with the current address of all the other slaves.
If no match was found, then we've found a slave with a permanent address
that isn't used by any other slave in the bond, so we can assign it to
\fIslave\fP.
.SH "ASSUMPTION"
 this function is called before \fIslave\fP is attached to the
bond slave list.

caller must hold the bond lock for write since the mac addresses are compared
and may be swapped.
.TH "alb_set_mac_address" 9 "alb_set_mac_address" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alb_set_mac_address \- 
.SH SYNOPSIS
.B "int" alb_set_mac_address
.BI "(struct bonding *" bond ","
.BI "void *" addr ");"
.SH ARGUMENTS
.IP "bond" 12
-- undescribed --
.IP "addr" 12
.SH "DESCRIPTION"
In TLB mode all slaves are configured to the bond's hw address, but set
their dev_addr field to different addresses (based on their permanent hw
addresses).

For each slave, this function sets the interface to the new address and then
changes its dev_addr field to its previous value.

Unwinding assumes bond's mac address has not yet changed.
.TH "bond_alb_handle_active_change" 9 "bond_alb_handle_active_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_alb_handle_active_change \-  assign new curr_active_slave
.SH SYNOPSIS
.B "void" bond_alb_handle_active_change
.BI "(struct bonding *" bond ","
.BI "struct slave *" new_slave ");"
.SH ARGUMENTS
.IP "bond" 12
 our bonding struct
.IP "new_slave" 12
 new slave to assign
.SH "DESCRIPTION"
Set the bond-&gt;curr_active_slave to \fInew_slave\fP and handle
mac address swapping and promiscuity changes as needed.

Caller must hold bond curr_slave_lock for write (or bond lock for write)
.TH "__get_bond_by_port" 9 "__get_bond_by_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_bond_by_port \-  get the port's bonding struct
.SH SYNOPSIS
.B "struct bonding *" __get_bond_by_port
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Return \fIport\fP's bonding struct, or NULL if it can't be found.
.TH "__get_first_port" 9 "__get_first_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_first_port \-  get the first port in the bond
.SH SYNOPSIS
.B "struct port *" __get_first_port
.BI "(struct bonding *" bond ");"
.SH ARGUMENTS
.IP "bond" 12
 the bond we're looking at
.SH "DESCRIPTION"
Return the port of the first slave in \fIbond\fP, or NULL if it can't be found.
.TH "__get_next_port" 9 "__get_next_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_next_port \-  get the next port in the bond
.SH SYNOPSIS
.B "struct port *" __get_next_port
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Return the port of the slave that is next in line of \fIport\fP's slave in the
bond, or NULL if it can't be found.
.TH "__get_first_agg" 9 "__get_first_agg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_first_agg \-  get the first aggregator in the bond
.SH SYNOPSIS
.B "struct aggregator *" __get_first_agg
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
-- undescribed --
.SH "DESCRIPTION"
Return the aggregator of the first slave in \fIbond\fP, or NULL if it can't be
found.
.TH "__get_next_agg" 9 "__get_next_agg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_next_agg \-  get the next aggregator in the bond
.SH SYNOPSIS
.B "struct aggregator *" __get_next_agg
.BI "(struct aggregator *" aggregator ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.SH "DESCRIPTION"
Return the aggregator of the slave that is next in line of \fIaggregator\fP's
slave in the bond, or NULL if it can't be found.
.TH "__disable_port" 9 "__disable_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__disable_port \-  disable the port's slave
.SH SYNOPSIS
.B "void" __disable_port
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "__enable_port" 9 "__enable_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__enable_port \-  enable the port's slave, if it's up
.SH SYNOPSIS
.B "void" __enable_port
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "__port_is_enabled" 9 "__port_is_enabled" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__port_is_enabled \-  check if the port's slave is in active state
.SH SYNOPSIS
.B "int" __port_is_enabled
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "__get_agg_selection_mode" 9 "__get_agg_selection_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_agg_selection_mode \-  get the aggregator selection mode
.SH SYNOPSIS
.B "u32" __get_agg_selection_mode
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Get the aggregator selection mode. Can be BANDWIDTH or COUNT.
.TH "__check_agg_selection_timer" 9 "__check_agg_selection_timer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__check_agg_selection_timer \-  check if the selection timer has expired
.SH SYNOPSIS
.B "int" __check_agg_selection_timer
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "__get_rx_machine_lock" 9 "__get_rx_machine_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_rx_machine_lock \-  lock the port's RX machine
.SH SYNOPSIS
.B "void" __get_rx_machine_lock
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "__release_rx_machine_lock" 9 "__release_rx_machine_lock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__release_rx_machine_lock \-  unlock the port's RX machine
.SH SYNOPSIS
.B "void" __release_rx_machine_lock
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "__get_link_speed" 9 "__get_link_speed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_link_speed \-  get a port's speed
.SH SYNOPSIS
.B "u16" __get_link_speed
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Return \fIport\fP's speed in 802.3ad bitmask format. i.e. one of:
0,
AD_LINK_SPEED_BITMASK_10MBPS,
AD_LINK_SPEED_BITMASK_100MBPS,
AD_LINK_SPEED_BITMASK_1000MBPS
.TH "__get_duplex" 9 "__get_duplex" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_duplex \-  get a port's duplex
.SH SYNOPSIS
.B "u8" __get_duplex
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Return \fIport\fP's duplex in 802.3ad bitmask format. i.e.:
0x01 if in full duplex
0x00 otherwise
.TH "__initialize_port_locks" 9 "__initialize_port_locks" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__initialize_port_locks \-  initialize a port's RX machine spinlock
.SH SYNOPSIS
.B "void" __initialize_port_locks
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "__ntohs_lacpdu" 9 "__ntohs_lacpdu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ntohs_lacpdu \-  convert the contents of a LACPDU to host byte order
.SH SYNOPSIS
.B "void" __ntohs_lacpdu
.BI "(struct lacpdu *" lacpdu ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 the speicifed lacpdu
.SH "DESCRIPTION"
For each multi-byte field in the lacpdu, convert its content
.TH "__ad_timer_to_ticks" 9 "__ad_timer_to_ticks" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__ad_timer_to_ticks \-  convert a given timer type to AD module ticks
.SH SYNOPSIS
.B "u16" __ad_timer_to_ticks
.BI "(u16 " timer_type ","
.BI "u16 " par ");"
.SH ARGUMENTS
.IP "timer_type" 12
	which timer to operate
.IP "par" 12
 timer parameter. see below
.SH "DESCRIPTION"
If \fItimer_type\fP is current_while_timer, \fIpar\fP indicates long/short timer.
If \fItimer_type\fP is periodic_timer, \fIpar\fP is one of FAST_PERIODIC_TIME,
SLOW_PERIODIC_TIME.
.TH "__record_pdu" 9 "__record_pdu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__record_pdu \-  record parameters from a received lacpdu
.SH SYNOPSIS
.B "void" __record_pdu
.BI "(struct lacpdu *" lacpdu ","
.BI "struct port *" port ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 the lacpdu we've received
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Record the parameter values for the Actor carried in a received lacpdu as
the current partner operational parameter values and sets
actor_oper_port_state.defaulted to FALSE.
.TH "__record_default" 9 "__record_default" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__record_default \-  record default parameters
.SH SYNOPSIS
.B "void" __record_default
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
This function records the default parameter values for the partner carried
in the Partner Admin parameters as the current partner operational parameter
values and sets actor_oper_port_state.defaulted to TRUE.
.TH "__update_selected" 9 "__update_selected" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__update_selected \-  update a port's Selected variable from a received lacpdu
.SH SYNOPSIS
.B "void" __update_selected
.BI "(struct lacpdu *" lacpdu ","
.BI "struct port *" port ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 the lacpdu we've received
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Update the value of the selected variable, using parameter values from a
newly received lacpdu. The parameter values for the Actor carried in the
received PDU are compared with the corresponding operational parameter
values for the ports partner. If one or more of the comparisons shows that
the value(s) received in the PDU differ from the current operational values,
then selected is set to FALSE and actor_oper_port_state.synchronization is
set to out_of_sync. Otherwise, selected remains unchanged.
.TH "__update_default_selected" 9 "__update_default_selected" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__update_default_selected \-  update a port's Selected variable from Partner
.SH SYNOPSIS
.B "void" __update_default_selected
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
This function updates the value of the selected variable, using the partner
administrative parameter values. The administrative values are compared with
the corresponding operational parameter values for the partner. If one or
more of the comparisons shows that the administrative value(s) differ from
the current operational values, then Selected is set to FALSE and
actor_oper_port_state.synchronization is set to OUT_OF_SYNC. Otherwise,
Selected remains unchanged.
.TH "__choose_matched" 9 "__choose_matched" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__choose_matched \-  update a port's matched variable from a received lacpdu
.SH SYNOPSIS
.B "void" __choose_matched
.BI "(struct lacpdu *" lacpdu ","
.BI "struct port *" port ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 the lacpdu we've received
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Update the value of the matched variable, using parameter values from a
newly received lacpdu. Parameter values for the partner carried in the
received PDU are compared with the corresponding operational parameter
values for the actor. Matched is set to TRUE if all of these parameters
match and the PDU parameter partner_state.aggregation has the same value as
actor_oper_port_state.aggregation and lacp will actively maintain the link
in the aggregation. Matched is also set to TRUE if the value of
actor_state.aggregation in the received PDU is set to FALSE, i.e., indicates
an individual link and lacp will actively maintain the link. Otherwise,
matched is set to FALSE. LACP is considered to be actively maintaining the
link if either the PDU's actor_state.lacp_activity variable is TRUE or both
the actor's actor_oper_port_state.lacp_activity and the PDU's
partner_state.lacp_activity variables are TRUE.
.TH "__update_ntt" 9 "__update_ntt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__update_ntt \-  update a port's ntt variable from a received lacpdu
.SH SYNOPSIS
.B "void" __update_ntt
.BI "(struct lacpdu *" lacpdu ","
.BI "struct port *" port ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 the lacpdu we've received
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Updates the value of the ntt variable, using parameter values from a newly
received lacpdu. The parameter values for the partner carried in the
received PDU are compared with the corresponding operational parameter
values for the Actor. If one or more of the comparisons shows that the
value(s) received in the PDU differ from the current operational values,
then ntt is set to TRUE. Otherwise, ntt remains unchanged.
.TH "__attach_bond_to_agg" 9 "__attach_bond_to_agg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__attach_bond_to_agg \- 
.SH SYNOPSIS
.B "void" __attach_bond_to_agg
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Handle the attaching of the port's control parser/multiplexer and the
aggregator. This function does nothing since the parser/multiplexer of the
receive and the parser/multiplexer of the aggregator are already combined.
.TH "__detach_bond_from_agg" 9 "__detach_bond_from_agg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__detach_bond_from_agg \- 
.SH SYNOPSIS
.B "void" __detach_bond_from_agg
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Handle the detaching of the port's control parser/multiplexer from the
aggregator. This function does nothing since the parser/multiplexer of the
receive and the parser/multiplexer of the aggregator are already combined.
.TH "__agg_ports_are_ready" 9 "__agg_ports_are_ready" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__agg_ports_are_ready \-  check if all ports in an aggregator are ready
.SH SYNOPSIS
.B "int" __agg_ports_are_ready
.BI "(struct aggregator *" aggregator ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.TH "__set_agg_ports_ready" 9 "__set_agg_ports_ready" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__set_agg_ports_ready \-  set value of Ready bit in all ports of an aggregator
.SH SYNOPSIS
.B "void" __set_agg_ports_ready
.BI "(struct aggregator *" aggregator ","
.BI "int " val ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.IP "val" 12
 Should the ports' ready bit be set on or off
.TH "__get_agg_bandwidth" 9 "__get_agg_bandwidth" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_agg_bandwidth \-  get the total bandwidth of an aggregator
.SH SYNOPSIS
.B "u32" __get_agg_bandwidth
.BI "(struct aggregator *" aggregator ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.TH "__get_active_agg" 9 "__get_active_agg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__get_active_agg \-  get the current active aggregator
.SH SYNOPSIS
.B "struct aggregator *" __get_active_agg
.BI "(struct aggregator *" aggregator ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.TH "__update_lacpdu_from_port" 9 "__update_lacpdu_from_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__update_lacpdu_from_port \-  update a port's lacpdu fields
.SH SYNOPSIS
.B "void" __update_lacpdu_from_port
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "ad_lacpdu_send" 9 "ad_lacpdu_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_lacpdu_send \-  send out a lacpdu packet on a given port
.SH SYNOPSIS
.B "int" ad_lacpdu_send
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "RETURNS"
   0 on success
&lt; 0 on error
.TH "ad_marker_send" 9 "ad_marker_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_marker_send \-  send marker information/response on a given port
.SH SYNOPSIS
.B "int" ad_marker_send
.BI "(struct port *" port ","
.BI "struct marker *" marker ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.IP "marker" 12
 marker data to send
.SH "RETURNS"
   0 on success
&lt; 0 on error
.TH "ad_mux_machine" 9 "ad_mux_machine" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_mux_machine \-  handle a port's mux state machine
.SH SYNOPSIS
.B "void" ad_mux_machine
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "ad_rx_machine" 9 "ad_rx_machine" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_rx_machine \-  handle a port's rx State Machine
.SH SYNOPSIS
.B "void" ad_rx_machine
.BI "(struct lacpdu *" lacpdu ","
.BI "struct port *" port ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 the lacpdu we've received
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
If lacpdu arrived, stop previous timer (if exists) and set the next state as
CURRENT. If timer expired set the state machine in the proper state.
In other cases, this function checks if we need to switch to other state.
.TH "ad_tx_machine" 9 "ad_tx_machine" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_tx_machine \-  handle a port's tx state machine
.SH SYNOPSIS
.B "void" ad_tx_machine
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "ad_periodic_machine" 9 "ad_periodic_machine" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_periodic_machine \-  handle a port's periodic state machine
.SH SYNOPSIS
.B "void" ad_periodic_machine
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Turn ntt flag on priodically to perform periodic transmission of lacpdu's.
.TH "ad_port_selection_logic" 9 "ad_port_selection_logic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_port_selection_logic \-  select aggregation groups
.SH SYNOPSIS
.B "void" ad_port_selection_logic
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Select aggregation groups, and assign each port for it's aggregetor. The
selection logic is called in the inititalization (after all the handshkes),
and after every lacpdu receive (if selected is off).
.TH "ad_agg_selection_logic" 9 "ad_agg_selection_logic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_agg_selection_logic \-  select an aggregation group for a team
.SH SYNOPSIS
.B "void" ad_agg_selection_logic
.BI "(struct aggregator *" aggregator ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.SH "DESCRIPTION"
It is assumed that only one aggregator may be selected for a team.
The logic of this function is to select (at first time) the aggregator with
the most ports attached to it, and to reselect the active aggregator only if
the previous aggregator has no more ports related to it.
.SH "FIXME"
 this function MUST be called with the first agg in the bond, or
\fB__get_active_agg\fP won't work correctly. This function should be better
called with the bond itself, and retrieve the first agg from it.
.TH "ad_clear_agg" 9 "ad_clear_agg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_clear_agg \-  clear a given aggregator's parameters
.SH SYNOPSIS
.B "void" ad_clear_agg
.BI "(struct aggregator *" aggregator ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.TH "ad_initialize_agg" 9 "ad_initialize_agg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_initialize_agg \-  initialize a given aggregator's parameters
.SH SYNOPSIS
.B "void" ad_initialize_agg
.BI "(struct aggregator *" aggregator ");"
.SH ARGUMENTS
.IP "aggregator" 12
 the aggregator we're looking at
.TH "ad_initialize_port" 9 "ad_initialize_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_initialize_port \-  initialize a given port's parameters
.SH SYNOPSIS
.B "void" ad_initialize_port
.BI "(struct port *" port ","
.BI "int " lacp_fast ");"
.SH ARGUMENTS
.IP "port" 12
-- undescribed --
.IP "lacp_fast" 12
 boolean. whether fast periodic should be used
.TH "ad_enable_collecting_distributing" 9 "ad_enable_collecting_distributing" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_enable_collecting_distributing \-  enable a port's transmit/receive
.SH SYNOPSIS
.B "void" ad_enable_collecting_distributing
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
Enable \fIport\fP if it's in an active aggregator
.TH "ad_disable_collecting_distributing" 9 "ad_disable_collecting_distributing" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_disable_collecting_distributing \-  disable a port's transmit/receive
.SH SYNOPSIS
.B "void" ad_disable_collecting_distributing
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.TH "ad_marker_info_send" 9 "ad_marker_info_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_marker_info_send \-  send a marker information frame
.SH SYNOPSIS
.B "void" ad_marker_info_send
.BI "(struct port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
This function does nothing since we decided not to implement send and handle
response for marker PDU's, in this stage, but only to respond to marker
information.
.TH "ad_marker_info_received" 9 "ad_marker_info_received" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_marker_info_received \-  handle receive of a Marker information frame
.SH SYNOPSIS
.B "void" ad_marker_info_received
.BI "(struct marker *" marker_info ","
.BI "struct port *" port ");"
.SH ARGUMENTS
.IP "marker_info" 12
 Marker info received
.IP "port" 12
 the port we're looking at
.TH "ad_marker_response_received" 9 "ad_marker_response_received" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_marker_response_received \-  handle receive of a marker response frame
.SH SYNOPSIS
.B "void" ad_marker_response_received
.BI "(struct marker *" marker ","
.BI "struct port *" port ");"
.SH ARGUMENTS
.IP "marker" 12
 marker PDU received
.IP "port" 12
 the port we're looking at
.SH "DESCRIPTION"
This function does nothing since we decided not to implement send and handle
response for marker PDU's, in this stage, but only to respond to marker
information.
.TH "ad_initialize_lacpdu" 9 "ad_initialize_lacpdu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad_initialize_lacpdu \-  initialize a given lacpdu structure
.SH SYNOPSIS
.B "void" ad_initialize_lacpdu
.BI "(struct lacpdu *" lacpdu ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 lacpdu structure to initialize
.TH "bond_3ad_initialize" 9 "bond_3ad_initialize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_initialize \-  initialize a bond's 802.3ad parameters and structures
.SH SYNOPSIS
.B "void" bond_3ad_initialize
.BI "(struct bonding *" bond ","
.BI "u16 " tick_resolution ","
.BI "int " lacp_fast ");"
.SH ARGUMENTS
.IP "bond" 12
 bonding struct to work on
.IP "tick_resolution" 12
 tick duration (millisecond resolution)
.IP "lacp_fast" 12
 boolean. whether fast periodic should be used
.SH "DESCRIPTION"
Can be called only after the mac address of the bond is set.
.TH "bond_3ad_bind_slave" 9 "bond_3ad_bind_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_bind_slave \-  initialize a slave's port
.SH SYNOPSIS
.B "int" bond_3ad_bind_slave
.BI "(struct slave *" slave ");"
.SH ARGUMENTS
.IP "slave" 12
 slave struct to work on
.SH "RETURNS"
   0 on success
&lt; 0 on error
.TH "bond_3ad_unbind_slave" 9 "bond_3ad_unbind_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_unbind_slave \-  deinitialize a slave's port
.SH SYNOPSIS
.B "void" bond_3ad_unbind_slave
.BI "(struct slave *" slave ");"
.SH ARGUMENTS
.IP "slave" 12
 slave struct to work on
.SH "DESCRIPTION"
Search for the aggregator that is related to this port, remove the
aggregator and assign another aggregator for other port related to it
(if any), and remove the port.
.TH "bond_3ad_state_machine_handler" 9 "bond_3ad_state_machine_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_state_machine_handler \-  handle state machines timeout
.SH SYNOPSIS
.B "void" bond_3ad_state_machine_handler
.BI "(struct bonding *" bond ");"
.SH ARGUMENTS
.IP "bond" 12
 bonding struct to work on
.SH "DESCRIPTION"
The state machine handling concept in this module is to check every tick
which state machine should operate any function. The execution order is
round robin, so when we have an interaction between state machines, the
reply of one to each other might be delayed until next tick.

This function also complete the initialization when the agg_select_timer
times out, and it selects an aggregator for the ports that are yet not
related to any aggregator, and selects the active aggregator for a bond.
.TH "bond_3ad_rx_indication" 9 "bond_3ad_rx_indication" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_rx_indication \-  handle a received frame
.SH SYNOPSIS
.B "void" bond_3ad_rx_indication
.BI "(struct lacpdu *" lacpdu ","
.BI "struct slave *" slave ","
.BI "u16 " length ");"
.SH ARGUMENTS
.IP "lacpdu" 12
 received lacpdu
.IP "slave" 12
 slave struct to work on
.IP "length" 12
 length of the data received
.SH "DESCRIPTION"
It is assumed that frames that were sent on this NIC don't returned as new
received frames (loopback). Since only the payload is given to this
function, it check for loopback.
.TH "bond_3ad_adapter_speed_changed" 9 "bond_3ad_adapter_speed_changed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_adapter_speed_changed \-  handle a slave's speed change indication
.SH SYNOPSIS
.B "void" bond_3ad_adapter_speed_changed
.BI "(struct slave *" slave ");"
.SH ARGUMENTS
.IP "slave" 12
 slave struct to work on
.SH "DESCRIPTION"
Handle reselection of aggregator (if needed) for this port.
.TH "bond_3ad_adapter_duplex_changed" 9 "bond_3ad_adapter_duplex_changed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_adapter_duplex_changed \-  handle a slave's duplex change indication
.SH SYNOPSIS
.B "void" bond_3ad_adapter_duplex_changed
.BI "(struct slave *" slave ");"
.SH ARGUMENTS
.IP "slave" 12
 slave struct to work on
.SH "DESCRIPTION"
Handle reselection of aggregator (if needed) for this port.
.TH "bond_3ad_handle_link_change" 9 "bond_3ad_handle_link_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_handle_link_change \-  handle a slave's link status change indication
.SH SYNOPSIS
.B "void" bond_3ad_handle_link_change
.BI "(struct slave *" slave ","
.BI "char " link ");"
.SH ARGUMENTS
.IP "slave" 12
 slave struct to work on
.IP "link" 12
-- undescribed --
.SH "DESCRIPTION"
Handle reselection of aggregator (if needed) for this port.
.TH "bond_3ad_get_active_agg_info" 9 "bond_3ad_get_active_agg_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_3ad_get_active_agg_info \-  get information of the active aggregator
.SH SYNOPSIS
.B "int" bond_3ad_get_active_agg_info
.BI "(struct bonding *" bond ","
.BI "struct ad_info *" ad_info ");"
.SH ARGUMENTS
.IP "bond" 12
 bonding struct to work on
.IP "ad_info" 12
 ad_info struct to fill with the bond's info
.SH "RETURNS"
   0 on success
&lt; 0 on error
.TH "bond_add_vlan" 9 "bond_add_vlan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_add_vlan \-  add a new vlan id on bond
.SH SYNOPSIS
.B "int" bond_add_vlan
.BI "(struct bonding *" bond ","
.BI "unsigned short " vlan_id ");"
.SH ARGUMENTS
.IP "bond" 12
 bond that got the notification
.IP "vlan_id" 12
 the vlan id to add
.SH "DESCRIPTION"
Returns -ENOMEM if allocation failed.
.TH "bond_del_vlan" 9 "bond_del_vlan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_del_vlan \-  delete a vlan id from bond
.SH SYNOPSIS
.B "int" bond_del_vlan
.BI "(struct bonding *" bond ","
.BI "unsigned short " vlan_id ");"
.SH ARGUMENTS
.IP "bond" 12
 bond that got the notification
.IP "vlan_id" 12
 the vlan id to delete
.SH "DESCRIPTION"
returns -ENODEV if \fIvlan_id\fP was not found in \fIbond\fP.
.TH "bond_has_challenged_slaves" 9 "bond_has_challenged_slaves" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_has_challenged_slaves \- 
.SH SYNOPSIS
.B "int" bond_has_challenged_slaves
.BI "(struct bonding *" bond ");"
.SH ARGUMENTS
.IP "bond" 12
 the bond we're working on
.SH "DESCRIPTION"
Searches the slave list. Returns 1 if a vlan challenged slave
was found, 0 otherwise.

Assumes bond-&gt;lock is held.
.TH "bond_next_vlan" 9 "bond_next_vlan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_next_vlan \-  safely skip to the next item in the vlans list.
.SH SYNOPSIS
.B "struct vlan_entry *" bond_next_vlan
.BI "(struct bonding *" bond ","
.BI "struct vlan_entry *" curr ");"
.SH ARGUMENTS
.IP "bond" 12
 the bond we're working on
.IP "curr" 12
 item we're advancing from
.SH "DESCRIPTION"
Returns NULL if list is empty, bond-&gt;next_vlan if \fIcurr\fP is NULL,
or \fIcurr\fP-&gt;next otherwise (even if it is \fIcurr\fP itself again).

Caller must hold bond-&gt;lock
.TH "bond_dev_queue_xmit" 9 "bond_dev_queue_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_dev_queue_xmit \-  Prepare skb for xmit.
.SH SYNOPSIS
.B "int" bond_dev_queue_xmit
.BI "(struct bonding *" bond ","
.BI "struct sk_buff *" skb ","
.BI "struct net_device *" slave_dev ");"
.SH ARGUMENTS
.IP "bond" 12
 bond device that got this skb for tx.
.IP "skb" 12
 hw accel VLAN tagged skb to transmit
.IP "slave_dev" 12
 slave that is supposed to xmit this skbuff
.SH "DESCRIPTION"
When the bond gets an skb to transmit that is
already hardware accelerated VLAN tagged, and it
needs to relay this skb to a slave that is not
hw accel capable, the skb needs to be "unaccelerated",
i.e. strip the hwaccel tag and re-insert it as part
of the payload.
.SH "DESCRIPTION"
When the bond gets an skb to transmit that is
already hardware accelerated VLAN tagged, and it
needs to relay this skb to a slave that is not
hw accel capable, the skb needs to be "unaccelerated",
i.e. strip the hwaccel tag and re-insert it as part
of the payload.
.TH "bond_vlan_rx_register" 9 "bond_vlan_rx_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_vlan_rx_register \-  Propagates registration to slaves
.SH SYNOPSIS
.B "void" bond_vlan_rx_register
.BI "(struct net_device *" bond_dev ","
.BI "struct vlan_group *" grp ");"
.SH ARGUMENTS
.IP "bond_dev" 12
 bonding net device that got called
.IP "grp" 12
 vlan group being registered
.TH "bond_vlan_rx_add_vid" 9 "bond_vlan_rx_add_vid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_vlan_rx_add_vid \-  Propagates adding an id to slaves
.SH SYNOPSIS
.B "void" bond_vlan_rx_add_vid
.BI "(struct net_device *" bond_dev ","
.BI "uint16_t " vid ");"
.SH ARGUMENTS
.IP "bond_dev" 12
 bonding net device that got called
.IP "vid" 12
 vlan id being added
.TH "bond_vlan_rx_kill_vid" 9 "bond_vlan_rx_kill_vid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_vlan_rx_kill_vid \-  Propagates deleting an id to slaves
.SH SYNOPSIS
.B "void" bond_vlan_rx_kill_vid
.BI "(struct net_device *" bond_dev ","
.BI "uint16_t " vid ");"
.SH ARGUMENTS
.IP "bond_dev" 12
 bonding net device that got called
.IP "vid" 12
 vlan id being removed
.TH "bond_find_best_slave" 9 "bond_find_best_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_find_best_slave \-  select the best available slave to be the active one
.SH SYNOPSIS
.B "struct slave *" bond_find_best_slave
.BI "(struct bonding *" bond ");"
.SH ARGUMENTS
.IP "bond" 12
 our bonding struct
.SH "WARNING"
 Caller must hold curr_slave_lock for writing.
.TH "bond_change_active_slave" 9 "bond_change_active_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_change_active_slave \-  change the active slave into the specified one
.SH SYNOPSIS
.B "void" bond_change_active_slave
.BI "(struct bonding *" bond ","
.BI "struct slave *" new_active ");"
.SH ARGUMENTS
.IP "bond" 12
 our bonding struct
.IP "new_active" 12
-- undescribed --
.SH "DESCRIPTION"
Set the new slave to the bond's settings and unset them on the old
curr_active_slave.
Setting include flags, mc-list, promiscuity, allmulti, etc.

If \fInew\fP's link state is BOND_LINK_BACK we'll set it to BOND_LINK_UP,
because it is apparently the best available slave we have, even though its
updelay hasn't timed out yet.
.SH "WARNING"
 Caller must hold curr_slave_lock for writing.
.TH "bond_select_active_slave" 9 "bond_select_active_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_select_active_slave \-  select a new active slave, if needed
.SH SYNOPSIS
.B "void" bond_select_active_slave
.BI "(struct bonding *" bond ");"
.SH ARGUMENTS
.IP "bond" 12
 our bonding struct
.SH "THIS FUNCTIONS SHOUD BE CALLED WHEN ONE OF THE FOLLOWING OCCURS"
- The old curr_active_slave has been released or lost its link.
- The primary_slave has got its link back.
- A slave has got its link back and there's no old curr_active_slave.
.SH "WARNING"
 Caller must hold curr_slave_lock for writing.
.TH "bond_for_each_slave_from" 9 "bond_for_each_slave_from" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_for_each_slave_from \-  iterate the slaves list from a starting point
.SH SYNOPSIS
.B "" bond_for_each_slave_from
.BI "(" bond ","
.BI "" pos ","
.BI "" cnt ","
.BI "" start ");"
.SH ARGUMENTS
.IP "bond" 12
	the bond holding this list.
.IP "pos" 12
	current slave.
.IP "cnt" 12
	counter for max number of moves
.IP "start" 12
	starting point.
.SH "DESCRIPTION"
Caller must hold bond-&gt;lock
.TH "bond_for_each_slave_from_to" 9 "bond_for_each_slave_from_to" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_for_each_slave_from_to \-  iterate the slaves list from start point to stop point
.SH SYNOPSIS
.B "" bond_for_each_slave_from_to
.BI "(" bond ","
.BI "" pos ","
.BI "" cnt ","
.BI "" start ","
.BI "" stop ");"
.SH ARGUMENTS
.IP "bond" 12
	the bond holding this list.
.IP "pos" 12
	current slave.
.IP "cnt" 12
	counter for number max of moves
.IP "start" 12
	start point.
.IP "stop" 12
	stop point.
.SH "DESCRIPTION"
Caller must hold bond-&gt;lock
.TH "bond_for_each_slave" 9 "bond_for_each_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_for_each_slave \-  iterate the slaves list from head
.SH SYNOPSIS
.B "" bond_for_each_slave
.BI "(" bond ","
.BI "" pos ","
.BI "" cnt ");"
.SH ARGUMENTS
.IP "bond" 12
	the bond holding this list.
.IP "pos" 12
	current slave.
.IP "cnt" 12
	counter for max number of moves
.SH "DESCRIPTION"
Caller must hold bond-&gt;lock
.TH "bond_get_slave_by_dev" 9 "bond_get_slave_by_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bond_get_slave_by_dev \- 
.SH SYNOPSIS
.B "struct slave *" bond_get_slave_by_dev
.BI "(struct bonding *" bond ","
.BI "struct net_device *" slave_dev ");"
.SH ARGUMENTS
.IP "bond" 12
-- undescribed --
.IP "slave_dev" 12
-- undescribed --
.SH "DESCRIPTION"

Caller must hold bond lock for read
.TH "ei_open" 9 "ei_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_open \-  Open/initialize the board.
.SH SYNOPSIS
.B "int" ei_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device to initialize
.SH "DESCRIPTION"
This routine goes all-out, setting everything
up anew at each open, even though many of these registers should only
need to be set once at boot.
.TH "ei_close" 9 "ei_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_close \-  shut down network device
.SH SYNOPSIS
.B "int" ei_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device to close
.SH "DESCRIPTION"
Opposite of \fBei_open\fP. Only used when "ifconfig &lt;devname&gt; down" is done.
.TH "ei_tx_timeout" 9 "ei_tx_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_tx_timeout \-  handle transmit time out condition
.SH SYNOPSIS
.B "void" ei_tx_timeout
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device which has apparently fallen asleep
.SH "DESCRIPTION"
Called by kernel when device never acknowledges a transmit has
completed (or failed) - i.e. never posted a Tx related interrupt.
.TH "ei_start_xmit" 9 "ei_start_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_start_xmit \-  begin packet transmission
.SH SYNOPSIS
.B "int" ei_start_xmit
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "skb" 12
 packet to be sent
.IP "dev" 12
 network device to which packet is sent
.SH "DESCRIPTION"
Sends a packet to an 8390 network device.
.TH "ei_interrupt" 9 "ei_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_interrupt \-  handle the interrupts from an 8390
.SH SYNOPSIS
.B "irqreturn_t" ei_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 interrupt number
.IP "dev_id" 12
 a pointer to the net_device
.IP "regs" 12
 unused
.SH "DESCRIPTION"
Handle the ether interface interrupts. We pull packets from
the 8390 via the card specific functions and fire them at the networking
stack. We also handle transmit completions and wake the transmit path if
necessary. We also update the counters and do other housekeeping as
needed.
.TH "ei_tx_err" 9 "ei_tx_err" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_tx_err \-  handle transmitter error
.SH SYNOPSIS
.B "void" ei_tx_err
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device which threw the exception
.SH "DESCRIPTION"
A transmitter error has happened. Most likely excess collisions (which
is a fairly normal condition). If the error is one where the Tx will
have been aborted, we try and send another one right away, instead of
letting the failed packet sit and collect dust in the Tx buffer. This
is a much better solution as it avoids kernel based Tx timeouts, and
an unnecessary card reset.

Called with lock held.
.TH "ei_tx_intr" 9 "ei_tx_intr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_tx_intr \-  transmit interrupt handler
.SH SYNOPSIS
.B "void" ei_tx_intr
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device for which tx intr is handled
.SH "WE HAVE FINISHED A TRANSMIT"
 check for errors and then trigger the next
packet to be sent. Called with lock held.
.TH "ei_receive" 9 "ei_receive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_receive \-  receive some packets
.SH SYNOPSIS
.B "void" ei_receive
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device with which receive will be run
.SH "DESCRIPTION"
We have a good packet(s), get it/them out of the buffers. 
Called with lock held.
.TH "ei_rx_overrun" 9 "ei_rx_overrun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ei_rx_overrun \-  handle receiver overrun
.SH SYNOPSIS
.B "void" ei_rx_overrun
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device which threw exception
.SH "WE HAVE A RECEIVER OVERRUN"
 we have to kick the 8390 to get it started
again. Problem is that you have to kick it exactly as NS prescribes in
the updated datasheets, or "the NIC may act in an unpredictable manner."
This includes causing "the NIC to defer indefinitely when it is stopped
on a busy network."  Ugh.
Called with lock held. Don't call this with the interrupts off or your
computer will hate you - it takes 10ms or so. 
.TH "do_set_multicast_list" 9 "do_set_multicast_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_set_multicast_list \-  set/clear multicast filter
.SH SYNOPSIS
.B "void" do_set_multicast_list
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 net device for which multicast filter is adjusted
.SH "DESCRIPTION"
Set or clear the multicast filter for this adaptor. May be called
from a BH in 2.1.x. Must be called with lock held. 
.TH "ethdev_setup" 9 "ethdev_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ethdev_setup \-  init rest of 8390 device struct
.SH SYNOPSIS
.B "void" ethdev_setup
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 network device structure to init
.SH "DESCRIPTION"
Initialize the rest of the 8390 device structure.  Do NOT __init
this, as it is used by 8390 based modular drivers too.
.TH "__alloc_ei_netdev" 9 "__alloc_ei_netdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__alloc_ei_netdev \-  alloc_etherdev counterpart for 8390
.SH SYNOPSIS
.B "struct net_device *" __alloc_ei_netdev
.BI "(int " size ");"
.SH ARGUMENTS
.IP "size" 12
 extra bytes to allocate
.SH "DESCRIPTION"
Allocate 8390-specific net_device.
.TH "NS8390_init" 9 "NS8390_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
NS8390_init \-  initialize 8390 hardware
.SH SYNOPSIS
.B "void" NS8390_init
.BI "(struct net_device *" dev ","
.BI "int " startp ");"
.SH ARGUMENTS
.IP "dev" 12
 network device to initialize
.IP "startp" 12
 boolean.  non-zero value to initiate chip processing
.SH "DESCRIPTION"
Must be called with lock held.
.TH "w1_touch_bit" 9 "w1_touch_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_touch_bit \- 0 or write-1 cycle and samples the level.
.SH SYNOPSIS
.B "u8" w1_touch_bit
.BI "(struct w1_master *" dev ","
.BI "int " bit ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "bit" 12
-- undescribed --
.TH "w1_write_bit" 9 "w1_write_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_write_bit \- 0 or write-1 cycle.
.SH SYNOPSIS
.B "void" w1_write_bit
.BI "(struct w1_master *" dev ","
.BI "int " bit ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "bit" 12
-- undescribed --
.SH "DESCRIPTION"
Only call if dev-&gt;bus_master-&gt;touch_bit is NULL
.TH "w1_write_8" 9 "w1_write_8" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_write_8 \- 
.SH SYNOPSIS
.B "void" w1_write_8
.BI "(struct w1_master *" dev ","
.BI "u8 " byte ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "byte" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP dev     the master device
\fIparam\fP byte    the byte to write
.TH "w1_read_bit" 9 "w1_read_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_read_bit \- 1 cycle and samples the level.
.SH SYNOPSIS
.B "u8" w1_read_bit
.BI "(struct w1_master *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
Only call if dev-&gt;bus_master-&gt;touch_bit is NULL
.TH "w1_triplet" 9 "w1_triplet" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_triplet \-  used for searching ROM addresses.
.SH SYNOPSIS
.B "u8" w1_triplet
.BI "(struct w1_master *" dev ","
.BI "int " bdir ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "bdir" 12
-- undescribed --
.SH "RETURN BITS"
bit 0 = id_bit
bit 1 = comp_bit
bit 2 = dir_taken
If both bits 0 &amp; 1 are set, the search should be restarted.

\fIparam\fP dev     the master device
\fIparam\fP bdir    the bit to write if both id_bit and comp_bit are 0
\fIreturn\fP        bit fields - see above
.TH "w1_read_8" 9 "w1_read_8" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_read_8 \- 
.SH SYNOPSIS
.B "u8" w1_read_8
.BI "(struct w1_master *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP dev     the master device
\fIreturn\fP        the byte read
.TH "w1_write_block" 9 "w1_write_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_write_block \- 
.SH SYNOPSIS
.B "void" w1_write_block
.BI "(struct w1_master *" dev ","
.BI "const u8 *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP dev     the master device
\fIparam\fP buf     pointer to the data to write
\fIparam\fP len     the number of bytes to write
\fIreturn\fP        the byte read
.TH "w1_read_block" 9 "w1_read_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_read_block \- 
.SH SYNOPSIS
.B "u8" w1_read_block
.BI "(struct w1_master *" dev ","
.BI "u8 *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP dev     the master device
\fIparam\fP buf     pointer to the buffer to fill
\fIparam\fP len     the number of bytes to read
\fIreturn\fP        the number of bytes read
.TH "w1_reset_bus" 9 "w1_reset_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_reset_bus \- 
.SH SYNOPSIS
.B "int" w1_reset_bus
.BI "(struct w1_master *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP  dev The bus master pointer
\fIreturn\fP     0=Device present, 1=No device present or error
.TH "w1_reset_select_slave" 9 "w1_reset_select_slave" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_reset_select_slave \- 
.SH SYNOPSIS
.B "int" w1_reset_select_slave
.BI "(struct w1_slave *" sl ");"
.SH ARGUMENTS
.IP "sl" 12
-- undescribed --
.SH "DESCRIPTION"
or a rom match.
The w1 master lock must be held.

\fIparam\fP sl	the slave to select
\fIreturn\fP 	0=success, anything else=error
.TH "w1_f23_fix_count" 9 "w1_f23_fix_count" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_f23_fix_count \- 
.SH SYNOPSIS
.B "size_t" w1_f23_fix_count
.BI "(loff_t " off ","
.BI "size_t " count ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "off" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
This would not be needed if the file size didn't reset to 0 after a write.
.TH "w1_f23_write" 9 "w1_f23_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_f23_write \- 
.SH SYNOPSIS
.B "int" w1_f23_write
.BI "(struct w1_slave *" sl ","
.BI "int " addr ","
.BI "int " len ","
.BI "const u8 *" data ");"
.SH ARGUMENTS
.IP "sl" 12
-- undescribed --
.IP "addr" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
Then copies the scratchpad to EEPROM.
The data must be on one page.
The master must be locked.

\fIparam\fP sl	The slave structure
\fIparam\fP addr	Address for the write
\fIparam\fP len   length must be &lt;= (W1_PAGE_SIZE - (addr &amp; W1_PAGE_MASK))
\fIparam\fP data	The data to write
\fIreturn\fP	0=Success -1=failure
.TH "w1_search" 9 "w1_search" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
w1_search \- 
.SH SYNOPSIS
.B "void" w1_search
.BI "(struct w1_master *" dev ","
.BI "w1_slave_found_callback " cb ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "cb" 12
-- undescribed --
.SH "DESCRIPTION"
The 1-wire search is a simple binary tree search.
For each bit of the address, we read two bits and write one bit.
The bit written will put to sleep all devies that don't match that bit.
When the two reads differ, the direction choice is obvious.
When both bits are 0, we must choose a path to take.
When we can scan all 64 bits without having to choose a path, we are done.

See "Application note 187 1-wire search algorithm" at www.maxim-ic.com

\fIdev\fP        The master device to search
\fIcb\fP         Function to call when a device is found
.TH "zfcp_device_setup" 9 "zfcp_device_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_device_setup \-  setup function
.SH SYNOPSIS
.B "int __init" zfcp_device_setup
.BI "(char *" devstr ");"
.SH ARGUMENTS
.IP "devstr" 12
-- undescribed --
.SH "DESCRIPTION"
Parse "device=..." parameter string.
.TH "zfcp_sg_list_alloc" 9 "zfcp_sg_list_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sg_list_alloc \-  create a scatter-gather list of the specified size
.SH SYNOPSIS
.B "int" zfcp_sg_list_alloc
.BI "(struct zfcp_sg_list *" sg_list ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "sg_list" 12
 structure describing a scatter gather list
.IP "size" 12
 size of scatter-gather list
.SH "RETURN"
 0 on success, else -ENOMEM

In sg_list-&gt;sg a pointer to the created scatter-gather list is returned,
or NULL if we run out of memory. sg_list-&gt;count specifies the number of
elements of the scatter-gather list. The maximum size of a single element
in the scatter-gather list is PAGE_SIZE.
.TH "zfcp_sg_list_free" 9 "zfcp_sg_list_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sg_list_free \-  free memory of a scatter-gather list
.SH SYNOPSIS
.B "void" zfcp_sg_list_free
.BI "(struct zfcp_sg_list *" sg_list ");"
.SH ARGUMENTS
.IP "sg_list" 12
 structure describing a scatter-gather list
.SH "DESCRIPTION"
Memory for each element in the scatter-gather list is freed.
Finally sg_list-&gt;sg is freed itself and sg_list-&gt;count is reset.
.TH "zfcp_sg_size" 9 "zfcp_sg_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sg_size \-  determine size of a scatter-gather list
.SH SYNOPSIS
.B "size_t" zfcp_sg_size
.BI "(struct scatterlist *" sg ","
.BI "unsigned int " sg_count ");"
.SH ARGUMENTS
.IP "sg" 12
 array of (struct scatterlist)
.IP "sg_count" 12
 elements in array
.SH "RETURN"
 size of entire scatter-gather list
.TH "zfcp_sg_list_copy_from_user" 9 "zfcp_sg_list_copy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sg_list_copy_from_user \- copy data from user space to scatter-gather list
.SH SYNOPSIS
.B "int" zfcp_sg_list_copy_from_user
.BI "(struct zfcp_sg_list *" sg_list ","
.BI "void __user *" user_buffer ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "sg_list" 12
 structure describing a scatter-gather list
.IP "user_buffer" 12
 pointer to buffer in user space
.IP "size" 12
 number of bytes to be copied
.SH "RETURN"
 0 on success, -EFAULT if copy_from_user fails.
.TH "zfcp_sg_list_copy_to_user" 9 "zfcp_sg_list_copy_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sg_list_copy_to_user \-  copy data from scatter-gather list to user space
.SH SYNOPSIS
.B "int" zfcp_sg_list_copy_to_user
.BI "(void __user *" user_buffer ","
.BI "struct zfcp_sg_list *" sg_list ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "user_buffer" 12
 pointer to buffer in user space
.IP "sg_list" 12
 structure describing a scatter-gather list
.IP "size" 12
 number of bytes to be copied
.SH "RETURN"
 0 on success, -EFAULT if copy_to_user fails
.TH "zfcp_get_unit_by_lun" 9 "zfcp_get_unit_by_lun" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_get_unit_by_lun \-  find unit in unit list of port by FCP LUN
.SH SYNOPSIS
.B "struct zfcp_unit *" zfcp_get_unit_by_lun
.BI "(struct zfcp_port *" port ","
.BI "fcp_lun_t " fcp_lun ");"
.SH ARGUMENTS
.IP "port" 12
 pointer to port to search for unit
.IP "fcp_lun" 12
 FCP LUN to search for
Traverse list of all units of a port and return pointer to a unit
with the given FCP LUN.
.TH "zfcp_get_port_by_wwpn" 9 "zfcp_get_port_by_wwpn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_get_port_by_wwpn \-  find port in port list of adapter by wwpn
.SH SYNOPSIS
.B "struct zfcp_port *" zfcp_get_port_by_wwpn
.BI "(struct zfcp_adapter *" adapter ","
.BI "wwn_t " wwpn ");"
.SH ARGUMENTS
.IP "adapter" 12
 pointer to adapter to search for port
.IP "wwpn" 12
 wwpn to search for
Traverse list of all ports of an adapter and return pointer to a port
with the given wwpn.
.TH "zfcp_get_port_by_did" 9 "zfcp_get_port_by_did" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_get_port_by_did \-  find port in port list of adapter by d_id
.SH SYNOPSIS
.B "struct zfcp_port *" zfcp_get_port_by_did
.BI "(struct zfcp_adapter *" adapter ","
.BI "u32 " d_id ");"
.SH ARGUMENTS
.IP "adapter" 12
 pointer to adapter to search for port
.IP "d_id" 12
 d_id to search for
Traverse list of all ports of an adapter and return pointer to a port
with the given d_id.
.TH "zfcp_get_adapter_by_busid" 9 "zfcp_get_adapter_by_busid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_get_adapter_by_busid \-  find adpater in adapter list by bus_id
.SH SYNOPSIS
.B "struct zfcp_adapter *" zfcp_get_adapter_by_busid
.BI "(char *" bus_id ");"
.SH ARGUMENTS
.IP "bus_id" 12
 bus_id to search for
Traverse list of all adapters and return pointer to an adapter
with the given bus_id.
.TH "zfcp_unit_enqueue" 9 "zfcp_unit_enqueue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_unit_enqueue \-  enqueue unit to unit list of a port.
.SH SYNOPSIS
.B "struct zfcp_unit *" zfcp_unit_enqueue
.BI "(struct zfcp_port *" port ","
.BI "fcp_lun_t " fcp_lun ");"
.SH ARGUMENTS
.IP "port" 12
 pointer to port where unit is added
.IP "fcp_lun" 12
 FCP LUN of unit to be enqueued
.SH "RETURN"
 pointer to enqueued unit on success, NULL on error
.SH "LOCKS"
 config_sema must be held to serialize changes to the unit list

Sets up some unit internal structures and creates sysfs entry.
.TH "zfcp_free_low_mem_buffers" 9 "zfcp_free_low_mem_buffers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_free_low_mem_buffers \-  free memory pools of an adapter
.SH SYNOPSIS
.B "void" zfcp_free_low_mem_buffers
.BI "(struct zfcp_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 pointer to zfcp_adapter for which memory pools should be freed
.SH "LOCKING"
  zfcp_data.config_sema must be held
.TH "zfcp_port_enqueue" 9 "zfcp_port_enqueue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_port_enqueue \-  enqueue port to port list of adapter
.SH SYNOPSIS
.B "struct zfcp_port *" zfcp_port_enqueue
.BI "(struct zfcp_adapter *" adapter ","
.BI "wwn_t " wwpn ","
.BI "u32 " status ","
.BI "u32 " d_id ");"
.SH ARGUMENTS
.IP "adapter" 12
 adapter where remote port is added
.IP "wwpn" 12
 WWPN of the remote port to be enqueued
.IP "status" 12
 initial status for the port
.IP "d_id" 12
 destination id of the remote port to be enqueued
.SH "RETURN"
 pointer to enqueued port on success, NULL on error
.SH "LOCKS"
 config_sema must be held to serialize changes to the port list

All port internal structures are set up and the sysfs entry is generated.
d_id is used to enqueue ports with a well known address like the Directory
Service for nameserver lookup.
.TH "zfcp_gid_pn_buffers_alloc" 9 "zfcp_gid_pn_buffers_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_gid_pn_buffers_alloc \-  allocate buffers for GID_PN nameserver request
.SH SYNOPSIS
.B "int" zfcp_gid_pn_buffers_alloc
.BI "(struct zfcp_gid_pn_data **" gid_pn ","
.BI "mempool_t *" pool ");"
.SH ARGUMENTS
.IP "gid_pn" 12
 pointer to return pointer to struct zfcp_gid_pn_data
.IP "pool" 12
 pointer to mempool_t if non-null memory pool is used for allocation
.TH "zfcp_gid_pn_buffers_free" 9 "zfcp_gid_pn_buffers_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_gid_pn_buffers_free \-  free buffers for GID_PN nameserver request
.SH SYNOPSIS
.B "void" zfcp_gid_pn_buffers_free
.BI "(struct zfcp_gid_pn_data *" gid_pn ");"
.SH ARGUMENTS
.IP "gid_pn" 12
 pointer to struct zfcp_gid_pn_data which has to be freed
.TH "zfcp_ns_gid_pn_request" 9 "zfcp_ns_gid_pn_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ns_gid_pn_request \-  initiate GID_PN nameserver request
.SH SYNOPSIS
.B "int" zfcp_ns_gid_pn_request
.BI "(struct zfcp_erp_action *" erp_action ");"
.SH ARGUMENTS
.IP "erp_action" 12
 pointer to zfcp_erp_action where GID_PN request is needed
.TH "zfcp_ns_gid_pn_handler" 9 "zfcp_ns_gid_pn_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ns_gid_pn_handler \-  handler for GID_PN nameserver request
.SH SYNOPSIS
.B "void" zfcp_ns_gid_pn_handler
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 unsigned long, contains pointer to struct zfcp_gid_pn_data
.TH "zfcp_rc_description" 9 "zfcp_rc_description" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_rc_description \-  return description for given reaon code
.SH SYNOPSIS
.B "const char *" zfcp_rc_description
.BI "(u8 " code ","
.BI "const struct zfcp_rc_entry *" rc_table ");"
.SH ARGUMENTS
.IP "code" 12
 reason code
.IP "rc_table" 12
 table of reason codes and descriptions
.TH "zfcp_check_ct_response" 9 "zfcp_check_ct_response" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_check_ct_response \-  evaluate reason code for CT_IU
.SH SYNOPSIS
.B "int" zfcp_check_ct_response
.BI "(struct ct_hdr *" rjt ");"
.SH ARGUMENTS
.IP "rjt" 12
 response payload to an CT_IU request
.SH "RETURN"
 0 for accept CT_IU, 1 for reject CT_IU or invlid response code
.TH "zfcp_print_els_rjt" 9 "zfcp_print_els_rjt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_print_els_rjt \-  print reject parameter and description for ELS reject
.SH SYNOPSIS
.B "void" zfcp_print_els_rjt
.BI "(struct zfcp_ls_rjt_par *" rjt_par ","
.BI "const struct zfcp_rc_entry *" rc_table ");"
.SH ARGUMENTS
.IP "rjt_par" 12
 reject parameter acc. to FC-PH/FC-FS
.IP "rc_table" 12
 table of reason codes and descriptions
.TH "zfcp_handle_els_rjt" 9 "zfcp_handle_els_rjt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_handle_els_rjt \-  evaluate status qualifier/reason code on ELS reject
.SH SYNOPSIS
.B "int" zfcp_handle_els_rjt
.BI "(u32 " sq ","
.BI "struct zfcp_ls_rjt_par *" rjt_par ");"
.SH ARGUMENTS
.IP "sq" 12
 status qualifier word
.IP "rjt_par" 12
 reject parameter as described in FC-PH and FC-FS
.SH "RETURN"
 -EROMTEIO for LS_RJT, -EREMCHG for invalid D_ID, -EIO else
.TH "zfcp_ccw_probe" 9 "zfcp_ccw_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_probe \-  probe function of zfcp driver
.SH SYNOPSIS
.B "int" zfcp_ccw_probe
.BI "(struct ccw_device *" ccw_device ");"
.SH ARGUMENTS
.IP "ccw_device" 12
 pointer to belonging ccw device
.SH "DESCRIPTION"
This function gets called by the common i/o layer and sets up the initial
data structures for each fcp adapter, which was detected by the system.
Also the sysfs files for this adapter will be created by this function.
In addition the nameserver port will be added to the ports of the adapter
and its sysfs representation will be created too.
.TH "zfcp_ccw_remove" 9 "zfcp_ccw_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_remove \-  remove function of zfcp driver
.SH SYNOPSIS
.B "void" zfcp_ccw_remove
.BI "(struct ccw_device *" ccw_device ");"
.SH ARGUMENTS
.IP "ccw_device" 12
 pointer to belonging ccw device
.SH "DESCRIPTION"
This function gets called by the common i/o layer and removes an adapter
from the system. Task of this function is to get rid of all units and
ports that belong to this adapter. And in addition all resources of this
adapter will be freed too.
.TH "zfcp_ccw_set_online" 9 "zfcp_ccw_set_online" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_set_online \-  set_online function of zfcp driver
.SH SYNOPSIS
.B "int" zfcp_ccw_set_online
.BI "(struct ccw_device *" ccw_device ");"
.SH ARGUMENTS
.IP "ccw_device" 12
 pointer to belonging ccw device
.SH "DESCRIPTION"
This function gets called by the common i/o layer and sets an adapter
into state online. Setting an fcp device online means that it will be
registered with the SCSI stack, that the QDIO queues will be set up
and that the adapter will be opened (asynchronously).
.TH "zfcp_ccw_set_offline" 9 "zfcp_ccw_set_offline" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_set_offline \-  set_offline function of zfcp driver
.SH SYNOPSIS
.B "int" zfcp_ccw_set_offline
.BI "(struct ccw_device *" ccw_device ");"
.SH ARGUMENTS
.IP "ccw_device" 12
 pointer to belonging ccw device
.SH "DESCRIPTION"
This function gets called by the common i/o layer and sets an adapter
into state offline. Setting an fcp device offline means that it will be
unregistered from the SCSI stack and that the adapter will be shut down
asynchronously.
.TH "zfcp_ccw_notify" 9 "zfcp_ccw_notify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_notify \- 
.SH SYNOPSIS
.B "int" zfcp_ccw_notify
.BI "(struct ccw_device *" ccw_device ","
.BI "int " event ");"
.SH ARGUMENTS
.IP "ccw_device" 12
 pointer to belonging ccw device
.IP "event" 12
 indicates if adapter was detached or attached
.SH "DESCRIPTION"
This function gets called by the common i/o layer if an adapter has gone
or reappeared.
.TH "zfcp_ccw_register" 9 "zfcp_ccw_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_register \-  ccw register function
.SH SYNOPSIS
.B "int __init" zfcp_ccw_register
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Registers the driver at the common i/o layer. This function will be called
at module load time/system start.
.TH "zfcp_ccw_unregister" 9 "zfcp_ccw_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_unregister \-  ccw unregister function
.SH SYNOPSIS
.B "void __exit" zfcp_ccw_unregister
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters the driver from common i/o layer. Function will be called at
module unload/system shutdown.
.TH "zfcp_ccw_shutdown" 9 "zfcp_ccw_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_ccw_shutdown \-  gets called on reboot/shutdown
.SH SYNOPSIS
.B "void" zfcp_ccw_shutdown
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Makes sure that QDIO queues are down when the system gets stopped.
.TH "zfcp_qdio_sbale_get" 9 "zfcp_qdio_sbale_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbale_get \-  return pointer to SBALE of qdio_queue
.SH SYNOPSIS
.B "volatile struct qdio_buffer_element *" zfcp_qdio_sbale_get
.BI "(struct zfcp_qdio_queue *" queue ","
.BI "int " sbal ","
.BI "int " sbale ");"
.SH ARGUMENTS
.IP "queue" 12
 queue from which SBALE should be returned
.IP "sbal" 12
 specifies number of SBAL in queue
.IP "sbale" 12
 specifes number of SBALE in SBAL
.TH "zfcp_qdio_sbale_req" 9 "zfcp_qdio_sbale_req" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbale_req \-  return pointer to SBALE of request_queue for
.SH SYNOPSIS
.B "volatile struct qdio_buffer_element *" zfcp_qdio_sbale_req
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "int " sbal ","
.BI "int " sbale ");"
.SH ARGUMENTS
.IP "fsf_req" 12
-- undescribed --
.IP "sbal" 12
-- undescribed --
.IP "sbale" 12
-- undescribed --
.SH "DESCRIPTION"
a struct zfcp_fsf_req
.TH "zfcp_qdio_sbale_resp" 9 "zfcp_qdio_sbale_resp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbale_resp \-  return pointer to SBALE of response_queue for
.SH SYNOPSIS
.B "volatile struct qdio_buffer_element *" zfcp_qdio_sbale_resp
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "int " sbal ","
.BI "int " sbale ");"
.SH ARGUMENTS
.IP "fsf_req" 12
-- undescribed --
.IP "sbal" 12
-- undescribed --
.IP "sbale" 12
-- undescribed --
.SH "DESCRIPTION"
a struct zfcp_fsf_req
.TH "zfcp_qdio_sbale_curr" 9 "zfcp_qdio_sbale_curr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbale_curr \-  return current SBALE on request_queue for
.SH SYNOPSIS
.B "volatile struct qdio_buffer_element *" zfcp_qdio_sbale_curr
.BI "(struct zfcp_fsf_req *" fsf_req ");"
.SH ARGUMENTS
.IP "fsf_req" 12
-- undescribed --
.SH "DESCRIPTION"
a struct zfcp_fsf_req
.TH "zfcp_qdio_sbal_limit" 9 "zfcp_qdio_sbal_limit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbal_limit \-  determine maximum number of SBALs that can be used
.SH SYNOPSIS
.B "void" zfcp_qdio_sbal_limit
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "int " max_sbals ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 the number of the last SBAL that can be used is stored herein
.IP "max_sbals" 12
 used to pass an upper limit for the number of SBALs
.SH "DESCRIPTION"
on the request_queue for a struct zfcp_fsf_req
.SH "NOTE"
 We can assume at least one free SBAL in the request_queue when called.
.TH "zfcp_qdio_sbal_chain" 9 "zfcp_qdio_sbal_chain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbal_chain \-  chain SBALs if more than one SBAL is needed for a
.SH SYNOPSIS
.B "volatile struct qdio_buffer_element *" zfcp_qdio_sbal_chain
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "unsigned long " sbtype ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 zfcp_fsf_req to be processed
.IP "sbtype" 12
 SBAL flags which have to be set in first SBALE of new SBAL
.SH "DESCRIPTION"
This function changes sbal_curr, sbale_curr, sbal_number of fsf_req.
.SH "DESCRIPTION"
This function changes sbal_curr, sbale_curr, sbal_number of fsf_req.
.TH "zfcp_qdio_sbale_next" 9 "zfcp_qdio_sbale_next" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbale_next \-  switch to next SBALE, chain SBALs if needed
.SH SYNOPSIS
.B "volatile struct qdio_buffer_element *" zfcp_qdio_sbale_next
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "unsigned long " sbtype ");"
.SH ARGUMENTS
.IP "fsf_req" 12
-- undescribed --
.IP "sbtype" 12
-- undescribed --
.TH "zfcp_qdio_sbals_zero" 9 "zfcp_qdio_sbals_zero" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbals_zero \-  initialize SBALs between first and last in queue
.SH SYNOPSIS
.B "int" zfcp_qdio_sbals_zero
.BI "(struct zfcp_qdio_queue *" queue ","
.BI "int " first ","
.BI "int " last ");"
.SH ARGUMENTS
.IP "queue" 12
-- undescribed --
.IP "first" 12
-- undescribed --
.IP "last" 12
-- undescribed --
.SH "DESCRIPTION"
with zero from
.TH "zfcp_qdio_sbals_wipe" 9 "zfcp_qdio_sbals_wipe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbals_wipe \-  reset all changes in SBALs for an fsf_req
.SH SYNOPSIS
.B "int" zfcp_qdio_sbals_wipe
.BI "(struct zfcp_fsf_req *" fsf_req ");"
.SH ARGUMENTS
.IP "fsf_req" 12
-- undescribed --
.TH "zfcp_qdio_sbale_fill" 9 "zfcp_qdio_sbale_fill" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbale_fill \-  set address and lenght in current SBALE
.SH SYNOPSIS
.B "void" zfcp_qdio_sbale_fill
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "unsigned long " sbtype ","
.BI "void *" addr ","
.BI "int " length ");"
.SH ARGUMENTS
.IP "fsf_req" 12
-- undescribed --
.IP "sbtype" 12
-- undescribed --
.IP "addr" 12
-- undescribed --
.IP "length" 12
-- undescribed --
.SH "DESCRIPTION"
on request_queue
.TH "zfcp_qdio_sbals_from_segment" 9 "zfcp_qdio_sbals_from_segment" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbals_from_segment \-  map memory segment to SBALE(s)
.SH SYNOPSIS
.B "int" zfcp_qdio_sbals_from_segment
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "unsigned long " sbtype ","
.BI "void *" start_addr ","
.BI "unsigned long " total_length ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 request to be processed
.IP "sbtype" 12
 SBALE flags
.IP "start_addr" 12
 address of memory segment
.IP "total_length" 12
 length of memory segment
.SH "DESCRIPTION"
Alignment and length of the segment determine how many SBALEs are needed
for the memory segment.
.TH "zfcp_qdio_sbals_from_sg" 9 "zfcp_qdio_sbals_from_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbals_from_sg \-  fill SBALs from scatter-gather list
.SH SYNOPSIS
.B "int" zfcp_qdio_sbals_from_sg
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "unsigned long " sbtype ","
.BI "struct scatterlist *" sg ","
.BI "int " sg_count ","
.BI "int " max_sbals ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 request to be processed
.IP "sbtype" 12
 SBALE flags
.IP "sg" 12
 scatter-gather list
.IP "sg_count" 12
 number of elements in scatter-gather list
.IP "max_sbals" 12
 upper bound for number of SBALs to be used
.TH "zfcp_qdio_sbals_from_buffer" 9 "zfcp_qdio_sbals_from_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbals_from_buffer \-  fill SBALs from buffer
.SH SYNOPSIS
.B "int" zfcp_qdio_sbals_from_buffer
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "unsigned long " sbtype ","
.BI "void *" buffer ","
.BI "unsigned long " length ","
.BI "int " max_sbals ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 request to be processed
.IP "sbtype" 12
 SBALE flags
.IP "buffer" 12
 data buffer
.IP "length" 12
 length of buffer
.IP "max_sbals" 12
 upper bound for number of SBALs to be used
.TH "zfcp_qdio_sbals_from_scsicmnd" 9 "zfcp_qdio_sbals_from_scsicmnd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_sbals_from_scsicmnd \-  fill SBALs from scsi command
.SH SYNOPSIS
.B "int" zfcp_qdio_sbals_from_scsicmnd
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "unsigned long " sbtype ","
.BI "struct scsi_cmnd *" scsi_cmnd ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 request to be processed
.IP "sbtype" 12
 SBALE flags
.IP "scsi_cmnd" 12
 either scatter-gather list or buffer contained herein is used
to fill SBALs
.TH "zfcp_qdio_determine_pci" 9 "zfcp_qdio_determine_pci" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_qdio_determine_pci \-  set PCI flag in first SBALE on qdio queue if needed
.SH SYNOPSIS
.B "int" zfcp_qdio_determine_pci
.BI "(struct zfcp_qdio_queue *" req_queue ","
.BI "struct zfcp_fsf_req *" fsf_req ");"
.SH ARGUMENTS
.IP "req_queue" 12
-- undescribed --
.IP "fsf_req" 12
-- undescribed --
.TH "zfcp_sg_to_address" 9 "zfcp_sg_to_address" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sg_to_address \-  determine kernel address from struct scatterlist
.SH SYNOPSIS
.B "void *" zfcp_sg_to_address
.BI "(struct scatterlist *" list ");"
.SH ARGUMENTS
.IP "list" 12
 struct scatterlist
.SH "RETURN"
 kernel address
.TH "zfcp_address_to_sg" 9 "zfcp_address_to_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_address_to_sg \-  set up struct scatterlist from kernel address
.SH SYNOPSIS
.B "void" zfcp_address_to_sg
.BI "(void *" address ","
.BI "struct scatterlist *" list ");"
.SH ARGUMENTS
.IP "address" 12
 kernel address
.IP "list" 12
 struct scatterlist
.TH "Kernel API" 9 "struct zfcp_send_ct" "January 2021" "API Manual" LINUX
.SH NAME
struct zfcp_send_ct \-  used to pass parameters to function zfcp_fsf_send_ct
.SH SYNOPSIS
struct zfcp_send_ct {
.br
.BI "    struct zfcp_port *" port ""
;

.br
.BI "    struct scatterlist *" req ""
;

.br
.BI "    struct scatterlist *" resp ""
;

.br
.BI "    unsigned int " req_count ""
;

.br
.BI "    unsigned int " resp_count ""
;

.br
.BI "    zfcp_send_ct_handler_t " handler ""
;

.br
.BI "    unsigned long " handler_data ""
;

.br
.BI "    mempool_t *" pool ""
;

.br
.BI "    int " timeout ""
;

.br
.BI "    struct timer_list *" timer ""
;

.br
.BI "    struct completion *" completion ""
;

.br
.BI "    int " status ""
;

.br
};
.br
.SH Arguments
.IP "port" 12
 port where the request is sent to
.IP "req" 12
 scatter-gather list for request
.IP "resp" 12
 scatter-gather list for response
.IP "req_count" 12
 number of elements in request scatter-gather list
.IP "resp_count" 12
 number of elements in response scatter-gather list
.IP "handler" 12
 handler function (called for response to the request)
.IP "handler_data" 12
 data passed to handler function
.IP "pool" 12
 pointer to memory pool for ct request structure
.IP "timeout" 12
 FSF timeout for this request
.IP "timer" 12
 timer (e.g. for request initiated by erp)
.IP "completion" 12
 completion for synchronization purposes
.IP "status" 12
 used to pass error status to calling function
.TH "Kernel API" 9 "struct zfcp_send_els" "January 2021" "API Manual" LINUX
.SH NAME
struct zfcp_send_els \-  used to pass parameters to function zfcp_fsf_send_els
.SH SYNOPSIS
struct zfcp_send_els {
.br
.BI "    struct zfcp_adapter *" adapter ""
;

.br
.BI "    struct zfcp_port *" port ""
;

.br
.BI "    u32 " d_id ""
;

.br
.BI "    struct scatterlist *" req ""
;

.br
.BI "    struct scatterlist *" resp ""
;

.br
.BI "    unsigned int " req_count ""
;

.br
.BI "    unsigned int " resp_count ""
;

.br
.BI "    zfcp_send_els_handler_t " handler ""
;

.br
.BI "    unsigned long " handler_data ""
;

.br
.BI "    struct timer_list *" timer ""
;

.br
.BI "    struct completion *" completion ""
;

.br
.BI "    int " ls_code ""
;

.br
.BI "    int " status ""
;

.br
};
.br
.SH Arguments
.IP "adapter" 12
 adapter where request is sent from
.IP "port" 12
 port where ELS is destinated (port reference count has to be increased)
.IP "d_id" 12
 destiniation id of port where request is sent to
.IP "req" 12
 scatter-gather list for request
.IP "resp" 12
 scatter-gather list for response
.IP "req_count" 12
 number of elements in request scatter-gather list
.IP "resp_count" 12
 number of elements in response scatter-gather list
.IP "handler" 12
 handler function (called for response to the request)
.IP "handler_data" 12
 data passed to handler function
.IP "timer" 12
 timer (e.g. for request initiated by erp)
.IP "completion" 12
 completion for synchronization purposes
.IP "ls_code" 12
 hex code of ELS command
.IP "status" 12
 used to pass error status to calling function
.TH "Kernel API" 9 "struct zfcp_sg_list" "January 2021" "API Manual" LINUX
.SH NAME
struct zfcp_sg_list \-  struct describing a scatter-gather list
.SH SYNOPSIS
struct zfcp_sg_list {
.br
.BI "    struct scatterlist *" sg ""
;

.br
.BI "    unsigned int " count ""
;

.br
};
.br
.SH Arguments
.IP "sg" 12
 pointer to array of (struct scatterlist)
.IP "count" 12
 number of elements in scatter-gather list
.TH "zfcp_fsf_link_down_info_eval" 9 "zfcp_fsf_link_down_info_eval" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_link_down_info_eval \-  evaluate link down information block
.SH SYNOPSIS
.B "void" zfcp_fsf_link_down_info_eval
.BI "(struct zfcp_adapter *" adapter ","
.BI "struct fsf_link_down_info *" link_down ");"
.SH ARGUMENTS
.IP "adapter" 12
-- undescribed --
.IP "link_down" 12
-- undescribed --
.TH "zfcp_use_one_sbal" 9 "zfcp_use_one_sbal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_use_one_sbal \-  checks whether req buffer and resp bother each fit into
.SH SYNOPSIS
.B "int" zfcp_use_one_sbal
.BI "(struct scatterlist *" req ","
.BI "int " req_count ","
.BI "struct scatterlist *" resp ","
.BI "int " resp_count ");"
.SH ARGUMENTS
.IP "req" 12
-- undescribed --
.IP "req_count" 12
-- undescribed --
.IP "resp" 12
-- undescribed --
.IP "resp_count" 12
-- undescribed --
.SH "DESCRIPTION"
one SBALE
Two scatter-gather lists are passed, one for the reqeust and one for the
response.
.TH "zfcp_fsf_send_ct" 9 "zfcp_fsf_send_ct" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_send_ct \-  initiate a Generic Service request (FC-GS)
.SH SYNOPSIS
.B "int" zfcp_fsf_send_ct
.BI "(struct zfcp_send_ct *" ct ","
.BI "mempool_t *" pool ","
.BI "struct zfcp_erp_action *" erp_action ");"
.SH ARGUMENTS
.IP "ct" 12
 pointer to struct zfcp_send_ct which conatins all needed data for
the request
.IP "pool" 12
 pointer to memory pool, if non-null this pool is used to allocate
a struct zfcp_fsf_req
.IP "erp_action" 12
 pointer to erp_action, if non-null the Generic Service request
is sent within error recovery
.TH "zfcp_fsf_send_ct_handler" 9 "zfcp_fsf_send_ct_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_send_ct_handler \-  handler for Generic Service requests
.SH SYNOPSIS
.B "int" zfcp_fsf_send_ct_handler
.BI "(struct zfcp_fsf_req *" fsf_req ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 pointer to struct zfcp_fsf_req
.SH "DESCRIPTION"
Data specific for the Generic Service request is passed using
fsf_req-&gt;data. There we find the pointer to struct zfcp_send_ct.
Usually a specific handler for the CT request is called which is
found in this structure.
.TH "zfcp_fsf_send_els" 9 "zfcp_fsf_send_els" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_send_els \-  initiate an ELS command (FC-FS)
.SH SYNOPSIS
.B "int" zfcp_fsf_send_els
.BI "(struct zfcp_send_els *" els ");"
.SH ARGUMENTS
.IP "els" 12
 pointer to struct zfcp_send_els which contains all needed data for
the command.
.TH "zfcp_fsf_send_els_handler" 9 "zfcp_fsf_send_els_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_send_els_handler \-  handler for ELS commands
.SH SYNOPSIS
.B "int" zfcp_fsf_send_els_handler
.BI "(struct zfcp_fsf_req *" fsf_req ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 pointer to struct zfcp_fsf_req
.SH "DESCRIPTION"
Data specific for the ELS command is passed using
fsf_req-&gt;data. There we find the pointer to struct zfcp_send_els.
Usually a specific handler for the ELS command is called which is
found in this structure.
.TH "zfcp_fsf_exchange_config_evaluate" 9 "zfcp_fsf_exchange_config_evaluate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_exchange_config_evaluate \- 
.SH SYNOPSIS
.B "int" zfcp_fsf_exchange_config_evaluate
.BI "(struct zfcp_fsf_req *" fsf_req ","
.BI "int " xchg_ok ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 fsf_req which belongs to xchg config data request
.IP "xchg_ok" 12
 specifies if xchg config data was incomplete or complete (0/1)
.SH "RETURNS"
 -EIO on error, 0 otherwise
.TH "zfcp_fsf_exchange_port_data" 9 "zfcp_fsf_exchange_port_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_exchange_port_data \-  request information about local port
.SH SYNOPSIS
.B "int" zfcp_fsf_exchange_port_data
.BI "(struct zfcp_erp_action *" erp_action ","
.BI "struct zfcp_adapter *" adapter ","
.BI "struct fsf_qtcb_bottom_port *" data ");"
.SH ARGUMENTS
.IP "erp_action" 12
 ERP action for the adapter for which port data is requested
.IP "adapter" 12
 for which port data is requested
.IP "data" 12
 response to exchange port data request
.TH "zfcp_fsf_exchange_port_data_handler" 9 "zfcp_fsf_exchange_port_data_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_exchange_port_data_handler \-  handler for exchange_port_data request
.SH SYNOPSIS
.B "void" zfcp_fsf_exchange_port_data_handler
.BI "(struct zfcp_fsf_req *" fsf_req ");"
.SH ARGUMENTS
.IP "fsf_req" 12
 pointer to struct zfcp_fsf_req
.TH "zfcp_fsf_send_fcp_command_task" 9 "zfcp_fsf_send_fcp_command_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_send_fcp_command_task \-  initiate an FCP command (for a SCSI command)
.SH SYNOPSIS
.B "int" zfcp_fsf_send_fcp_command_task
.BI "(struct zfcp_adapter *" adapter ","
.BI "struct zfcp_unit *" unit ","
.BI "struct scsi_cmnd *" scsi_cmnd ","
.BI "struct timer_list *" timer ","
.BI "int " req_flags ");"
.SH ARGUMENTS
.IP "adapter" 12
 adapter where scsi command is issued
.IP "unit" 12
 unit where command is sent to
.IP "scsi_cmnd" 12
 scsi command to be sent
.IP "timer" 12
 timer to be started when request is initiated
.IP "req_flags" 12
 flags for fsf_request
.TH "zfcp_fsf_req_sbal_get" 9 "zfcp_fsf_req_sbal_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_req_sbal_get \-  try to get one SBAL in the request queue
.SH SYNOPSIS
.B "int" zfcp_fsf_req_sbal_get
.BI "(struct zfcp_adapter *" adapter ","
.BI "int " req_flags ","
.BI "unsigned long *" lock_flags ");"
.SH ARGUMENTS
.IP "adapter" 12
 adapter for which request queue is examined
.IP "req_flags" 12
 flags indicating whether to wait for needed SBAL or not
.IP "lock_flags" 12
 lock_flags if queue_lock is taken
.SH "RETURN"
 0 on success, otherwise -EIO, or -ERESTARTSYS
.SH "LOCKS"
 lock adapter-&gt;request_queue-&gt;queue_lock on success
.TH "ZFCP_DEFINE_DRIVER_ATTR" 9 "ZFCP_DEFINE_DRIVER_ATTR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ZFCP_DEFINE_DRIVER_ATTR \-  define for all loglevels sysfs attributes
.SH SYNOPSIS
.B "" ZFCP_DEFINE_DRIVER_ATTR
.BI "(" _name ","
.BI "" _define ");"
.SH ARGUMENTS
.IP "_name" 12
       name of attribute
.IP "_define" 12
     name of ZFCP loglevel define
.SH "DESCRIPTION"
Generates store function for a sysfs loglevel attribute of zfcp driver.
.TH "zfcp_sysfs_driver_create_files" 9 "zfcp_sysfs_driver_create_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_driver_create_files \-  create sysfs driver files
.SH SYNOPSIS
.B "int" zfcp_sysfs_driver_create_files
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.SH "DESCRIPTION"
Create all sysfs attributes of the zfcp device driver
.TH "zfcp_sysfs_driver_remove_files" 9 "zfcp_sysfs_driver_remove_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_driver_remove_files \-  remove sysfs driver files
.SH SYNOPSIS
.B "void" zfcp_sysfs_driver_remove_files
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.SH "DESCRIPTION"
Remove all sysfs attributes of the zfcp device driver
.TH "zfcp_scsi_command_fail" 9 "zfcp_scsi_command_fail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_scsi_command_fail \-  set result in scsi_cmnd and call scsi_done function
.SH SYNOPSIS
.B "void" zfcp_scsi_command_fail
.BI "(struct scsi_cmnd *" scpnt ","
.BI "int " result ");"
.SH ARGUMENTS
.IP "scpnt" 12
 pointer to struct scsi_cmnd where result is set
.IP "result" 12
 result to be set in scpnt (e.g. DID_ERROR)
.TH "zfcp_scsi_command_async" 9 "zfcp_scsi_command_async" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_scsi_command_async \-  worker for zfcp_scsi_queuecommand and
.SH SYNOPSIS
.B "int" zfcp_scsi_command_async
.BI "(struct zfcp_adapter *" adapter ","
.BI "struct zfcp_unit *" unit ","
.BI "struct scsi_cmnd *" scpnt ","
.BI "struct timer_list *" timer ");"
.SH ARGUMENTS
.IP "adapter" 12
 adapter where scsi command is issued
.IP "unit" 12
 unit to which scsi command is sent
.IP "scpnt" 12
 scsi command to be sent
.IP "timer" 12
 timer to be started if request is successfully initiated
.SH "DESCRIPTION"
zfcp_scsi_command_sync
.SH "NOTE"
 In scsi_done function must be set in scpnt.
.TH "zfcp_scsi_command_sync" 9 "zfcp_scsi_command_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_scsi_command_sync \-  send a SCSI command and wait for completion
.SH SYNOPSIS
.B "int" zfcp_scsi_command_sync
.BI "(struct zfcp_unit *" unit ","
.BI "struct scsi_cmnd *" scpnt ","
.BI "struct timer_list *" timer ");"
.SH ARGUMENTS
.IP "unit" 12
 unit where command is sent to
.IP "scpnt" 12
 scsi command to be sent
.IP "timer" 12
 timer to be started if request is successfully initiated
.SH "RETURN"
 0

Errors are indicated in scpnt-&gt;result
.TH "zfcp_scsi_eh_abort_handler" 9 "zfcp_scsi_eh_abort_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_scsi_eh_abort_handler \-  abort the specified SCSI command
.SH SYNOPSIS
.B "int" zfcp_scsi_eh_abort_handler
.BI "(struct scsi_cmnd *" scpnt ");"
.SH ARGUMENTS
.IP "scpnt" 12
 pointer to scsi_cmnd to be aborted 
.SH "RETURN"
 SUCCESS - command has been aborted and cleaned up in internal
bookkeeping, SCSI stack won't be called for aborted command
FAILED - otherwise

We do not need to care for a SCSI command which completes normally
but late during this abort routine runs.  We are allowed to return
late commands to the SCSI stack.  It tracks the state of commands and
will handle late commands.  (Usually, the normal completion of late
commands is ignored with respect to the running abort operation.)
.TH "zfcp_scsi_eh_bus_reset_handler" 9 "zfcp_scsi_eh_bus_reset_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_scsi_eh_bus_reset_handler \-  reset bus (reopen adapter)
.SH SYNOPSIS
.B "int" zfcp_scsi_eh_bus_reset_handler
.BI "(struct scsi_cmnd *" scpnt ");"
.SH ARGUMENTS
.IP "scpnt" 12
-- undescribed --
.TH "zfcp_scsi_eh_host_reset_handler" 9 "zfcp_scsi_eh_host_reset_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_scsi_eh_host_reset_handler \-  reset host (reopen adapter)
.SH SYNOPSIS
.B "int" zfcp_scsi_eh_host_reset_handler
.BI "(struct scsi_cmnd *" scpnt ");"
.SH ARGUMENTS
.IP "scpnt" 12
-- undescribed --
.TH "ZFCP_DEFINE_SCSI_ATTR" 9 "ZFCP_DEFINE_SCSI_ATTR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ZFCP_DEFINE_SCSI_ATTR \- 
.SH SYNOPSIS
.B "" ZFCP_DEFINE_SCSI_ATTR
.BI "(" _name ","
.BI "" _format ","
.BI "" _value ");"
.SH ARGUMENTS
.IP "_name" 12
   name of show attribute
.IP "_format" 12
 format string
.IP "_value" 12
  value to print
.SH "DESCRIPTION"
Generates attribute for a unit.
.TH "zfcp_adapter_debug_register" 9 "zfcp_adapter_debug_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_adapter_debug_register \-  registers debug feature for an adapter
.SH SYNOPSIS
.B "int" zfcp_adapter_debug_register
.BI "(struct zfcp_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 pointer to adapter for which debug features should be registered
.SH "RETURN"
 -ENOMEM on error, 0 otherwise
.TH "zfcp_adapter_debug_unregister" 9 "zfcp_adapter_debug_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_adapter_debug_unregister \-  unregisters debug feature for an adapter
.SH SYNOPSIS
.B "void" zfcp_adapter_debug_unregister
.BI "(struct zfcp_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 pointer to adapter for which debug features should be unregistered
.TH "zfcp_sysfs_unit_release" 9 "zfcp_sysfs_unit_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_unit_release \-  gets called when a struct device unit is released
.SH SYNOPSIS
.B "void" zfcp_sysfs_unit_release
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.TH "ZFCP_DEFINE_UNIT_ATTR" 9 "ZFCP_DEFINE_UNIT_ATTR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ZFCP_DEFINE_UNIT_ATTR \- 
.SH SYNOPSIS
.B "" ZFCP_DEFINE_UNIT_ATTR
.BI "(" _name ","
.BI "" _format ","
.BI "" _value ");"
.SH ARGUMENTS
.IP "_name" 12
   name of show attribute
.IP "_format" 12
 format string
.IP "_value" 12
  value to print
.SH "DESCRIPTION"
Generates attribute for a unit.
.TH "zfcp_sysfs_unit_failed_store" 9 "zfcp_sysfs_unit_failed_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_unit_failed_store \-  failed state of unit
.SH SYNOPSIS
.B "ssize_t" zfcp_sysfs_unit_failed_store
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 pointer to input buffer
.IP "count" 12
 number of bytes in buffer
.SH "DESCRIPTION"
Store function of the "failed" attribute of a unit.
If a "0" gets written to "failed", error recovery will be
started for the belonging unit.
.TH "zfcp_sysfs_unit_failed_show" 9 "zfcp_sysfs_unit_failed_show" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_unit_failed_show \-  failed state of unit
.SH SYNOPSIS
.B "ssize_t" zfcp_sysfs_unit_failed_show
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 pointer to input buffer
.SH "DESCRIPTION"
Show function of "failed" attribute of unit. Will be
"0" if unit is working, otherwise "1".
.TH "zfcp_sysfs_unit_create_files" 9 "zfcp_sysfs_unit_create_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_unit_create_files \-  create sysfs unit files
.SH SYNOPSIS
.B "int" zfcp_sysfs_unit_create_files
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.SH "DESCRIPTION"
Create all attributes of the sysfs representation of a unit.
.TH "zfcp_sysfs_unit_remove_files" 9 "zfcp_sysfs_unit_remove_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_unit_remove_files \-  remove sysfs unit files
.SH SYNOPSIS
.B "void" zfcp_sysfs_unit_remove_files
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.SH "DESCRIPTION"
Remove all attributes of the sysfs representation of a unit.
.TH "ZFCP_DEFINE_ADAPTER_ATTR" 9 "ZFCP_DEFINE_ADAPTER_ATTR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ZFCP_DEFINE_ADAPTER_ATTR \- 
.SH SYNOPSIS
.B "" ZFCP_DEFINE_ADAPTER_ATTR
.BI "(" _name ","
.BI "" _format ","
.BI "" _value ");"
.SH ARGUMENTS
.IP "_name" 12
   name of show attribute
.IP "_format" 12
 format string
.IP "_value" 12
  value to print
.SH "DESCRIPTION"
Generates attributes for an adapter.
.TH "zfcp_sysfs_port_add_store" 9 "zfcp_sysfs_port_add_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_port_add_store \-  add a port to sysfs tree
.SH SYNOPSIS
.B "ssize_t" zfcp_sysfs_port_add_store
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 pointer to input buffer
.IP "count" 12
 number of bytes in buffer
.SH "DESCRIPTION"
Store function of the "port_add" attribute of an adapter.
.TH "zfcp_sysfs_port_remove_store" 9 "zfcp_sysfs_port_remove_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_port_remove_store \-  remove a port from sysfs tree
.SH SYNOPSIS
.B "ssize_t" zfcp_sysfs_port_remove_store
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 pointer to input buffer
.IP "count" 12
 number of bytes in buffer
.SH "DESCRIPTION"
Store function of the "port_remove" attribute of an adapter.
.TH "zfcp_sysfs_adapter_failed_store" 9 "zfcp_sysfs_adapter_failed_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_adapter_failed_store \-  failed state of adapter
.SH SYNOPSIS
.B "ssize_t" zfcp_sysfs_adapter_failed_store
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 pointer to input buffer
.IP "count" 12
 number of bytes in buffer
.SH "DESCRIPTION"
Store function of the "failed" attribute of an adapter.
If a "0" gets written to "failed", error recovery will be
started for the belonging adapter.
.TH "zfcp_sysfs_adapter_failed_show" 9 "zfcp_sysfs_adapter_failed_show" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_adapter_failed_show \-  failed state of adapter
.SH SYNOPSIS
.B "ssize_t" zfcp_sysfs_adapter_failed_show
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.IP "attr" 12
-- undescribed --
.IP "buf" 12
 pointer to input buffer
.SH "DESCRIPTION"
Show function of "failed" attribute of adapter. Will be
"0" if adapter is working, otherwise "1".
.TH "zfcp_sysfs_adapter_create_files" 9 "zfcp_sysfs_adapter_create_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_adapter_create_files \-  create sysfs adapter files
.SH SYNOPSIS
.B "int" zfcp_sysfs_adapter_create_files
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.SH "DESCRIPTION"
Create all attributes of the sysfs representation of an adapter.
.TH "zfcp_sysfs_adapter_remove_files" 9 "zfcp_sysfs_adapter_remove_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_sysfs_adapter_remove_files \-  remove sysfs adapter files
.SH SYNOPSIS
.B "void" zfcp_sysfs_adapter_remove_files
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to belonging device
.SH "DESCRIPTION"
Remove all attributes of the sysfs representation of an adapter.
.TH "zfcp_fsf_request_timeout_handler" 9 "zfcp_fsf_request_timeout_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_fsf_request_timeout_handler \-  called if a request timed out
.SH SYNOPSIS
.B "void" zfcp_fsf_request_timeout_handler
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 pointer to adapter for handler function
.SH "DESCRIPTION"
This function needs to be called if requests (ELS, Generic Service,
or SCSI commands) exceed a certain time limit. The assumption is
that after the time limit the adapter get stuck. So we trigger a reopen of
the adapter. This should not be used for error recovery, SCSI abort
commands and SCSI requests from SCSI mid-layer.
.TH "zfcp_erp_adisc" 9 "zfcp_erp_adisc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_erp_adisc \-  send ADISC ELS command
.SH SYNOPSIS
.B "int" zfcp_erp_adisc
.BI "(struct zfcp_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 port structure
.TH "zfcp_erp_adisc_handler" 9 "zfcp_erp_adisc_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_erp_adisc_handler \-  handler for ADISC ELS command
.SH SYNOPSIS
.B "void" zfcp_erp_adisc_handler
.BI "(unsigned long " data ");"
.SH ARGUMENTS
.IP "data" 12
 pointer to struct zfcp_send_els
.SH "DESCRIPTION"
If ADISC failed (LS_RJT or timed out) forced reopen of the port is triggered.
.TH "zfcp_test_link" 9 "zfcp_test_link" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_test_link \-  lightweight link test procedure
.SH SYNOPSIS
.B "int" zfcp_test_link
.BI "(struct zfcp_port *" port ");"
.SH ARGUMENTS
.IP "port" 12
 port to be tested
.SH "DESCRIPTION"
Test status of a link to a remote port using the ELS command ADISC.
.TH "zfcp_erp_port_reopen" 9 "zfcp_erp_port_reopen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_erp_port_reopen \-  initiate reopen of a remote port
.SH SYNOPSIS
.B "int" zfcp_erp_port_reopen
.BI "(struct zfcp_port *" port ","
.BI "int " clear_mask ");"
.SH ARGUMENTS
.IP "port" 12
 port to be reopened
.IP "clear_mask" 12
 specifies flags in port status to be cleared
.SH "RETURN"
 0 on success, &lt; 0 on error

This is a wrappper function for zfcp_erp_port_reopen_internal. It ensures
correct locking. An error recovery task is initiated to do the reopen.
To wait for the completion of the reopen zfcp_erp_wait should be used.
.TH "zfcp_erp_unit_reopen" 9 "zfcp_erp_unit_reopen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_erp_unit_reopen \-  initiate reopen of a unit
.SH SYNOPSIS
.B "int" zfcp_erp_unit_reopen
.BI "(struct zfcp_unit *" unit ","
.BI "int " clear_mask ");"
.SH ARGUMENTS
.IP "unit" 12
 unit to be reopened
.IP "clear_mask" 12
 specifies flags in unit status to be cleared
.SH "RETURN"
 0 on success, &lt; 0 on error

This is a wrappper for zfcp_erp_unit_reopen_internal. It ensures correct
locking. An error recovery task is initiated to do the reopen.
To wait for the completion of the reopen zfcp_erp_wait should be used.
.TH "zfcp_erp_wait" 9 "zfcp_erp_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_erp_wait \-  wait for completion of error recovery on an adapter
.SH SYNOPSIS
.B "int" zfcp_erp_wait
.BI "(struct zfcp_adapter *" adapter ");"
.SH ARGUMENTS
.IP "adapter" 12
 adapter for which to wait for completion of its error recovery
.SH "RETURN"
 0
.TH "zfcp_erp_action_cleanup" 9 "zfcp_erp_action_cleanup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zfcp_erp_action_cleanup \- 
.SH SYNOPSIS
.B "void" zfcp_erp_action_cleanup
.BI "(int " action ","
.BI "struct zfcp_adapter *" adapter ","
.BI "struct zfcp_port *" port ","
.BI "struct zfcp_unit *" unit ","
.BI "int " result ");"
.SH ARGUMENTS
.IP "action" 12
-- undescribed --
.IP "adapter" 12
-- undescribed --
.IP "port" 12
-- undescribed --
.IP "unit" 12
-- undescribed --
.IP "result" 12
-- undescribed --
.SH "DESCRIPTION"

Register unit with scsi stack if appropiate and fix reference counts.
.SH "NOTE"
 Temporary units are not registered with scsi stack.
.TH "ctrlchar_handle" 9 "ctrlchar_handle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ctrlchar_handle \- 
.SH SYNOPSIS
.B "unsigned int" ctrlchar_handle
.BI "(const unsigned char *" buf ","
.BI "int " len ","
.BI "struct tty_struct *" tty ");"
.SH ARGUMENTS
.IP "buf" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.IP "tty" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP buf Console input buffer.
\fIparam\fP len Length of valid data in buffer.
\fIparam\fP tty The tty struct for this console.
\fIreturn\fP CTRLCHAR_NONE, if nothing matched,
CTRLCHAR_SYSRQ, if sysrq was encountered
otherwise char to be inserted logically or'ed
with CTRLCHAR_CTRL
.TH "read_dev_chars" 9 "read_dev_chars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_dev_chars \-  read device characteristics
.SH SYNOPSIS
.B "int" read_dev_chars
.BI "(struct ccw_device *" cdev ","
.BI "void **" buffer ","
.BI "int " length ");"
.SH ARGUMENTS
.IP "cdev" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "length" 12
-- undescribed --
.SH "DESCRIPTION"
\fIparam\fP cdev   target ccw device
\fIparam\fP buffer pointer to buffer for rdc data
\fIparam\fP length size of rdc data
\fIreturns\fP 0 for success, negative error value on failure
.SH "CONTEXT"
called for online device, lock not held
.TH "qeth_tso_fill_header" 9 "qeth_tso_fill_header" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qeth_tso_fill_header \- 
.SH SYNOPSIS
.B "void" qeth_tso_fill_header
.BI "(struct qeth_card *" card ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "card" 12
-- undescribed --
.IP "skb" 12
-- undescribed --
.TH "qeth_tso_set_tcpip_header" 9 "qeth_tso_set_tcpip_header" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
qeth_tso_set_tcpip_header \- 
.SH SYNOPSIS
.B "void" qeth_tso_set_tcpip_header
.BI "(struct qeth_card *" card ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "card" 12
-- undescribed --
.IP "skb" 12
-- undescribed --
.TH "mmc_register_driver" 9 "mmc_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_register_driver \-  register a media driver
.SH SYNOPSIS
.B "int" mmc_register_driver
.BI "(struct mmc_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 MMC media driver
.TH "mmc_unregister_driver" 9 "mmc_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_unregister_driver \-  unregister a media driver
.SH SYNOPSIS
.B "void" mmc_unregister_driver
.BI "(struct mmc_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 MMC media driver
.TH "mmc_init_queue" 9 "mmc_init_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_init_queue \-  initialise a queue structure.
.SH SYNOPSIS
.B "int" mmc_init_queue
.BI "(struct mmc_queue *" mq ","
.BI "struct mmc_card *" card ","
.BI "spinlock_t *" lock ");"
.SH ARGUMENTS
.IP "mq" 12
 mmc queue
.IP "card" 12
 mmc card to attach this queue
.IP "lock" 12
 queue lock
.SH "DESCRIPTION"
Initialise a MMC card request queue.
.TH "mmc_queue_suspend" 9 "mmc_queue_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_queue_suspend \-  suspend a MMC request queue
.SH SYNOPSIS
.B "void" mmc_queue_suspend
.BI "(struct mmc_queue *" mq ");"
.SH ARGUMENTS
.IP "mq" 12
 MMC queue to suspend
.SH "DESCRIPTION"
Stop the block request queue, and wait for our thread to
complete any outstanding requests.  This ensures that we
won't suspend while a request is being processed.
.TH "mmc_queue_resume" 9 "mmc_queue_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_queue_resume \-  resume a previously suspended MMC request queue
.SH SYNOPSIS
.B "void" mmc_queue_resume
.BI "(struct mmc_queue *" mq ");"
.SH ARGUMENTS
.IP "mq" 12
 MMC queue to resume
.TH "mmc_request_done" 9 "mmc_request_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_request_done \-  finish processing an MMC command
.SH SYNOPSIS
.B "void" mmc_request_done
.BI "(struct mmc_host *" host ","
.BI "struct mmc_request *" mrq ");"
.SH ARGUMENTS
.IP "host" 12
 MMC host which completed command
.IP "mrq" 12
 MMC request which completed
.SH "DESCRIPTION"
MMC drivers should call this function when they have completed
their processing of a command.  This should be called before the
data part of the command has completed.
.TH "mmc_start_request" 9 "mmc_start_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_start_request \-  start a command on a host
.SH SYNOPSIS
.B "void" mmc_start_request
.BI "(struct mmc_host *" host ","
.BI "struct mmc_request *" mrq ");"
.SH ARGUMENTS
.IP "host" 12
 MMC host to start command on
.IP "mrq" 12
 MMC request to start
.SH "DESCRIPTION"
Queue a command on the specified host.  We expect the
caller to be holding the host lock with interrupts disabled.
.TH "mmc_wait_for_cmd" 9 "mmc_wait_for_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_wait_for_cmd \-  start a command and wait for completion
.SH SYNOPSIS
.B "int" mmc_wait_for_cmd
.BI "(struct mmc_host *" host ","
.BI "struct mmc_command *" cmd ","
.BI "int " retries ");"
.SH ARGUMENTS
.IP "host" 12
 MMC host to start command
.IP "cmd" 12
 MMC command to start
.IP "retries" 12
 maximum number of retries
.SH "DESCRIPTION"
Start a new MMC command for a host, and wait for the command
to complete.  Return any error that occurred while the command
was executing.  Do not attempt to parse the response.
.TH "mmc_wait_for_app_cmd" 9 "mmc_wait_for_app_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_wait_for_app_cmd \-  start an application command and wait for
.SH SYNOPSIS
.B "int" mmc_wait_for_app_cmd
.BI "(struct mmc_host *" host ","
.BI "unsigned int " rca ","
.BI "struct mmc_command *" cmd ","
.BI "int " retries ");"
.SH ARGUMENTS
.IP "host" 12
 MMC host to start command
.IP "rca" 12
 RCA to send MMC_APP_CMD to
.IP "cmd" 12
 MMC command to start
.IP "retries" 12
 maximum number of retries
.SH "DESCRIPTION"
Sends a MMC_APP_CMD, checks the card response, sends the command
in the parameter and waits for it to complete. Return any error
that occurred while the command was executing.  Do not attempt to
parse the response.
.TH "__mmc_claim_host" 9 "__mmc_claim_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__mmc_claim_host \-  exclusively claim a host
.SH SYNOPSIS
.B "int" __mmc_claim_host
.BI "(struct mmc_host *" host ","
.BI "struct mmc_card *" card ");"
.SH ARGUMENTS
.IP "host" 12
 mmc host to claim
.IP "card" 12
 mmc card to claim host for
.SH "DESCRIPTION"
Claim a host for a set of operations.  If a valid card
is passed and this wasn't the last card selected, select
the card before returning.
.SH "NOTE"
 you should use mmc_card_claim_host or mmc_claim_host.
.TH "mmc_release_host" 9 "mmc_release_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_release_host \-  release a host
.SH SYNOPSIS
.B "void" mmc_release_host
.BI "(struct mmc_host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 mmc host to release
.SH "DESCRIPTION"
Release a MMC host, allowing others to claim the host
for their operations.
.TH "mmc_detect_change" 9 "mmc_detect_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_detect_change \-  process change of state on a MMC socket
.SH SYNOPSIS
.B "void" mmc_detect_change
.BI "(struct mmc_host *" host ","
.BI "unsigned long " delay ");"
.SH ARGUMENTS
.IP "host" 12
 host which changed state.
.IP "delay" 12
 optional delay to wait before detection (jiffies)
.SH "DESCRIPTION"
All we know is that card(s) have been inserted or removed
from the socket(s).  We don't know which socket or cards.
.TH "mmc_alloc_host" 9 "mmc_alloc_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_alloc_host \-  initialise the per-host structure.
.SH SYNOPSIS
.B "struct mmc_host *" mmc_alloc_host
.BI "(int " extra ","
.BI "struct device *" dev ");"
.SH ARGUMENTS
.IP "extra" 12
 sizeof private data structure
.IP "dev" 12
 pointer to host device model structure
.SH "DESCRIPTION"
Initialise the per-host structure.
.TH "mmc_add_host" 9 "mmc_add_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_add_host \-  initialise host hardware
.SH SYNOPSIS
.B "int" mmc_add_host
.BI "(struct mmc_host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 mmc host
.TH "mmc_remove_host" 9 "mmc_remove_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_remove_host \-  remove host hardware
.SH SYNOPSIS
.B "void" mmc_remove_host
.BI "(struct mmc_host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 mmc host
.SH "DESCRIPTION"
Unregister and remove all cards associated with this host,
and power down the MMC bus.
.TH "mmc_free_host" 9 "mmc_free_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_free_host \-  free the host structure
.SH SYNOPSIS
.B "void" mmc_free_host
.BI "(struct mmc_host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 mmc host
.SH "DESCRIPTION"
Free the host once all references to it have been dropped.
.TH "mmc_suspend_host" 9 "mmc_suspend_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_suspend_host \-  suspend a host
.SH SYNOPSIS
.B "int" mmc_suspend_host
.BI "(struct mmc_host *" host ","
.BI "pm_message_t " state ");"
.SH ARGUMENTS
.IP "host" 12
 mmc host
.IP "state" 12
 suspend mode (PM_SUSPEND_xxx)
.TH "mmc_resume_host" 9 "mmc_resume_host" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mmc_resume_host \-  resume a previously suspended host
.SH SYNOPSIS
.B "int" mmc_resume_host
.BI "(struct mmc_host *" host ");"
.SH ARGUMENTS
.IP "host" 12
 mmc host
.TH "pci_bus_max_busnr" 9 "pci_bus_max_busnr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_bus_max_busnr \-  returns maximum PCI bus number of given bus' children
.SH SYNOPSIS
.B "unsigned char __devinit" pci_bus_max_busnr
.BI "(struct pci_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 pointer to PCI bus structure to search
.SH "DESCRIPTION"
Given a PCI bus, returns the highest PCI bus number present in the set
including the given PCI bus and its list of child PCI buses.
.TH "pci_max_busnr" 9 "pci_max_busnr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_max_busnr \-  returns maximum PCI bus number
.SH SYNOPSIS
.B "unsigned char __devinit" pci_max_busnr
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns the highest PCI bus number present in the system global list of
PCI buses.
.TH "pci_find_capability" 9 "pci_find_capability" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_find_capability \-  query for devices' capabilities 
.SH SYNOPSIS
.B "int" pci_find_capability
.BI "(struct pci_dev *" dev ","
.BI "int " cap ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to query
.IP "cap" 12
 capability code
.SH "DESCRIPTION"
Tell if a device supports a given PCI capability.
Returns the address of the requested capability structure within the
device's PCI configuration space or 0 in case the device does not
support it.  Possible values for \fIcap\fP:

PCI_CAP_ID_PM           Power Management 
PCI_CAP_ID_AGP          Accelerated Graphics Port 
PCI_CAP_ID_VPD          Vital Product Data 
PCI_CAP_ID_SLOTID       Slot Identification 
PCI_CAP_ID_MSI          Message Signalled Interrupts
PCI_CAP_ID_CHSWP        CompactPCI HotSwap 
PCI_CAP_ID_PCIX         PCI-X
PCI_CAP_ID_EXP          PCI Express
.TH "pci_bus_find_capability" 9 "pci_bus_find_capability" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_bus_find_capability \-  query for devices' capabilities 
.SH SYNOPSIS
.B "int" pci_bus_find_capability
.BI "(struct pci_bus *" bus ","
.BI "unsigned int " devfn ","
.BI "int " cap ");"
.SH ARGUMENTS
.IP "bus" 12
   the PCI bus to query
.IP "devfn" 12
 PCI device to query
.IP "cap" 12
   capability code
.SH "DESCRIPTION"
Like \fBpci_find_capability\fP but works for pci devices that do not have a
pci_dev structure set up yet. 

Returns the address of the requested capability structure within the
device's PCI configuration space or 0 in case the device does not
support it.
.TH "pci_find_ext_capability" 9 "pci_find_ext_capability" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_find_ext_capability \-  Find an extended capability
.SH SYNOPSIS
.B "int" pci_find_ext_capability
.BI "(struct pci_dev *" dev ","
.BI "int " cap ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to query
.IP "cap" 12
 capability code
.SH "DESCRIPTION"
Returns the address of the requested extended capability structure
within the device's PCI configuration space or 0 if the device does
not support it.  Possible values for \fIcap\fP:

PCI_EXT_CAP_ID_ERR		Advanced Error Reporting
PCI_EXT_CAP_ID_VC		Virtual Channel
PCI_EXT_CAP_ID_DSN		Device Serial Number
PCI_EXT_CAP_ID_PWR		Power Budgeting
.TH "pci_find_parent_resource" 9 "pci_find_parent_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_find_parent_resource \-  return resource region of parent bus of given region
.SH SYNOPSIS
.B "struct resource *" pci_find_parent_resource
.BI "(const struct pci_dev *" dev ","
.BI "struct resource *" res ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device structure contains resources to be searched
.IP "res" 12
 child resource record for which parent is sought
.SH "DESCRIPTION"
For given resource region of given device, return the resource
region of parent bus the given region is contained in or where
it should be allocated from.
.TH "pci_restore_bars" 9 "pci_restore_bars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_restore_bars \-  restore a devices BAR values (e.g. after wake-up)
.SH SYNOPSIS
.B "void" pci_restore_bars
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to have its BARs restored
.SH "DESCRIPTION"
Restore the BAR values for a given device, so as to make it
accessible by its driver.
.TH "int" 9 "int" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
int \-  Set the power state of a PCI device
.SH SYNOPSIS
.B "" int
.BI "( *" platform_pci_set_power_state ");"
.SH ARGUMENTS
.IP "platform_pci_set_power_state" 12
-- undescribed --
.SH "DESCRIPTION"
Transition a device to a new power state, using the Power Management 
Capabilities in the device's config space.
.SH "RETURN VALUE"
 
-EINVAL if trying to enter a lower state than we're already in.
0 if we're already in the requested state.
-EIO if device does not support PCI PM.
0 if we can successfully change the power state.
.TH "pci_choose_state" 9 "pci_choose_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_choose_state \-  Choose the power state of a PCI device
.SH SYNOPSIS
.B "pci_power_t" pci_choose_state
.BI "(struct pci_dev *" dev ","
.BI "pm_message_t " state ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to be suspended
.IP "state" 12
 target sleep state for the whole system. This is the value
that is passed to \fBsuspend\fP function.
.SH "DESCRIPTION"
Returns PCI power state suitable for given device and given system
message.
.TH "pci_save_state" 9 "pci_save_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_save_state \-  save the PCI configuration space of a device before suspending
.SH SYNOPSIS
.B "int" pci_save_state
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 - PCI device that we're dealing with
.TH "pci_restore_state" 9 "pci_restore_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_restore_state \-  Restore the saved state of a PCI device
.SH SYNOPSIS
.B "int" pci_restore_state
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 - PCI device that we're dealing with
.TH "pci_enable_device_bars" 9 "pci_enable_device_bars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_enable_device_bars \-  Initialize some of a device for use
.SH SYNOPSIS
.B "int" pci_enable_device_bars
.BI "(struct pci_dev *" dev ","
.BI "int " bars ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to be initialized
.IP "bars" 12
 bitmask of BAR's that must be configured
.SH "DESCRIPTION"
Initialize device before it's used by a driver. Ask low-level code
to enable selected I/O and memory resources. Wake up the device if it 
was suspended. Beware, this function can fail.
.TH "pci_enable_device" 9 "pci_enable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_enable_device \-  Initialize device before it's used by a driver.
.SH SYNOPSIS
.B "int" pci_enable_device
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to be initialized
.SH "DESCRIPTION"
Initialize device before it's used by a driver. Ask low-level code
to enable I/O and memory. Wake up the device if it was suspended.
Beware, this function can fail.
.TH "pcibios_disable_device" 9 "pcibios_disable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcibios_disable_device \-  disable arch specific PCI resources for device dev
.SH SYNOPSIS
.B "void" pcibios_disable_device
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the PCI device to disable
.SH "DESCRIPTION"
Disables architecture specific PCI resources for the device. This
is the default implementation. Architecture implementations can
override this.
.TH "pci_disable_device" 9 "pci_disable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_disable_device \-  Disable PCI device after use
.SH SYNOPSIS
.B "void" pci_disable_device
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to be disabled
.SH "DESCRIPTION"
Signal to the system that the PCI device is not in use by the system
anymore.  This only involves disabling PCI bus-mastering, if active.
.TH "pci_enable_wake" 9 "pci_enable_wake" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_enable_wake \-  enable device to generate PME# when suspended
.SH SYNOPSIS
.B "int" pci_enable_wake
.BI "(struct pci_dev *" dev ","
.BI "pci_power_t " state ","
.BI "int " enable ");"
.SH ARGUMENTS
.IP "dev" 12
 - PCI device to operate on
.IP "state" 12
 - Current state of device.
.IP "enable" 12
 - Flag to enable or disable generation
.SH "DESCRIPTION"
Set the bits in the device's PM Capabilities to generate PME# when
the system is suspended. 

-EIO is returned if device doesn't have PM Capabilities. 
-EINVAL is returned if device supports it, but can't generate wake events.
0 if operation is successful.
.TH "pci_release_region" 9 "pci_release_region" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_release_region \-  Release a PCI bar
.SH SYNOPSIS
.B "void" pci_release_region
.BI "(struct pci_dev *" pdev ","
.BI "int " bar ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device whose resources were previously reserved by pci_request_region
.IP "bar" 12
 BAR to release
.SH "DESCRIPTION"
Releases the PCI I/O and memory resources previously reserved by a
successful call to pci_request_region.  Call this function only
after all use of the PCI regions has ceased.
.TH "pci_request_region" 9 "pci_request_region" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_request_region \-  Reserved PCI I/O and memory resource
.SH SYNOPSIS
.B "int" pci_request_region
.BI "(struct pci_dev *" pdev ","
.BI "int " bar ","
.BI "char *" res_name ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device whose resources are to be reserved
.IP "bar" 12
 BAR to be reserved
.IP "res_name" 12
 Name to be associated with resource.
.SH "DESCRIPTION"
Mark the PCI region associated with PCI device \fIpdev\fP BR \fIbar\fP as
being reserved by owner \fIres_name\fP.  Do not access any
address inside the PCI regions unless this call returns
successfully.

Returns 0 on success, or EBUSY on error.  A warning
message is also printed on failure.
.TH "pci_release_regions" 9 "pci_release_regions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_release_regions \-  Release reserved PCI I/O and memory resources
.SH SYNOPSIS
.B "void" pci_release_regions
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device whose resources were previously reserved by pci_request_regions
.SH "DESCRIPTION"
Releases all PCI I/O and memory resources previously reserved by a
successful call to pci_request_regions.  Call this function only
after all use of the PCI regions has ceased.
.TH "pci_request_regions" 9 "pci_request_regions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_request_regions \-  Reserved PCI I/O and memory resources
.SH SYNOPSIS
.B "int" pci_request_regions
.BI "(struct pci_dev *" pdev ","
.BI "char *" res_name ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device whose resources are to be reserved
.IP "res_name" 12
 Name to be associated with resource.
.SH "DESCRIPTION"
Mark all PCI regions associated with PCI device \fIpdev\fP as
being reserved by owner \fIres_name\fP.  Do not access any
address inside the PCI regions unless this call returns
successfully.

Returns 0 on success, or EBUSY on error.  A warning
message is also printed on failure.
.TH "pci_set_master" 9 "pci_set_master" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_set_master \-  enables bus-mastering for device dev
.SH SYNOPSIS
.B "void" pci_set_master
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the PCI device to enable
.SH "DESCRIPTION"
Enables bus-mastering on the device and calls \fBpcibios_set_master\fP
to do the needed arch specific settings.
.TH "pci_generic_prep_mwi" 9 "pci_generic_prep_mwi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_generic_prep_mwi \-  helper function for pci_set_mwi
.SH SYNOPSIS
.B "int" pci_generic_prep_mwi
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the PCI device for which MWI is enabled
.SH "DESCRIPTION"
Helper function for generic implementation of pcibios_prep_mwi
function.  Originally copied from drivers/net/acenic.c.
Copyright 1998-2001 by Jes Sorensen, &lt;jes\fItrained\fP-monkey.org&gt;.
.SH "RETURNS"
 An appropriate -ERRNO error value on error, or zero for success.
.TH "pci_set_mwi" 9 "pci_set_mwi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_set_mwi \-  enables memory-write-invalidate PCI transaction
.SH SYNOPSIS
.B "int" pci_set_mwi
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the PCI device for which MWI is enabled
.SH "DESCRIPTION"
Enables the Memory-Write-Invalidate transaction in PCI_COMMAND,
and then calls \fIpcibios_set_mwi\fP to do the needed arch specific
operations or a generic mwi-prep function.
.SH "RETURNS"
 An appropriate -ERRNO error value on error, or zero for success.
.TH "pci_clear_mwi" 9 "pci_clear_mwi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_clear_mwi \-  disables Memory-Write-Invalidate for device dev
.SH SYNOPSIS
.B "void" pci_clear_mwi
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the PCI device to disable
.SH "DESCRIPTION"
Disables PCI Memory-Write-Invalidate transaction on the device
.TH "pci_intx" 9 "pci_intx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_intx \-  enables/disables PCI INTx for device dev
.SH SYNOPSIS
.B "void" pci_intx
.BI "(struct pci_dev *" pdev ","
.BI "int " enable ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.IP "enable" 12
 boolean
.SH "DESCRIPTION"
Enables/disables PCI INTx for device dev
.TH "msi_capability_init" 9 "msi_capability_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
msi_capability_init \-  configure device's MSI capability structure
.SH SYNOPSIS
.B "int" msi_capability_init
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the pci_dev data structure of MSI device function
.SH "DESCRIPTION"
Setup the MSI capability structure of device function with a single
MSI vector, regardless of device function is capable of handling
multiple messages. A return of zero indicates the successful setup
of an entry zero with the new MSI vector or non-zero for otherwise.
.TH "msix_capability_init" 9 "msix_capability_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
msix_capability_init \-  configure device's MSI-X capability
.SH SYNOPSIS
.B "int" msix_capability_init
.BI "(struct pci_dev *" dev ","
.BI "struct msix_entry *" entries ","
.BI "int " nvec ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the pci_dev data structure of MSI-X device function
.IP "entries" 12
-- undescribed --
.IP "nvec" 12
-- undescribed --
.SH "DESCRIPTION"
Setup the MSI-X capability structure of device function with a
single MSI-X vector. A return of zero indicates the successful setup of
requested MSI-X entries with allocated vectors or non-zero for otherwise.
.TH "pci_enable_msi" 9 "pci_enable_msi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_enable_msi \-  configure device's MSI capability structure
.SH SYNOPSIS
.B "int" pci_enable_msi
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the pci_dev data structure of MSI device function
.SH "DESCRIPTION"
Setup the MSI capability structure of device function with
a single MSI vector upon its software driver call to request for
MSI mode enabled on its hardware device function. A return of zero
indicates the successful setup of an entry zero with the new MSI
vector or non-zero for otherwise.
.TH "pci_enable_msix" 9 "pci_enable_msix" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_enable_msix \-  configure device's MSI-X capability structure
.SH SYNOPSIS
.B "int" pci_enable_msix
.BI "(struct pci_dev *" dev ","
.BI "struct msix_entry *" entries ","
.BI "int " nvec ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the pci_dev data structure of MSI-X device function
.IP "entries" 12
 pointer to an array of MSI-X entries
.IP "nvec" 12
 number of MSI-X vectors requested for allocation by device driver
.SH "DESCRIPTION"
Setup the MSI-X capability structure of device function with the number
of requested vectors upon its software driver call to request for
MSI-X mode enabled on its hardware device function. A return of zero
indicates the successful configuration of MSI-X capability structure
with new allocated MSI-X vectors. A return of &lt; 0 indicates a failure.
Or a return of &gt; 0 indicates that driver request is exceeding the number
of vectors available. Driver should use the returned value to re-send
its request.
.TH "msi_remove_pci_irq_vectors" 9 "msi_remove_pci_irq_vectors" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
msi_remove_pci_irq_vectors \-  reclaim MSI(X) vectors to unused state
.SH SYNOPSIS
.B "void" msi_remove_pci_irq_vectors
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the pci_dev data structure of MSI(X) device function
.SH "DESCRIPTION"
Being called during hotplug remove, from which the device function
is hot-removed. All previous assigned MSI/MSI-X vectors, if
allocated for this device function, are reclaimed to unused state,
which may be used later on.
.TH "pci_read_legacy_io" 9 "pci_read_legacy_io" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_read_legacy_io \-  read byte(s) from legacy I/O port space
.SH SYNOPSIS
.B "ssize_t" pci_read_legacy_io
.BI "(struct kobject *" kobj ","
.BI "char *" buf ","
.BI "loff_t " off ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "kobj" 12
 kobject corresponding to file to read from
.IP "buf" 12
 buffer to store results
.IP "off" 12
 offset into legacy I/O port space
.IP "count" 12
 number of bytes to read
.SH "DESCRIPTION"
Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_read).
.TH "pci_write_legacy_io" 9 "pci_write_legacy_io" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_write_legacy_io \-  write byte(s) to legacy I/O port space
.SH SYNOPSIS
.B "ssize_t" pci_write_legacy_io
.BI "(struct kobject *" kobj ","
.BI "char *" buf ","
.BI "loff_t " off ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "kobj" 12
 kobject corresponding to file to read from
.IP "buf" 12
 buffer containing value to be written
.IP "off" 12
 offset into legacy I/O port space
.IP "count" 12
 number of bytes to write
.SH "DESCRIPTION"
Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_write).
.TH "pci_mmap_legacy_mem" 9 "pci_mmap_legacy_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_mmap_legacy_mem \-  map legacy PCI memory into user memory space
.SH SYNOPSIS
.B "int" pci_mmap_legacy_mem
.BI "(struct kobject *" kobj ","
.BI "struct bin_attribute *" attr ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "kobj" 12
 kobject corresponding to device to be mapped
.IP "attr" 12
 struct bin_attribute for this file
.IP "vma" 12
 struct vm_area_struct passed to mmap
.SH "DESCRIPTION"
Uses an arch specific callback, pci_mmap_legacy_page_range, to mmap
legacy memory space (first meg of bus space) into application virtual
memory space.
.TH "pci_mmap_resource" 9 "pci_mmap_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_mmap_resource \-  map a PCI resource into user memory space
.SH SYNOPSIS
.B "int" pci_mmap_resource
.BI "(struct kobject *" kobj ","
.BI "struct bin_attribute *" attr ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "kobj" 12
 kobject for mapping
.IP "attr" 12
 struct bin_attribute for the file being mapped
.IP "vma" 12
 struct vm_area_struct passed into the mmap
.SH "DESCRIPTION"
Use the regular PCI mapping routines to map a PCI resource into userspace.
.SH "FIXME"
 write combining?  maybe automatic for prefetchable regions?
.TH "pci_create_resource_files" 9 "pci_create_resource_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_create_resource_files \-  create resource files in sysfs for @dev
.SH SYNOPSIS
.B "void" pci_create_resource_files
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.SH "DESCRIPTION"
Walk the resources in \fIdev\fP creating files for each resource available.
.TH "pci_remove_resource_files" 9 "pci_remove_resource_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_remove_resource_files \-  cleanup resource files
.SH SYNOPSIS
.B "void" pci_remove_resource_files
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.SH "DESCRIPTION"
If we created resource files for \fIdev\fP, remove them from sysfs and
free their resources.
.TH "pci_write_rom" 9 "pci_write_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_write_rom \-  used to enable access to the PCI ROM display
.SH SYNOPSIS
.B "ssize_t" pci_write_rom
.BI "(struct kobject *" kobj ","
.BI "char *" buf ","
.BI "loff_t " off ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "kobj" 12
 kernel object handle
.IP "buf" 12
 user input
.IP "off" 12
 file offset
.IP "count" 12
 number of byte in input
.SH "DESCRIPTION"
writing anything except 0 enables it
.TH "pci_read_rom" 9 "pci_read_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_read_rom \-  read a PCI ROM
.SH SYNOPSIS
.B "ssize_t" pci_read_rom
.BI "(struct kobject *" kobj ","
.BI "char *" buf ","
.BI "loff_t " off ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "kobj" 12
 kernel object handle
.IP "buf" 12
 where to put the data we read from the ROM
.IP "off" 12
 file offset
.IP "count" 12
 number of bytes to read
.SH "DESCRIPTION"
Put \fIcount\fP bytes starting at \fIoff\fP into \fIbuf\fP from the ROM in the PCI
device corresponding to \fIkobj\fP.
.TH "pci_remove_sysfs_dev_files" 9 "pci_remove_sysfs_dev_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_remove_sysfs_dev_files \-  cleanup PCI specific sysfs files
.SH SYNOPSIS
.B "void" pci_remove_sysfs_dev_files
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 device whose entries we should free
.SH "DESCRIPTION"
Cleanup when \fIpdev\fP is removed from sysfs.
.TH "store_new_id" 9 "store_new_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
store_new_id \- 
.SH SYNOPSIS
.B "ssize_t" store_new_id
.BI "(struct device_driver *" driver ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"

Adds a new dynamic pci device ID to this driver,
and causes the driver to probe for all devices again.
.TH "pci_match_id" 9 "pci_match_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_match_id \-  See if a pci device matches a given pci_id table
.SH SYNOPSIS
.B "const struct pci_device_id *" pci_match_id
.BI "(const struct pci_device_id *" ids ","
.BI "struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "ids" 12
 array of PCI device id structures to search in
.IP "dev" 12
 the PCI device structure to match against.
.SH "DESCRIPTION"
Used by a driver to check whether a PCI device present in the
system is in its list of supported devices.  Returns the matching
pci_device_id structure or NULL if there is no match.

Depreciated, don't use this as it will not catch any dynamic ids
that a driver might want to check for.
.TH "pci_match_device" 9 "pci_match_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_match_device \-  Tell if a PCI device structure has a matching
.SH SYNOPSIS
.B "const struct pci_device_id *" pci_match_device
.BI "(struct pci_driver *" drv ","
.BI "struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "drv" 12
 the PCI driver to match against
.IP "dev" 12
 the PCI device structure to match against
.SH "DESCRIPTION"
Used by a driver to check whether a PCI device present in the
system is in its list of supported devices.  Returns the matching
pci_device_id structure or NULL if there is no match.
.SH "DESCRIPTION"
Used by a driver to check whether a PCI device present in the
system is in its list of supported devices.  Returns the matching
pci_device_id structure or NULL if there is no match.
.TH "__pci_device_probe" 9 "__pci_device_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__pci_device_probe \- 
.SH SYNOPSIS
.B "int" __pci_device_probe
.BI "(struct pci_driver *" drv ","
.BI "struct pci_dev *" pci_dev ");"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.IP "pci_dev" 12
-- undescribed --
.SH "DESCRIPTION"

returns 0  on success, else error.
side-effect: pci_dev-&gt;driver is set to drv when drv claims pci_dev.
.TH "pci_register_driver" 9 "pci_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_register_driver \-  register a new pci driver
.SH SYNOPSIS
.B "int" pci_register_driver
.BI "(struct pci_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 the driver structure to register
.SH "DESCRIPTION"
Adds the driver structure to the list of registered drivers.
Returns a negative value on error, otherwise 0. 
If no error occurred, the driver remains registered even if 
no device was claimed during registration.
.TH "pci_unregister_driver" 9 "pci_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_unregister_driver \-  unregister a pci driver
.SH SYNOPSIS
.B "void" pci_unregister_driver
.BI "(struct pci_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 the driver structure to unregister
.SH "DESCRIPTION"
Deletes the driver structure from the list of registered PCI drivers,
gives it a chance to clean up by calling its \fBremove\fP function for
each device it was responsible for, and marks those devices as
driverless.
.TH "pci_dev_driver" 9 "pci_dev_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_dev_driver \-  get the pci_driver of a device
.SH SYNOPSIS
.B "struct pci_driver *" pci_dev_driver
.BI "(const struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device to query
.SH "DESCRIPTION"
Returns the appropriate pci_driver structure or NULL if there is no 
registered driver for the device.
.TH "pci_bus_match" 9 "pci_bus_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_bus_match \-  Tell if a PCI device structure has a matching PCI device id structure
.SH SYNOPSIS
.B "int" pci_bus_match
.BI "(struct device *" dev ","
.BI "struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "dev" 12
 the PCI device structure to match against
.IP "drv" 12
-- undescribed --
.SH "DESCRIPTION"
Used by a driver to check whether a PCI device present in the
system is in its list of supported devices.Returns the matching
pci_device_id structure or NULL if there is no match.
.TH "pci_dev_get" 9 "pci_dev_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_dev_get \-  increments the reference count of the pci device structure
.SH SYNOPSIS
.B "struct pci_dev *" pci_dev_get
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device being referenced
.SH "DESCRIPTION"
Each live reference to a device should be refcounted.

Drivers for PCI devices should normally record such references in
their \fBprobe\fP methods, when they bind to a device, and release
them by calling \fBpci_dev_put\fP, in their \fBdisconnect\fP methods.

A pointer to the device with the incremented reference counter is returned.
.TH "pci_dev_put" 9 "pci_dev_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_dev_put \-  release a use of the pci device structure
.SH SYNOPSIS
.B "void" pci_dev_put
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device that's been disconnected
.SH "DESCRIPTION"
Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.
.TH "pci_create_legacy_files" 9 "pci_create_legacy_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_create_legacy_files \-  create legacy I/O port and memory files
.SH SYNOPSIS
.B "void" pci_create_legacy_files
.BI "(struct pci_bus *" b ");"
.SH ARGUMENTS
.IP "b" 12
 bus to create files under
.SH "DESCRIPTION"
Some platforms allow access to legacy I/O port and ISA memory space on
a per-bus basis.  This routine creates the files and ties them into
their associated read, write and mmap files from pci-sysfs.c
.TH "pci_setup_device" 9 "pci_setup_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_setup_device \-  fill in class and map information of a device
.SH SYNOPSIS
.B "int" pci_setup_device
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device structure to fill
.SH "DESCRIPTION"
Initialize the device structure with information about the device's 
vendor,class,memory and IO-space addresses,IRQ lines etc.
Called at initialisation of the PCI subsystem and by CardBus services.
Returns 0 on success and -1 if unknown type of device (not normal, bridge
or CardBus).
.TH "pci_release_dev" 9 "pci_release_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_release_dev \-  free a pci device structure when all users of it are finished.
.SH SYNOPSIS
.B "void" pci_release_dev
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device that's been disconnected
.SH "DESCRIPTION"
Will be called only by the device core when all users of this pci device are
done.
.TH "pci_cfg_space_size" 9 "pci_cfg_space_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_cfg_space_size \-  get the configuration space size of the PCI device.
.SH SYNOPSIS
.B "int" pci_cfg_space_size
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Regular PCI devices have 256 bytes, but PCI-X 2 and PCI Express devices
have 4096 bytes.  Even if the device is capable, that doesn't mean we can
access it.  Maybe we don't have a way to generate extended config space
accesses, or the device is behind a reverse Express bridge.  So we try
reading the dword at 0x100 which must either be 0 or a valid extended
capability header.
.TH "pci_scan_slot" 9 "pci_scan_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_scan_slot \-  scan a PCI slot on a bus for devices.
.SH SYNOPSIS
.B "int __devinit" pci_scan_slot
.BI "(struct pci_bus *" bus ","
.BI "int " devfn ");"
.SH ARGUMENTS
.IP "bus" 12
 PCI bus to scan
.IP "devfn" 12
 slot number to scan (must have zero function.)
.SH "DESCRIPTION"
Scan a PCI slot on the specified PCI bus for devices, adding
discovered devices to the \fIbus\fP-&gt;devices list.  New devices
will have an empty dev-&gt;global_list head.
.TH "pci_match_one_device" 9 "pci_match_one_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_match_one_device \-  Tell if a PCI device structure has a matching
.SH SYNOPSIS
.B "const struct pci_device_id *" pci_match_one_device
.BI "(const struct pci_device_id *" id ","
.BI "const struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "id" 12
 single PCI device id structure to match
.IP "dev" 12
 the PCI device structure to match against
.SH "DESCRIPTION"
Returns the matching pci_device_id structure or NULL if there is no match.
.SH "DESCRIPTION"
Returns the matching pci_device_id structure or NULL if there is no match.
.TH "pci_osc_support_set" 9 "pci_osc_support_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_osc_support_set \-  register OS support to Firmware
.SH SYNOPSIS
.B "acpi_status" pci_osc_support_set
.BI "(u32 " flags ");"
.SH ARGUMENTS
.IP "flags" 12
 OS support bits
.SH "DESCRIPTION"
Update OS support fields and doing a _OSC Query to obtain an update
from Firmware on supported control bits.
.TH "pci_osc_control_set" 9 "pci_osc_control_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_osc_control_set \-  commit requested control to Firmware
.SH SYNOPSIS
.B "acpi_status" pci_osc_control_set
.BI "(u32 " flags ");"
.SH ARGUMENTS
.IP "flags" 12
 driver's requested control bits
.SH "DESCRIPTION"
Attempt to take control from Firmware on requested control bits.
.TH "dlpar_add_slot" 9 "dlpar_add_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dlpar_add_slot \-  DLPAR add an I/O Slot
.SH SYNOPSIS
.B "int" dlpar_add_slot
.BI "(char *" drc_name ");"
.SH ARGUMENTS
.IP "drc_name" 12
 drc-name of newly added slot
.SH "DESCRIPTION"
Make the hotplug module and the kernel aware
of a newly added I/O Slot.
Return Codes -
0			Success
-ENODEV		Not a valid drc_name
-EINVAL		Slot already added
-ERESTARTSYS		Signalled before obtaining lock
-EIO			Internal PCI Error
.TH "dlpar_remove_vio_slot" 9 "dlpar_remove_vio_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dlpar_remove_vio_slot \-  DLPAR remove a virtual I/O Slot
.SH SYNOPSIS
.B "int" dlpar_remove_vio_slot
.BI "(char *" drc_name ","
.BI "struct device_node *" dn ");"
.SH ARGUMENTS
.IP "drc_name" 12
 drc-name of newly added slot
.IP "dn" 12
-- undescribed --
.SH "DESCRIPTION"
Remove the kernel and hotplug representations
of an I/O Slot.
.SH "RETURN CODES"
0			Success
-EINVAL		Vio dev doesn't exist
.TH "dlpar_remove_pci_slot" 9 "dlpar_remove_pci_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dlpar_remove_pci_slot \-  DLPAR remove a PCI I/O Slot
.SH SYNOPSIS
.B "int" dlpar_remove_pci_slot
.BI "(char *" drc_name ","
.BI "struct device_node *" dn ");"
.SH ARGUMENTS
.IP "drc_name" 12
 drc-name of newly added slot
.IP "dn" 12
-- undescribed --
.SH "DESCRIPTION"
Remove the kernel and hotplug representations
of a PCI I/O Slot.
.SH "RETURN CODES"
0			Success
-ENODEV		Not a valid drc_name
-EIO			Internal PCI Error
.TH "dlpar_remove_slot" 9 "dlpar_remove_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dlpar_remove_slot \-  DLPAR remove an I/O Slot
.SH SYNOPSIS
.B "int" dlpar_remove_slot
.BI "(char *" drc_name ");"
.SH ARGUMENTS
.IP "drc_name" 12
 drc-name of newly added slot
.SH "DESCRIPTION"
Remove the kernel and hotplug representations
of an I/O Slot.
.SH "RETURN CODES"
0			Success
-ENODEV		Not a valid drc_name
-EINVAL		Slot already removed
-ERESTARTSYS		Signalled before obtaining lock
-EIO			Internal Error
.TH "Kernel API" 9 "struct hpp_param" "January 2021" "API Manual" LINUX
.SH NAME
struct hpp_param \-  ACPI 2.0 _HPP Hot Plug Parameters
.SH SYNOPSIS
struct hpp_param {
.br
};
.br
.SH Arguments
.SH "Description"
\fIcache_line_size\fP in DWORD
\fIlatency_timer\fP in PCI clock
\fIenable_SERR\fP 0 or 1
\fIenable_PERR\fP 0 or 1
.TH "Kernel API" 9 "struct acpiphp_bridge" "January 2021" "API Manual" LINUX
.SH NAME
struct acpiphp_bridge \-  PCI bridge information
.SH SYNOPSIS
struct acpiphp_bridge {
.br
};
.br
.SH Arguments
.SH "Description"

for each bridge device in ACPI namespace
.TH "Kernel API" 9 "struct acpiphp_slot" "January 2021" "API Manual" LINUX
.SH NAME
struct acpiphp_slot \-  PCI slot information
.SH SYNOPSIS
struct acpiphp_slot {
.br
};
.br
.SH Arguments
.SH "Description"

PCI slot information for each *physical* PCI slot
.TH "Kernel API" 9 "struct acpiphp_func" "January 2021" "API Manual" LINUX
.SH NAME
struct acpiphp_func \-  PCI function information
.SH SYNOPSIS
struct acpiphp_func {
.br
};
.br
.SH Arguments
.SH "Description"

PCI function information for each object in ACPI namespace
typically 8 objects per slot (i.e. for each PCI function)
.TH "Kernel API" 9 "struct acpiphp_attention_info" "January 2021" "API Manual" LINUX
.SH NAME
struct acpiphp_attention_info \-  device specific attention registration
.SH SYNOPSIS
struct acpiphp_attention_info {
.br
};
.br
.SH Arguments
.SH "Description"

ACPI has no generic method of setting/getting attention status
this allows for device specific driver registration
.TH "pci_rescan_slot" 9 "pci_rescan_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_rescan_slot \- 
.SH SYNOPSIS
.B "void" pci_rescan_slot
.BI "(struct pci_dev *" temp ");"
.SH ARGUMENTS
.IP "temp" 12
-- undescribed --
.SH "DESCRIPTION"
Tries hard not to re-enable already existing devices
also handles scanning of subfunctions

\fIparam\fP temp   Device template. Should be set: bus and devfn.
.TH "pci_rescan_bus" 9 "pci_rescan_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_rescan_bus \- 
.SH SYNOPSIS
.B "void" pci_rescan_bus
.BI "(const struct pci_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
-- undescribed --
.SH "DESCRIPTION"
call pci_rescan_slot for each possible function of the bus

\fIparam\fP bus
.TH "init_slots" 9 "init_slots" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_slots \-  initialize 'struct slot' structures for each slot
.SH SYNOPSIS
.B "int __init" init_slots
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "return_resource_list" 9 "return_resource_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
return_resource_list \- 
.SH SYNOPSIS
.B "void" return_resource_list
.BI "(struct pci_resource **" func ","
.BI "struct pci_resource **" res ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "res" 12
 resource list to free
.TH "kfree_resource_list" 9 "kfree_resource_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfree_resource_list \- 
.SH SYNOPSIS
.B "void" kfree_resource_list
.BI "(struct pci_resource **" r ");"
.SH ARGUMENTS
.IP "r" 12
-- undescribed --
.TH "pciehp_destroy_resource_list" 9 "pciehp_destroy_resource_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pciehp_destroy_resource_list \- 
.SH SYNOPSIS
.B "void" pciehp_destroy_resource_list
.BI "(struct resource_lists *" resources ");"
.SH ARGUMENTS
.IP "resources" 12
 list to put nodes back
.TH "pciehp_destroy_board_resources" 9 "pciehp_destroy_board_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pciehp_destroy_board_resources \- 
.SH SYNOPSIS
.B "void" pciehp_destroy_board_resources
.BI "(struct pci_func *" func ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.TH "set_attention_status" 9 "set_attention_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_attention_status \-  set attention LED
.SH SYNOPSIS
.B "int" set_attention_status
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u8 " value ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
-- undescribed --
.IP "value" 12
-- undescribed --
.SH "DESCRIPTION"
echo 0 &gt; attention -- set LED OFF
echo 1 &gt; attention -- set LED ON
echo 2 &gt; attention -- set LED ID(identify, light is blinking)
.TH "get_power_status" 9 "get_power_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_power_status \-  get power status of a slot
.SH SYNOPSIS
.B "int" get_power_status
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u8 *" value ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to get status
.IP "value" 12
 pointer to store status
.SH "DESCRIPTION"
.TH "get_attention_status" 9 "get_attention_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_attention_status \-  get attention LED status
.SH SYNOPSIS
.B "int" get_attention_status
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u8 *" value ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
-- undescribed --
.IP "value" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "return_resource_list" 9 "return_resource_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
return_resource_list \- 
.SH SYNOPSIS
.B "void" return_resource_list
.BI "(struct pci_resource **" func ","
.BI "struct pci_resource **" res ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "res" 12
 resource list to free
.TH "kfree_resource_list" 9 "kfree_resource_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfree_resource_list \- 
.SH SYNOPSIS
.B "void" kfree_resource_list
.BI "(struct pci_resource **" r ");"
.SH ARGUMENTS
.IP "r" 12
-- undescribed --
.TH "shpchp_destroy_resource_list" 9 "shpchp_destroy_resource_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shpchp_destroy_resource_list \- 
.SH SYNOPSIS
.B "void" shpchp_destroy_resource_list
.BI "(struct resource_lists *" resources ");"
.SH ARGUMENTS
.IP "resources" 12
 list to put nodes back
.TH "shpchp_destroy_board_resources" 9 "shpchp_destroy_board_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shpchp_destroy_board_resources \- 
.SH SYNOPSIS
.B "void" shpchp_destroy_board_resources
.BI "(struct pci_func *" func ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.TH "is_ejectable" 9 "is_ejectable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_ejectable \-  determine if a slot is ejectable
.SH SYNOPSIS
.B "int" is_ejectable
.BI "(acpi_handle " handle ");"
.SH ARGUMENTS
.IP "handle" 12
 handle to acpi namespace
.SH "EJECTABLE SLOT SHOULD SATISFY AT LEAST THESE CONDITIONS"

1. has _ADR method
2. has _EJ0 method

optionally

1. has _STA method
2. has _PS0 method
3. has _PS3 method
4. ..
.TH "enable_device" 9 "enable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_device \-  enable, configure a slot
.SH SYNOPSIS
.B "int" enable_device
.BI "(struct acpiphp_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
 slot to be enabled
.SH "DESCRIPTION"
This function should be called per *physical slot*,
not per each slot object in ACPI namespace.
.TH "disable_device" 9 "disable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_device \-  disable a slot
.SH SYNOPSIS
.B "int" disable_device
.BI "(struct acpiphp_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.TH "get_slot_status" 9 "get_slot_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_slot_status \-  get ACPI slot status
.SH SYNOPSIS
.B "unsigned int" get_slot_status
.BI "(struct acpiphp_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

if a slot has _STA for each function and if any one of them
returned non-zero status, return it

if a slot doesn't have _STA and if any one of its functions'
configuration space is configured, return 0x0f as a _STA

otherwise return 0
.TH "acpiphp_eject_slot" 9 "acpiphp_eject_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_eject_slot \-  physically eject the slot
.SH SYNOPSIS
.B "int" acpiphp_eject_slot
.BI "(struct acpiphp_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.TH "acpiphp_check_bridge" 9 "acpiphp_check_bridge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_check_bridge \-  re-enumerate devices
.SH SYNOPSIS
.B "int" acpiphp_check_bridge
.BI "(struct acpiphp_bridge *" bridge ");"
.SH ARGUMENTS
.IP "bridge" 12
-- undescribed --
.SH "DESCRIPTION"

Iterate over all slots under this bridge and make sure that if a
card is present they are enabled, and if not they are disabled.
.TH "handle_hotplug_event_bridge" 9 "handle_hotplug_event_bridge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
handle_hotplug_event_bridge \-  handle ACPI event on bridges
.SH SYNOPSIS
.B "void" handle_hotplug_event_bridge
.BI "(acpi_handle " handle ","
.BI "u32 " type ","
.BI "void *" context ");"
.SH ARGUMENTS
.IP "handle" 12
 \fBNotify\fP'ed acpi_handle
.IP "type" 12
 Notify code
.IP "context" 12
 pointer to acpiphp_bridge structure
.SH "DESCRIPTION"
handles ACPI event notification on {host,p2p} bridges
.SH "DESCRIPTION"
handles ACPI event notification on {host,p2p} bridges
.TH "handle_hotplug_event_func" 9 "handle_hotplug_event_func" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
handle_hotplug_event_func \-  handle ACPI event on functions (i.e. slots)
.SH SYNOPSIS
.B "void" handle_hotplug_event_func
.BI "(acpi_handle " handle ","
.BI "u32 " type ","
.BI "void *" context ");"
.SH ARGUMENTS
.IP "handle" 12
 \fBNotify\fP'ed acpi_handle
.IP "type" 12
 Notify code
.IP "context" 12
 pointer to acpiphp_func structure
.SH "DESCRIPTION"
handles ACPI event notification on slots
.SH "DESCRIPTION"
handles ACPI event notification on slots
.TH "acpiphp_glue_init" 9 "acpiphp_glue_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_glue_init \-  initializes all PCI hotplug - ACPI glue data structures
.SH SYNOPSIS
.B "int __init" acpiphp_glue_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "acpiphp_glue_exit" 9 "acpiphp_glue_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_glue_exit \-  terminates all PCI hotplug - ACPI glue data structures
.SH SYNOPSIS
.B "void __exit" acpiphp_glue_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function frees all data allocated in \fBacpiphp_glue_init\fP
.TH "acpiphp_get_num_slots" 9 "acpiphp_get_num_slots" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_get_num_slots \-  count number of slots in a system
.SH SYNOPSIS
.B "int __init" acpiphp_get_num_slots
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "acpiphp_for_each_slot" 9 "acpiphp_for_each_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_for_each_slot \-  call function for each slot
.SH SYNOPSIS
.B "int" acpiphp_for_each_slot
.BI "(acpiphp_callback " fn ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "fn" 12
 callback function
.IP "data" 12
 context to be passed to callback function
.TH "acpiphp_enable_slot" 9 "acpiphp_enable_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_enable_slot \-  power on slot
.SH SYNOPSIS
.B "int" acpiphp_enable_slot
.BI "(struct acpiphp_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.TH "acpiphp_disable_slot" 9 "acpiphp_disable_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_disable_slot \-  power off slot
.SH SYNOPSIS
.B "int" acpiphp_disable_slot
.BI "(struct acpiphp_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.TH "cpqhp_find_slot" 9 "cpqhp_find_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpqhp_find_slot \- 
.SH SYNOPSIS
.B "struct slot *" cpqhp_find_slot
.BI "(struct controller *" ctrl ","
.BI "u8 " device ");"
.SH ARGUMENTS
.IP "ctrl" 12
 scan lots of this controller
.IP "device" 12
 the device id to find
.TH "sort_by_size" 9 "sort_by_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sort_by_size \- 
.SH SYNOPSIS
.B "int" sort_by_size
.BI "(struct pci_resource **" head ");"
.SH ARGUMENTS
.IP "head" 12
 list to sort
.TH "sort_by_max_size" 9 "sort_by_max_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sort_by_max_size \- 
.SH SYNOPSIS
.B "int" sort_by_max_size
.BI "(struct pci_resource **" head ");"
.SH ARGUMENTS
.IP "head" 12
 list to sort
.TH "do_pre_bridge_resource_split" 9 "do_pre_bridge_resource_split" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_pre_bridge_resource_split \- 
.SH SYNOPSIS
.B "struct pci_resource *" do_pre_bridge_resource_split
.BI "(struct pci_resource **" head ","
.BI "struct pci_resource **" orig_head ","
.BI "u32 " alignment ");"
.SH ARGUMENTS
.IP "head" 12
-- undescribed --
.IP "orig_head" 12
-- undescribed --
.IP "alignment" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "do_bridge_resource_split" 9 "do_bridge_resource_split" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_bridge_resource_split \- 
.SH SYNOPSIS
.B "struct pci_resource *" do_bridge_resource_split
.BI "(struct pci_resource **" head ","
.BI "u32 " alignment ");"
.SH ARGUMENTS
.IP "head" 12
-- undescribed --
.IP "alignment" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "get_io_resource" 9 "get_io_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_io_resource \- 
.SH SYNOPSIS
.B "struct pci_resource *" get_io_resource
.BI "(struct pci_resource **" head ","
.BI "u32 " size ");"
.SH ARGUMENTS
.IP "head" 12
 list to search
.IP "size" 12
 size of node to find, must be a power of two.
.SH "DESCRIPTION"
 this function sorts the resource list by size and then returns
returns the first node of "size" length that is not in the ISA aliasing
window.  If it finds a node larger than "size" it will split it up.
.TH "get_max_resource" 9 "get_max_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_max_resource \- 
.SH SYNOPSIS
.B "struct pci_resource *" get_max_resource
.BI "(struct pci_resource **" head ","
.BI "u32 " size ");"
.SH ARGUMENTS
.IP "head" 12
 the list to search the node in
.IP "size" 12
 the minimum size of the node to find
.SH "DESCRIPTION"
 Gets the largest node that is at least "size" big from the
list pointed to by head.  It aligns the node on top and bottom
to "size" alignment before returning it.
.TH "get_resource" 9 "get_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_resource \- 
.SH SYNOPSIS
.B "struct pci_resource *" get_resource
.BI "(struct pci_resource **" head ","
.BI "u32 " size ");"
.SH ARGUMENTS
.IP "head" 12
 the list to search for resources
.IP "size" 12
 the size limit to use
.SH "DESCRIPTION"
 This function sorts the resource list by size and then
returns the first node of "size" length.  If it finds a node
larger than "size" it will split it up.

size must be a power of two.
.TH "cpqhp_resource_sort_and_combine" 9 "cpqhp_resource_sort_and_combine" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpqhp_resource_sort_and_combine \- 
.SH SYNOPSIS
.B "int" cpqhp_resource_sort_and_combine
.BI "(struct pci_resource **" head ");"
.SH ARGUMENTS
.IP "head" 12
 the list to sort and clean up
.SH "DESCRIPTION"
 Sorts all of the nodes in the list in ascending order by
their base addresses.  Also does garbage collection by
combining adjacent nodes.

returns 0 if success
.TH "cpqhp_slot_create" 9 "cpqhp_slot_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpqhp_slot_create \-  Creates a node and adds it to the proper bus.
.SH SYNOPSIS
.B "struct pci_func *" cpqhp_slot_create
.BI "(u8 " busnumber ");"
.SH ARGUMENTS
.IP "busnumber" 12
-- undescribed --
.SH "DESCRIPTION"
\fIbusnumber\fP - bus where new node is to be located

Returns pointer to the new node or NULL if unsuccessful
.TH "slot_remove" 9 "slot_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
slot_remove \-  Removes a node from the linked list of slots.
.SH SYNOPSIS
.B "int" slot_remove
.BI "(struct pci_func *" old_slot ");"
.SH ARGUMENTS
.IP "old_slot" 12
 slot to remove
.SH "DESCRIPTION"
Returns 0 if successful, !0 otherwise.
.TH "bridge_slot_remove" 9 "bridge_slot_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bridge_slot_remove \-  Removes a node from the linked list of slots.
.SH SYNOPSIS
.B "int" bridge_slot_remove
.BI "(struct pci_func *" bridge ");"
.SH ARGUMENTS
.IP "bridge" 12
 bridge to remove
.SH "DESCRIPTION"
Returns 0 if successful, !0 otherwise.
.TH "cpqhp_slot_find" 9 "cpqhp_slot_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpqhp_slot_find \-  Looks for a node by bus, and device, multiple functions accessed
.SH SYNOPSIS
.B "struct pci_func *" cpqhp_slot_find
.BI "(u8 " bus ","
.BI "u8 " device ","
.BI "u8 " index ");"
.SH ARGUMENTS
.IP "bus" 12
 bus to find
.IP "device" 12
 device to find
.IP "index" 12
 is 0 for first function found, 1 for the second...
.SH "DESCRIPTION"
Returns pointer to the node if successful, NULL otherwise.
.TH "set_controller_speed" 9 "set_controller_speed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_controller_speed \-  set the frequency and/or mode of a specific
.SH SYNOPSIS
.B "u8" set_controller_speed
.BI "(struct controller *" ctrl ","
.BI "u8 " adapter_speed ","
.BI "u8 " hp_slot ");"
.SH ARGUMENTS
.IP "ctrl" 12
 controller to change frequency/mode for.
.IP "adapter_speed" 12
 the speed of the adapter we want to match.
.IP "hp_slot" 12
 the slot number where the adapter is installed.
.SH "DESCRIPTION"
Returns 0 if we successfully change frequency and/or mode to match the
adapter speed.
.SH "DESCRIPTION"
Returns 0 if we successfully change frequency and/or mode to match the
adapter speed.
.TH "board_replaced" 9 "board_replaced" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
board_replaced \-  Called after a board has been replaced in the system.
.SH SYNOPSIS
.B "u32" board_replaced
.BI "(struct pci_func *" func ","
.BI "struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"

This is only used if we don't have resources for hot add
Turns power on for the board
Checks to see if board is the same
If board is same, reconfigures it
If board isn't same, turns it back off.
.TH "board_added" 9 "board_added" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
board_added \-  Called after a board has been added to the system.
.SH SYNOPSIS
.B "u32" board_added
.BI "(struct pci_func *" func ","
.BI "struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"

Turns power on for the board
Configures board
.TH "remove_board" 9 "remove_board" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
remove_board \-  Turns off slot and LED's
.SH SYNOPSIS
.B "u32" remove_board
.BI "(struct pci_func *" func ","
.BI "u32 " replace_flag ","
.BI "struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "replace_flag" 12
-- undescribed --
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "cpqhp_pushbutton_thread" 9 "cpqhp_pushbutton_thread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpqhp_pushbutton_thread \- 
.SH SYNOPSIS
.B "void" cpqhp_pushbutton_thread
.BI "(unsigned long " slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

Scheduled procedure to handle blocking stuff for the pushbuttons
Handles all pending events and exits.
.TH "switch_leds" 9 "switch_leds" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
switch_leds \- 
.SH SYNOPSIS
.B "void" switch_leds
.BI "(struct controller *" ctrl ","
.BI "const int " num_of_slots ","
.BI "u32 *" work_LED ","
.BI "const int " direction ");"
.SH ARGUMENTS
.IP "ctrl" 12
 controller to use
.IP "num_of_slots" 12
 number of slots to use
.IP "work_LED" 12
-- undescribed --
.IP "direction" 12
 1 to start from the left side, 0 to start right.
.TH "cpqhp_hardware_test" 9 "cpqhp_hardware_test" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpqhp_hardware_test \-  runs hardware tests
.SH SYNOPSIS
.B "int" cpqhp_hardware_test
.BI "(struct controller *" ctrl ","
.BI "int " test_num ");"
.SH ARGUMENTS
.IP "ctrl" 12
-- undescribed --
.IP "test_num" 12
-- undescribed --
.SH "DESCRIPTION"

For hot plug ctrl folks to play with.
test_num is the number written to the "test" file in sysfs
.TH "configure_new_device" 9 "configure_new_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
configure_new_device \-  Configures the PCI header information of one board.
.SH SYNOPSIS
.B "u32" configure_new_device
.BI "(struct controller *" ctrl ","
.BI "struct pci_func *" func ","
.BI "u8 " behind_bridge ","
.BI "struct resource_lists *" resources ");"
.SH ARGUMENTS
.IP "ctrl" 12
 pointer to controller structure
.IP "func" 12
 pointer to function structure
.IP "behind_bridge" 12
 1 if this is a recursive call, 0 if not
.IP "resources" 12
 pointer to set of resource lists
.SH "DESCRIPTION"
Returns 0 if success
.SH "DESCRIPTION"
Returns 0 if success
.TH "configure_new_function" 9 "configure_new_function" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
configure_new_function \-  Configures the PCI header information of one device
.SH SYNOPSIS
.B "int" configure_new_function
.BI "(struct controller *" ctrl ","
.BI "struct pci_func *" func ","
.BI "u8 " behind_bridge ","
.BI "struct resource_lists *" resources ");"
.SH ARGUMENTS
.IP "ctrl" 12
 pointer to controller structure
.IP "func" 12
 pointer to function structure
.IP "behind_bridge" 12
 1 if this is a recursive call, 0 if not
.IP "resources" 12
 pointer to set of resource lists
.SH "DESCRIPTION"
Calls itself recursively for bridged devices.
Returns 0 if success
.SH "DESCRIPTION"
Calls itself recursively for bridged devices.
Returns 0 if success
.TH "Kernel API" 9 "struct hotplug_slot_ops" "January 2021" "API Manual" LINUX
.SH NAME
struct hotplug_slot_ops \- the callbacks that the hotplug pci core can use
.SH SYNOPSIS
struct hotplug_slot_ops {
.br
.BI "    struct module *" owner ""
;

.br
.BI "    int (*" enable_slot ") (struct hotplug_slot *slot)"
;

.br
.BI "    int (*" disable_slot ") (struct hotplug_slot *slot)"
;

.br
.BI "    int (*" set_attention_status ") (struct hotplug_slot *slot, u8 value)"
;

.br
.BI "    int (*" hardware_test ") (struct hotplug_slot *slot, u32 value)"
;

.br
.BI "    int (*" get_power_status ") (struct hotplug_slot *slot, u8 *value)"
;

.br
.BI "    int (*" get_attention_status ") (struct hotplug_slot *slot, u8 *value)"
;

.br
.BI "    int (*" get_latch_status ") (struct hotplug_slot *slot, u8 *value)"
;

.br
.BI "    int (*" get_adapter_status ") (struct hotplug_slot *slot, u8 *value)"
;

.br
.BI "    int (*" get_address ") (struct hotplug_slot *slot, u32 *value)"
;

.br
.BI "    int (*" get_max_bus_speed ") (struct hotplug_slot *slot, enum pci_bus_speed *value)"
;

.br
.BI "    int (*" get_cur_bus_speed ") (struct hotplug_slot *slot, enum pci_bus_speed *value)"
;

.br
};
.br
.SH Arguments
.IP "owner" 12
 The module owner of this structure
.IP "enable_slot" 12
 Called when the user wants to enable a specific pci slot
.IP "disable_slot" 12
 Called when the user wants to disable a specific pci slot
.IP "set_attention_status" 12
 Called to set the specific slot's attention LED to
the specified value
.IP "hardware_test" 12
 Called to run a specified hardware test on the specified
slot.
.IP "get_power_status" 12
 Called to get the current power status of a slot.
If this field is NULL, the value passed in the struct hotplug_slot_info
will be used when this value is requested by a user.
.IP "get_attention_status" 12
 Called to get the current attention status of a slot.
If this field is NULL, the value passed in the struct hotplug_slot_info
will be used when this value is requested by a user.
.IP "get_latch_status" 12
 Called to get the current latch status of a slot.
If this field is NULL, the value passed in the struct hotplug_slot_info
will be used when this value is requested by a user.
.IP "get_adapter_status" 12
 Called to get see if an adapter is present in the slot or not.
If this field is NULL, the value passed in the struct hotplug_slot_info
will be used when this value is requested by a user.
.IP "get_address" 12
 Called to get pci address of a slot.
If this field is NULL, the value passed in the struct hotplug_slot_info
will be used when this value is requested by a user.
.IP "get_max_bus_speed" 12
 Called to get the max bus speed for a slot.
If this field is NULL, the value passed in the struct hotplug_slot_info
will be used when this value is requested by a user.
.IP "get_cur_bus_speed" 12
 Called to get the current bus speed for a slot.
If this field is NULL, the value passed in the struct hotplug_slot_info
will be used when this value is requested by a user.
.SH "Description"
The table of function pointers that is passed to the hotplug pci core by a
hotplug pci driver.  These functions are called by the hotplug pci core when
the user wants to do something to a specific slot (query it for information,
set an LED, enable / disable power, etc.)
.TH "Kernel API" 9 "struct hotplug_slot_info" "January 2021" "API Manual" LINUX
.SH NAME
struct hotplug_slot_info \-  used to notify the hotplug pci core of the state of the slot
.SH SYNOPSIS
struct hotplug_slot_info {
.br
.BI "    u8 " attention_status ""
;

.br
.BI "    u8 " latch_status ""
;

.br
.BI "    u32 " address ""
;

.br
};
.br
.SH Arguments
.IP "attention_status" 12
 if the attention light is enabled or not (1/0)
.IP "latch_status" 12
 if the latch (if any) is open or closed (1/0)
.IP "address" 12
 (domain &lt;&lt; 16 | bus &lt;&lt; 8 | dev)
.SH "Description"
Used to notify the hotplug pci core of the status of a specific slot.
.TH "Kernel API" 9 "struct hotplug_slot" "January 2021" "API Manual" LINUX
.SH NAME
struct hotplug_slot \-  used to register a physical slot with the hotplug pci core
.SH SYNOPSIS
struct hotplug_slot {
.br
.BI "    char *" name ""
;

.br
.BI "    struct hotplug_slot_ops *" ops ""
;

.br
.BI "    struct hotplug_slot_info *" info ""
;

.br
.BI "    void (*" release ") (struct hotplug_slot *slot)"
;

.br
.BI "    void *" private ""
;

.br
};
.br
.SH Arguments
.IP "name" 12
 the name of the slot being registered.  This string must
be unique amoung slots registered on this system.
.IP "ops" 12
 pointer to the &amp;struct hotplug_slot_ops to be used for this slot
.IP "info" 12
 pointer to the &amp;struct hotplug_slot_info for the initial values for
this slot.
.IP "release" 12
 called during pci_hp_deregister to free memory allocated in a
hotplug_slot structure.
.IP "private" 12
 used by the hotplug pci controller driver to store whatever it
needs.
.TH "release_slot" 9 "release_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
release_slot \-  free up the memory used by a slot
.SH SYNOPSIS
.B "void" release_slot
.BI "(struct hotplug_slot *" hotplug_slot ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to free
.TH "shpchp_slot_create" 9 "shpchp_slot_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shpchp_slot_create \-  Creates a node and adds it to the proper bus.
.SH SYNOPSIS
.B "struct pci_func *" shpchp_slot_create
.BI "(u8 " busnumber ");"
.SH ARGUMENTS
.IP "busnumber" 12
-- undescribed --
.SH "DESCRIPTION"
\fIbusnumber\fP - bus where new node is to be located

Returns pointer to the new node or NULL if unsuccessful
.TH "bridge_slot_remove" 9 "bridge_slot_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bridge_slot_remove \-  Removes a node from the linked list of slots.
.SH SYNOPSIS
.B "int" bridge_slot_remove
.BI "(struct pci_func *" bridge ");"
.SH ARGUMENTS
.IP "bridge" 12
 bridge to remove
.SH "DESCRIPTION"
Returns 0 if successful, !0 otherwise.
.TH "shpchp_slot_find" 9 "shpchp_slot_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shpchp_slot_find \-  Looks for a node by bus, and device, multiple functions accessed
.SH SYNOPSIS
.B "struct pci_func *" shpchp_slot_find
.BI "(u8 " bus ","
.BI "u8 " device ","
.BI "u8 " index ");"
.SH ARGUMENTS
.IP "bus" 12
 bus to find
.IP "device" 12
 device to find
.IP "index" 12
 is 0 for first function found, 1 for the second...
.SH "DESCRIPTION"
Returns pointer to the node if successful, NULL otherwise.
.TH "board_added" 9 "board_added" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
board_added \-  Called after a board has been added to the system.
.SH SYNOPSIS
.B "u32" board_added
.BI "(struct pci_func *" func ","
.BI "struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"

Turns power on for the board
Configures board
.TH "remove_board" 9 "remove_board" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
remove_board \-  Turns off slot and LED's
.SH SYNOPSIS
.B "u32" remove_board
.BI "(struct pci_func *" func ","
.BI "struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "shpchp_pushbutton_thread" 9 "shpchp_pushbutton_thread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
shpchp_pushbutton_thread \- 
.SH SYNOPSIS
.B "void" shpchp_pushbutton_thread
.BI "(unsigned long " slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

Scheduled procedure to handle blocking stuff for the pushbuttons
Handles all pending events and exits.
.TH "configure_new_device" 9 "configure_new_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
configure_new_device \-  Configures the PCI header information of one board.
.SH SYNOPSIS
.B "u32" configure_new_device
.BI "(struct controller *" ctrl ","
.BI "struct pci_func *" func ","
.BI "u8 " behind_bridge ","
.BI "struct resource_lists *" resources ","
.BI "u8 " bridge_bus ","
.BI "u8 " bridge_dev ");"
.SH ARGUMENTS
.IP "ctrl" 12
 pointer to controller structure
.IP "func" 12
 pointer to function structure
.IP "behind_bridge" 12
 1 if this is a recursive call, 0 if not
.IP "resources" 12
 pointer to set of resource lists
.IP "bridge_bus" 12
-- undescribed --
.IP "bridge_dev" 12
-- undescribed --
.SH "DESCRIPTION"
Returns 0 if success
.SH "DESCRIPTION"
Returns 0 if success
.TH "configure_new_function" 9 "configure_new_function" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
configure_new_function \-  Configures the PCI header information of one device
.SH SYNOPSIS
.B "int" configure_new_function
.BI "(struct controller *" ctrl ","
.BI "struct pci_func *" func ","
.BI "u8 " behind_bridge ","
.BI "struct resource_lists *" resources ","
.BI "u8 " bridge_bus ","
.BI "u8 " bridge_dev ");"
.SH ARGUMENTS
.IP "ctrl" 12
 pointer to controller structure
.IP "func" 12
 pointer to function structure
.IP "behind_bridge" 12
 1 if this is a recursive call, 0 if not
.IP "resources" 12
 pointer to set of resource lists
.IP "bridge_bus" 12
-- undescribed --
.IP "bridge_dev" 12
-- undescribed --
.SH "DESCRIPTION"
Calls itself recursively for bridged devices.
Returns 0 if success
.SH "DESCRIPTION"
Calls itself recursively for bridged devices.
Returns 0 if success
.TH "acpiphp_register_attention" 9 "acpiphp_register_attention" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_register_attention \-  set attention LED callback
.SH SYNOPSIS
.B "int" acpiphp_register_attention
.BI "(struct acpiphp_attention_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 must be completely filled with LED callbacks
.SH "DESCRIPTION"
 this is used to register a hardware specific ACPI
driver that manipulates the attention LED.  All the fields in
info must be set.
.TH "acpiphp_unregister_attention" 9 "acpiphp_unregister_attention" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpiphp_unregister_attention \-  unset attention LED callback
.SH SYNOPSIS
.B "int" acpiphp_unregister_attention
.BI "(struct acpiphp_attention_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 must match the pointer used to register
.SH "DESCRIPTION"
 this is used to un-register a hardware specific acpi
driver that manipulates the attention LED.  The pointer to the 
info struct must be the same as the one used to set it.
.TH "enable_slot" 9 "enable_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_slot \-  power on and enable a slot
.SH SYNOPSIS
.B "int" enable_slot
.BI "(struct hotplug_slot *" hotplug_slot ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to enable
.SH "DESCRIPTION"
Actual tasks are done in \fBacpiphp_enable_slot\fP
.TH "disable_slot" 9 "disable_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_slot \-  disable and power off a slot
.SH SYNOPSIS
.B "int" disable_slot
.BI "(struct hotplug_slot *" hotplug_slot ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to disable
.SH "DESCRIPTION"
Actual tasks are done in \fBacpiphp_disable_slot\fP
.TH "get_power_status" 9 "get_power_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_power_status \-  get power status of a slot
.SH SYNOPSIS
.B "int" get_power_status
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u8 *" value ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to get status
.IP "value" 12
 pointer to store status
.SH "DESCRIPTION"
Some platforms may not implement _STA method properly.
In that case, the value returned may not be reliable.
.TH "get_latch_status" 9 "get_latch_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_latch_status \-  get latch status of a slot
.SH SYNOPSIS
.B "int" get_latch_status
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u8 *" value ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to get status
.IP "value" 12
 pointer to store status
.SH "DESCRIPTION"
ACPI doesn't provide any formal means to access latch status.
Instead, we fake latch status from _STA
.TH "get_adapter_status" 9 "get_adapter_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_adapter_status \-  get adapter status of a slot
.SH SYNOPSIS
.B "int" get_adapter_status
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u8 *" value ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to get status
.IP "value" 12
 pointer to store status
.SH "DESCRIPTION"
ACPI doesn't provide any formal means to access adapter status.
Instead, we fake adapter status from _STA
.TH "get_address" 9 "get_address" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_address \-  get pci address of a slot
.SH SYNOPSIS
.B "int" get_address
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u32 *" value ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to get status
.IP "value" 12
 pointer to struct pci_busdev (seg, bus, dev)
.TH "make_slot_name" 9 "make_slot_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
make_slot_name \-  make a slot name that appears in pcihpfs
.SH SYNOPSIS
.B "void" make_slot_name
.BI "(struct slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
 slot to name
.TH "release_slot" 9 "release_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
release_slot \-  free up the memory used by a slot
.SH SYNOPSIS
.B "void" release_slot
.BI "(struct hotplug_slot *" hotplug_slot ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to free
.TH "init_slots" 9 "init_slots" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_slots \-  initialize 'struct slot' structures for each slot
.SH SYNOPSIS
.B "int __init" init_slots
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "rpaphp_get_pci_adapter_status" 9 "rpaphp_get_pci_adapter_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rpaphp_get_pci_adapter_status \-  get the status of a slot
.SH SYNOPSIS
.B "int" rpaphp_get_pci_adapter_status
.BI "(struct slot *" slot ","
.BI "int " is_init ","
.BI "u8 *" value ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.IP "is_init" 12
-- undescribed --
.IP "value" 12
-- undescribed --
.SH "DESCRIPTION"

0-- slot is empty
1-- adapter is configured
2-- adapter is not configured
3-- not valid
.TH "ibm_slot_from_id" 9 "ibm_slot_from_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibm_slot_from_id \-  workaround for bad ibm hardware
.SH SYNOPSIS
.B "union apci_descriptor *" ibm_slot_from_id
.BI "(int " id ");"
.SH ARGUMENTS
.IP "id" 12
 the slot number that linux refers to the slot by
.SH "DESCRIPTION"
 this method returns the aCPI slot descriptor
corresponding to the Linux slot number.  This descriptor
has info about the aPCI slot id and attention status.
This descriptor must be freed using kfree when done.
.TH "ibm_set_attention_status" 9 "ibm_set_attention_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibm_set_attention_status \-  callback method to set the attention LED
.SH SYNOPSIS
.B "int" ibm_set_attention_status
.BI "(struct hotplug_slot *" slot ","
.BI "u8 " status ");"
.SH ARGUMENTS
.IP "slot" 12
 the hotplug_slot to work with
.IP "status" 12
 what to set the LED to (0 or 1)
.SH "DESCRIPTION"
 this method is registered with the acpiphp module as a
callback to do the device specific task of setting the LED status
.TH "ibm_get_attention_status" 9 "ibm_get_attention_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibm_get_attention_status \-  callback method to get attention LED status
.SH SYNOPSIS
.B "int" ibm_get_attention_status
.BI "(struct hotplug_slot *" slot ","
.BI "u8 *" status ");"
.SH ARGUMENTS
.IP "slot" 12
 the hotplug_slot to work with
.IP "status" 12
 returns what the LED is set to (0 or 1)
.SH "DESCRIPTION"
 this method is registered with the acpiphp module as a
callback to do the device specific task of getting the LED status

Because there is no direct method of getting the LED status directly
from an ACPI call, we read the aPCI table and parse out our
slot descriptor to read the status from that.
.TH "ibm_handle_events" 9 "ibm_handle_events" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibm_handle_events \-  listens for ACPI events for the IBM37D0 device
.SH SYNOPSIS
.B "void" ibm_handle_events
.BI "(acpi_handle " handle ","
.BI "u32 " event ","
.BI "void *" context ");"
.SH ARGUMENTS
.IP "handle" 12
 an ACPI handle to the device that caused the event
.IP "event" 12
 the event info (device specific)
.IP "context" 12
 passed context (our notification struct)
.SH "DESCRIPTION"
 this method is registered as a callback with the ACPI
subsystem it is called when this device has an event to notify the OS of

The events actually come from the device as two events that get
synthesized into one event with data by this function.  The event
ID comes first and then the slot number that caused it.  We report
this as one event to the OS.

From section 5.6.2.2 of the ACPI 2.0 spec, I understand that the OSPM will
only re-enable the interrupt that causes this event AFTER this method
has returned, thereby enforcing serial access for the notification struct.
.TH "ibm_get_table_from_acpi" 9 "ibm_get_table_from_acpi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibm_get_table_from_acpi \-  reads the APLS buffer from ACPI
.SH SYNOPSIS
.B "int" ibm_get_table_from_acpi
.BI "(char **" bufp ");"
.SH ARGUMENTS
.IP "bufp" 12
 address to pointer to allocate for the table
.SH "DESCRIPTION"
 this method reads the APLS buffer in from ACPI and
stores the "stripped" table into a single buffer
it allocates and passes the address back in bufp

If NULL is passed in as buffer, this method only calculates
the size of the table and returns that without filling
in the buffer

returns &lt; 0 on error or the size of the table on success
.TH "ibm_read_apci_table" 9 "ibm_read_apci_table" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibm_read_apci_table \-  callback for the sysfs apci_table file
.SH SYNOPSIS
.B "ssize_t" ibm_read_apci_table
.BI "(struct kobject *" kobj ","
.BI "char *" buffer ","
.BI "loff_t " pos ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "kobj" 12
 the kobject this binary attribute is a part of
.IP "buffer" 12
 the kernel space buffer to fill
.IP "pos" 12
 the offset into the file
.IP "size" 12
 the number of bytes requested
.SH "DESCRIPTION"
 gets registered with sysfs as the reader callback
to be executed when /sys/bus/pci/slots/apci_table gets read

Since we don't get notified on open and close for this file,
things get really tricky here...
our solution is to only allow reading the table in all at once
.TH "ibm_find_acpi_device" 9 "ibm_find_acpi_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ibm_find_acpi_device \-  callback to find our ACPI device
.SH SYNOPSIS
.B "acpi_status __init" ibm_find_acpi_device
.BI "(acpi_handle " handle ","
.BI "u32 " lvl ","
.BI "void *" context ","
.BI "void **" rv ");"
.SH ARGUMENTS
.IP "handle" 12
 the ACPI handle of the device we are inspecting
.IP "lvl" 12
 depth into the namespace tree
.IP "context" 12
 a pointer to our handle to fill when we find the device
.IP "rv" 12
 a return value to fill if desired
.SH "DESCRIPTION"
 used as a callback when calling acpi_walk_namespace
to find our device.  When this method returns non-zero
acpi_walk_namespace quits its search and returns our value
.TH "detect_SMBIOS_pointer" 9 "detect_SMBIOS_pointer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
detect_SMBIOS_pointer \-  find the System Management BIOS Table in mem region.
.SH SYNOPSIS
.B "void __iomem *" detect_SMBIOS_pointer
.BI "(void __iomem *" begin ","
.BI "void __iomem *" end ");"
.SH ARGUMENTS
.IP "begin" 12
 begin pointer for region to be scanned.
.IP "end" 12
 end pointer for region to be scanned.
.SH "DESCRIPTION"
Returns pointer to the head of the SMBIOS tables (or NULL)
.SH "DESCRIPTION"
Returns pointer to the head of the SMBIOS tables (or NULL)
.TH "init_SERR" 9 "init_SERR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_SERR \-  Initializes the per slot SERR generation.
.SH SYNOPSIS
.B "int" init_SERR
.BI "(struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"

For unexpected switch opens
.TH "get_subsequent_smbios_entry" 9 "get_subsequent_smbios_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_subsequent_smbios_entry \- 
.SH SYNOPSIS
.B "void __iomem *" get_subsequent_smbios_entry
.BI "(void __iomem *" smbios_start ","
.BI "void __iomem *" smbios_table ","
.BI "void __iomem *" curr ");"
.SH ARGUMENTS
.IP "smbios_start" 12
-- undescribed --
.IP "smbios_table" 12
-- undescribed --
.IP "curr" 12
 NULL or pointer to previously returned structure
.SH "DESCRIPTION"
returns a pointer to an SMBIOS structure or NULL if none found
.SH "DESCRIPTION"
returns a pointer to an SMBIOS structure or NULL if none found
.TH "get_SMBIOS_entry" 9 "get_SMBIOS_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_SMBIOS_entry \- 
.SH SYNOPSIS
.B "void __iomem *" get_SMBIOS_entry
.BI "(void __iomem *" smbios_start ","
.BI "void __iomem *" smbios_table ","
.BI "u8 " type ","
.BI "void __iomem *" previous ");"
.SH ARGUMENTS
.IP "smbios_start" 12
-- undescribed --
.IP "smbios_table" 12
-- undescribed --
.IP "type" 12
SMBIOS structure type to be returned
.IP "previous" 12
 NULL or pointer to previously returned structure
.SH "DESCRIPTION"
Gets the first entry of the specified type if previous == NULL
Otherwise, returns the next entry of the given type.
Uses global SMBIOS Table pointer
Uses get_subsequent_smbios_entry

returns a pointer to an SMBIOS structure or NULL if none found
.SH "DESCRIPTION"
Gets the first entry of the specified type if previous == NULL
Otherwise, returns the next entry of the given type.
Uses global SMBIOS Table pointer
Uses get_subsequent_smbios_entry

returns a pointer to an SMBIOS structure or NULL if none found
.TH "cpqhp_set_attention_status" 9 "cpqhp_set_attention_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpqhp_set_attention_status \-  Turns the Amber LED for a slot on or off
.SH SYNOPSIS
.B "int" cpqhp_set_attention_status
.BI "(struct controller *" ctrl ","
.BI "struct pci_func *" func ","
.BI "u32 " status ");"
.SH ARGUMENTS
.IP "ctrl" 12
-- undescribed --
.IP "func" 12
-- undescribed --
.IP "status" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "set_attention_status" 9 "set_attention_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_attention_status \-  Turns the Amber LED for a slot on or off
.SH SYNOPSIS
.B "int" set_attention_status
.BI "(struct hotplug_slot *" hotplug_slot ","
.BI "u8 " status ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
-- undescribed --
.IP "status" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "pci_hp_register" 9 "pci_hp_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_hp_register \-  register a hotplug_slot with the PCI hotplug subsystem
.SH SYNOPSIS
.B "int" pci_hp_register
.BI "(struct hotplug_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
 pointer to the &amp;struct hotplug_slot to register
.SH "DESCRIPTION"
Registers a hotplug slot with the pci hotplug subsystem, which will allow
userspace interaction to the slot.

Returns 0 if successful, anything else for an error.
.TH "pci_hp_deregister" 9 "pci_hp_deregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_hp_deregister \-  deregister a hotplug_slot with the PCI hotplug subsystem
.SH SYNOPSIS
.B "int" pci_hp_deregister
.BI "(struct hotplug_slot *" slot ");"
.SH ARGUMENTS
.IP "slot" 12
 pointer to the &amp;struct hotplug_slot to deregister
.SH "DESCRIPTION"
The \fIslot\fP must have been registered with the pci hotplug subsystem
previously with a call to \fBpci_hp_register\fP.

Returns 0 if successful, anything else for an error.
.TH "pci_hp_change_slot_info" 9 "pci_hp_change_slot_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_hp_change_slot_info \-  changes the slot's information structure in the core
.SH SYNOPSIS
.B "int" pci_hp_change_slot_info
.BI "(struct hotplug_slot *" slot ","
.BI "struct hotplug_slot_info *" info ");"
.SH ARGUMENTS
.IP "slot" 12
 pointer to the slot whose info has changed
.IP "info" 12
 pointer to the info copy into the slot's info structure
.SH "DESCRIPTION"
\fIslot\fP must have been registered with the pci 
hotplug subsystem previously with a call to \fBpci_hp_register\fP.

Returns 0 if successful, anything else for an error.
.TH "sort_by_size" 9 "sort_by_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sort_by_size \- 
.SH SYNOPSIS
.B "int" sort_by_size
.BI "(struct pci_resource **" head ");"
.SH ARGUMENTS
.IP "head" 12
 list to sort
.SH "DESCRIPTION"
.TH "do_pre_bridge_resource_split" 9 "do_pre_bridge_resource_split" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_pre_bridge_resource_split \- 
.SH SYNOPSIS
.B "struct pci_resource *" do_pre_bridge_resource_split
.BI "(struct pci_resource **" head ","
.BI "struct pci_resource **" orig_head ","
.BI "u32 " alignment ");"
.SH ARGUMENTS
.IP "head" 12
 list to scan
.IP "orig_head" 12
-- undescribed --
.IP "alignment" 12
-- undescribed --
.TH "do_bridge_resource_split" 9 "do_bridge_resource_split" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_bridge_resource_split \- 
.SH SYNOPSIS
.B "struct pci_resource *" do_bridge_resource_split
.BI "(struct pci_resource **" head ","
.BI "u32 " alignment ");"
.SH ARGUMENTS
.IP "head" 12
 list to scan
.IP "alignment" 12
-- undescribed --
.TH "pciehp_slot_create" 9 "pciehp_slot_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pciehp_slot_create \-  Creates a node and adds it to the proper bus.
.SH SYNOPSIS
.B "struct pci_func *" pciehp_slot_create
.BI "(u8 " busnumber ");"
.SH ARGUMENTS
.IP "busnumber" 12
-- undescribed --
.SH "DESCRIPTION"
\fIbusnumber\fP - bus where new node is to be located

Returns pointer to the new node or NULL if unsuccessful
.TH "slot_remove" 9 "slot_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
slot_remove \-  Removes a node from the linked list of slots.
.SH SYNOPSIS
.B "int" slot_remove
.BI "(struct pci_func *" old_slot ");"
.SH ARGUMENTS
.IP "old_slot" 12
 slot to remove
.SH "DESCRIPTION"
Returns 0 if successful, !0 otherwise.
.TH "bridge_slot_remove" 9 "bridge_slot_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bridge_slot_remove \-  Removes a node from the linked list of slots.
.SH SYNOPSIS
.B "int" bridge_slot_remove
.BI "(struct pci_func *" bridge ");"
.SH ARGUMENTS
.IP "bridge" 12
 bridge to remove
.SH "DESCRIPTION"
Returns 0 if successful, !0 otherwise.
.TH "pciehp_slot_find" 9 "pciehp_slot_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pciehp_slot_find \-  Looks for a node by bus, and device, multiple functions accessed
.SH SYNOPSIS
.B "struct pci_func *" pciehp_slot_find
.BI "(u8 " bus ","
.BI "u8 " device ","
.BI "u8 " index ");"
.SH ARGUMENTS
.IP "bus" 12
 bus to find
.IP "device" 12
 device to find
.IP "index" 12
 is 0 for first function found, 1 for the second...
.SH "DESCRIPTION"
Returns pointer to the node if successful, NULL otherwise.
.TH "board_added" 9 "board_added" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
board_added \-  Called after a board has been added to the system.
.SH SYNOPSIS
.B "u32" board_added
.BI "(struct pci_func *" func ","
.BI "struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"

Turns power on for the board
Configures board
.TH "remove_board" 9 "remove_board" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
remove_board \-  Turns off slot and LED's
.SH SYNOPSIS
.B "u32" remove_board
.BI "(struct pci_func *" func ","
.BI "struct controller *" ctrl ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "ctrl" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "pciehp_pushbutton_thread" 9 "pciehp_pushbutton_thread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pciehp_pushbutton_thread \- 
.SH SYNOPSIS
.B "void" pciehp_pushbutton_thread
.BI "(unsigned long " slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

Scheduled procedure to handle blocking stuff for the pushbuttons
Handles all pending events and exits.
.TH "pciehp_surprise_rm_thread" 9 "pciehp_surprise_rm_thread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pciehp_surprise_rm_thread \- 
.SH SYNOPSIS
.B "void" pciehp_surprise_rm_thread
.BI "(unsigned long " slot ");"
.SH ARGUMENTS
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

Scheduled procedure to handle blocking stuff for the surprise removal
Handles all pending events and exits.
.TH "configure_new_device" 9 "configure_new_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
configure_new_device \-  Configures the PCI header information of one board.
.SH SYNOPSIS
.B "u32" configure_new_device
.BI "(struct controller *" ctrl ","
.BI "struct pci_func *" func ","
.BI "u8 " behind_bridge ","
.BI "struct resource_lists *" resources ","
.BI "u8 " bridge_bus ","
.BI "u8 " bridge_dev ");"
.SH ARGUMENTS
.IP "ctrl" 12
 pointer to controller structure
.IP "func" 12
 pointer to function structure
.IP "behind_bridge" 12
 1 if this is a recursive call, 0 if not
.IP "resources" 12
 pointer to set of resource lists
.IP "bridge_bus" 12
-- undescribed --
.IP "bridge_dev" 12
-- undescribed --
.SH "DESCRIPTION"
Returns 0 if success
.SH "DESCRIPTION"
Returns 0 if success
.TH "configure_bridge" 9 "configure_bridge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
configure_bridge \- 
.SH SYNOPSIS
.B "int" configure_bridge
.BI "(struct pci_bus *" pci_bus ","
.BI "unsigned int " devfn ","
.BI "struct pci_resource *" mem_node ","
.BI "struct pci_resource **" hold_mem_node ","
.BI "int " base_addr ","
.BI "int " limit_addr ");"
.SH ARGUMENTS
.IP "pci_bus" 12
-- undescribed --
.IP "devfn" 12
-- undescribed --
.IP "mem_node" 12
-- undescribed --
.IP "hold_mem_node" 12
-- undescribed --
.IP "base_addr" 12
-- undescribed --
.IP "limit_addr" 12
-- undescribed --
.TH "configure_new_function" 9 "configure_new_function" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
configure_new_function \-  Configures the PCI header information of one device
.SH SYNOPSIS
.B "int" configure_new_function
.BI "(struct controller *" ctrl ","
.BI "struct pci_func *" func ","
.BI "u8 " behind_bridge ","
.BI "struct resource_lists *" resources ","
.BI "u8 " bridge_bus ","
.BI "u8 " bridge_dev ");"
.SH ARGUMENTS
.IP "ctrl" 12
 pointer to controller structure
.IP "func" 12
 pointer to function structure
.IP "behind_bridge" 12
 1 if this is a recursive call, 0 if not
.IP "resources" 12
 pointer to set of resource lists
.IP "bridge_bus" 12
-- undescribed --
.IP "bridge_dev" 12
-- undescribed --
.SH "DESCRIPTION"
Calls itself recursively for bridged devices.
Returns 0 if success
.SH "DESCRIPTION"
Calls itself recursively for bridged devices.
Returns 0 if success
.TH "release_slot" 9 "release_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
release_slot \-  free up the memory used by a slot
.SH SYNOPSIS
.B "void" release_slot
.BI "(struct hotplug_slot *" hotplug_slot ");"
.SH ARGUMENTS
.IP "hotplug_slot" 12
 slot to free
.TH "pci_remove_device_safe" 9 "pci_remove_device_safe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_remove_device_safe \-  remove an unused hotplug device
.SH SYNOPSIS
.B "int" pci_remove_device_safe
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device to remove
.SH "DESCRIPTION"
Delete the device structure from the device lists and 
notify userspace (/sbin/hotplug), but only if the device
in question is not being used by a driver.
Returns 0 on success.
.TH "pci_remove_bus_device" 9 "pci_remove_bus_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_remove_bus_device \-  remove a PCI device and any children
.SH SYNOPSIS
.B "void" pci_remove_bus_device
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device to remove
.SH "DESCRIPTION"
Remove a PCI device from the device lists, informing the drivers
that the device has been removed.  We also remove any subordinate
buses and children in a depth-first manner.

For each device we remove, delete the device structure from the
device lists, remove the /proc entry, and notify userspace
(/sbin/hotplug).
.TH "pci_remove_behind_bridge" 9 "pci_remove_behind_bridge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_remove_behind_bridge \-  remove all devices behind a PCI bridge
.SH SYNOPSIS
.B "void" pci_remove_behind_bridge
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI bridge device
.SH "DESCRIPTION"
Remove all devices on the bus, except for the parent bridge.
This also removes any child buses, and any devices they may
contain in a depth-first manner.
.TH "pci_bus_alloc_resource" 9 "pci_bus_alloc_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_bus_alloc_resource \-  allocate a resource from a parent bus
.SH SYNOPSIS
.B "int" pci_bus_alloc_resource
.BI "(struct pci_bus *" bus ","
.BI "struct resource *" res ","
.BI "unsigned long " size ","
.BI "unsigned long " align ","
.BI "unsigned long " min ","
.BI "unsigned int " type_mask ","
.BI "void (*" alignf ") (void *, struct resource *, 			unsigned long, unsigned long),"
.BI "void *" alignf_data ");"
.SH ARGUMENTS
.IP "bus" 12
 PCI bus
.IP "res" 12
 resource to allocate
.IP "size" 12
 size of resource to allocate
.IP "align" 12
 alignment of resource to allocate
.IP "min" 12
 minimum /proc/iomem address to allocate
.IP "type_mask" 12
 IORESOURCE_* type flags
.IP "alignf" 12
 resource alignment function
.IP "alignf_data" 12
 data argument for resource alignment function
.SH "DESCRIPTION"
Given the PCI bus a device resides on, the size, minimum address,
alignment and type, try to find an acceptable resource allocation
for a specific device resource.
.TH "pci_bus_add_device" 9 "pci_bus_add_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_bus_add_device \- 
.SH SYNOPSIS
.B "void __devinit" pci_bus_add_device
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to add
.SH "DESCRIPTION"
This adds a single pci device to the global
device list and adds sysfs and procfs entries
.TH "pci_bus_add_devices" 9 "pci_bus_add_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_bus_add_devices \-  insert newly discovered PCI devices
.SH SYNOPSIS
.B "void __devinit" pci_bus_add_devices
.BI "(struct pci_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 bus to check for new devices
.SH "DESCRIPTION"
Add newly discovered PCI devices (which are on the bus-&gt;devices
list) to the global PCI device list, add the sysfs and procfs
entries.  Where a bridge is found, add the discovered bus to
the parents list of child buses, and recurse (breadth-first
to be compatible with 2.4)

Call hotplug for each new devices.
.TH "pci_enable_rom" 9 "pci_enable_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_enable_rom \-  enable ROM decoding for a PCI device
.SH SYNOPSIS
.B "int" pci_enable_rom
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device to enable
.SH "DESCRIPTION"
Enable ROM decoding on \fIdev\fP.  This involves simply turning on the last
bit of the PCI ROM BAR.  Note that some cards may share address decoders
between the ROM and other resources, so enabling it may disable access
to MMIO registers or other card memory.
.TH "pci_disable_rom" 9 "pci_disable_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_disable_rom \-  disable ROM decoding for a PCI device
.SH SYNOPSIS
.B "void" pci_disable_rom
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 PCI device to disable
.SH "DESCRIPTION"
Disable ROM decoding on a PCI device by turning off the last bit in the
ROM BAR.
.TH "pci_map_rom" 9 "pci_map_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_map_rom \-  map a PCI ROM to kernel space
.SH SYNOPSIS
.B "void __iomem *" pci_map_rom
.BI "(struct pci_dev *" pdev ","
.BI "size_t *" size ");"
.SH ARGUMENTS
.IP "pdev" 12
 pointer to pci device struct
.IP "size" 12
 pointer to receive size of pci window over ROM
.SH "DESCRIPTION"
Map a PCI ROM into kernel space. If ROM is boot video ROM,
the shadow BIOS copy will be returned instead of the
actual ROM.
.TH "pci_map_rom_copy" 9 "pci_map_rom_copy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_map_rom_copy \-  map a PCI ROM to kernel space, create a copy
.SH SYNOPSIS
.B "void __iomem *" pci_map_rom_copy
.BI "(struct pci_dev *" pdev ","
.BI "size_t *" size ");"
.SH ARGUMENTS
.IP "pdev" 12
 pointer to pci device struct
.IP "size" 12
 pointer to receive size of pci window over ROM
.SH "DESCRIPTION"
Map a PCI ROM into kernel space. If ROM is boot video ROM,
the shadow BIOS copy will be returned instead of the
actual ROM.
.TH "pci_unmap_rom" 9 "pci_unmap_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_unmap_rom \-  unmap the ROM from kernel space
.SH SYNOPSIS
.B "void" pci_unmap_rom
.BI "(struct pci_dev *" pdev ","
.BI "void __iomem *" rom ");"
.SH ARGUMENTS
.IP "pdev" 12
 pointer to pci device struct
.IP "rom" 12
 virtual address of the previous mapping
.SH "DESCRIPTION"
Remove a mapping of a previously mapped ROM
.TH "pci_remove_rom" 9 "pci_remove_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_remove_rom \-  disable the ROM and remove its sysfs attribute
.SH SYNOPSIS
.B "void" pci_remove_rom
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 pointer to pci device struct
.SH "DESCRIPTION"
Remove the rom file in sysfs and disable ROM decoding.
.TH "pci_cleanup_rom" 9 "pci_cleanup_rom" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_cleanup_rom \-  internal routine for freeing the ROM copy created
.SH SYNOPSIS
.B "void" pci_cleanup_rom
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 pointer to pci device struct
.SH "DESCRIPTION"
Free the copied ROM if we allocated one.
.SH "DESCRIPTION"
Free the copied ROM if we allocated one.
.TH "video_register_device" 9 "video_register_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
video_register_device \-  register video4linux devices
.SH SYNOPSIS
.B "int" video_register_device
.BI "(struct video_device *" vfd ","
.BI "int " type ","
.BI "int " nr ");"
.SH ARGUMENTS
.IP "vfd" 12
  video device structure we want to register
.IP "type" 12
 type of device to register
.IP "nr" 12
   which device number (0 == /dev/video0, 1 == /dev/video1, ...
-1 == first free)
.SH "DESCRIPTION"
The registration code assigns minor numbers based on the type
requested. -ENFILE is returned in all the device slots for this
category are full. If not then the minor field is set and the
driver initialize function is called (if non NULL).

Zero is returned on success.

Valid types are

VFL_TYPE_GRABBER - A frame grabber

VFL_TYPE_VTX - A teletext device

VFL_TYPE_VBI - Vertical blank data (undecoded)

VFL_TYPE_RADIO - A radio card	
.TH "video_unregister_device" 9 "video_unregister_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
video_unregister_device \-  unregister a video4linux device
.SH SYNOPSIS
.B "void" video_unregister_device
.BI "(struct video_device *" vfd ");"
.SH ARGUMENTS
.IP "vfd" 12
 the device to unregister
.SH "DESCRIPTION"
This unregisters the passed device and deassigns the minor
number. Future open calls will be met with errors.
.TH "findstr" 9 "findstr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
findstr \- 
.SH SYNOPSIS
.B "u8 *" findstr
.BI "(u8 *" haystack ","
.BI "int " hlen ","
.BI "u8 *" needle ","
.BI "int " nlen ");"
.SH ARGUMENTS
.IP "haystack" 12
-- undescribed --
.IP "hlen" 12
-- undescribed --
.IP "needle" 12
-- undescribed --
.IP "nlen" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP haystack Buffer to look in.
\fIparam\fP hlen Number of bytes in haystack.
\fIparam\fP needle Buffer to find.
\fIparam\fP nlen Number of bytes in needle.
\fIreturn\fP Pointer into haystack needle was found at, or NULL if not found.
.TH "dvb_ca_en50221_check_camstatus" 9 "dvb_ca_en50221_check_camstatus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_check_camstatus \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_check_camstatus
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.TH "dvb_ca_en50221_wait_if_status" 9 "dvb_ca_en50221_wait_if_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_wait_if_status \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_wait_if_status
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ","
.BI "u8 " waitfor ","
.BI "int " timeout_hz ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.IP "waitfor" 12
-- undescribed --
.IP "timeout_hz" 12
-- undescribed --
.SH "DESCRIPTION"
checking for errors and timeout.

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot on interface.
\fIparam\fP waitfor Flags to wait for.
\fIparam\fP timeout_ms Timeout in milliseconds.

\fIreturn\fP 0 on success, nonzero on error.
.TH "dvb_ca_en50221_link_init" 9 "dvb_ca_en50221_link_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_link_init \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_link_init
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot id.

\fIreturn\fP 0 on success, nonzero on failure.
.TH "dvb_ca_en50221_read_tuple" 9 "dvb_ca_en50221_read_tuple" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_read_tuple \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_read_tuple
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ","
.BI "int *" address ","
.BI "int *" tupleType ","
.BI "int *" tupleLength ","
.BI "u8 *" tuple ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.IP "address" 12
-- undescribed --
.IP "tupleType" 12
-- undescribed --
.IP "tupleLength" 12
-- undescribed --
.IP "tuple" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot id.
\fIparam\fP address Address to read from. Updated.
\fIparam\fP tupleType Tuple id byte. Updated.
\fIparam\fP tupleLength Tuple length. Updated.
\fIparam\fP tuple Dest buffer for tuple (must be 256 bytes). Updated.

\fIreturn\fP 0 on success, nonzero on error.
.TH "dvb_ca_en50221_parse_attributes" 9 "dvb_ca_en50221_parse_attributes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_parse_attributes \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_parse_attributes
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"
it is a DVB CAM module.

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot id.

\fIreturn\fP 0 on success, &lt;0 on failure.
.TH "dvb_ca_en50221_set_configoption" 9 "dvb_ca_en50221_set_configoption" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_set_configoption \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_set_configoption
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot containing the CAM.
.TH "dvb_ca_en50221_read_data" 9 "dvb_ca_en50221_read_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_read_data \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_read_data
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ","
.BI "u8 *" ebuf ","
.BI "int " ecount ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.IP "ebuf" 12
-- undescribed --
.IP "ecount" 12
-- undescribed --
.SH "DESCRIPTION"
data from the CAM. The data can either be stored in a supplied buffer, or
automatically be added to the slot's rx_buffer.

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot to read from.
\fIparam\fP ebuf If non-NULL, the data will be written to this buffer. If NULL,
the data will be added into the buffering system as a normal fragment.
\fIparam\fP ecount Size of ebuf. Ignored if ebuf is NULL.

\fIreturn\fP Number of bytes read, or &lt; 0 on error
.TH "dvb_ca_en50221_write_data" 9 "dvb_ca_en50221_write_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_write_data \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_write_data
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ","
.BI "u8 *" buf ","
.BI "int " bytes_write ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "bytes_write" 12
-- undescribed --
.SH "DESCRIPTION"
to a CAM.

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot to write to.
\fIparam\fP ebuf The data in this buffer is treated as a complete link-level packet to
be written.
\fIparam\fP count Size of ebuf.

\fIreturn\fP Number of bytes written, or &lt; 0 on error.
.TH "dvb_ca_en50221_slot_shutdown" 9 "dvb_ca_en50221_slot_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_slot_shutdown \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_slot_shutdown
.BI "(struct dvb_ca_private *" ca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot to shut down.
.TH "dvb_ca_en50221_camchange_irq" 9 "dvb_ca_en50221_camchange_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_camchange_irq \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_camchange_irq
.BI "(struct dvb_ca_en50221 *" pubca ","
.BI "int " slot ","
.BI "int " change_type ");"
.SH ARGUMENTS
.IP "pubca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.IP "change_type" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot concerned.
\fIparam\fP change_type One of the DVB_CA_CAMCHANGE_* values.
.TH "dvb_ca_en50221_camready_irq" 9 "dvb_ca_en50221_camready_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_camready_irq \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_camready_irq
.BI "(struct dvb_ca_en50221 *" pubca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "pubca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot concerned.
.TH "dvb_ca_en50221_frda_irq" 9 "dvb_ca_en50221_frda_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_frda_irq \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_frda_irq
.BI "(struct dvb_ca_en50221 *" pubca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "pubca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot concerned.
.TH "dvb_ca_en50221_thread_wakeup" 9 "dvb_ca_en50221_thread_wakeup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_thread_wakeup \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_thread_wakeup
.BI "(struct dvb_ca_private *" ca ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
.TH "dvb_ca_en50221_thread_should_wakeup" 9 "dvb_ca_en50221_thread_should_wakeup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_thread_should_wakeup \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_thread_should_wakeup
.BI "(struct dvb_ca_private *" ca ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
.TH "dvb_ca_en50221_thread_update_delay" 9 "dvb_ca_en50221_thread_update_delay" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_thread_update_delay \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_thread_update_delay
.BI "(struct dvb_ca_private *" ca ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
.TH "dvb_ca_en50221_thread" 9 "dvb_ca_en50221_thread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_thread \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_thread
.BI "(void *" data ");"
.SH ARGUMENTS
.IP "data" 12
-- undescribed --
.TH "dvb_ca_en50221_io_do_ioctl" 9 "dvb_ca_en50221_io_do_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_do_ioctl \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_io_do_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "void *" parg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "parg" 12
-- undescribed --
.SH "NOTE"
 CA_SEND_MSG/CA_GET_MSG ioctls have userspace buffers passed to them.

\fIparam\fP inode Inode concerned.
\fIparam\fP file File concerned.
\fIparam\fP cmd IOCTL command.
\fIparam\fP arg Associated argument.

\fIreturn\fP 0 on success, &lt;0 on error.
.TH "dvb_ca_en50221_io_ioctl" 9 "dvb_ca_en50221_io_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_ioctl \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_io_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP inode Inode concerned.
\fIparam\fP file File concerned.
\fIparam\fP cmd IOCTL command.
\fIparam\fP arg Associated argument.

\fIreturn\fP 0 on success, &lt;0 on error.
.TH "dvb_ca_en50221_io_write" 9 "dvb_ca_en50221_io_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_write \- 
.SH SYNOPSIS
.B "ssize_t" dvb_ca_en50221_io_write
.BI "(struct file *" file ","
.BI "const char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "ppos" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP file File structure.
\fIparam\fP buf Source buffer.
\fIparam\fP count Size of source buffer.
\fIparam\fP ppos Position in file (ignored).

\fIreturn\fP Number of bytes read, or &lt;0 on error.
.TH "dvb_ca_en50221_io_read_condition" 9 "dvb_ca_en50221_io_read_condition" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_read_condition \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_io_read_condition
.BI "(struct dvb_ca_private *" ca ","
.BI "int *" result ","
.BI "int *" _slot ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "result" 12
-- undescribed --
.IP "_slot" 12
-- undescribed --
.TH "dvb_ca_en50221_io_read" 9 "dvb_ca_en50221_io_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_read \- 
.SH SYNOPSIS
.B "ssize_t" dvb_ca_en50221_io_read
.BI "(struct file *" file ","
.BI "char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "ppos" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP file File structure.
\fIparam\fP buf Destination buffer.
\fIparam\fP count Size of destination buffer.
\fIparam\fP ppos Position in file (ignored).

\fIreturn\fP Number of bytes read, or &lt;0 on error.
.TH "dvb_ca_en50221_io_open" 9 "dvb_ca_en50221_io_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_open \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_io_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP inode Inode concerned.
\fIparam\fP file File concerned.

\fIreturn\fP 0 on success, &lt;0 on failure.
.TH "dvb_ca_en50221_io_release" 9 "dvb_ca_en50221_io_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_release \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_io_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP inode Inode concerned.
\fIparam\fP file File concerned.

\fIreturn\fP 0 on success, &lt;0 on failure.
.TH "dvb_ca_en50221_io_poll" 9 "dvb_ca_en50221_io_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_io_poll \- 
.SH SYNOPSIS
.B "unsigned int" dvb_ca_en50221_io_poll
.BI "(struct file *" file ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "wait" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP file File concerned.
\fIparam\fP wait poll wait table.

\fIreturn\fP Standard poll mask.
.TH "dvb_ca_en50221_init" 9 "dvb_ca_en50221_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_init \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_init
.BI "(struct dvb_adapter *" dvb_adapter ","
.BI "struct dvb_ca_en50221 *" pubca ","
.BI "int " flags ","
.BI "int " slot_count ");"
.SH ARGUMENTS
.IP "dvb_adapter" 12
-- undescribed --
.IP "pubca" 12
-- undescribed --
.IP "flags" 12
-- undescribed --
.IP "slot_count" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP dvb_adapter DVB adapter to attach the new CA device to.
\fIparam\fP ca The dvb_ca instance.
\fIparam\fP flags Flags describing the CA device (DVB_CA_FLAG_*).
\fIparam\fP slot_count Number of slots supported.

\fIreturn\fP 0 on success, nonzero on failure
.TH "dvb_ca_en50221_release" 9 "dvb_ca_en50221_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_release \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_release
.BI "(struct dvb_ca_en50221 *" pubca ");"
.SH ARGUMENTS
.IP "pubca" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca_dev The dvb_device_t instance for the CA device.
\fIparam\fP ca The associated dvb_ca instance.
.TH "dvb_ringbuffer_pkt_write" 9 "dvb_ringbuffer_pkt_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ringbuffer_pkt_write \- 
.SH SYNOPSIS
.B "ssize_t" dvb_ringbuffer_pkt_write
.BI "(struct dvb_ringbuffer *" rbuf ","
.BI "u8 *" buf ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "rbuf" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"

&lt;rbuf&gt; Ringbuffer to write to.
&lt;buf&gt; Buffer to write.
&lt;len&gt; Length of buffer (currently limited to 65535 bytes max).
returns Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.
.TH "dvb_ringbuffer_pkt_read" 9 "dvb_ringbuffer_pkt_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ringbuffer_pkt_read \- 
.SH SYNOPSIS
.B "ssize_t" dvb_ringbuffer_pkt_read
.BI "(struct dvb_ringbuffer *" rbuf ","
.BI "size_t " idx ","
.BI "int " offset ","
.BI "u8 *" buf ","
.BI "size_t " len ","
.BI "int " usermem ");"
.SH ARGUMENTS
.IP "rbuf" 12
-- undescribed --
.IP "idx" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.IP "usermem" 12
-- undescribed --
.SH "DESCRIPTION"
does NOT update the read pointer in the ringbuffer. You must use
\fBdvb_ringbuffer_pkt_dispose\fP to mark a packet as no longer required.

&lt;rbuf&gt; Ringbuffer concerned.
&lt;idx&gt; Packet index as returned by \fBdvb_ringbuffer_pkt_next\fP.
&lt;offset&gt; Offset into packet to read from.
&lt;buf&gt; Destination buffer for data.
&lt;len&gt; Size of destination buffer.
&lt;usermem&gt; Set to 1 if &lt;buf&gt; is in userspace.
returns Number of bytes read, or -EFAULT.
.TH "dvb_ringbuffer_pkt_dispose" 9 "dvb_ringbuffer_pkt_dispose" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ringbuffer_pkt_dispose \- 
.SH SYNOPSIS
.B "void" dvb_ringbuffer_pkt_dispose
.BI "(struct dvb_ringbuffer *" rbuf ","
.BI "size_t " idx ");"
.SH ARGUMENTS
.IP "rbuf" 12
-- undescribed --
.IP "idx" 12
-- undescribed --
.SH "DESCRIPTION"

&lt;rbuf&gt; Ring buffer concerned.
&lt;idx&gt; Packet index as returned by \fBdvb_ringbuffer_pkt_next\fP.
.TH "dvb_ringbuffer_pkt_next" 9 "dvb_ringbuffer_pkt_next" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ringbuffer_pkt_next \- 
.SH SYNOPSIS
.B "ssize_t" dvb_ringbuffer_pkt_next
.BI "(struct dvb_ringbuffer *" rbuf ","
.BI "size_t " idx ","
.BI "size_t *" pktlen ");"
.SH ARGUMENTS
.IP "rbuf" 12
-- undescribed --
.IP "idx" 12
-- undescribed --
.IP "pktlen" 12
-- undescribed --
.SH "DESCRIPTION"

&lt;rbuf&gt; Ringbuffer concerned.
&lt;idx&gt; Previous packet index, or -1 to return the first packet index.
&lt;pktlen&gt; On success, will be updated to contain the length of the packet in bytes.
returns Packet index (if &gt;=0), or -1 if no packets available.
.TH "dvb_ca_en50221_camchange_irq" 9 "dvb_ca_en50221_camchange_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_camchange_irq \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_camchange_irq
.BI "(struct dvb_ca_en50221 *" pubca ","
.BI "int " slot ","
.BI "int " change_type ");"
.SH ARGUMENTS
.IP "pubca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.IP "change_type" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot concerned.
\fIparam\fP change_type One of the DVB_CA_CAMCHANGE_* values
.TH "dvb_ca_en50221_camready_irq" 9 "dvb_ca_en50221_camready_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_camready_irq \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_camready_irq
.BI "(struct dvb_ca_en50221 *" pubca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "pubca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot concerned.
.TH "dvb_ca_en50221_frda_irq" 9 "dvb_ca_en50221_frda_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_frda_irq \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_frda_irq
.BI "(struct dvb_ca_en50221 *" ca ","
.BI "int " slot ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.IP "slot" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca CA instance.
\fIparam\fP slot Slot concerned.
.TH "dvb_ca_en50221_init" 9 "dvb_ca_en50221_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_init \- 
.SH SYNOPSIS
.B "int" dvb_ca_en50221_init
.BI "(struct dvb_adapter *" dvb_adapter ","
.BI "struct dvb_ca_en50221 *" ca ","
.BI "int " flags ","
.BI "int " slot_count ");"
.SH ARGUMENTS
.IP "dvb_adapter" 12
-- undescribed --
.IP "ca" 12
-- undescribed --
.IP "flags" 12
-- undescribed --
.IP "slot_count" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP dvb_adapter DVB adapter to attach the new CA device to.
\fIparam\fP ca The dvb_ca instance.
\fIparam\fP flags Flags describing the CA device (DVB_CA_EN50221_FLAG_*).
\fIparam\fP slot_count Number of slots supported.

\fIreturn\fP 0 on success, nonzero on failure
.TH "dvb_ca_en50221_release" 9 "dvb_ca_en50221_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_ca_en50221_release \- 
.SH SYNOPSIS
.B "void" dvb_ca_en50221_release
.BI "(struct dvb_ca_en50221 *" ca ");"
.SH ARGUMENTS
.IP "ca" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP ca The associated dvb_ca instance.
.TH "dvb_frontend_autotune" 9 "dvb_frontend_autotune" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_frontend_autotune \- 
.SH SYNOPSIS
.B "int" dvb_frontend_autotune
.BI "(struct dvb_frontend *" fe ","
.BI "int " check_wrapped ");"
.SH ARGUMENTS
.IP "fe" 12
-- undescribed --
.IP "check_wrapped" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP fe The frontend concerned.
\fIparam\fP check_wrapped Checks if an iteration has completed. DO NOT SET ON THE FIRST ATTEMPT
\fIreturns\fP Number of complete iterations that have been performed.
.TH "dvb_net_eth_type_trans" 9 "dvb_net_eth_type_trans" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_net_eth_type_trans \- 
.SH SYNOPSIS
.B "unsigned short" dvb_net_eth_type_trans
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "skb" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
assume 802.3 if the type field is short enough to be a length.
This is normal practice and works for any 'now in use' protocol.

stolen from eth.c out of the linux kernel, hacked for dvb-device
by Michael Holzt &lt;kju\fIdebian\fP.org&gt;
.TH "dvb_net_ule" 9 "dvb_net_ule" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dvb_net_ule \- ietf-ipdvb-ule-03.txt from a sequence of
.SH SYNOPSIS
.B "void" dvb_net_ule
.BI "(struct net_device *" dev ","
.BI "const u8 *" buf ","
.BI "size_t " buf_len ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "buf_len" 12
-- undescribed --
.SH "DESCRIPTION"
TS cells of a single PID.
.TH "compute_tps" 9 "compute_tps" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
compute_tps \- dvb frontend parameter set into TPS.
.SH SYNOPSIS
.B "uint16_t" compute_tps
.BI "(struct dvb_frontend_parameters *" p ");"
.SH ARGUMENTS
.IP "p" 12
-- undescribed --
.SH "DESCRIPTION"
See ETSI ETS-300744, section 4.6.2, table 9 for details.

This function is probably reusable and may better get placed in a support
library.

We replace errornous fields by default TPS fields (the ones with value 0).
.TH "Kernel API" 9 "struct dvb_usb_device_description" "January 2021" "API Manual" LINUX
.SH NAME
struct dvb_usb_device_description \-  name and its according USB IDs
.SH SYNOPSIS
struct dvb_usb_device_description {
.br
.BI "    const char *" name ""
;

.br
.BI "#define DVB_USB_ID_MAX_NUM 15"
.br
.BI "    struct usb_device_id *" cold_ids[DVB_USB_ID_MAX_NUM] ""
;

.br
.BI "    struct usb_device_id *" warm_ids[DVB_USB_ID_MAX_NUM] ""
;

.br
};
.br
.SH Arguments
.IP "name" 12
 real name of the box, regardless which DVB USB device class is in use
.IP "cold_ids[DVB_USB_ID_MAX_NUM]" 12
 array of struct usb_device_id which describe the device in
pre-firmware state
.IP "warm_ids[DVB_USB_ID_MAX_NUM]" 12
 array of struct usb_device_id which describe the device in
post-firmware state
.SH "Description"
Each DVB USB device class can have one or more actual devices, this struct
assigns a name to it.
.TH "Kernel API" 9 "struct dvb_usb_rc_key" "January 2021" "API Manual" LINUX
.SH NAME
struct dvb_usb_rc_key \-  a remote control key and its input-event
.SH SYNOPSIS
struct dvb_usb_rc_key {
.br
.BI "    u8 " custom ""
;

.br
.BI "    u8 " data ""
;

.br
.BI "    u32 " event ""
;

.br
};
.br
.SH Arguments
.IP "custom" 12
 the vendor/custom part of the key
.IP "data" 12
 the actual key part
.IP "event" 12
 the input event assigned to key identified by custom and data
.TH "Kernel API" 9 "struct dvb_usb_properties" "January 2021" "API Manual" LINUX
.SH NAME
struct dvb_usb_properties \-  properties of a dvb-usb-device
.SH SYNOPSIS
struct dvb_usb_properties {
.br
.BI "#define DVB_USB_HAS_PID_FILTER               0x01"
.br
.BI "#define DVB_USB_PID_FILTER_CAN_BE_TURNED_OFF 0x02"
.br
.BI "#define DVB_USB_NEED_PID_FILTERING           0x04"
.br
.BI "#define DVB_USB_IS_AN_I2C_ADAPTER            0x08"
.br
.BI "    int " caps ""
;

.br
.BI "    int " pid_filter_count ""
;

.br
.BI "#define CYPRESS_AN2135  0"
.br
.BI "#define CYPRESS_AN2235  1"
.br
.BI "#define CYPRESS_FX2     2"
.br
.BI "    int " usb_ctrl ""
;

.br
.BI "    const char *" firmware ""
;

.br
.BI "    int " size_of_priv ""
;

.br
.BI "    int (*" power_ctrl ") (struct dvb_usb_device *, int)"
;

.br
.BI "    int (*" pid_filter_ctrl ") (struct dvb_usb_device *, int)"
;

.br
.BI "    int (*" pid_filter ") (struct dvb_usb_device *, int, u16, int)"
;

.br
.BI "    int (*" read_mac_address ") (struct dvb_usb_device *, u8 [])"
;

.br
.BI "    int (*" frontend_attach ") (struct dvb_usb_device *)"
;

.br
.BI "    int (*" tuner_attach ") (struct dvb_usb_device *)"
;

.br
.BI "    int (*" identify_state ") (struct usb_device *, struct dvb_usb_properties *,struct dvb_usb_device_description **, int *)"
;

.br
.BI "#define REMOTE_NO_KEY_PRESSED      0x00"
.br
.BI "#define REMOTE_KEY_PRESSED         0x01"
.br
.BI "#define REMOTE_KEY_REPEAT          0x02"
.br
.BI "    struct dvb_usb_rc_key *" rc_key_map ""
;

.br
.BI "    int " rc_key_map_size ""
;

.br
.BI "    int (*" rc_query ") (struct dvb_usb_device *, u32 *, int *)"
;

.br
.BI "    int " rc_interval ""
;

.br
.BI "    struct i2c_algorithm *" i2c_algo ""
;

.br
.BI "    int " generic_bulk_ctrl_endpoint ""
;

.br
.BI "    } " urb ""
;

.br
.BI "    int " num_device_descs ""
;

.br
.BI "    struct dvb_usb_device_description " devices[9] ""
;

.br
};
.br
.SH Arguments
.IP "caps" 12
 capabilites of the DVB USB device.
.IP "pid_filter_count" 12
 number of PID filter position in the optional hardware
PID-filter.
.IP "usb_ctrl" 12
 which USB device-side controller is in use. Needed for firmware
download.
.IP "firmware" 12
 name of the firmware file.
.IP "size_of_priv" 12
 how many bytes shall be allocated for the private field
of struct dvb_usb_device.
.IP "power_ctrl" 12
 called to enable/disable power of the device.
.IP "pid_filter_ctrl" 12
 called to en/disable the PID filter, if any.
.IP "pid_filter" 12
 called to set/unset a PID for filtering.
.IP "read_mac_address" 12
 called to read the MAC address of the device.
.IP "frontend_attach" 12
 called to attach the possible frontends (fill fe-field
of struct dvb_usb_device).
.IP "tuner_attach" 12
 called to attach the correct tuner and to fill pll_addr,
pll_desc and pll_init_buf of struct dvb_usb_device).
.IP "identify_state" 12
 called to determine the state (cold or warm), when it
is not distinguishable by the USB IDs.
.IP "rc_key_map" 12
 a hard-wired array of struct dvb_usb_rc_key (NULL to disable
remote control handling).
.IP "rc_key_map_size" 12
 number of items in \fIrc_key_map\fP.
.IP "rc_query" 12
 called to query an event event.
.IP "rc_interval" 12
 time in ms between two queries.
.IP "i2c_algo" 12
 i2c_algorithm if the device has I2CoverUSB.
.IP "generic_bulk_ctrl_endpoint" 12
 most of the DVB USB devices have a generic
endpoint which received control messages with bulk transfers. When this
is non-zero, one can use dvb_usb_generic_rw and dvb_usb_generic_write-
helper functions.
.IP "urb" 12
 describes the kind of USB transfer used for MPEG2-TS-streaming.
(BULK or ISOC)
.IP "num_device_descs" 12
 number of struct dvb_usb_device_description in \fIdevices\fP
.IP "devices[9]" 12
 array of struct dvb_usb_device_description compatibles with these
properties.
.TH "Kernel API" 9 "struct dvb_usb_device" "January 2021" "API Manual" LINUX
.SH NAME
struct dvb_usb_device \-  object of a DVB USB device
.SH SYNOPSIS
struct dvb_usb_device {
.br
.BI "    struct dvb_usb_properties " props ""
;

.br
.BI "    struct dvb_usb_device_description *" desc ""
;

.br
.BI "#define DVB_USB_STATE_INIT        0x000"
.br
.BI "#define DVB_USB_STATE_URB_LIST    0x001"
.br
.BI "#define DVB_USB_STATE_URB_BUF     0x002"
.br
.BI "#define DVB_USB_STATE_DVB         0x004"
.br
.BI "#define DVB_USB_STATE_I2C         0x008"
.br
.BI "#define DVB_USB_STATE_REMOTE      0x010"
.br
.BI "#define DVB_USB_STATE_URB_SUBMIT  0x020"
.br
.BI "    int " state ""
;

.br
.BI "    struct usb_device *" udev ""
;

.br
.BI "    struct urb **" urb_list ""
;

.br
.BI "    int " buf_num ""
;

.br
.BI "    unsigned long " buf_size ""
;

.br
.BI "    u8 **" buf_list ""
;

.br
.BI "    dma_addr_t *" dma_addr ""
;

.br
.BI "    int " urbs_initialized ""
;

.br
.BI "    int " urbs_submitted ""
;

.br
.BI "    int " feedcount ""
;

.br
.BI "    int " pid_filtering ""
;

.br
.BI "    struct semaphore " usb_sem ""
;

.br
.BI "    struct semaphore " i2c_sem ""
;

.br
.BI "    struct i2c_adapter " i2c_adap ""
;

.br
.BI "    u8 " pll_addr ""
;

.br
.BI "    u8 " pll_init[4] ""
;

.br
.BI "    struct dvb_pll_desc *" pll_desc ""
;

.br
.BI "    int (*" tuner_pass_ctrl ") (struct dvb_frontend *, int, u8)"
;

.br
.BI "    struct dvb_adapter " dvb_adap ""
;

.br
.BI "    struct dmxdev " dmxdev ""
;

.br
.BI "    struct dvb_demux " demux ""
;

.br
.BI "    struct dvb_net " dvb_net ""
;

.br
.BI "    int " max_feed_count ""
;

.br
.BI "    int (*" fe_sleep ") (struct dvb_frontend *)"
;

.br
.BI "    int (*" fe_init ") (struct dvb_frontend *)"
;

.br
.BI "    struct input_dev " rc_input_dev ""
;

.br
.BI "    struct work_struct " rc_query_work ""
;

.br
.BI "    u32 " last_event ""
;

.br
.BI "    int " last_state ""
;

.br
.BI "    struct module *" owner ""
;

.br
.BI "    void *" priv ""
;

.br
};
.br
.SH Arguments
.IP "props" 12
 copy of the struct dvb_usb_properties this device belongs to.
.IP "desc" 12
 pointer to the device's struct dvb_usb_device_description.
.IP "state" 12
 initialization and runtime state of the device.
.IP "udev" 12
 pointer to the device's struct usb_device.
.IP "urb_list" 12
 array of dynamically allocated struct urb for the MPEG2-TS-
streaming.
.IP "buf_num" 12
 number of buffer allocated.
.IP "buf_size" 12
 size of each buffer in buf_list.
.IP "buf_list" 12
 array containing all allocate buffers for streaming.
.IP "dma_addr" 12
 list of dma_addr_t for each buffer in buf_list.
.IP "urbs_initialized" 12
 number of URBs initialized.
.IP "urbs_submitted" 12
 number of URBs submitted.
.IP "feedcount" 12
 number of reqested feeds (used for streaming-activation)
.IP "pid_filtering" 12
 is hardware pid_filtering used or not.
.IP "usb_sem" 12
 semaphore of USB control messages (reading needs two messages)
.IP "i2c_sem" 12
 semaphore for i2c-transfers
.IP "i2c_adap" 12
 device's i2c_adapter if it uses I2CoverUSB
.IP "pll_addr" 12
 I2C address of the tuner for programming
.IP "pll_init[4]" 12
 array containing the initialization buffer
.IP "pll_desc" 12
 pointer to the appropriate struct dvb_pll_desc
.IP "tuner_pass_ctrl" 12
 called to (de)activate tuner passthru of the demod or the board
.IP "dvb_adap" 12
 device's dvb_adapter.
.IP "dmxdev" 12
 device's dmxdev.
.IP "demux" 12
 device's software demuxer.
.IP "dvb_net" 12
 device's dvb_net interfaces.
.IP "max_feed_count" 12
 how many feeds can be handled simultaneously by this
device
.IP "fe_sleep" 12
 rerouted frontend-sleep function.
.IP "fe_init" 12
 rerouted frontend-init (wakeup) function.
.IP "rc_input_dev" 12
 input device for the remote control.
.IP "rc_query_work" 12
 struct work_struct frequent rc queries
.IP "last_event" 12
 last triggered event
.IP "last_state" 12
 last state (no, pressed, repeat)
.IP "owner" 12
 owner of the dvb_adapter
.IP "priv" 12
 private data of the actual driver (allocate by dvb-usb, size defined
in size_of_priv of dvb_usb_properties).
.TH "sp887x_initial_setup" 9 "sp887x_initial_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sp887x_initial_setup \- 
.SH SYNOPSIS
.B "int" sp887x_initial_setup
.BI "(struct dvb_frontend *" fe ","
.BI "const struct firmware *" fw ");"
.SH ARGUMENTS
.IP "fe" 12
-- undescribed --
.IP "fw" 12
-- undescribed --
.TH "divide" 9 "divide" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
divide \- 
.SH SYNOPSIS
.B "void" divide
.BI "(int " n ","
.BI "int " d ","
.BI "int *" quotient_i ","
.BI "int *" quotient_f ");"
.SH ARGUMENTS
.IP "n" 12
-- undescribed --
.IP "d" 12
-- undescribed --
.IP "quotient_i" 12
-- undescribed --
.IP "quotient_f" 12
-- undescribed --
.SH "DESCRIPTION"
derived from the ves1820/stv0299 driver code
.TH "driver_init" 9 "driver_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_init \-  initialize driver model.
.SH SYNOPSIS
.B "void __init" driver_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Call the driver model init functions to initialize their
subsystems. Called early from init/main.c.
.TH "firmware_timeout_store" 9 "firmware_timeout_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
firmware_timeout_store \- 
.SH SYNOPSIS
.B "ssize_t" firmware_timeout_store
.BI "(struct class *" class ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "class" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"
Sets the number of seconds to wait for the firmware.  Once
this expires an error will be return to the driver and no
firmware will be provided.
.SH "NOTE"
 zero means 'wait for ever'
.TH "firmware_loading_store" 9 "firmware_loading_store" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
firmware_loading_store \-  loading control file
.SH SYNOPSIS
.B "ssize_t" firmware_loading_store
.BI "(struct class_device *" class_dev ","
.BI "const char *" buf ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "class_dev" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "THE RELEVANT VALUES ARE"
.SH "1"
 Start a load, discarding any previous partial load.
.SH "0"
 Conclude the load and handle the data to the driver code.
-1: Conclude the load with an error and discard any written data.
.TH "firmware_data_write" 9 "firmware_data_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
firmware_data_write \- 
.SH SYNOPSIS
.B "ssize_t" firmware_data_write
.BI "(struct kobject *" kobj ","
.BI "char *" buffer ","
.BI "loff_t " offset ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "kobj" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.SH "DESCRIPTION"

Data written to the 'data' attribute will be later handled to
the driver as a firmware image.
.SH "DESCRIPTION"

Data written to the 'data' attribute will be later handled to
the driver as a firmware image.
.TH "request_firmware" 9 "request_firmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
request_firmware \-  request firmware to hotplug and wait for it
.SH SYNOPSIS
.B "int" request_firmware
.BI "(const struct firmware **" firmware_p ","
.BI "const char *" name ","
.BI "struct device *" device ");"
.SH ARGUMENTS
.IP "firmware_p" 12
-- undescribed --
.IP "name" 12
-- undescribed --
.IP "device" 12
-- undescribed --
.SH "DESCRIPTION"
\fIfirmware\fP will be used to return a firmware image by the name
of \fIname\fP for device \fIdevice\fP.

Should be called from user context where sleeping is allowed.

\fIname\fP will be use as $FIRMWARE in the hotplug environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.
.TH "release_firmware" 9 "release_firmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
release_firmware \-  release the resource associated with a firmware image
.SH SYNOPSIS
.B "void" release_firmware
.BI "(const struct firmware *" fw ");"
.SH ARGUMENTS
.IP "fw" 12
-- undescribed --
.TH "register_firmware" 9 "register_firmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_firmware \-  provide a firmware image for later usage
.SH SYNOPSIS
.B "void" register_firmware
.BI "(const char *" name ","
.BI "const u8 *" data ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "name" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
Make sure that \fIdata\fP will be available by requesting firmware \fIname\fP.
.SH "DESCRIPTION"
Make sure that \fIdata\fP will be available by requesting firmware \fIname\fP.
.SH "NOTE"
 This will not be possible until some kind of persistence
is available.
.TH "request_firmware_nowait" 9 "request_firmware_nowait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
request_firmware_nowait \- 
.SH SYNOPSIS
.B "int" request_firmware_nowait
.BI "(struct module *" module ","
.BI "int " hotplug ","
.BI "const char *" name ","
.BI "struct device *" device ","
.BI "void *" context ","
.BI "void (*" cont ") (const struct firmware *fw, void *context));"
.SH ARGUMENTS
.IP "module" 12
-- undescribed --
.IP "hotplug" 12
-- undescribed --
.IP "name" 12
-- undescribed --
.IP "device" 12
-- undescribed --
.IP "context" 12
-- undescribed --
.IP "cont" 12
-- undescribed --
.SH "DESCRIPTION"
Asynchronous variant of \fBrequest_firmware\fP for contexts where
it is not possible to sleep.

\fIhotplug\fP invokes hotplug event to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.

\fIcont\fP will be called asynchronously when the firmware request is over.

\fIcontext\fP will be passed over to \fIcont\fP.

\fIfw\fP may be NULL if firmware request fails.
.SH "DESCRIPTION"
Asynchronous variant of \fBrequest_firmware\fP for contexts where
it is not possible to sleep.

\fIhotplug\fP invokes hotplug event to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.

\fIcont\fP will be called asynchronously when the firmware request is over.

\fIcontext\fP will be passed over to \fIcont\fP.

\fIfw\fP may be NULL if firmware request fails.
.TH "bus_for_each_dev" 9 "bus_for_each_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_for_each_dev \-  device iterator.
.SH SYNOPSIS
.B "int" bus_for_each_dev
.BI "(struct bus_type *" bus ","
.BI "struct device *" start ","
.BI "void *" data ","
.BI "int (*" fn ") (struct device *, void *));"
.SH ARGUMENTS
.IP "bus" 12
	bus type.
.IP "start" 12
	device to start iterating from.
.IP "data" 12
	data for the callback.
.IP "fn" 12
	function to be called for each device.
.SH "DESCRIPTION"
Iterate over \fIbus\fP's list of devices, and call \fIfn\fP for each,
passing it \fIdata\fP. If \fIstart\fP is not NULL, we use that device to
begin iterating from.

We check the return of \fIfn\fP each time. If it returns anything
other than 0, we break out and return that value.
.SH "NOTE"
 The device that returns a non-zero value is not retained
in any way, nor is its refcount incremented. If the caller needs
to retain this data, it should do, and increment the reference
count in the supplied callback.
.TH "bus_find_device" 9 "bus_find_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_find_device \-  device iterator for locating a particular device.
.SH SYNOPSIS
.B "struct device *" bus_find_device
.BI "(struct bus_type *" bus ","
.BI "struct device *" start ","
.BI "void *" data ","
.BI "int (*" match ") (struct device *, void *));"
.SH ARGUMENTS
.IP "bus" 12
 bus type
.IP "start" 12
 Device to begin with
.IP "data" 12
 Data to pass to match function
.IP "match" 12
 Callback function to check device
.SH "DESCRIPTION"
This is similar to the \fBbus_for_each_dev\fP function above, but it
returns a reference to a device that is 'found' for later use, as
determined by the \fImatch\fP callback.

The callback should return 0 if the device doesn't match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.
.TH "bus_for_each_drv" 9 "bus_for_each_drv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_for_each_drv \-  driver iterator
.SH SYNOPSIS
.B "int" bus_for_each_drv
.BI "(struct bus_type *" bus ","
.BI "struct device_driver *" start ","
.BI "void *" data ","
.BI "int (*" fn ") (struct device_driver *, void *));"
.SH ARGUMENTS
.IP "bus" 12
	bus we're dealing with.
.IP "start" 12
	driver to start iterating on.
.IP "data" 12
	data to pass to the callback.
.IP "fn" 12
	function to call for each driver.
.SH "DESCRIPTION"
This is nearly identical to the device iterator above.
We iterate over each driver that belongs to \fIbus\fP, and call
\fIfn\fP for each. If \fIfn\fP returns anything but 0, we break out
and return it. If \fIstart\fP is not NULL, we use it as the head
of the list.
.SH "NOTE"
 we don't return the driver that returns a non-zero
value, nor do we leave the reference count incremented for that
driver. If the caller needs to know that info, it must set it
in the callback. It must also be sure to increment the refcount
so it doesn't disappear before returning to the caller.
.TH "bus_add_device" 9 "bus_add_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_add_device \-  add device to bus
.SH SYNOPSIS
.B "int" bus_add_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device being added
.SH "DESCRIPTION"
- Add the device to its bus's list of devices.
- Try to attach to driver.
- Create link to device's physical location.
.TH "bus_remove_device" 9 "bus_remove_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_remove_device \-  remove device from bus
.SH SYNOPSIS
.B "void" bus_remove_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device to be removed
.SH "DESCRIPTION"
- Remove symlink from bus's directory.
- Delete device from bus's list.
- Detach from its driver.
- Drop reference taken in \fBbus_add_device\fP.
.TH "bus_add_driver" 9 "bus_add_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_add_driver \-  Add a driver to the bus.
.SH SYNOPSIS
.B "int" bus_add_driver
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.TH "bus_remove_driver" 9 "bus_remove_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_remove_driver \-  delete driver from bus's knowledge.
.SH SYNOPSIS
.B "void" bus_remove_driver
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.SH "DESCRIPTION"
Detach the driver from the devices it controls, and remove
it from its bus's list of drivers. Finally, we drop the reference
to the bus we took in \fBbus_add_driver\fP.
.TH "bus_rescan_devices" 9 "bus_rescan_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_rescan_devices \-  rescan devices on the bus for possible drivers
.SH SYNOPSIS
.B "void" bus_rescan_devices
.BI "(struct bus_type *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 the bus to scan.
.SH "DESCRIPTION"
This function will look for devices on the bus with no driver
attached and rescan it against existing drivers to see if it matches
any by calling \fBdevice_attach\fP for the unbound devices.
.TH "find_bus" 9 "find_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_bus \-  locate bus by name.
.SH SYNOPSIS
.B "struct bus_type *" find_bus
.BI "(char *" name ");"
.SH ARGUMENTS
.IP "name" 12
	name of bus.
.SH "DESCRIPTION"
Call \fBkset_find_obj\fP to iterate over list of buses to
find a bus by name. Return bus if found.

Note that kset_find_obj increments bus' reference count.
.TH "bus_add_attrs" 9 "bus_add_attrs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_add_attrs \-  Add default attributes for this bus.
.SH SYNOPSIS
.B "int" bus_add_attrs
.BI "(struct bus_type *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
	Bus that has just been registered.
.TH "bus_register" 9 "bus_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_register \-  register a bus with the system.
.SH SYNOPSIS
.B "int" bus_register
.BI "(struct bus_type *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
	bus.
.SH "DESCRIPTION"
Once we have that, we registered the bus with the kobject
infrastructure, then register the children subsystems it has:
the devices and drivers that belong to the bus.
.TH "bus_unregister" 9 "bus_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bus_unregister \-  remove a bus from the system
.SH SYNOPSIS
.B "void" bus_unregister
.BI "(struct bus_type *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
	bus.
.SH "DESCRIPTION"
Unregister the child subsystems and the bus itself.
Finally, we call \fBput_bus\fP to release the refcount
.TH "attribute_container_classdev_to_container" 9 "attribute_container_classdev_to_container" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_classdev_to_container \-  given a classdev, return the container
.SH SYNOPSIS
.B "struct attribute_container *" attribute_container_classdev_to_container
.BI "(struct class_device *" classdev ");"
.SH ARGUMENTS
.IP "classdev" 12
 the class device created by attribute_container_add_device.
.SH "DESCRIPTION"
Returns the container associated with this classdev.
.SH "DESCRIPTION"
Returns the container associated with this classdev.
.TH "attribute_container_register" 9 "attribute_container_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_register \-  register an attribute container
.SH SYNOPSIS
.B "int" attribute_container_register
.BI "(struct attribute_container *" cont ");"
.SH ARGUMENTS
.IP "cont" 12
 The container to register.  This must be allocated by the
callee and should also be zeroed by it.
.SH "DESCRIPTION"
.TH "attribute_container_unregister" 9 "attribute_container_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_unregister \-  remove a container registration
.SH SYNOPSIS
.B "int" attribute_container_unregister
.BI "(struct attribute_container *" cont ");"
.SH ARGUMENTS
.IP "cont" 12
 previously registered container to remove
.SH "DESCRIPTION"
.TH "attribute_container_add_device" 9 "attribute_container_add_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_add_device \-  see if any container is interested in dev
.SH SYNOPSIS
.B "void" attribute_container_add_device
.BI "(struct device *" dev ","
.BI "int (*" fn ") (struct attribute_container *, 					 struct device *, 					 struct class_device *));"
.SH ARGUMENTS
.IP "dev" 12
 device to add attributes to
.IP "fn" 12
	 function to trigger addition of class device.
.SH "DESCRIPTION"
This function allocates storage for the class device(s) to be
attached to dev (one for each matching attribute_container).  If no
fn is provided, the code will simply register the class device via
class_device_add.  If a function is provided, it is expected to add
the class device at the appropriate time.  One of the things that
might be necessary is to allocate and initialise the classdev and
then add it a later time.  To do this, call this routine for
allocation and initialisation and then use
\fBattribute_container_device_trigger\fP to call \fBclass_device_add\fP on
it.  Note: after this, the class device contains a reference to dev
which is not relinquished until the release of the classdev.
.SH "DESCRIPTION"
This function allocates storage for the class device(s) to be
attached to dev (one for each matching attribute_container).  If no
fn is provided, the code will simply register the class device via
class_device_add.  If a function is provided, it is expected to add
the class device at the appropriate time.  One of the things that
might be necessary is to allocate and initialise the classdev and
then add it a later time.  To do this, call this routine for
allocation and initialisation and then use
\fBattribute_container_device_trigger\fP to call \fBclass_device_add\fP on
it.  Note: after this, the class device contains a reference to dev
which is not relinquished until the release of the classdev.
.TH "attribute_container_remove_device" 9 "attribute_container_remove_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_remove_device \-  make device eligible for removal.
.SH SYNOPSIS
.B "void" attribute_container_remove_device
.BI "(struct device *" dev ","
.BI "void (*" fn ") (struct attribute_container *, 					     struct device *, 					     struct class_device *));"
.SH ARGUMENTS
.IP "dev" 12
  The generic device
.IP "fn" 12
	  A function to call to remove the device
.SH "DESCRIPTION"
This routine triggers device removal.  If fn is NULL, then it is
simply done via class_device_unregister (note that if something
still has a reference to the classdev, then the memory occupied
will not be freed until the classdev is released).  If you want a
.SH "DESCRIPTION"
This routine triggers device removal.  If fn is NULL, then it is
simply done via class_device_unregister (note that if something
still has a reference to the classdev, then the memory occupied
will not be freed until the classdev is released).  If you want a
.SH "TWO PHASE RELEASE"
 remove from visibility and then delete the
device, then you should use this routine with a fn that calls
\fBclass_device_del\fP and then use
\fBattribute_container_device_trigger\fP to do the final put on the
classdev.
.TH "attribute_container_device_trigger" 9 "attribute_container_device_trigger" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_device_trigger \-  execute a trigger for each matching classdev
.SH SYNOPSIS
.B "void" attribute_container_device_trigger
.BI "(struct device *" dev ","
.BI "int (*" fn ") (struct attribute_container *, 					     struct device *, 					     struct class_device *));"
.SH ARGUMENTS
.IP "dev" 12
  The generic device to run the trigger for
\fIfn\fP	  the function to execute for each classdev.
.IP "fn" 12
-- undescribed --
.SH "DESCRIPTION"
This funcion is for executing a trigger when you need to know both
the container and the classdev.  If you only care about the
container, then use \fBattribute_container_trigger\fP instead.
.SH "DESCRIPTION"
This funcion is for executing a trigger when you need to know both
the container and the classdev.  If you only care about the
container, then use \fBattribute_container_trigger\fP instead.
.TH "attribute_container_trigger" 9 "attribute_container_trigger" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_trigger \-  trigger a function for each matching container
.SH SYNOPSIS
.B "void" attribute_container_trigger
.BI "(struct device *" dev ","
.BI "int (*" fn ") (struct attribute_container *, 				      struct device *));"
.SH ARGUMENTS
.IP "dev" 12
  The generic device to activate the trigger for
.IP "fn" 12
	  the function to trigger
.SH "DESCRIPTION"
This routine triggers a function that only needs to know the
matching containers (not the classdev) associated with a device.
It is more lightweight than attribute_container_device_trigger, so
should be used in preference unless the triggering function
actually needs to know the classdev.
.SH "DESCRIPTION"
This routine triggers a function that only needs to know the
matching containers (not the classdev) associated with a device.
It is more lightweight than attribute_container_device_trigger, so
should be used in preference unless the triggering function
actually needs to know the classdev.
.TH "attribute_container_add_attrs" 9 "attribute_container_add_attrs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_add_attrs \-  add attributes
.SH SYNOPSIS
.B "int" attribute_container_add_attrs
.BI "(struct class_device *" classdev ");"
.SH ARGUMENTS
.IP "classdev" 12
 The class device
.SH "DESCRIPTION"
This simply creates all the class device sysfs files from the
attributes listed in the container
.SH "DESCRIPTION"
This simply creates all the class device sysfs files from the
attributes listed in the container
.TH "attribute_container_add_class_device" 9 "attribute_container_add_class_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_add_class_device \-  same function as class_device_add
.SH SYNOPSIS
.B "int" attribute_container_add_class_device
.BI "(struct class_device *" classdev ");"
.SH ARGUMENTS
.IP "classdev" 12
	the class device to add
.SH "DESCRIPTION"
This performs essentially the same function as class_device_add except for
attribute containers, namely add the classdev to the system and then
create the attribute files
.SH "DESCRIPTION"
This performs essentially the same function as class_device_add except for
attribute containers, namely add the classdev to the system and then
create the attribute files
.TH "attribute_container_add_class_device_adapter" 9 "attribute_container_add_class_device_adapter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_add_class_device_adapter \-  simple adapter for triggers
.SH SYNOPSIS
.B "int" attribute_container_add_class_device_adapter
.BI "(struct attribute_container *" cont ","
.BI "struct device *" dev ","
.BI "struct class_device *" classdev ");"
.SH ARGUMENTS
.IP "cont" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.IP "classdev" 12
-- undescribed --
.SH "DESCRIPTION"

This function is identical to attribute_container_add_class_device except
that it is designed to be called from the triggers
.TH "attribute_container_remove_attrs" 9 "attribute_container_remove_attrs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_remove_attrs \-  remove any attribute files
.SH SYNOPSIS
.B "void" attribute_container_remove_attrs
.BI "(struct class_device *" classdev ");"
.SH ARGUMENTS
.IP "classdev" 12
 The class device to remove the files from
.SH "DESCRIPTION"
.TH "attribute_container_class_device_del" 9 "attribute_container_class_device_del" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_class_device_del \-  equivalent of class_device_del
.SH SYNOPSIS
.B "void" attribute_container_class_device_del
.BI "(struct class_device *" classdev ");"
.SH ARGUMENTS
.IP "classdev" 12
 the class device
.SH "DESCRIPTION"
This function simply removes all the attribute files and then calls
class_device_del.
.SH "DESCRIPTION"
This function simply removes all the attribute files and then calls
class_device_del.
.TH "attribute_container_find_class_device" 9 "attribute_container_find_class_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
attribute_container_find_class_device \-  find the corresponding class_device
.SH SYNOPSIS
.B "struct class_device *" attribute_container_find_class_device
.BI "(struct attribute_container *" cont ","
.BI "struct device *" dev ");"
.SH ARGUMENTS
.IP "cont" 12
	the container
.IP "dev" 12
	the generic device
.SH "DESCRIPTION"
Looks up the device in the container's list of class devices and returns
the corresponding class_device.
.SH "DESCRIPTION"
Looks up the device in the container's list of class devices and returns
the corresponding class_device.
.TH "sysdev_driver_register" 9 "sysdev_driver_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysdev_driver_register \-  Register auxillary driver
.SH SYNOPSIS
.B "int" sysdev_driver_register
.BI "(struct sysdev_class *" cls ","
.BI "struct sysdev_driver *" drv ");"
.SH ARGUMENTS
.IP "cls" 12
	Device class driver belongs to.
.IP "drv" 12
	Driver.
.SH "DESCRIPTION"
If \fIcls\fP is valid, then \fIdrv\fP is inserted into \fIcls\fP-&gt;drivers to be
called on each operation on devices of that class. The refcount
of \fIcls\fP is incremented.
Otherwise, \fIdrv\fP is inserted into sysdev_drivers, and called for
each device.
.TH "sysdev_driver_unregister" 9 "sysdev_driver_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysdev_driver_unregister \-  Remove an auxillary driver.
.SH SYNOPSIS
.B "void" sysdev_driver_unregister
.BI "(struct sysdev_class *" cls ","
.BI "struct sysdev_driver *" drv ");"
.SH ARGUMENTS
.IP "cls" 12
	Class driver belongs to.
.IP "drv" 12
	Driver.
.TH "sysdev_register" 9 "sysdev_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysdev_register \-  add a system device to the tree
.SH SYNOPSIS
.B "int" sysdev_register
.BI "(struct sys_device *" sysdev ");"
.SH ARGUMENTS
.IP "sysdev" 12
	device in question
.TH "sysdev_shutdown" 9 "sysdev_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysdev_shutdown \-  Shut down all system devices.
.SH SYNOPSIS
.B "void" sysdev_shutdown
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Loop over each class of system devices, and the devices in each
of those classes. For each device, we call the shutdown method for
each driver registered for the device - the globals, the auxillaries,
and the class driver.
.SH "NOTE"
 The list is iterated in reverse order, so that we shut down
child devices before we shut down thier parents. The list ordering
is guaranteed by virtue of the fact that child devices are registered
after their parents.
.TH "sysdev_suspend" 9 "sysdev_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysdev_suspend \-  Suspend all system devices.
.SH SYNOPSIS
.B "int" sysdev_suspend
.BI "(pm_message_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		Power state to enter.
.SH "DESCRIPTION"
We perform an almost identical operation as \fBsys_device_shutdown\fP
above, though calling -&gt;\fBsuspend\fP instead. Interrupts are disabled
when this called. Devices are responsible for both saving state and
quiescing or powering down the device.

This is only called by the device PM core, so we let them handle
all synchronization.
.TH "sysdev_resume" 9 "sysdev_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysdev_resume \-  Bring system devices back to life.
.SH SYNOPSIS
.B "int" sysdev_resume
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Similar to \fBsys_device_suspend\fP, but we iterate the list forwards
to guarantee that parent devices are resumed before their children.
.SH "NOTE"
 Interrupts are disabled when called.
.TH "transport_class_register" 9 "transport_class_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transport_class_register \-  register an initial transport class
.SH SYNOPSIS
.B "int" transport_class_register
.BI "(struct transport_class *" tclass ");"
.SH ARGUMENTS
.IP "tclass" 12
	a pointer to the transport class structure to be initialised
.SH "DESCRIPTION"
The transport class contains an embedded class which is used to
identify it.  The caller should initialise this structure with
zeros and then generic class must have been initialised with the
actual transport class unique name.  There's a macro
\fBDECLARE_TRANSPORT_CLASS\fP to do this (declared classes still must
be registered).

Returns 0 on success or error on failure.
.SH "DESCRIPTION"
The transport class contains an embedded class which is used to
identify it.  The caller should initialise this structure with
zeros and then generic class must have been initialised with the
actual transport class unique name.  There's a macro
\fBDECLARE_TRANSPORT_CLASS\fP to do this (declared classes still must
be registered).

Returns 0 on success or error on failure.
.TH "transport_class_unregister" 9 "transport_class_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transport_class_unregister \-  unregister a previously registered class
.SH SYNOPSIS
.B "void" transport_class_unregister
.BI "(struct transport_class *" tclass ");"
.SH ARGUMENTS
.IP "tclass" 12
 The transport class to unregister
.SH "DESCRIPTION"
Must be called prior to deallocating the memory for the transport
class.
.SH "DESCRIPTION"
Must be called prior to deallocating the memory for the transport
class.
.TH "anon_transport_class_register" 9 "anon_transport_class_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
anon_transport_class_register \-  register an anonymous class
.SH SYNOPSIS
.B "int" anon_transport_class_register
.BI "(struct anon_transport_class *" atc ");"
.SH ARGUMENTS
.IP "atc" 12
 The anon transport class to register
.SH "DESCRIPTION"
The anonymous transport class contains both a transport class and a
container.  The idea of an anonymous class is that it never
actually has any device attributes associated with it (and thus
saves on container storage).  So it can only be used for triggering
events.  Use prezero and then use \fBDECLARE_ANON_TRANSPORT_CLASS\fP to
initialise the anon transport class storage.
.SH "DESCRIPTION"
The anonymous transport class contains both a transport class and a
container.  The idea of an anonymous class is that it never
actually has any device attributes associated with it (and thus
saves on container storage).  So it can only be used for triggering
events.  Use prezero and then use \fBDECLARE_ANON_TRANSPORT_CLASS\fP to
initialise the anon transport class storage.
.TH "anon_transport_class_unregister" 9 "anon_transport_class_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
anon_transport_class_unregister \-  unregister an anon class
.SH SYNOPSIS
.B "void" anon_transport_class_unregister
.BI "(struct anon_transport_class *" atc ");"
.SH ARGUMENTS
.IP "atc" 12
 Pointer to the anon transport class to unregister
.SH "DESCRIPTION"
Must be called prior to deallocating the memory for the anon
transport class.
.SH "DESCRIPTION"
Must be called prior to deallocating the memory for the anon
transport class.
.TH "transport_setup_device" 9 "transport_setup_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transport_setup_device \-  declare a new dev for transport class association
.SH SYNOPSIS
.B "void" transport_setup_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the generic device representing the entity being added
.SH "DESCRIPTION"
Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point to see if any set of transport
classes wishes to associate with the added device.  This allocates
storage for the class device and initialises it, but does not yet
add it to the system or add attributes to it (you do this with
transport_add_device).  If you have no need for a separate setup
and add operations, use transport_register_device (see
transport_class.h).
.SH "DESCRIPTION"
Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point to see if any set of transport
classes wishes to associate with the added device.  This allocates
storage for the class device and initialises it, but does not yet
add it to the system or add attributes to it (you do this with
transport_add_device).  If you have no need for a separate setup
and add operations, use transport_register_device (see
transport_class.h).
.TH "transport_add_device" 9 "transport_add_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transport_add_device \-  declare a new dev for transport class association
.SH SYNOPSIS
.B "void" transport_add_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the generic device representing the entity being added
.SH "DESCRIPTION"
Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point used to add the device to the
system and register attributes for it.
.SH "DESCRIPTION"
Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point used to add the device to the
system and register attributes for it.
.TH "transport_configure_device" 9 "transport_configure_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transport_configure_device \-  configure an already set up device
.SH SYNOPSIS
.B "void" transport_configure_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 generic device representing device to be configured
.SH "DESCRIPTION"
The idea of configure is simply to provide a point within the setup
process to allow the transport class to extract information from a
device after it has been setup.  This is used in SCSI because we
have to have a setup device to begin using the HBA, but after we
send the initial inquiry, we use configure to extract the device
parameters.  The device need not have been added to be configured.
.SH "DESCRIPTION"
The idea of configure is simply to provide a point within the setup
process to allow the transport class to extract information from a
device after it has been setup.  This is used in SCSI because we
have to have a setup device to begin using the HBA, but after we
send the initial inquiry, we use configure to extract the device
parameters.  The device need not have been added to be configured.
.TH "transport_remove_device" 9 "transport_remove_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transport_remove_device \-  remove the visibility of a device
.SH SYNOPSIS
.B "void" transport_remove_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 generic device to remove
.SH "DESCRIPTION"
This call removes the visibility of the device (to the user from
sysfs), but does not destroy it.  To eliminate a device entirely
you must also call transport_destroy_device.  If you don't need to
do remove and destroy as separate operations, use
\fBtransport_unregister_device\fP (see transport_class.h) which will
perform both calls for you.
.SH "DESCRIPTION"
This call removes the visibility of the device (to the user from
sysfs), but does not destroy it.  To eliminate a device entirely
you must also call transport_destroy_device.  If you don't need to
do remove and destroy as separate operations, use
\fBtransport_unregister_device\fP (see transport_class.h) which will
perform both calls for you.
.TH "transport_destroy_device" 9 "transport_destroy_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
transport_destroy_device \-  destroy a removed device
.SH SYNOPSIS
.B "void" transport_destroy_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to eliminate from the transport class.
.SH "DESCRIPTION"
This call triggers the elimination of storage associated with the
transport classdev.  Note: all it really does is relinquish a
reference to the classdev.  The memory will not be freed until the
last reference goes to zero.  Note also that the classdev retains a
reference count on dev, so dev too will remain for as long as the
transport class device remains around.
.SH "DESCRIPTION"
This call triggers the elimination of storage associated with the
transport classdev.  Note: all it really does is relinquish a
reference to the classdev.  The memory will not be freed until the
last reference goes to zero.  Note also that the classdev retains a
reference count on dev, so dev too will remain for as long as the
transport class device remains around.
.TH "dma_pool_create" 9 "dma_pool_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_pool_create \-  Creates a pool of consistent memory blocks, for dma.
.SH SYNOPSIS
.B "struct dma_pool *" dma_pool_create
.BI "(const char *" name ","
.BI "struct device *" dev ","
.BI "size_t " size ","
.BI "size_t " align ","
.BI "size_t " allocation ");"
.SH ARGUMENTS
.IP "name" 12
 name of pool, for diagnostics
.IP "dev" 12
 device that will be doing the DMA
.IP "size" 12
 size of the blocks in this pool.
.IP "align" 12
 alignment requirement for blocks; must be a power of two
.IP "allocation" 12
 returned blocks won't cross this boundary (or zero)
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Returns a dma allocation pool with the requested characteristics, or
null if one can't be created.  Given one of these pools, \fBdma_pool_alloc\fP
may be used to allocate memory.  Such memory will all have "consistent"
DMA mappings, accessible by the device and its driver without using
cache flushing primitives.  The actual size of blocks allocated may be
larger than requested because of alignment.

If allocation is nonzero, objects returned from \fBdma_pool_alloc\fP won't
cross that size boundary.  This is useful for devices which have
addressing restrictions on individual DMA transfers, such as not crossing
boundaries of 4KBytes.
.TH "dma_pool_destroy" 9 "dma_pool_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_pool_destroy \-  destroys a pool of dma memory blocks.
.SH SYNOPSIS
.B "void" dma_pool_destroy
.BI "(struct dma_pool *" pool ");"
.SH ARGUMENTS
.IP "pool" 12
 dma pool that will be destroyed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Caller guarantees that no more memory from the pool is in use,
and that nothing will try to use the pool after this call.
.TH "dma_pool_alloc" 9 "dma_pool_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_pool_alloc \-  get a block of consistent memory
.SH SYNOPSIS
.B "void *" dma_pool_alloc
.BI "(struct dma_pool *" pool ","
.BI "gfp_t " mem_flags ","
.BI "dma_addr_t *" handle ");"
.SH ARGUMENTS
.IP "pool" 12
 dma pool that will produce the block
.IP "mem_flags" 12
 GFP_* bitmask
.IP "handle" 12
 pointer to dma address of block
.SH "DESCRIPTION"
This returns the kernel virtual address of a currently unused block,
and reports its dma address through the handle.
If such a memory block can't be allocated, null is returned.
.TH "dma_pool_free" 9 "dma_pool_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dma_pool_free \-  put block back into dma pool
.SH SYNOPSIS
.B "void" dma_pool_free
.BI "(struct dma_pool *" pool ","
.BI "void *" vaddr ","
.BI "dma_addr_t " dma ");"
.SH ARGUMENTS
.IP "pool" 12
 the dma pool holding the block
.IP "vaddr" 12
 virtual address of block
.IP "dma" 12
 dma address of block
.SH "DESCRIPTION"
Caller promises neither device nor driver will again touch this block
unless it is first re-allocated.
.TH "class_create" 9 "class_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
class_create \-  create a struct class structure
.SH SYNOPSIS
.B "struct class *" class_create
.BI "(struct module *" owner ","
.BI "char *" name ");"
.SH ARGUMENTS
.IP "owner" 12
 pointer to the module that is to "own" this struct class
.IP "name" 12
 pointer to a string for the name of this class.
.SH "DESCRIPTION"
This is used to create a struct class pointer that can then be used
in calls to \fBclass_device_create\fP.

Note, the pointer created here is to be destroyed when finished by
making a call to \fBclass_destroy\fP.
.TH "class_destroy" 9 "class_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
class_destroy \-  destroys a struct class structure
.SH SYNOPSIS
.B "void" class_destroy
.BI "(struct class *" cls ");"
.SH ARGUMENTS
.IP "cls" 12
-- undescribed --
.SH "DESCRIPTION"
Note, the pointer to be destroyed must have been created with a call
to \fBclass_create\fP.
.TH "class_device_create" 9 "class_device_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
class_device_create \-  creates a class device and registers it with sysfs
.SH SYNOPSIS
.B "struct class_device *" class_device_create
.BI "(struct class *" cls ","
.BI "dev_t " devt ","
.BI "struct device *" device ","
.BI "char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "cls" 12
-- undescribed --
.IP "devt" 12
-- undescribed --
.IP "device" 12
 a pointer to a struct device that is assiociated with this class device.
.IP "fmt" 12
 string for the class device's name
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
This function can be used by char device classes.  A struct
class_device will be created in sysfs, registered to the specified
class.  A "dev" file will be created, showing the dev_t for the
device.  The pointer to the struct class_device will be returned from
the call.  Any further sysfs files that might be required can be
created using this pointer.
.SH "NOTE"
 the struct class passed to this function must have previously
been created with a call to \fBclass_create\fP.
.TH "class_device_destroy" 9 "class_device_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
class_device_destroy \-  removes a class device that was created with class_device_create()
.SH SYNOPSIS
.B "void" class_device_destroy
.BI "(struct class *" cls ","
.BI "dev_t " devt ");"
.SH ARGUMENTS
.IP "cls" 12
 the pointer to the struct class that this device was registered * with.
.IP "devt" 12
-- undescribed --
.SH "DESCRIPTION"
This call unregisters and cleans up a class device that was created with a
call to \fBclass_device_create\fP
.TH "driver_for_each_device" 9 "driver_for_each_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_for_each_device \-  Iterator for devices bound to a driver.
.SH SYNOPSIS
.B "int" driver_for_each_device
.BI "(struct device_driver *" drv ","
.BI "struct device *" start ","
.BI "void *" data ","
.BI "int (*" fn ") (struct device *, void *));"
.SH ARGUMENTS
.IP "drv" 12
	Driver we're iterating.
.IP "start" 12
-- undescribed --
.IP "data" 12
	Data to pass to the callback.
.IP "fn" 12
	Function to call for each device.
.SH "DESCRIPTION"
Iterate over the \fIdrv\fP's list of devices calling \fIfn\fP for each one.
.TH "driver_find_device" 9 "driver_find_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_find_device \-  device iterator for locating a particular device.
.SH SYNOPSIS
.B "struct device *" driver_find_device
.BI "(struct device_driver *" drv ","
.BI "struct device *" start ","
.BI "void *" data ","
.BI "int (*" match ") (struct device *, void *));"
.SH ARGUMENTS
.IP "drv" 12
-- undescribed --
.IP "start" 12
 Device to begin with
.IP "data" 12
 Data to pass to match function
.IP "match" 12
 Callback function to check device
.SH "DESCRIPTION"
This is similar to the \fBdriver_for_each_device\fP function above, but
it returns a reference to a device that is 'found' for later use, as
determined by the \fImatch\fP callback.

The callback should return 0 if the device doesn't match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.
.TH "driver_create_file" 9 "driver_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_create_file \-  create sysfs file for driver.
.SH SYNOPSIS
.B "int" driver_create_file
.BI "(struct device_driver *" drv ","
.BI "struct driver_attribute *" attr ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.IP "attr" 12
	driver attribute descriptor.
.TH "driver_remove_file" 9 "driver_remove_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_remove_file \-  remove sysfs file for driver.
.SH SYNOPSIS
.B "void" driver_remove_file
.BI "(struct device_driver *" drv ","
.BI "struct driver_attribute *" attr ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.IP "attr" 12
	driver attribute descriptor.
.TH "get_driver" 9 "get_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_driver \-  increment driver reference count.
.SH SYNOPSIS
.B "struct device_driver *" get_driver
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.TH "put_driver" 9 "put_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_driver \-  decrement driver's refcount.
.SH SYNOPSIS
.B "void" put_driver
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.TH "driver_register" 9 "driver_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_register \-  register driver with bus
.SH SYNOPSIS
.B "int" driver_register
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
	driver to register
.SH "DESCRIPTION"
We pass off most of the work to the \fBbus_add_driver\fP call,
since most of the things we have to do deal with the bus
structures.

The one interesting aspect is that we setup \fIdrv\fP-&gt;unloaded
as a completion that gets complete when the driver reference
count reaches 0.
.TH "driver_unregister" 9 "driver_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_unregister \-  remove driver from system.
.SH SYNOPSIS
.B "void" driver_unregister
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.SH "DESCRIPTION"
Again, we pass off most of the work to the bus-level call.

Though, once that is done, we wait until \fIdrv\fP-&gt;unloaded is completed.
This will block until the driver refcount reaches 0, and it is
released. Only modular drivers will call this function, and we
have to guarantee that it won't complete, letting the driver
unload until all references are gone.
.TH "driver_find" 9 "driver_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_find \-  locate driver on a bus by its name.
.SH SYNOPSIS
.B "struct device_driver *" driver_find
.BI "(const char *" name ","
.BI "struct bus_type *" bus ");"
.SH ARGUMENTS
.IP "name" 12
	name of the driver.
.IP "bus" 12
	bus to scan for the driver.
.SH "DESCRIPTION"
Call \fBkset_find_obj\fP to iterate over list of drivers on
a bus to find driver by name. Return driver if found.

Note that kset_find_obj increments driver's reference count.
.TH "unregister_node" 9 "unregister_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_node \-  unregister a node device
.SH SYNOPSIS
.B "void" unregister_node
.BI "(struct node *" node ");"
.SH ARGUMENTS
.IP "node" 12
 node going away
.SH "DESCRIPTION"
Unregisters a node device \fInode\fP.  All the devices on the node must be
unregistered before calling this function.
.TH "platform_get_resource" 9 "platform_get_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_get_resource \-  get a resource for a device
.SH SYNOPSIS
.B "struct resource *" platform_get_resource
.BI "(struct platform_device *" dev ","
.BI "unsigned int " type ","
.BI "unsigned int " num ");"
.SH ARGUMENTS
.IP "dev" 12
 platform device
.IP "type" 12
 resource type
.IP "num" 12
 resource index
.TH "platform_get_irq" 9 "platform_get_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_get_irq \-  get an IRQ for a device
.SH SYNOPSIS
.B "int" platform_get_irq
.BI "(struct platform_device *" dev ","
.BI "unsigned int " num ");"
.SH ARGUMENTS
.IP "dev" 12
 platform device
.IP "num" 12
 IRQ number index
.TH "platform_get_resource_byname" 9 "platform_get_resource_byname" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_get_resource_byname \-  get a resource for a device by name
.SH SYNOPSIS
.B "struct resource *" platform_get_resource_byname
.BI "(struct platform_device *" dev ","
.BI "unsigned int " type ","
.BI "char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 platform device
.IP "type" 12
 resource type
.IP "name" 12
 resource name
.TH "platform_get_irq_byname" 9 "platform_get_irq_byname" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_get_irq_byname \-  get an IRQ for a device
.SH SYNOPSIS
.B "int" platform_get_irq_byname
.BI "(struct platform_device *" dev ","
.BI "char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 platform device
.IP "name" 12
 IRQ name
.TH "platform_add_devices" 9 "platform_add_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_add_devices \-  add a numbers of platform devices
.SH SYNOPSIS
.B "int" platform_add_devices
.BI "(struct platform_device **" devs ","
.BI "int " num ");"
.SH ARGUMENTS
.IP "devs" 12
 array of platform devices to add
.IP "num" 12
 number of platform devices in array
.TH "platform_device_register" 9 "platform_device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_device_register \-  add a platform-level device
.SH SYNOPSIS
.B "int" platform_device_register
.BI "(struct platform_device *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
	platform device we're adding
.TH "platform_device_unregister" 9 "platform_device_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_device_unregister \-  remove a platform-level device
.SH SYNOPSIS
.B "void" platform_device_unregister
.BI "(struct platform_device *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
	platform device we're removing
.SH "DESCRIPTION"
Note that this function will also release all memory- and port-based
resources owned by the device (\fIdev\fP-&gt;resource).
.TH "platform_device_register_simple" 9 "platform_device_register_simple" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_device_register_simple \- 
.SH SYNOPSIS
.B "struct platform_device *" platform_device_register_simple
.BI "(char *" name ","
.BI "unsigned int " id ","
.BI "struct resource *" res ","
.BI "unsigned int " num ");"
.SH ARGUMENTS
.IP "name" 12
  base name of the device we're adding
.IP "id" 12
    instance id
.IP "res" 12
   set of resources that needs to be allocated for the device
.IP "num" 12
	number of resources
.SH "DESCRIPTION"
This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing
memory allocated for the device allows drivers using such devices
to be unloaded iwithout waiting for the last reference to the device
to be dropped.
.TH "platform_match" 9 "platform_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
platform_match \-  bind platform device to platform driver.
.SH SYNOPSIS
.B "int" platform_match
.BI "(struct device *" dev ","
.BI "struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.IP "drv" 12
	driver.
.SH "PLATFORM DEVICE IDS ARE ASSUMED TO BE ENCODED LIKE THIS"
"&lt;name&gt;&lt;instance&gt;", where &lt;name&gt; is a short description of the
type of device, like "pci" or "floppy", and &lt;instance&gt; is the
enumerated instance of the device, like '0' or '42'.
Driver IDs are simply "&lt;name&gt;".
So, extract the &lt;name&gt; from the platform_device structure,
and compare it against the name of the driver. Return whether
they match or not.
.TH "device_release" 9 "device_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_release \-  free device structure.
.SH SYNOPSIS
.B "void" device_release
.BI "(struct kobject *" kobj ");"
.SH ARGUMENTS
.IP "kobj" 12
	device's kobject.
.SH "DESCRIPTION"
This is called once the reference count for the object
reaches 0. We forward the call to the device's release
method, which should handle actually freeing the structure.
.TH "decl_subsys" 9 "decl_subsys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
decl_subsys \-  structure to be registered with kobject core.
.SH SYNOPSIS
.B "" decl_subsys
.BI "(" devices ","
.BI "" &ktype_device ","
.BI "" &device_hotplug_ops ");"
.SH ARGUMENTS
.IP "devices" 12
.IP "&ktype_device" 12
.IP "&device_hotplug_ops" 12
.TH "device_create_file" 9 "device_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_create_file \-  create sysfs attribute file for device.
.SH SYNOPSIS
.B "int" device_create_file
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.IP "attr" 12
	device attribute descriptor.
.TH "device_remove_file" 9 "device_remove_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_remove_file \-  remove sysfs attribute file.
.SH SYNOPSIS
.B "void" device_remove_file
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.IP "attr" 12
	device attribute descriptor.
.TH "device_initialize" 9 "device_initialize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_initialize \-  init device structure.
.SH SYNOPSIS
.B "void" device_initialize
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.SH "DESCRIPTION"
This prepares the device for use by other layers,
including adding it to the device hierarchy.
It is the first half of \fBdevice_register\fP, if called by
that, though it can also be called separately, so one
may use \fIdev\fP's fields (e.g. the refcount).
.TH "device_add" 9 "device_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_add \-  add device to device hierarchy.
.SH SYNOPSIS
.B "int" device_add
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.SH "DESCRIPTION"
This is part 2 of \fBdevice_register\fP, though may be called
separately _iff_ \fBdevice_initialize\fP has been called separately.

This adds it to the kobject hierarchy via \fBkobject_add\fP, adds it
to the global and sibling lists for the device, then
adds it to the other relevant subsystems of the driver model.
.TH "device_register" 9 "device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_register \-  register a device with the system.
.SH SYNOPSIS
.B "int" device_register
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	pointer to the device structure
.SH "DESCRIPTION"
This happens in two clean steps - initialize the device
and add it to the system. The two steps can be called
separately, but this is the easiest and most common.
I.e. you should only call the two helpers separately if
have a clearly defined need to use and refcount the device
before it is added to the hierarchy.
.TH "get_device" 9 "get_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_device \-  increment reference count for device.
.SH SYNOPSIS
.B "struct device *" get_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.SH "DESCRIPTION"
This simply forwards the call to \fBkobject_get\fP, though
we do take care to provide for the case that we get a NULL
pointer passed in.
.TH "put_device" 9 "put_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
put_device \-  decrement reference count.
.SH SYNOPSIS
.B "void" put_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device in question.
.TH "device_del" 9 "device_del" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_del \-  delete device from system.
.SH SYNOPSIS
.B "void" device_del
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.SH "DESCRIPTION"
This is the first part of the device unregistration
sequence. This removes the device from the lists we control
from here, has it removed from the other driver model
subsystems it was added to in \fBdevice_add\fP, and removes it
from the kobject hierarchy.
.SH "NOTE"
 this should be called manually _iff_ \fBdevice_add\fP was
also called manually.
.TH "device_unregister" 9 "device_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_unregister \-  unregister device from system.
.SH SYNOPSIS
.B "void" device_unregister
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device going away.
.SH "DESCRIPTION"
We do this in two parts, like we do \fBdevice_register\fP. First,
we remove it from all the subsystems with \fBdevice_del\fP, then
we decrement the reference count via \fBput_device\fP. If that
is the final reference count, the device will be cleaned up
via \fBdevice_release\fP above. Otherwise, the structure will
stick around until the final reference to the device is dropped.
.TH "device_for_each_child" 9 "device_for_each_child" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_for_each_child \-  device child iterator.
.SH SYNOPSIS
.B "int" device_for_each_child
.BI "(struct device *" parent ","
.BI "void *" data ","
.BI "int (*" fn ") (struct device *, void *));"
.SH ARGUMENTS
.IP "parent" 12
-- undescribed --
.IP "data" 12
	data for the callback.
.IP "fn" 12
	function to be called for each device.
.SH "DESCRIPTION"
Iterate over \fIdev\fP's child devices, and call \fIfn\fP for each,
passing it \fIdata\fP.

We check the return of \fIfn\fP each time. If it returns anything
other than 0, we break out and return that value.
.TH "device_bind_driver" 9 "device_bind_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_bind_driver \-  bind a driver to one device.
.SH SYNOPSIS
.B "void" device_bind_driver
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.SH "DESCRIPTION"
Allow manual attachment of a driver to a device.
Caller must have already set \fIdev\fP-&gt;driver.

Note that this does not modify the bus reference count
nor take the bus's rwsem. Please verify those are accounted
for before calling this. (It is ok to call with no other effort
from a driver's \fBprobe\fP method.)

This function must be called with \fIdev\fP-&gt;sem held.
.TH "driver_probe_device" 9 "driver_probe_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_probe_device \-  attempt to bind device \\\amp; driver.
.SH SYNOPSIS
.B "int" driver_probe_device
.BI "(struct device_driver *" drv ","
.BI "struct device *" dev ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.IP "dev" 12
	device.
.SH "DESCRIPTION"
First, we call the bus's match function, if one present, which
should compare the device IDs the driver supports with the
device IDs of the device. Note we don't do this ourselves
because we don't know the format of the ID structures, nor what
is to be considered a match and what is not.


This function returns 1 if a match is found, an error if one
occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.

This function must be called with \fIdev\fP-&gt;sem held.
.TH "device_attach" 9 "device_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_attach \-  try to attach device to a driver.
.SH SYNOPSIS
.B "int" device_attach
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.SH "DESCRIPTION"
Walk the list of drivers that the bus has and call
\fBdriver_probe_device\fP for each pair. If a compatible
pair is found, break out and return.

Returns 1 if the device was bound to a driver;
0 if no matching device was found; error code otherwise.
.TH "driver_attach" 9 "driver_attach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_attach \-  try to bind driver to devices.
.SH SYNOPSIS
.B "void" driver_attach
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
	driver.
.SH "DESCRIPTION"
Walk the list of devices that the bus has on it and try to
match the driver with each one.  If \fBdriver_probe_device\fP
returns 0 and the \fIdev\fP-&gt;driver is set, we've found a
compatible pair.
.TH "__device_release_driver" 9 "__device_release_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__device_release_driver \-  manually detach device from driver.
.SH SYNOPSIS
.B "void" __device_release_driver
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device.
.SH "DESCRIPTION"
Manually detach device from driver.

\fB__device_release_driver\fP must be called with \fIdev\fP-&gt;sem held.
.TH "driver_detach" 9 "driver_detach" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
driver_detach \-  detach driver from all devices it controls.
.SH SYNOPSIS
.B "void" driver_detach
.BI "(struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 driver.
.TH "sysdev_shutdown" 9 "sysdev_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sysdev_shutdown \-  we suspend and shut them
.SH SYNOPSIS
.B "int" sysdev_shutdown
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
down last and resume them first. That way, we don't do anything stupid like
shutting down the interrupt controller before any devices..

Note that there are not different stages for power management calls -
they only get one called once when interrupts are disabled.
.TH "device_shutdown" 9 "device_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_shutdown \-  call -\\\gt;shutdown() on each device to shutdown.
.SH SYNOPSIS
.B "void" device_shutdown
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "device_pm_set_parent" 9 "device_pm_set_parent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_pm_set_parent \-  Specify power dependency.
.SH SYNOPSIS
.B "void" device_pm_set_parent
.BI "(struct device *" dev ","
.BI "struct device *" parent ");"
.SH ARGUMENTS
.IP "dev" 12
		Device who needs power.
.IP "parent" 12
	Device that supplies power.
.SH "DESCRIPTION"
This function is used to manually describe a power-dependency
relationship. It may be used to specify a transversal relationship
(where the power supplier is not the physical (or electrical)
ancestor of a specific device.
The effect of this is that the supplier will not be powered down
before the power dependent.
.TH "dpm_runtime_resume" 9 "dpm_runtime_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dpm_runtime_resume \-  Power one device back on.
.SH SYNOPSIS
.B "void" dpm_runtime_resume
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Device.
.SH "DESCRIPTION"
Bring one device back to the on state by first powering it
on, then restoring state. We only operate on devices that aren't
already on.
.SH "FIXME"
 We need to handle devices that are in an unknown state.
.TH "dpm_runtime_suspend" 9 "dpm_runtime_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dpm_runtime_suspend \-  Put one device in low-power state.
.SH SYNOPSIS
.B "int" dpm_runtime_suspend
.BI "(struct device *" dev ","
.BI "pm_message_t " state ");"
.SH ARGUMENTS
.IP "dev" 12
	Device.
.IP "state" 12
	State to enter.
.TH "dpm_set_power_state" 9 "dpm_set_power_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dpm_set_power_state \-  Update power_state field.
.SH SYNOPSIS
.B "void" dpm_set_power_state
.BI "(struct device *" dev ","
.BI "pm_message_t " state ");"
.SH ARGUMENTS
.IP "dev" 12
	Device.
.IP "state" 12
	Power state device is in.
.SH "DESCRIPTION"
This is an update mechanism for drivers to notify the core
what power state a device is in. Device probing code may not
always be able to tell, but we need accurate information to
work reliably.
.TH "suspend_device" 9 "suspend_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
suspend_device \-  Save state of one device.
.SH SYNOPSIS
.B "int" suspend_device
.BI "(struct device *" dev ","
.BI "pm_message_t " state ");"
.SH ARGUMENTS
.IP "dev" 12
	Device.
.IP "state" 12
	Power state device is entering.
.TH "device_suspend" 9 "device_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_suspend \-  Save state and stop all devices in system.
.SH SYNOPSIS
.B "int" device_suspend
.BI "(pm_message_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		Power state to put each device in.
.SH "DESCRIPTION"
Walk the dpm_active list, call -&gt;\fBsuspend\fP for each device, and move
it to dpm_off.
Check the return value for each. If it returns 0, then we move the
the device to the dpm_off list. If it returns -EAGAIN, we move it to
the dpm_off_irq list. If we get a different error, try and back out.

If we hit a failure with any of the devices, call \fBdevice_resume\fP
above to bring the suspended devices back to life.
.TH "device_power_down" 9 "device_power_down" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_power_down \-  Shut down special devices.
.SH SYNOPSIS
.B "int" device_power_down
.BI "(pm_message_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		Power state to enter.
.SH "DESCRIPTION"
Walk the dpm_off_irq list, calling -&gt;\fBpower_down\fP for each device that
couldn't power down the device with interrupts enabled. When we're
done, power down system devices.
.TH "resume_device" 9 "resume_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
resume_device \-  Restore state for one device.
.SH SYNOPSIS
.B "int" resume_device
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	Device.
.TH "device_resume" 9 "device_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_resume \-  Restore state of each device in system.
.SH SYNOPSIS
.B "void" device_resume
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Walk the dpm_off list, remove each entry, resume the device,
then add it to the dpm_active list.
.TH "dpm_power_up" 9 "dpm_power_up" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dpm_power_up \-  Power on some devices.
.SH SYNOPSIS
.B "void" dpm_power_up
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Walk the dpm_off_irq list and power each device up. This
is used for devices that required they be powered down with
interrupts disabled. As devices are powered on, they are moved to
the dpm_suspended list.

Interrupts must be disabled when calling this.
.TH "device_power_up" 9 "device_power_up" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_power_up \-  Turn on all devices that need special attention.
.SH SYNOPSIS
.B "void" device_power_up
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Power on system devices then devices that required we shut them down
with interrupts disabled.
Called with interrupts disabled.
.TH "state_show" 9 "state_show" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
state_show \-  Control current power state of device
.SH SYNOPSIS
.B "ssize_t" state_show
.BI "(struct device *" dev ","
.BI "struct device_attribute *" attr ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "attr" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"

\fBshow\fP returns the current power state of the device. '0' indicates
the device is on. Other values (1-3) indicate the device is in a low
power state.

\fBstore\fP sets the current power state, which is an integer value
between 0-3. If the device is on ('0'), and the value written is
greater than 0, then the device is placed directly into the low-power
state (via its driver's -&gt;\fBsuspend\fP method).
If the device is currently in a low-power state, and the value is 0,
the device is powered back on (via the -&gt;\fBresume\fP method).
If the device is in a low-power state, and a different low-power state
is requested, the device is first resumed, then suspended into the new
low-power state.
.TH "add_mtd_device" 9 "add_mtd_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
add_mtd_device \-  register an MTD device
.SH SYNOPSIS
.B "int" add_mtd_device
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
 pointer to new MTD device info structure
.SH "DESCRIPTION"
Add a device to the list of MTD devices present in the system, and
notify each currently active MTD 'user' of its arrival. Returns
zero on success or 1 on failure, which currently will only happen
if the number of present devices exceeds MAX_MTD_DEVICES (i.e. 16)
.TH "del_mtd_device" 9 "del_mtd_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
del_mtd_device \-  unregister an MTD device
.SH SYNOPSIS
.B "int" del_mtd_device
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
 pointer to MTD device info structure
.SH "DESCRIPTION"
Remove a device from the list of MTD devices present in the system,
and notify each currently active MTD 'user' of its departure.
Returns zero on success or 1 on failure, which currently will happen
if the requested device does not appear to be present in the list.
.TH "register_mtd_user" 9 "register_mtd_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_mtd_user \-  register a 'user' of MTD devices.
.SH SYNOPSIS
.B "void" register_mtd_user
.BI "(struct mtd_notifier *" new ");"
.SH ARGUMENTS
.IP "new" 12
 pointer to notifier info structure
.SH "DESCRIPTION"
Registers a pair of callbacks function to be called upon addition
or removal of MTD devices. Causes the 'add' callback to be immediately
invoked for each MTD device currently present in the system.
.TH "unregister_mtd_user" 9 "unregister_mtd_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_mtd_user \-  unregister a 'user' of MTD devices.
.SH SYNOPSIS
.B "int" unregister_mtd_user
.BI "(struct mtd_notifier *" old ");"
.SH ARGUMENTS
.IP "old" 12
 pointer to notifier info structure
.SH "DESCRIPTION"
Removes a callback function pair from the list of 'users' to be
notified upon addition or removal of MTD devices. Causes the
'remove' callback to be immediately invoked for each MTD device
currently present in the system.
.TH "get_mtd_device" 9 "get_mtd_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_mtd_device \-  obtain a validated handle for an MTD device
.SH SYNOPSIS
.B "struct mtd_info *" get_mtd_device
.BI "(struct mtd_info *" mtd ","
.BI "int " num ");"
.SH ARGUMENTS
.IP "mtd" 12
 last known address of the required MTD device
.IP "num" 12
 internal device number of the required MTD device
.SH "DESCRIPTION"
Given a number and NULL address, return the num'th entry in the device
table, if any.	Given an address and num == -1, search the device table
for a device with that address and return if it's still present. Given
both, return the num'th driver only if its address matches. Return NULL
if not.
.TH "check_pattern" 9 "check_pattern" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_pattern \-  [GENERIC] check if a pattern is in the buffer
.SH SYNOPSIS
.B "int" check_pattern
.BI "(uint8_t *" buf ","
.BI "int " len ","
.BI "int " paglen ","
.BI "struct nand_bbt_descr *" td ");"
.SH ARGUMENTS
.IP "buf" 12
	the buffer to search
.IP "len" 12
	the length of buffer to search
.IP "paglen" 12
	the pagelength
.IP "td" 12
		search pattern descriptor
.SH "DESCRIPTION"
Check for a pattern at the given place. Used to search bad block
tables and good / bad block identifiers.
If the SCAN_EMPTY option is set then check, if all bytes except the
pattern area contain 0xff
.TH "check_short_pattern" 9 "check_short_pattern" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_short_pattern \-  [GENERIC] check if a pattern is in the buffer
.SH SYNOPSIS
.B "int" check_short_pattern
.BI "(uint8_t *" buf ","
.BI "struct nand_bbt_descr *" td ");"
.SH ARGUMENTS
.IP "buf" 12
	the buffer to search
.IP "td" 12
		search pattern descriptor
.SH "DESCRIPTION"
Check for a pattern at the given place. Used to search bad block
tables and good / bad block identifiers. Same as check_pattern, but 
no optional empty check
.TH "read_bbt" 9 "read_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_bbt \-  [GENERIC] Read the bad block table starting from page
.SH SYNOPSIS
.B "int" read_bbt
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "int " page ","
.BI "int " num ","
.BI "int " bits ","
.BI "int " offs ","
.BI "int " reserved_block_code ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "page" 12
	the starting page
.IP "num" 12
	the number of bbt descriptors to read
.IP "bits" 12
	number of bits per block
.IP "offs" 12
	offset in the memory table
.IP "reserved_block_code" 12
	Pattern to identify reserved blocks
.SH "DESCRIPTION"
Read the bad block table starting from page.
.TH "read_abs_bbt" 9 "read_abs_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_abs_bbt \-  [GENERIC] Read the bad block table starting at a given page
.SH SYNOPSIS
.B "int" read_abs_bbt
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "struct nand_bbt_descr *" td ","
.BI "int " chip ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "td" 12
		descriptor for the bad block table 
.IP "chip" 12
	read the table for a specific chip, -1 read all chips.
Applies only if NAND_BBT_PERCHIP option is set
.SH "DESCRIPTION"
Read the bad block table for all chips starting at a given page
We assume that the bbt bits are in consecutive order.
.TH "read_abs_bbts" 9 "read_abs_bbts" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_abs_bbts \-  [GENERIC] Read the bad block table(s) for all chips starting at a given page
.SH SYNOPSIS
.B "int" read_abs_bbts
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "struct nand_bbt_descr *" td ","
.BI "struct nand_bbt_descr *" md ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "td" 12
		descriptor for the bad block table 
.IP "md" 12
		descriptor for the bad block table mirror
.SH "DESCRIPTION"
Read the bad block table(s) for all chips starting at a given page
We assume that the bbt bits are in consecutive order.
.TH "create_bbt" 9 "create_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
create_bbt \-  [GENERIC] Create a bad block table by scanning the device
.SH SYNOPSIS
.B "int" create_bbt
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "struct nand_bbt_descr *" bd ","
.BI "int " chip ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "bd" 12
		descriptor for the good/bad block search pattern
.IP "chip" 12
	create the table for a specific chip, -1 read all chips.
Applies only if NAND_BBT_PERCHIP option is set
.SH "DESCRIPTION"
Create a bad block table by scanning the device
for the given good/bad block identify pattern
.TH "search_bbt" 9 "search_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
search_bbt \-  [GENERIC] scan the device for a specific bad block table
.SH SYNOPSIS
.B "int" search_bbt
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "struct nand_bbt_descr *" td ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "td" 12
		descriptor for the bad block table
.SH "DESCRIPTION"
Read the bad block table by searching for a given ident pattern.
Search is preformed either from the beginning up or from the end of 
the device downwards. The search starts always at the start of a
block.
If the option NAND_BBT_PERCHIP is given, each chip is searched 
for a bbt, which contains the bad block information of this chip.
This is neccecary to provide support for certain DOC devices.

The bbt ident pattern resides in the oob area of the first page 
in a block. 
.TH "search_read_bbts" 9 "search_read_bbts" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
search_read_bbts \-  [GENERIC] scan the device for bad block table(s)
.SH SYNOPSIS
.B "int" search_read_bbts
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "struct nand_bbt_descr *" td ","
.BI "struct nand_bbt_descr *" md ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "td" 12
		descriptor for the bad block table 
.IP "md" 12
		descriptor for the bad block table mirror
.SH "DESCRIPTION"
Search and read the bad block table(s)
.TH "write_bbt" 9 "write_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_bbt \-  [GENERIC] (Re)write the bad block table
.SH SYNOPSIS
.B "int" write_bbt
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "struct nand_bbt_descr *" td ","
.BI "struct nand_bbt_descr *" md ","
.BI "int " chipsel ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "td" 12
		descriptor for the bad block table 
.IP "md" 12
		descriptor for the bad block table mirror
.IP "chipsel" 12
	selector for a specific chip, -1 for all
.SH "DESCRIPTION"
(Re)write the bad block table
.SH "DESCRIPTION"
(Re)write the bad block table
.TH "nand_memory_bbt" 9 "nand_memory_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_memory_bbt \-  [GENERIC] create a memory based bad block table
.SH SYNOPSIS
.B "int" nand_memory_bbt
.BI "(struct mtd_info *" mtd ","
.BI "struct nand_bbt_descr *" bd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "bd" 12
		descriptor for the good/bad block search pattern
.SH "DESCRIPTION"
The function creates a memory based bbt by scanning the device 
for manufacturer / software marked good / bad blocks
.TH "check_create" 9 "check_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
check_create \-  [GENERIC] create and write bbt(s) if neccecary
.SH SYNOPSIS
.B "int" check_create
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "struct nand_bbt_descr *" bd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "bd" 12
		descriptor for the good/bad block search pattern
.SH "DESCRIPTION"
The function checks the results of the previous call to read_bbt
and creates / updates the bbt(s) if neccecary
Creation is neccecary if no bbt was found for the chip/device
Update is neccecary if one of the tables is missing or the
version nr. of one table is less than the other
.TH "mark_bbt_region" 9 "mark_bbt_region" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mark_bbt_region \-  [GENERIC] mark the bad block table regions 
.SH SYNOPSIS
.B "void" mark_bbt_region
.BI "(struct mtd_info *" mtd ","
.BI "struct nand_bbt_descr *" td ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "td" 12
		bad block table descriptor
.SH "DESCRIPTION"
The bad block table regions are marked as "bad" to prevent
accidental erasures / writes. The regions are identified by
the mark 0x02.
.TH "nand_scan_bbt" 9 "nand_scan_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_scan_bbt \-  [NAND Interface] scan, find, read and maybe create bad block table(s)
.SH SYNOPSIS
.B "int" nand_scan_bbt
.BI "(struct mtd_info *" mtd ","
.BI "struct nand_bbt_descr *" bd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "bd" 12
		descriptor for the good/bad block search pattern
.SH "DESCRIPTION"
The function checks, if a bad block table(s) is/are already 
available. If not it scans the device for manufacturer
marked good / bad blocks and writes the bad block table(s) to
the selected place.

The bad block table memory is allocated here. It must be freed
by calling the nand_free_bbt function.
.TH "nand_update_bbt" 9 "nand_update_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_update_bbt \-  [NAND Interface] update bad block table(s) 
.SH SYNOPSIS
.B "int" nand_update_bbt
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " offs ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "offs" 12
	the offset of the newly marked block
.SH "DESCRIPTION"
The function updates the bad block table(s)
.TH "nand_default_bbt" 9 "nand_default_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_default_bbt \-  [NAND Interface] Select a default bad block table for the device 
.SH SYNOPSIS
.B "int" nand_default_bbt
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
This function selects the default bad block table
support for the device and calls the nand_scan_bbt function
.TH "nand_isbad_bbt" 9 "nand_isbad_bbt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_isbad_bbt \-  [NAND Interface] Check if a block is bad 
.SH SYNOPSIS
.B "int" nand_isbad_bbt
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " offs ","
.BI "int " allowbbt ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "offs" 12
	offset in the device
.IP "allowbbt" 12
	allow access to bad block table region
.TH "rtc_from4_errstat" 9 "rtc_from4_errstat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rtc_from4_errstat \-  perform additional error status checks
.SH SYNOPSIS
.B "int" rtc_from4_errstat
.BI "(struct mtd_info *" mtd ","
.BI "struct nand_chip *" this ","
.BI "int " state ","
.BI "int " status ","
.BI "int " page ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "this" 12
	NAND chip structure
.IP "state" 12
	state or the operation
.IP "status" 12
	status code returned from read status
.IP "page" 12
	startpage inside the chip, must be called with (page &amp; this-&gt;pagemask)
.SH "DESCRIPTION"
Perform additional error status checks on erase and write failures 
to determine if errors are correctable.  For this device, correctable 
1-bit errors on erase and write are considered acceptable.
.SH "NOTE"
 see pages 34..37 of data sheet for details.
.TH "au_read_byte" 9 "au_read_byte" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_read_byte \-   read one byte from the chip
.SH SYNOPSIS
.B "u_char" au_read_byte
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
read function for 8bit buswith
.TH "au_write_byte" 9 "au_write_byte" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_write_byte \-   write one byte to the chip
.SH SYNOPSIS
.B "void" au_write_byte
.BI "(struct mtd_info *" mtd ","
.BI "u_char " byte ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "byte" 12
	pointer to data byte to write
.SH "DESCRIPTION"
write function for 8it buswith
.TH "au_read_byte16" 9 "au_read_byte16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_read_byte16 \-   read one byte endianess aware from the chip
.SH SYNOPSIS
.B "u_char" au_read_byte16
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
read function for 16bit buswith with 
endianess conversion
.TH "au_write_byte16" 9 "au_write_byte16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_write_byte16 \-   write one byte endianess aware to the chip
.SH SYNOPSIS
.B "void" au_write_byte16
.BI "(struct mtd_info *" mtd ","
.BI "u_char " byte ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "byte" 12
	pointer to data byte to write
.SH "DESCRIPTION"
write function for 16bit buswith with
endianess conversion
.TH "au_read_word" 9 "au_read_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_read_word \-   read one word from the chip
.SH SYNOPSIS
.B "u16" au_read_word
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
read function for 16bit buswith without 
endianess conversion
.TH "au_write_word" 9 "au_write_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_write_word \-   write one word to the chip
.SH SYNOPSIS
.B "void" au_write_word
.BI "(struct mtd_info *" mtd ","
.BI "u16 " word ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "word" 12
	data word to write
.SH "DESCRIPTION"
write function for 16bit buswith without 
endianess conversion
.TH "au_write_buf" 9 "au_write_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_write_buf \-   write buffer to chip
.SH SYNOPSIS
.B "void" au_write_buf
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	data buffer
.IP "len" 12
	number of bytes to write
.SH "DESCRIPTION"
write function for 8bit buswith
.TH "au_read_buf" 9 "au_read_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_read_buf \-   read chip data into buffer 
.SH SYNOPSIS
.B "void" au_read_buf
.BI "(struct mtd_info *" mtd ","
.BI "u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer to store date
.IP "len" 12
	number of bytes to read
.SH "DESCRIPTION"
read function for 8bit buswith
.TH "au_verify_buf" 9 "au_verify_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_verify_buf \-   Verify chip data against buffer 
.SH SYNOPSIS
.B "int" au_verify_buf
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer containing the data to compare
.IP "len" 12
	number of bytes to compare
.SH "DESCRIPTION"
verify function for 8bit buswith
.TH "au_write_buf16" 9 "au_write_buf16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_write_buf16 \-   write buffer to chip
.SH SYNOPSIS
.B "void" au_write_buf16
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	data buffer
.IP "len" 12
	number of bytes to write
.SH "DESCRIPTION"
write function for 16bit buswith
.TH "au_read_buf16" 9 "au_read_buf16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_read_buf16 \-   read chip data into buffer 
.SH SYNOPSIS
.B "void" au_read_buf16
.BI "(struct mtd_info *" mtd ","
.BI "u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer to store date
.IP "len" 12
	number of bytes to read
.SH "DESCRIPTION"
read function for 16bit buswith
.TH "au_verify_buf16" 9 "au_verify_buf16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
au_verify_buf16 \-   Verify chip data against buffer 
.SH SYNOPSIS
.B "int" au_verify_buf16
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer containing the data to compare
.IP "len" 12
	number of bytes to compare
.SH "DESCRIPTION"
verify function for 16bit buswith
.TH "nand_trans_result" 9 "nand_trans_result" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_trans_result \-  [GENERIC] create non-inverted ECC
.SH SYNOPSIS
.B "void" nand_trans_result
.BI "(u_char " reg2 ","
.BI "u_char " reg3 ","
.BI "u_char *" ecc_code ");"
.SH ARGUMENTS
.IP "reg2" 12
	line parity reg 2
.IP "reg3" 12
	line parity reg 3
.IP "ecc_code" 12
	ecc 
.SH "DESCRIPTION"
Creates non-inverted ECC code from line parity
.TH "nand_calculate_ecc" 9 "nand_calculate_ecc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_calculate_ecc \-  [NAND Interface] Calculate 3 byte ECC code for 256 byte block
.SH SYNOPSIS
.B "int" nand_calculate_ecc
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" dat ","
.BI "u_char *" ecc_code ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD block structure
.IP "dat" 12
	raw data
.IP "ecc_code" 12
	buffer for ECC
.TH "nand_correct_data" 9 "nand_correct_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_correct_data \-  [NAND Interface] Detect and correct bit error(s)
.SH SYNOPSIS
.B "int" nand_correct_data
.BI "(struct mtd_info *" mtd ","
.BI "u_char *" dat ","
.BI "u_char *" read_ecc ","
.BI "u_char *" calc_ecc ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD block structure
.IP "dat" 12
	raw data read from the chip
.IP "read_ecc" 12
	ECC from the chip
.IP "calc_ecc" 12
	the ECC calculated from raw data
.SH "DESCRIPTION"
Detect and correct a 1 bit error for 256 byte block
.TH "nand_release_device" 9 "nand_release_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_release_device \-  [GENERIC] release chip
.SH SYNOPSIS
.B "void" nand_release_device
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
Deselect, release chip lock and wake up anyone waiting on the device 
.TH "nand_read_byte" 9 "nand_read_byte" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_byte \-  [DEFAULT] read one byte from the chip
.SH SYNOPSIS
.B "u_char" nand_read_byte
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
Default read function for 8bit buswith
.TH "nand_write_byte" 9 "nand_write_byte" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_byte \-  [DEFAULT] write one byte to the chip
.SH SYNOPSIS
.B "void" nand_write_byte
.BI "(struct mtd_info *" mtd ","
.BI "u_char " byte ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "byte" 12
	pointer to data byte to write
.SH "DESCRIPTION"
Default write function for 8it buswith
.TH "nand_read_byte16" 9 "nand_read_byte16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_byte16 \-  [DEFAULT] read one byte endianess aware from the chip
.SH SYNOPSIS
.B "u_char" nand_read_byte16
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
Default read function for 16bit buswith with 
endianess conversion
.TH "nand_write_byte16" 9 "nand_write_byte16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_byte16 \-  [DEFAULT] write one byte endianess aware to the chip
.SH SYNOPSIS
.B "void" nand_write_byte16
.BI "(struct mtd_info *" mtd ","
.BI "u_char " byte ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "byte" 12
	pointer to data byte to write
.SH "DESCRIPTION"
Default write function for 16bit buswith with
endianess conversion
.TH "nand_read_word" 9 "nand_read_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_word \-  [DEFAULT] read one word from the chip
.SH SYNOPSIS
.B "u16" nand_read_word
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
Default read function for 16bit buswith without 
endianess conversion
.TH "nand_write_word" 9 "nand_write_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_word \-  [DEFAULT] write one word to the chip
.SH SYNOPSIS
.B "void" nand_write_word
.BI "(struct mtd_info *" mtd ","
.BI "u16 " word ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "word" 12
	data word to write
.SH "DESCRIPTION"
Default write function for 16bit buswith without 
endianess conversion
.TH "nand_select_chip" 9 "nand_select_chip" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_select_chip \-  [DEFAULT] control CE line
.SH SYNOPSIS
.B "void" nand_select_chip
.BI "(struct mtd_info *" mtd ","
.BI "int " chip ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "chip" 12
	chipnumber to select, -1 for deselect
.SH "DESCRIPTION"
Default select function for 1 chip devices.
.TH "nand_write_buf" 9 "nand_write_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_buf \-  [DEFAULT] write buffer to chip
.SH SYNOPSIS
.B "void" nand_write_buf
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	data buffer
.IP "len" 12
	number of bytes to write
.SH "DESCRIPTION"
Default write function for 8bit buswith
.TH "nand_read_buf" 9 "nand_read_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_buf \-  [DEFAULT] read chip data into buffer 
.SH SYNOPSIS
.B "void" nand_read_buf
.BI "(struct mtd_info *" mtd ","
.BI "u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer to store date
.IP "len" 12
	number of bytes to read
.SH "DESCRIPTION"
Default read function for 8bit buswith
.TH "nand_verify_buf" 9 "nand_verify_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_verify_buf \-  [DEFAULT] Verify chip data against buffer 
.SH SYNOPSIS
.B "int" nand_verify_buf
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer containing the data to compare
.IP "len" 12
	number of bytes to compare
.SH "DESCRIPTION"
Default verify function for 8bit buswith
.TH "nand_write_buf16" 9 "nand_write_buf16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_buf16 \-  [DEFAULT] write buffer to chip
.SH SYNOPSIS
.B "void" nand_write_buf16
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	data buffer
.IP "len" 12
	number of bytes to write
.SH "DESCRIPTION"
Default write function for 16bit buswith
.TH "nand_read_buf16" 9 "nand_read_buf16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_buf16 \-  [DEFAULT] read chip data into buffer 
.SH SYNOPSIS
.B "void" nand_read_buf16
.BI "(struct mtd_info *" mtd ","
.BI "u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer to store date
.IP "len" 12
	number of bytes to read
.SH "DESCRIPTION"
Default read function for 16bit buswith
.TH "nand_verify_buf16" 9 "nand_verify_buf16" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_verify_buf16 \-  [DEFAULT] Verify chip data against buffer 
.SH SYNOPSIS
.B "int" nand_verify_buf16
.BI "(struct mtd_info *" mtd ","
.BI "const u_char *" buf ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	buffer containing the data to compare
.IP "len" 12
	number of bytes to compare
.SH "DESCRIPTION"
Default verify function for 16bit buswith
.TH "nand_block_bad" 9 "nand_block_bad" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_block_bad \-  [DEFAULT] Read bad block marker from the chip
.SH SYNOPSIS
.B "int" nand_block_bad
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " ofs ","
.BI "int " getchip ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "ofs" 12
	offset from device start
.IP "getchip" 12
	0, if the chip is already selected
.SH "DESCRIPTION"
Check, if the block is bad. 
.TH "nand_default_block_markbad" 9 "nand_default_block_markbad" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_default_block_markbad \-  [DEFAULT] mark a block bad
.SH SYNOPSIS
.B "int" nand_default_block_markbad
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " ofs ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "ofs" 12
	offset from device start
.SH "DESCRIPTION"
This is the default implementation, which can be overridden by
a hardware specific driver.
.TH "nand_check_wp" 9 "nand_check_wp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_check_wp \-  [GENERIC] check if the chip is write protected
.SH SYNOPSIS
.B "int" nand_check_wp
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
Check, if the device is write protected 
.SH "DESCRIPTION"
The function expects, that the device is already selected 
.TH "nand_block_checkbad" 9 "nand_block_checkbad" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_block_checkbad \-  [GENERIC] Check if a block is marked bad
.SH SYNOPSIS
.B "int" nand_block_checkbad
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " ofs ","
.BI "int " getchip ","
.BI "int " allowbbt ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "ofs" 12
	offset from device start
.IP "getchip" 12
	0, if the chip is already selected
.IP "allowbbt" 12
	1, if its allowed to access the bbt area
.SH "DESCRIPTION"
Check, if the block is bad. Either by reading the bad block table or
calling of the scan function.
.TH "nand_command" 9 "nand_command" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_command \-  [DEFAULT] Send command to NAND device
.SH SYNOPSIS
.B "void" nand_command
.BI "(struct mtd_info *" mtd ","
.BI "unsigned " command ","
.BI "int " column ","
.BI "int " page_addr ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "command" 12
	the command to be sent
.IP "column" 12
	the column address for this command, -1 if none
.IP "page_addr" 12
	the page address for this command, -1 if none
.SH "DESCRIPTION"
Send command to NAND device. This function is used for small page
devices (256/512 Bytes per page)
.TH "nand_command_lp" 9 "nand_command_lp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_command_lp \-  [DEFAULT] Send command to NAND large page device
.SH SYNOPSIS
.B "void" nand_command_lp
.BI "(struct mtd_info *" mtd ","
.BI "unsigned " command ","
.BI "int " column ","
.BI "int " page_addr ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "command" 12
	the command to be sent
.IP "column" 12
	the column address for this command, -1 if none
.IP "page_addr" 12
	the page address for this command, -1 if none
.SH "DESCRIPTION"
Send command to NAND device. This is the version for the new large page devices
We dont have the seperate regions as we have in the small page devices.
We must emulate NAND_CMD_READOOB to keep the code compatible.
.TH "nand_get_device" 9 "nand_get_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_get_device \-  [GENERIC] Get chip for selected access
.SH SYNOPSIS
.B "void" nand_get_device
.BI "(struct nand_chip *" this ","
.BI "struct mtd_info *" mtd ","
.BI "int " new_state ");"
.SH ARGUMENTS
.IP "this" 12
	the nand chip descriptor
.IP "mtd" 12
	MTD device structure
.IP "new_state" 12
	the state which is requested 
.SH "DESCRIPTION"
Get the device and lock it for exclusive access
.TH "nand_wait" 9 "nand_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_wait \-  [DEFAULT]  wait until the command is done
.SH SYNOPSIS
.B "int" nand_wait
.BI "(struct mtd_info *" mtd ","
.BI "struct nand_chip *" this ","
.BI "int " state ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "this" 12
	NAND chip structure
.IP "state" 12
	state to select the max. timeout value
.SH "DESCRIPTION"
Wait for command done. This applies to erase and program only
Erase can take up to 400ms and program up to 20ms according to 
general NAND and SmartMedia specs
.TH "nand_write_page" 9 "nand_write_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_page \-  [GENERIC] write one page
.SH SYNOPSIS
.B "int" nand_write_page
.BI "(struct mtd_info *" mtd ","
.BI "struct nand_chip *" this ","
.BI "int " page ","
.BI "u_char *" oob_buf ","
.BI "struct nand_oobinfo *" oobsel ","
.BI "int " cached ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "this" 12
	NAND chip structure
.IP "page" 12
 	startpage inside the chip, must be called with (page &amp; this-&gt;pagemask)
.IP "oob_buf" 12
	out of band data buffer
.IP "oobsel" 12
	out of band selecttion structre
.IP "cached" 12
	1 = enable cached programming if supported by chip
.SH "DESCRIPTION"
Nand_page_program function is used for write and writev !
This function will always program a full page of data
If you call it with a non page aligned buffer, you're lost :)

Cached programming is not supported yet.
.TH "nand_verify_pages" 9 "nand_verify_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_verify_pages \-  [GENERIC] verify the chip contents after a write
.SH SYNOPSIS
.B "int" nand_verify_pages
.BI "(struct mtd_info *" mtd ","
.BI "struct nand_chip *" this ","
.BI "int " page ","
.BI "int " numpages ","
.BI "u_char *" oob_buf ","
.BI "struct nand_oobinfo *" oobsel ","
.BI "int " chipnr ","
.BI "int " oobmode ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "this" 12
	NAND chip structure
.IP "page" 12
 	startpage inside the chip, must be called with (page &amp; this-&gt;pagemask)
.IP "numpages" 12
	number of pages to verify
.IP "oob_buf" 12
	out of band data buffer
.IP "oobsel" 12
	out of band selecttion structre
.IP "chipnr" 12
	number of the current chip
.IP "oobmode" 12
	1 = full buffer verify, 0 = ecc only
.SH "DESCRIPTION"
The NAND device assumes that it is always writing to a cleanly erased page.
Hence, it performs its internal write verification only on bits that 
transitioned from 1 to 0. The device does NOT verify the whole page on a
byte by byte basis. It is possible that the page was not completely erased 
or the page is becoming unusable due to wear. The read with ECC would catch 
the error later when the ECC page check fails, but we would rather catch 
it early in the page write stage. Better to write no data than invalid data.
.TH "nand_read" 9 "nand_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read \-  [MTD Interface] MTD compability function for nand_do_read_ecc
.SH SYNOPSIS
.B "int" nand_read
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " from ","
.BI "size_t " len ","
.BI "size_t *" retlen ","
.BI "u_char *" buf ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "from" 12
	offset to read from
.IP "len" 12
	number of bytes to read
.IP "retlen" 12
	pointer to variable to store the number of read bytes
.IP "buf" 12
	the databuffer to put data
.SH "DESCRIPTION"
This function simply calls nand_do_read_ecc with oob buffer and oobsel = NULL
and flags = 0xff
.TH "nand_read_ecc" 9 "nand_read_ecc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_ecc \-  [MTD Interface] MTD compability function for nand_do_read_ecc
.SH SYNOPSIS
.B "int" nand_read_ecc
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " from ","
.BI "size_t " len ","
.BI "size_t *" retlen ","
.BI "u_char *" buf ","
.BI "u_char *" oob_buf ","
.BI "struct nand_oobinfo *" oobsel ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "from" 12
	offset to read from
.IP "len" 12
	number of bytes to read
.IP "retlen" 12
	pointer to variable to store the number of read bytes
.IP "buf" 12
	the databuffer to put data
.IP "oob_buf" 12
	filesystem supplied oob data buffer
.IP "oobsel" 12
	oob selection structure
.SH "DESCRIPTION"
This function simply calls nand_do_read_ecc with flags = 0xff
.TH "nand_do_read_ecc" 9 "nand_do_read_ecc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_do_read_ecc \-  [MTD Interface] Read data with ECC
.SH SYNOPSIS
.B "int" nand_do_read_ecc
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " from ","
.BI "size_t " len ","
.BI "size_t *" retlen ","
.BI "u_char *" buf ","
.BI "u_char *" oob_buf ","
.BI "struct nand_oobinfo *" oobsel ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "from" 12
	offset to read from
.IP "len" 12
	number of bytes to read
.IP "retlen" 12
	pointer to variable to store the number of read bytes
.IP "buf" 12
	the databuffer to put data
.IP "oob_buf" 12
	filesystem supplied oob data buffer (can be NULL)
.IP "oobsel" 12
	oob selection structure
.IP "flags" 12
	flag to indicate if nand_get_device/nand_release_device should be preformed
.SH "AND HOW MANY CORRECTED ERROR BITS ARE ACCEPTABLE"
bits 0..7 - number of tolerable errors
bit  8    - 0 == do not get/release chip, 1 == get/release chip

NAND read with ECC
.TH "nand_read_oob" 9 "nand_read_oob" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_oob \-  [MTD Interface] NAND read out-of-band
.SH SYNOPSIS
.B "int" nand_read_oob
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " from ","
.BI "size_t " len ","
.BI "size_t *" retlen ","
.BI "u_char *" buf ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "from" 12
	offset to read from
.IP "len" 12
	number of bytes to read
.IP "retlen" 12
	pointer to variable to store the number of read bytes
.IP "buf" 12
	the databuffer to put data
.SH "DESCRIPTION"
NAND read out-of-band data from the spare area
.TH "nand_read_raw" 9 "nand_read_raw" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_read_raw \-  [GENERIC] Read raw data including oob into buffer
.SH SYNOPSIS
.B "int" nand_read_raw
.BI "(struct mtd_info *" mtd ","
.BI "uint8_t *" buf ","
.BI "loff_t " from ","
.BI "size_t " len ","
.BI "size_t " ooblen ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "buf" 12
	temporary buffer
.IP "from" 12
	offset to read from
.IP "len" 12
	number of bytes to read
.IP "ooblen" 12
	number of oob data bytes to read
.SH "DESCRIPTION"
Read raw data including oob into buffer
.TH "nand_prepare_oobbuf" 9 "nand_prepare_oobbuf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_prepare_oobbuf \-  [GENERIC] Prepare the out of band buffer 
.SH SYNOPSIS
.B "u_char *" nand_prepare_oobbuf
.BI "(struct mtd_info *" mtd ","
.BI "u_char *" fsbuf ","
.BI "struct nand_oobinfo *" oobsel ","
.BI "int " autoplace ","
.BI "int " numpages ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "fsbuf" 12
	buffer given by fs driver
.IP "oobsel" 12
	out of band selection structre
.IP "autoplace" 12
	1 = place given buffer into the oob bytes
.IP "numpages" 12
	number of pages to prepare
.SH "RETURN"
1. Filesystem buffer available and autoplacement is off,
return filesystem buffer
2. No filesystem buffer or autoplace is off, return internal
buffer
3. Filesystem buffer is given and autoplace selected
put data from fs buffer into internal buffer and
retrun internal buffer
.SH "NOTE"
 The internal buffer is filled with 0xff. This must
be done only once, when no autoplacement happens
Autoplacement sets the buffer dirty flag, which
forces the 0xff fill before using the buffer again.
.TH "nand_write" 9 "nand_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write \-  [MTD Interface] compability function for nand_write_ecc
.SH SYNOPSIS
.B "int" nand_write
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " to ","
.BI "size_t " len ","
.BI "size_t *" retlen ","
.BI "const u_char *" buf ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "to" 12
		offset to write to
.IP "len" 12
	number of bytes to write
.IP "retlen" 12
	pointer to variable to store the number of written bytes
.IP "buf" 12
	the data to write
.SH "DESCRIPTION"
This function simply calls nand_write_ecc with oob buffer and oobsel = NULL
.TH "nand_write_ecc" 9 "nand_write_ecc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_ecc \-  [MTD Interface] NAND write with ECC
.SH SYNOPSIS
.B "int" nand_write_ecc
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " to ","
.BI "size_t " len ","
.BI "size_t *" retlen ","
.BI "const u_char *" buf ","
.BI "u_char *" eccbuf ","
.BI "struct nand_oobinfo *" oobsel ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "to" 12
		offset to write to
.IP "len" 12
	number of bytes to write
.IP "retlen" 12
	pointer to variable to store the number of written bytes
.IP "buf" 12
	the data to write
.IP "eccbuf" 12
	filesystem supplied oob data buffer
.IP "oobsel" 12
	oob selection structure
.SH "DESCRIPTION"
NAND write with ECC
.TH "nand_write_oob" 9 "nand_write_oob" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_write_oob \-  [MTD Interface] NAND write out-of-band
.SH SYNOPSIS
.B "int" nand_write_oob
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " to ","
.BI "size_t " len ","
.BI "size_t *" retlen ","
.BI "const u_char *" buf ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "to" 12
		offset to write to
.IP "len" 12
	number of bytes to write
.IP "retlen" 12
	pointer to variable to store the number of written bytes
.IP "buf" 12
	the data to write
.SH "DESCRIPTION"
NAND write out-of-band
.TH "nand_writev" 9 "nand_writev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_writev \-  [MTD Interface] compabilty function for nand_writev_ecc
.SH SYNOPSIS
.B "int" nand_writev
.BI "(struct mtd_info *" mtd ","
.BI "const struct kvec *" vecs ","
.BI "unsigned long " count ","
.BI "loff_t " to ","
.BI "size_t *" retlen ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "vecs" 12
	the iovectors to write
.IP "count" 12
	number of vectors
.IP "to" 12
		offset to write to
.IP "retlen" 12
	pointer to variable to store the number of written bytes
.SH "DESCRIPTION"
NAND write with kvec. This just calls the ecc function
.TH "nand_writev_ecc" 9 "nand_writev_ecc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_writev_ecc \-  [MTD Interface] write with iovec with ecc
.SH SYNOPSIS
.B "int" nand_writev_ecc
.BI "(struct mtd_info *" mtd ","
.BI "const struct kvec *" vecs ","
.BI "unsigned long " count ","
.BI "loff_t " to ","
.BI "size_t *" retlen ","
.BI "u_char *" eccbuf ","
.BI "struct nand_oobinfo *" oobsel ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "vecs" 12
	the iovectors to write
.IP "count" 12
	number of vectors
.IP "to" 12
		offset to write to
.IP "retlen" 12
	pointer to variable to store the number of written bytes
.IP "eccbuf" 12
	filesystem supplied oob data buffer
.IP "oobsel" 12
	oob selection structure
.SH "DESCRIPTION"
NAND write with iovec with ecc
.TH "single_erase_cmd" 9 "single_erase_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
single_erase_cmd \-  [GENERIC] NAND standard block erase command function
.SH SYNOPSIS
.B "void" single_erase_cmd
.BI "(struct mtd_info *" mtd ","
.BI "int " page ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "page" 12
	the page address of the block which will be erased
.SH "DESCRIPTION"
Standard erase command for NAND chips
.TH "multi_erase_cmd" 9 "multi_erase_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
multi_erase_cmd \-  [GENERIC] AND specific block erase command function
.SH SYNOPSIS
.B "void" multi_erase_cmd
.BI "(struct mtd_info *" mtd ","
.BI "int " page ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "page" 12
	the page address of the block which will be erased
.SH "DESCRIPTION"
AND multi block erase command function
Erase 4 consecutive blocks
.TH "nand_erase" 9 "nand_erase" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_erase \-  [MTD Interface] erase block(s)
.SH SYNOPSIS
.B "int" nand_erase
.BI "(struct mtd_info *" mtd ","
.BI "struct erase_info *" instr ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "instr" 12
	erase instruction
.SH "DESCRIPTION"
Erase one ore more blocks
.TH "nand_erase_nand" 9 "nand_erase_nand" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_erase_nand \-  [NAND Interface] erase block(s)
.SH SYNOPSIS
.B "int" nand_erase_nand
.BI "(struct mtd_info *" mtd ","
.BI "struct erase_info *" instr ","
.BI "int " allowbbt ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "instr" 12
	erase instruction
.IP "allowbbt" 12
	allow erasing the bbt area
.SH "DESCRIPTION"
Erase one ore more blocks
.TH "nand_sync" 9 "nand_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_sync \-  [MTD Interface] sync
.SH SYNOPSIS
.B "void" nand_sync
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.SH "DESCRIPTION"
Sync is actually a wait for chip ready function
.TH "nand_block_isbad" 9 "nand_block_isbad" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_block_isbad \-  [MTD Interface] Check whether the block at the given offset is bad
.SH SYNOPSIS
.B "int" nand_block_isbad
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " ofs ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "ofs" 12
	offset relative to mtd start
.TH "nand_block_markbad" 9 "nand_block_markbad" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_block_markbad \-  [MTD Interface] Mark the block at the given offset as bad
.SH SYNOPSIS
.B "int" nand_block_markbad
.BI "(struct mtd_info *" mtd ","
.BI "loff_t " ofs ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "ofs" 12
	offset relative to mtd start
.TH "nand_scan" 9 "nand_scan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_scan \-  [NAND Interface] Scan for the NAND device
.SH SYNOPSIS
.B "int" nand_scan
.BI "(struct mtd_info *" mtd ","
.BI "int " maxchips ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.IP "maxchips" 12
	Number of chips to scan for
.SH "DESCRIPTION"
This fills out all the not initialized function pointers
with the defaults.
The flash ID is read and the mtd/chip structures are
filled with the appropriate values. Buffers are allocated if
they are not provided by the board driver
.TH "nand_release" 9 "nand_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nand_release \-  [NAND Interface] Free resources held by the NAND device 
.SH SYNOPSIS
.B "void" nand_release
.BI "(struct mtd_info *" mtd ");"
.SH ARGUMENTS
.IP "mtd" 12
	MTD device structure
.TH "blkmtd_add_page" 9 "blkmtd_add_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blkmtd_add_page \-  add a page to the current BIO
.SH SYNOPSIS
.B "struct bio *" blkmtd_add_page
.BI "(struct bio *" bio ","
.BI "struct block_device *" blkdev ","
.BI "struct page *" page ","
.BI "int " pagecnt ");"
.SH ARGUMENTS
.IP "bio" 12
 bio to add to (NULL to alloc initial bio)
.IP "blkdev" 12
 block device
.IP "page" 12
 page to add
.IP "pagecnt" 12
 pages left to add
.SH "DESCRIPTION"
Adds a page to the current bio, allocating it if necessary. If it cannot be
added, the current bio is written out and a new one is allocated. Returns
the new bio to add or NULL on error
.TH "write_pages" 9 "write_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_pages \-  write block of data to device via the page cache
.SH SYNOPSIS
.B "int" write_pages
.BI "(struct blkmtd_dev *" dev ","
.BI "const u_char *" buf ","
.BI "loff_t " to ","
.BI "size_t " len ","
.BI "size_t *" retlen ");"
.SH ARGUMENTS
.IP "dev" 12
 device to write to
.IP "buf" 12
 data source or NULL if erase (output is set to 0xff)
.IP "to" 12
 offset into output device
.IP "len" 12
 amount to data to write
.IP "retlen" 12
 amount of data written
.SH "DESCRIPTION"
Grab pages from the page cache and fill them with the source data.
Non page aligned start and end result in a readin of the page and
part of the page being modified. Pages are added to the bio and then written
out.
.TH "add_disk" 9 "add_disk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
add_disk \-  add partitioning information to kernel list
.SH SYNOPSIS
.B "void" add_disk
.BI "(struct gendisk *" disk ");"
.SH ARGUMENTS
.IP "disk" 12
 per-device partitioning information
.SH "DESCRIPTION"
This function registers the partitioning information in \fIdisk\fP
with the kernel.
.TH "get_gendisk" 9 "get_gendisk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_gendisk \-  get partitioning information for a given device
.SH SYNOPSIS
.B "struct gendisk *" get_gendisk
.BI "(dev_t " dev ","
.BI "int *" part ");"
.SH ARGUMENTS
.IP "dev" 12
 device to get partitioning information for
.IP "part" 12
-- undescribed --
.SH "DESCRIPTION"
This function gets the structure containing partitioning
information for the given device \fIdev\fP.
.TH "do_lo_send_aops" 9 "do_lo_send_aops" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_lo_send_aops \-  helper for writing data to a loop device
.SH SYNOPSIS
.B "int" do_lo_send_aops
.BI "(struct loop_device *" lo ","
.BI "struct bio_vec *" bvec ","
.BI "int " bsize ","
.BI "loff_t " pos ","
.BI "struct page *" page ");"
.SH ARGUMENTS
.IP "lo" 12
-- undescribed --
.IP "bvec" 12
-- undescribed --
.IP "bsize" 12
-- undescribed --
.IP "pos" 12
-- undescribed --
.IP "page" 12
-- undescribed --
.SH "DESCRIPTION"

This is the fast version for backing filesystems which implement the address
space operations prepare_write and commit_write.
.TH "__do_lo_send_write" 9 "__do_lo_send_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__do_lo_send_write \-  helper for writing data to a loop device
.SH SYNOPSIS
.B "int" __do_lo_send_write
.BI "(struct file *" file ","
.BI "u8 __user *" buf ","
.BI "const int " len ","
.BI "loff_t " pos ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.IP "pos" 12
-- undescribed --
.SH "DESCRIPTION"

This helper just factors out common code between \fBdo_lo_send_direct_write\fP
and \fBdo_lo_send_write\fP.
.TH "do_lo_send_direct_write" 9 "do_lo_send_direct_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_lo_send_direct_write \-  helper for writing data to a loop device
.SH SYNOPSIS
.B "int" do_lo_send_direct_write
.BI "(struct loop_device *" lo ","
.BI "struct bio_vec *" bvec ","
.BI "int " bsize ","
.BI "loff_t " pos ","
.BI "struct page *" page ");"
.SH ARGUMENTS
.IP "lo" 12
-- undescribed --
.IP "bvec" 12
-- undescribed --
.IP "bsize" 12
-- undescribed --
.IP "pos" 12
-- undescribed --
.IP "page" 12
-- undescribed --
.SH "DESCRIPTION"

This is the fast, non-transforming version for backing filesystems which do
not implement the address space operations prepare_write and commit_write.
It uses the write file operation which should be present on all writeable
filesystems.
.TH "do_lo_send_write" 9 "do_lo_send_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
do_lo_send_write \-  helper for writing data to a loop device
.SH SYNOPSIS
.B "int" do_lo_send_write
.BI "(struct loop_device *" lo ","
.BI "struct bio_vec *" bvec ","
.BI "int " bsize ","
.BI "loff_t " pos ","
.BI "struct page *" page ");"
.SH ARGUMENTS
.IP "lo" 12
-- undescribed --
.IP "bvec" 12
-- undescribed --
.IP "bsize" 12
-- undescribed --
.IP "pos" 12
-- undescribed --
.IP "page" 12
-- undescribed --
.SH "DESCRIPTION"

This is the slow, transforming version for filesystems which do not
implement the address space operations prepare_write and commit_write.  It
uses the write file operation which should be present on all writeable
filesystems.

Using fops-&gt;write is slower than using aops-&gt;{prepare,commit}_write in the
transforming case because we need to double buffer the data as we cannot do
the transformations in place as we do not have direct access to the
destination pages of the backing file.
.TH "blk_get_backing_dev_info" 9 "blk_get_backing_dev_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_get_backing_dev_info \-  get the address of a queue's backing_dev_info
.SH SYNOPSIS
.B "struct backing_dev_info *" blk_get_backing_dev_info
.BI "(struct block_device *" bdev ");"
.SH ARGUMENTS
.IP "bdev" 12
	device
.SH "DESCRIPTION"
Locates the passed device's request queue and returns the address of its
backing_dev_info

Will return NULL if the request queue cannot be located.
.TH "blk_queue_prep_rq" 9 "blk_queue_prep_rq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_prep_rq \-  set a prepare_request function for queue
.SH SYNOPSIS
.B "void" blk_queue_prep_rq
.BI "(request_queue_t *" q ","
.BI "prep_rq_fn *" pfn ");"
.SH ARGUMENTS
.IP "q" 12
		queue
.IP "pfn" 12
	prepare_request function
.SH "DESCRIPTION"
It's possible for a queue to register a prepare_request callback which
is invoked before the request is handed to the request_fn. The goal of
the function is to prepare a request for I/O, it can be used to build a
cdb from the request data for instance.
.TH "blk_queue_merge_bvec" 9 "blk_queue_merge_bvec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_merge_bvec \-  set a merge_bvec function for queue
.SH SYNOPSIS
.B "void" blk_queue_merge_bvec
.BI "(request_queue_t *" q ","
.BI "merge_bvec_fn *" mbfn ");"
.SH ARGUMENTS
.IP "q" 12
		queue
.IP "mbfn" 12
	merge_bvec_fn
.SH "DESCRIPTION"
Usually queues have static limitations on the max sectors or segments that
we can put in a request. Stacking drivers may have some settings that
are dynamic, and thus we have to query the queue whether it is ok to
add a new bio_vec to a bio at a given offset or not. If the block device
has such limitations, it needs to register a merge_bvec_fn to control
the size of bio's sent to it. Note that a block device *must* allow a
single page to be added to an empty bio. The block device driver may want
to use the \fBbio_split\fP function to deal with these bio's. By default
no merge_bvec_fn is defined for a queue, and only the fixed limits are
honored.
.TH "blk_queue_make_request" 9 "blk_queue_make_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_make_request \-  define an alternate make_request function for a device
.SH SYNOPSIS
.B "void" blk_queue_make_request
.BI "(request_queue_t *" q ","
.BI "make_request_fn *" mfn ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device to be affected
.IP "mfn" 12
 the alternate make_request function
.SH "DESCRIPTION"
The normal way for &amp;struct bios to be passed to a device
driver is for them to be collected into requests on a request
queue, and then to allow the device driver to select requests
off that queue when it is ready.  This works well for many block
devices. However some block devices (typically virtual devices
such as md or lvm) do not benefit from the processing on the
request queue, and are served best by having the requests passed
directly to them.  This can be achieved by providing a function
to \fBblk_queue_make_request\fP.
.SH "CAVEAT"
The driver that does this *must* be able to deal appropriately
with buffers in "highmemory". This can be accomplished by either calling
\fB__bio_kmap_atomic\fP to get a temporary kernel mapping, or by calling
\fBblk_queue_bounce\fP to create a buffer in normal memory.
.TH "blk_queue_ordered" 9 "blk_queue_ordered" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_ordered \-  does this queue support ordered writes
.SH SYNOPSIS
.B "void" blk_queue_ordered
.BI "(request_queue_t *" q ","
.BI "int " flag ");"
.SH ARGUMENTS
.IP "q" 12
     the request queue
.IP "flag" 12
  see below
.SH "DESCRIPTION"
For journalled file systems, doing ordered writes on a commit
block instead of explicitly doing wait_on_buffer (which is bad
for performance) can be a big win. Block drivers supporting this
feature should call this function and indicate so.
.TH "blk_queue_issue_flush_fn" 9 "blk_queue_issue_flush_fn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_issue_flush_fn \-  set function for issuing a flush
.SH SYNOPSIS
.B "void" blk_queue_issue_flush_fn
.BI "(request_queue_t *" q ","
.BI "issue_flush_fn *" iff ");"
.SH ARGUMENTS
.IP "q" 12
     the request queue
.IP "iff" 12
   the function to be called issuing the flush
.SH "DESCRIPTION"
If a driver supports issuing a flush command, the support is notified
to the block layer by defining it through this call.
.TH "blk_complete_barrier_rq" 9 "blk_complete_barrier_rq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_complete_barrier_rq \-  complete possible barrier request
.SH SYNOPSIS
.B "int" blk_complete_barrier_rq
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ","
.BI "int " sectors ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "rq" 12
  the request
.IP "sectors" 12
  number of sectors to complete
.SH "DESCRIPTION"
Used in driver end_io handling to determine whether to postpone
completion of a barrier request until a post flush has been done. This
is the unlocked variant, used if the caller doesn't already hold the
queue lock.
.TH "blk_complete_barrier_rq_locked" 9 "blk_complete_barrier_rq_locked" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_complete_barrier_rq_locked \-  complete possible barrier request
.SH SYNOPSIS
.B "int" blk_complete_barrier_rq_locked
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ","
.BI "int " sectors ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "rq" 12
  the request
.IP "sectors" 12
  number of sectors to complete
.SH "DESCRIPTION"
See \fBblk_complete_barrier_rq\fP. This variant must be used if the caller
holds the queue lock.
.TH "blk_queue_bounce_limit" 9 "blk_queue_bounce_limit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_bounce_limit \-  set bounce buffer limit for queue
.SH SYNOPSIS
.B "void" blk_queue_bounce_limit
.BI "(request_queue_t *" q ","
.BI "u64 " dma_addr ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "dma_addr" 12
   bus address limit
.SH "DESCRIPTION"
Different hardware can have different requirements as to what pages
it can do I/O directly to. A low level driver can call
blk_queue_bounce_limit to have lower memory pages allocated as bounce
buffers for doing I/O to pages residing above \fIpage\fP. By default
the block layer sets this to the highest numbered "low" memory page.
.TH "blk_queue_max_sectors" 9 "blk_queue_max_sectors" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_max_sectors \-  set max sectors for a request for this queue
.SH SYNOPSIS
.B "void" blk_queue_max_sectors
.BI "(request_queue_t *" q ","
.BI "unsigned short " max_sectors ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "max_sectors" 12
  max sectors in the usual 512b unit
.SH "DESCRIPTION"
Enables a low level driver to set an upper limit on the size of
received requests.
.TH "blk_queue_max_phys_segments" 9 "blk_queue_max_phys_segments" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_max_phys_segments \-  set max phys segments for a request for this queue
.SH SYNOPSIS
.B "void" blk_queue_max_phys_segments
.BI "(request_queue_t *" q ","
.BI "unsigned short " max_segments ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "max_segments" 12
  max number of segments
.SH "DESCRIPTION"
Enables a low level driver to set an upper limit on the number of
physical data segments in a request.  This would be the largest sized
scatter list the driver could handle.
.TH "blk_queue_max_hw_segments" 9 "blk_queue_max_hw_segments" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_max_hw_segments \-  set max hw segments for a request for this queue
.SH SYNOPSIS
.B "void" blk_queue_max_hw_segments
.BI "(request_queue_t *" q ","
.BI "unsigned short " max_segments ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "max_segments" 12
  max number of segments
.SH "DESCRIPTION"
Enables a low level driver to set an upper limit on the number of
hw data segments in a request.  This would be the largest number of
address/length pairs the host adapter can actually give as once
to the device.
.TH "blk_queue_max_segment_size" 9 "blk_queue_max_segment_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_max_segment_size \-  set max segment size for blk_rq_map_sg
.SH SYNOPSIS
.B "void" blk_queue_max_segment_size
.BI "(request_queue_t *" q ","
.BI "unsigned int " max_size ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "max_size" 12
  max size of segment in bytes
.SH "DESCRIPTION"
Enables a low level driver to set an upper limit on the size of a
coalesced segment
.TH "blk_queue_hardsect_size" 9 "blk_queue_hardsect_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_hardsect_size \-  set hardware sector size for the queue
.SH SYNOPSIS
.B "void" blk_queue_hardsect_size
.BI "(request_queue_t *" q ","
.BI "unsigned short " size ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "size" 12
  the hardware sector size, in bytes
.SH "DESCRIPTION"
This should typically be set to the lowest possible sector size
that the hardware can operate on (possible without reverting to
even internal read-modify-write operations). Usually the default
of 512 covers most hardware.
.TH "blk_queue_stack_limits" 9 "blk_queue_stack_limits" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_stack_limits \-  inherit underlying queue limits for stacked drivers
.SH SYNOPSIS
.B "void" blk_queue_stack_limits
.BI "(request_queue_t *" t ","
.BI "request_queue_t *" b ");"
.SH ARGUMENTS
.IP "t" 12
	the stacking driver (top)
.IP "b" 12
  the underlying device (bottom)
.TH "blk_queue_segment_boundary" 9 "blk_queue_segment_boundary" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_segment_boundary \-  set boundary rules for segment merging
.SH SYNOPSIS
.B "void" blk_queue_segment_boundary
.BI "(request_queue_t *" q ","
.BI "unsigned long " mask ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "mask" 12
  the memory boundary mask
.TH "blk_queue_dma_alignment" 9 "blk_queue_dma_alignment" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_dma_alignment \-  set dma length and memory alignment
.SH SYNOPSIS
.B "void" blk_queue_dma_alignment
.BI "(request_queue_t *" q ","
.BI "int " mask ");"
.SH ARGUMENTS
.IP "q" 12
     the request queue for the device
.IP "mask" 12
  alignment mask
.SH "DESCRIPTION"
set required memory and length aligment for direct dma transactions.
this is used when buiding direct io requests for the queue.
.TH "blk_queue_find_tag" 9 "blk_queue_find_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_find_tag \-  find a request by its tag and queue
.SH SYNOPSIS
.B "struct request *" blk_queue_find_tag
.BI "(request_queue_t *" q ","
.BI "int " tag ");"
.SH ARGUMENTS
.IP "q" 12
	 The request queue for the device
.IP "tag" 12
 The tag of the request
.SH "DESCRIPTION"
.SH "NOTES"
Should be used when a device returns a tag and you want to match
it with a request.

no locks need be held.
.TH "__blk_queue_free_tags" 9 "__blk_queue_free_tags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__blk_queue_free_tags \-  release tag maintenance info
.SH SYNOPSIS
.B "void" __blk_queue_free_tags
.BI "(request_queue_t *" q ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.SH "NOTES"
\fBblk_cleanup_queue\fP will take care of calling this function, if tagging
has been used. So there's no need to call this directly.
.TH "blk_queue_free_tags" 9 "blk_queue_free_tags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_free_tags \-  release tag maintenance info
.SH SYNOPSIS
.B "void" blk_queue_free_tags
.BI "(request_queue_t *" q ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.SH "NOTES"
This is used to disabled tagged queuing to a device, yet leave
queue in function.
.TH "blk_queue_init_tags" 9 "blk_queue_init_tags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_init_tags \-  initialize the queue tag info
.SH SYNOPSIS
.B "int" blk_queue_init_tags
.BI "(request_queue_t *" q ","
.BI "int " depth ","
.BI "struct blk_queue_tag *" tags ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "depth" 12
  the maximum queue depth supported
.IP "tags" 12
 the tag to use
.TH "blk_queue_resize_tags" 9 "blk_queue_resize_tags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_resize_tags \-  change the queueing depth
.SH SYNOPSIS
.B "int" blk_queue_resize_tags
.BI "(request_queue_t *" q ","
.BI "int " new_depth ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "new_depth" 12
 the new max command queueing depth
.SH "NOTES"
Must be called with the queue lock held.
.TH "blk_queue_end_tag" 9 "blk_queue_end_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_end_tag \-  end tag operations for a request
.SH SYNOPSIS
.B "void" blk_queue_end_tag
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "rq" 12
 the request that has completed
.SH "DESCRIPTION"
Typically called when \fBend_that_request_first\fP returns 0, meaning
all transfers have been done for a request. It's important to call
this function before \fBend_that_request_last\fP, as that will put the
request back on the free list thus corrupting the internal tag list.
.SH "NOTES"
queue lock must be held.
.TH "blk_queue_start_tag" 9 "blk_queue_start_tag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_start_tag \-  find a free tag and assign it
.SH SYNOPSIS
.B "int" blk_queue_start_tag
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.IP "rq" 12
  the block request that needs tagging
.SH "DESCRIPTION"
This can either be used as a stand-alone helper, or possibly be
assigned as the queue &amp;prep_rq_fn (in which case &amp;struct request
automagically gets a tag assigned). Note that this function
assumes that any type of request can be queued! if this is not
true for your device, you must check the request type before
calling this function.  The request will also be removed from
the request queue, so it's the drivers responsibility to readd
it if it should need to be restarted for some reason.
.SH "NOTES"
queue lock must be held.
.TH "blk_queue_invalidate_tags" 9 "blk_queue_invalidate_tags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_queue_invalidate_tags \-  invalidate all pending tags
.SH SYNOPSIS
.B "void" blk_queue_invalidate_tags
.BI "(request_queue_t *" q ");"
.SH ARGUMENTS
.IP "q" 12
  the request queue for the device
.SH "DESCRIPTION"
Hardware conditions may dictate a need to stop all pending requests.
In this case, we will safely clear the block side of the tag queue and
readd all requests to the request queue in the right order.
.SH "NOTES"
queue lock must be held.
.TH "generic_unplug_device" 9 "generic_unplug_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_unplug_device \-  fire a request queue
.SH SYNOPSIS
.B "void" generic_unplug_device
.BI "(request_queue_t *" q ");"
.SH ARGUMENTS
.IP "q" 12
    The &amp;request_queue_t in question
.SH "DESCRIPTION"
Linux uses plugging to build bigger requests queues before letting
the device have at them. If a queue is plugged, the I/O scheduler
is still adding and merging requests on the queue. Once the queue
gets unplugged, the request_fn defined for the queue is invoked and
transfers started.
.TH "blk_start_queue" 9 "blk_start_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_start_queue \-  restart a previously stopped queue
.SH SYNOPSIS
.B "void" blk_start_queue
.BI "(request_queue_t *" q ");"
.SH ARGUMENTS
.IP "q" 12
    The &amp;request_queue_t in question
.SH "DESCRIPTION"
\fBblk_start_queue\fP will clear the stop flag on the queue, and call
the request_fn for the queue if it was in a stopped state when
entered. Also see \fBblk_stop_queue\fP. Queue lock must be held.
.TH "blk_stop_queue" 9 "blk_stop_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_stop_queue \-  stop a queue
.SH SYNOPSIS
.B "void" blk_stop_queue
.BI "(request_queue_t *" q ");"
.SH ARGUMENTS
.IP "q" 12
    The &amp;request_queue_t in question
.SH "DESCRIPTION"
The Linux block layer assumes that a block driver will consume all
entries on the request queue when the request_fn strategy is called.
Often this will not happen, because of hardware limitations (queue
depth settings). If a device driver gets a 'queue full' response,
or if it simply chooses not to queue more I/O at one point, it can
call this function to prevent the request_fn from being called until
the driver has signalled it's ready to go again. This happens by calling
\fBblk_start_queue\fP to restart queue operations. Queue lock must be held.
.TH "blk_sync_queue" 9 "blk_sync_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_sync_queue \-  cancel any pending callbacks on a queue
.SH SYNOPSIS
.B "void" blk_sync_queue
.BI "(struct request_queue *" q ");"
.SH ARGUMENTS
.IP "q" 12
 the queue
.SH "DESCRIPTION"
The block layer may perform asynchronous callback activity
on a queue, such as calling the unplug function after a timeout.
A block device may call blk_sync_queue to ensure that any
such activity is cancelled, thus allowing it to release resources
the the callbacks might use. The caller must already have made sure
that its -&gt;make_request_fn will not re-add plugging prior to calling
this function.
.TH "blk_run_queue" 9 "blk_run_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_run_queue \-  run a single device queue
.SH SYNOPSIS
.B "void" blk_run_queue
.BI "(struct request_queue *" q ");"
.SH ARGUMENTS
.IP "q" 12
	The queue to run
.TH "blk_cleanup_queue" 9 "blk_cleanup_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_cleanup_queue \-  release a \\\amp;request_queue_t when it is no longer needed
.SH SYNOPSIS
.B "void" blk_cleanup_queue
.BI "(request_queue_t *" q ");"
.SH ARGUMENTS
.IP "q" 12
    the request queue to be released
.SH "DESCRIPTION"
blk_cleanup_queue is the pair to \fBblk_init_queue\fP or
\fBblk_queue_make_request\fP.  It should be called when a request queue is
being released; typically when a block device is being de-registered.
Currently, its primary task it to free all the &amp;struct request
structures that were allocated to the queue and the queue itself.
.SH "CAVEAT"
Hopefully the low level driver will have finished any
outstanding requests first...
.TH "blk_init_queue" 9 "blk_init_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_init_queue \-  prepare a request queue for use with a block device
.SH SYNOPSIS
.B "request_queue_t *" blk_init_queue
.BI "(request_fn_proc *" rfn ","
.BI "spinlock_t *" lock ");"
.SH ARGUMENTS
.IP "rfn" 12
  The function to be called to process requests that have been
placed on the queue.
.IP "lock" 12
 Request queue spin lock
.SH "DESCRIPTION"
If a block device wishes to use the standard request handling procedures,
which sorts requests and coalesces adjacent requests, then it must
call \fBblk_init_queue\fP.  The function \fIrfn\fP will be called when there
are requests on the queue that need to be processed.  If the device
supports plugging, then \fIrfn\fP may not be called immediately when requests
are available on the queue, but may be called at some time later instead.
Plugged queues are generally unplugged when a buffer belonging to one
of the requests on the queue is needed, or due to memory pressure.

\fIrfn\fP is not required, or even expected, to remove all requests off the
queue, but only as many as it can handle at a time.  If it does leave
requests on the queue, it is responsible for arranging that the requests
get dealt with eventually.

The queue spin lock must be held while manipulating the requests on the
request queue.

Function returns a pointer to the initialized request queue, or NULL if
it didn't succeed.
.SH "NOTE"
\fBblk_init_queue\fP must be paired with a \fBblk_cleanup_queue\fP call
when the block device is deactivated (such as at module unload).
.TH "blk_requeue_request" 9 "blk_requeue_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_requeue_request \-  put a request back on queue
.SH SYNOPSIS
.B "void" blk_requeue_request
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "q" 12
		request queue where request should be inserted
.IP "rq" 12
		request to be inserted
.SH "DESCRIPTION"
Drivers often keep queueing requests until the hardware cannot accept
more, when that condition happens we need to put the request back
on the queue. Must be called with queue lock held.
.TH "blk_insert_request" 9 "blk_insert_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_insert_request \-  insert a special request in to a request queue
.SH SYNOPSIS
.B "void" blk_insert_request
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ","
.BI "int " at_head ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "q" 12
		request queue where request should be inserted
.IP "rq" 12
		request to be inserted
.IP "at_head" 12
	insert request at head or tail of queue
.IP "data" 12
	private data
.SH "DESCRIPTION"
Many block devices need to execute commands asynchronously, so they don't
block the whole kernel from preemption during request execution.  This is
accomplished normally by inserting aritficial requests tagged as
REQ_SPECIAL in to the corresponding request queue, and letting them be
scheduled for actual execution by the request queue.

We have the option of inserting the head or the tail of the queue.
Typically we use the tail for new ioctls and so forth.  We use the head
of the queue for things like a QUEUE_FULL message from a device, or a
host that is unable to accept a particular command.
.TH "blk_rq_map_user" 9 "blk_rq_map_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_rq_map_user \-  map user data to a request, for REQ_BLOCK_PC usage
.SH SYNOPSIS
.B "int" blk_rq_map_user
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ","
.BI "void __user *" ubuf ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "q" 12
		request queue where request should be inserted
.IP "rq" 12
		request structure to fill
.IP "ubuf" 12
	the user buffer
.IP "len" 12
	length of user data
.SH "DESCRIPTION"
Data will be mapped directly for zero copy io, if possible. Otherwise
a kernel bounce buffer is used.

A matching \fBblk_rq_unmap_user\fP must be issued at the end of io, while
still in process context.
.SH "NOTE"
 The mapped bio may need to be bounced through \fBblk_queue_bounce\fP
before being submitted to the device, as pages mapped may be out of
reach. It's the callers responsibility to make sure this happens. The
original bio must be passed back in to \fBblk_rq_unmap_user\fP for proper
unmapping.
.TH "blk_rq_map_user_iov" 9 "blk_rq_map_user_iov" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_rq_map_user_iov \-  map user data to a request, for REQ_BLOCK_PC usage
.SH SYNOPSIS
.B "int" blk_rq_map_user_iov
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ","
.BI "struct sg_iovec *" iov ","
.BI "int " iov_count ");"
.SH ARGUMENTS
.IP "q" 12
		request queue where request should be inserted
.IP "rq" 12
		request to map data to
.IP "iov" 12
	pointer to the iovec
.IP "iov_count" 12
	number of elements in the iovec
.SH "DESCRIPTION"
Data will be mapped directly for zero copy io, if possible. Otherwise
a kernel bounce buffer is used.

A matching \fBblk_rq_unmap_user\fP must be issued at the end of io, while
still in process context.
.SH "NOTE"
 The mapped bio may need to be bounced through \fBblk_queue_bounce\fP
before being submitted to the device, as pages mapped may be out of
reach. It's the callers responsibility to make sure this happens. The
original bio must be passed back in to \fBblk_rq_unmap_user\fP for proper
unmapping.
.TH "blk_rq_unmap_user" 9 "blk_rq_unmap_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_rq_unmap_user \-  unmap a request with user data
.SH SYNOPSIS
.B "int" blk_rq_unmap_user
.BI "(struct bio *" bio ","
.BI "unsigned int " ulen ");"
.SH ARGUMENTS
.IP "bio" 12
	bio to be unmapped
.IP "ulen" 12
	length of user buffer
.SH "DESCRIPTION"
Unmap a bio previously mapped by \fBblk_rq_map_user\fP.
.TH "blk_rq_map_kern" 9 "blk_rq_map_kern" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_rq_map_kern \-  map kernel data to a request, for REQ_BLOCK_PC usage
.SH SYNOPSIS
.B "int" blk_rq_map_kern
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ","
.BI "void *" kbuf ","
.BI "unsigned int " len ","
.BI "unsigned int " gfp_mask ");"
.SH ARGUMENTS
.IP "q" 12
		request queue where request should be inserted
.IP "rq" 12
		request to fill
.IP "kbuf" 12
	the kernel buffer
.IP "len" 12
	length of user data
.IP "gfp_mask" 12
	memory allocation flags
.TH "blk_execute_rq_nowait" 9 "blk_execute_rq_nowait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_execute_rq_nowait \-  insert a request into queue for execution
.SH SYNOPSIS
.B "void" blk_execute_rq_nowait
.BI "(request_queue_t *" q ","
.BI "struct gendisk *" bd_disk ","
.BI "struct request *" rq ","
.BI "int " at_head ","
.BI "void (*" done ") (struct request *));"
.SH ARGUMENTS
.IP "q" 12
		queue to insert the request in
.IP "bd_disk" 12
	matching gendisk
.IP "rq" 12
		request to insert
.IP "at_head" 12
    insert request at head or tail of queue
.IP "done" 12
	I/O completion handler
.SH "DESCRIPTION"
Insert a fully prepared request at the back of the io scheduler queue
for execution.  Don't wait for completion.
.TH "blk_execute_rq" 9 "blk_execute_rq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_execute_rq \-  insert a request into queue for execution
.SH SYNOPSIS
.B "int" blk_execute_rq
.BI "(request_queue_t *" q ","
.BI "struct gendisk *" bd_disk ","
.BI "struct request *" rq ","
.BI "int " at_head ");"
.SH ARGUMENTS
.IP "q" 12
		queue to insert the request in
.IP "bd_disk" 12
	matching gendisk
.IP "rq" 12
		request to insert
.IP "at_head" 12
    insert request at head or tail of queue
.SH "DESCRIPTION"
Insert a fully prepared request at the back of the io scheduler queue
for execution and wait for completion.
.TH "blkdev_issue_flush" 9 "blkdev_issue_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blkdev_issue_flush \-  queue a flush
.SH SYNOPSIS
.B "int" blkdev_issue_flush
.BI "(struct block_device *" bdev ","
.BI "sector_t *" error_sector ");"
.SH ARGUMENTS
.IP "bdev" 12
	blockdev to issue flush for
.IP "error_sector" 12
	error sector
.SH "DESCRIPTION"
Issue a flush for the block device in question. Caller can supply
room for storing the error offset in case of a flush error, if they
wish to.  Caller must run \fBwait_for_completion\fP on its own.
.TH "blk_end_sync_rq" 9 "blk_end_sync_rq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_end_sync_rq \-  executes a completion event on a request
.SH SYNOPSIS
.B "void" blk_end_sync_rq
.BI "(struct request *" rq ");"
.SH ARGUMENTS
.IP "rq" 12
 request to complete
.TH "blk_congestion_wait" 9 "blk_congestion_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_congestion_wait \-  wait for a queue to become uncongested
.SH SYNOPSIS
.B "long" blk_congestion_wait
.BI "(int " rw ","
.BI "long " timeout ");"
.SH ARGUMENTS
.IP "rw" 12
 READ or WRITE
.IP "timeout" 12
 timeout in jiffies
.SH "DESCRIPTION"
Waits for up to \fItimeout\fP jiffies for a queue (any queue) to exit congestion.
If no queues are congested then just wait for the next request to be
returned.
.TH "blk_attempt_remerge" 9 "blk_attempt_remerge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
blk_attempt_remerge \-  attempt to remerge active head with next request
.SH SYNOPSIS
.B "void" blk_attempt_remerge
.BI "(request_queue_t *" q ","
.BI "struct request *" rq ");"
.SH ARGUMENTS
.IP "q" 12
    The &amp;request_queue_t belonging to the device
.IP "rq" 12
   The head request (usually)
.SH "DESCRIPTION"
For head-active devices, the queue can easily be unplugged so quickly
that proper merging is not done on the front request. This may hurt
performance greatly for some devices. The block layer cannot safely
do merging on that first request for these queues, but the driver can
call this function and make it happen any way. Only the driver knows
when it is safe to do so.
.TH "generic_make_request" 9 "generic_make_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
generic_make_request \- 
.SH SYNOPSIS
.B "void" generic_make_request
.BI "(struct bio *" bio ");"
.SH ARGUMENTS
.IP "bio" 12
  The bio describing the location in memory and on the device.
.SH "DESCRIPTION"
\fBgeneric_make_request\fP is used to make I/O requests of block
devices. It is passed a &amp;struct bio, which describes the I/O that needs
to be done.

\fBgeneric_make_request\fP does not return any status.  The
success/failure status of the request, along with notification of
completion, is delivered asynchronously through the bio-&gt;bi_end_io
function described (one day) else where.

The caller of generic_make_request must make sure that bi_io_vec
are set to describe the memory buffer, and that bi_dev and bi_sector are
set to describe the device address, and the
bi_end_io and optionally bi_private are set to describe how
completion notification should be signaled.

generic_make_request and the drivers it calls may use bi_next if this
bio happens to be merged with someone else, and may change bi_dev and
bi_sector for remaps as it sees fit.  So the values of these fields
should NOT be depended on after the call to generic_make_request.
.TH "submit_bio" 9 "submit_bio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
submit_bio \- 
.SH SYNOPSIS
.B "void" submit_bio
.BI "(int " rw ","
.BI "struct bio *" bio ");"
.SH ARGUMENTS
.IP "rw" 12
 whether to READ or WRITE, or maybe to READA (read ahead)
.IP "bio" 12
 The &amp;struct bio which describes the I/O
.SH "DESCRIPTION"
\fBsubmit_bio\fP is very similar in purpose to \fBgeneric_make_request\fP, and
uses that function to do most of the work. Both are fairly rough
interfaces, \fIbio\fP must be presetup and ready for I/O.
.TH "end_that_request_first" 9 "end_that_request_first" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
end_that_request_first \-  end I/O on a request
.SH SYNOPSIS
.B "int" end_that_request_first
.BI "(struct request *" req ","
.BI "int " uptodate ","
.BI "int " nr_sectors ");"
.SH ARGUMENTS
.IP "req" 12
      the request being processed
.IP "uptodate" 12
 1 for success, 0 for I/O error, &lt; 0 for specific error
.IP "nr_sectors" 12
 number of sectors to end I/O on
.SH "DESCRIPTION"
Ends I/O on a number of sectors attached to \fIreq\fP, and sets it up
for the next range of segments (if any) in the cluster.
.SH "RETURN"
0 - we are done with this request, call \fBend_that_request_last\fP
1 - still buffers pending for this request
.TH "end_that_request_chunk" 9 "end_that_request_chunk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
end_that_request_chunk \-  end I/O on a request
.SH SYNOPSIS
.B "int" end_that_request_chunk
.BI "(struct request *" req ","
.BI "int " uptodate ","
.BI "int " nr_bytes ");"
.SH ARGUMENTS
.IP "req" 12
      the request being processed
.IP "uptodate" 12
 1 for success, 0 for I/O error, &lt; 0 for specific error
.IP "nr_bytes" 12
 number of bytes to complete
.SH "DESCRIPTION"
Ends I/O on a number of bytes attached to \fIreq\fP, and sets it up
for the next range of segments (if any). Like \fBend_that_request_first\fP,
but deals with bytes instead of sectors.
.SH "RETURN"
0 - we are done with this request, call \fBend_that_request_last\fP
1 - still buffers pending for this request
.TH "lego_usb_tower_debug_data" 9 "lego_usb_tower_debug_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lego_usb_tower_debug_data \- 
.SH SYNOPSIS
.B "void" lego_usb_tower_debug_data
.BI "(int " level ","
.BI "const char *" function ","
.BI "int " size ","
.BI "const unsigned char *" data ");"
.SH ARGUMENTS
.IP "level" 12
-- undescribed --
.IP "function" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.TH "tower_delete" 9 "tower_delete" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_delete \- 
.SH SYNOPSIS
.B "void" tower_delete
.BI "(struct lego_usb_tower *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.TH "tower_open" 9 "tower_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_open \- 
.SH SYNOPSIS
.B "int" tower_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.TH "tower_release" 9 "tower_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_release \- 
.SH SYNOPSIS
.B "int" tower_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.TH "tower_abort_transfers" 9 "tower_abort_transfers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_abort_transfers \- 
.SH SYNOPSIS
.B "void" tower_abort_transfers
.BI "(struct lego_usb_tower *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
aborts transfers and frees associated data structures
.TH "tower_check_for_read_packet" 9 "tower_check_for_read_packet" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_check_for_read_packet \- 
.SH SYNOPSIS
.B "void" tower_check_for_read_packet
.BI "(struct lego_usb_tower *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

To get correct semantics for signals and non-blocking I/O
with packetizing we pretend not to see any data in the read buffer
until it has been there unchanged for at least
dev-&gt;packet_timeout_jiffies, or until the buffer is full.
.TH "tower_poll" 9 "tower_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_poll \- 
.SH SYNOPSIS
.B "unsigned int" tower_poll
.BI "(struct file *" file ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "wait" 12
-- undescribed --
.TH "tower_llseek" 9 "tower_llseek" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_llseek \- 
.SH SYNOPSIS
.B "loff_t" tower_llseek
.BI "(struct file *" file ","
.BI "loff_t " off ","
.BI "int " whence ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "off" 12
-- undescribed --
.IP "whence" 12
-- undescribed --
.TH "tower_read" 9 "tower_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_read \- 
.SH SYNOPSIS
.B "ssize_t" tower_read
.BI "(struct file *" file ","
.BI "char __user *" buffer ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "ppos" 12
-- undescribed --
.TH "tower_write" 9 "tower_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_write \- 
.SH SYNOPSIS
.B "ssize_t" tower_write
.BI "(struct file *" file ","
.BI "const char __user *" buffer ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "ppos" 12
-- undescribed --
.TH "tower_interrupt_in_callback" 9 "tower_interrupt_in_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_interrupt_in_callback \- 
.SH SYNOPSIS
.B "void" tower_interrupt_in_callback
.BI "(struct urb *" urb ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "urb" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.TH "tower_interrupt_out_callback" 9 "tower_interrupt_out_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_interrupt_out_callback \- 
.SH SYNOPSIS
.B "void" tower_interrupt_out_callback
.BI "(struct urb *" urb ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "urb" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.TH "tower_probe" 9 "tower_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_probe \- 
.SH SYNOPSIS
.B "int" tower_probe
.BI "(struct usb_interface *" interface ","
.BI "const struct usb_device_id *" id ");"
.SH ARGUMENTS
.IP "interface" 12
-- undescribed --
.IP "id" 12
-- undescribed --
.SH "DESCRIPTION"

Called by the usb core when a new device is connected that it thinks
this driver might be interested in.
.TH "tower_disconnect" 9 "tower_disconnect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tower_disconnect \- 
.SH SYNOPSIS
.B "void" tower_disconnect
.BI "(struct usb_interface *" interface ");"
.SH ARGUMENTS
.IP "interface" 12
-- undescribed --
.SH "DESCRIPTION"

Called by the usb core when the device is removed from the system.
.TH "lego_usb_tower_init" 9 "lego_usb_tower_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lego_usb_tower_init \- 
.SH SYNOPSIS
.B "int __init" lego_usb_tower_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "lego_usb_tower_exit" 9 "lego_usb_tower_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lego_usb_tower_exit \- 
.SH SYNOPSIS
.B "void __exit" lego_usb_tower_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "fcs_compute10" 9 "fcs_compute10" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fcs_compute10 \-  memcpy and calculate 10 bit CRC across buffer
.SH SYNOPSIS
.B "__u16 __inline__" fcs_compute10
.BI "(unsigned char *" sp ","
.BI "int " len ","
.BI "__u16 " fcs ");"
.SH ARGUMENTS
.IP "sp" 12
 pointer to buffer
.IP "len" 12
 number of bytes
.IP "fcs" 12
 starting FCS
.SH "DESCRIPTION"
Perform a memcpy and calculate fcs using ppp 10bit CRC algorithm. Return
new 10 bit FCS.
.TH "Kernel API" 9 "struct palm_ext_connection_info" "January 2021" "API Manual" LINUX
.SH NAME
struct palm_ext_connection_info \-  return data from a PALM_GET_EXT_CONNECTION_INFORMATION request
.SH SYNOPSIS
struct palm_ext_connection_info {
.br
.BI "    __u8 " num_ports ""
;

.br
.BI "    __u8 " endpoint_numbers_different ""
;

.br
};
.br
.SH Arguments
.IP "num_ports" 12
 maximum number of functions/connections in use
.IP "endpoint_numbers_different" 12
 will be 1 if in and out endpoints numbers are
different, otherwise it is 0.  If value is 1, then
connections.end_point_info is non-zero.  If value is 0, then
connections.port contains the endpoint number, which is the same for in
and out.
.SH "Description"
The maximum number of connections currently supported is 2
.TH "TIReadDownloadMemory" 9 "TIReadDownloadMemory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
TIReadDownloadMemory \-  Read edgeport memory from TI chip
.SH SYNOPSIS
.B "int" TIReadDownloadMemory
.BI "(struct usb_device *" dev ","
.BI "int " start_address ","
.BI "int " length ","
.BI "__u8 " address_type ","
.BI "__u8 *" buffer ");"
.SH ARGUMENTS
.IP "dev" 12
 usb device pointer
.IP "start_address" 12
 Device CPU address at which to read
.IP "length" 12
 Length of above data
.IP "address_type" 12
 Can read both XDATA and I2C
.IP "buffer" 12
 pointer to input data buffer
.TH "TIDownloadFirmware" 9 "TIDownloadFirmware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
TIDownloadFirmware \-  Download run-time operating firmware to the TI5052
.SH SYNOPSIS
.B "int" TIDownloadFirmware
.BI "(struct edgeport_serial *" serial ");"
.SH ARGUMENTS
.IP "serial" 12
-- undescribed --
.SH "DESCRIPTION"

This routine downloads the main operating code into the TI5052, using the
boot code already burned into E2PROM or ROM.
.TH "lh7a40x_in_epn" 9 "lh7a40x_in_epn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lh7a40x_in_epn \-  handle IN interrupt
.SH SYNOPSIS
.B "void" lh7a40x_in_epn
.BI "(struct lh7a40x_udc *" dev ","
.BI "u32 " ep_idx ","
.BI "u32 " intr ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "ep_idx" 12
-- undescribed --
.IP "intr" 12
-- undescribed --
.TH "udc_set_address" 9 "udc_set_address" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
udc_set_address \-  set the USB address for this device
.SH SYNOPSIS
.B "void" udc_set_address
.BI "(struct lh7a40x_udc *" dev ","
.BI "unsigned char " address ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "address" 12
.SH "DESCRIPTION"
Called from control endpoint function after it decodes a set address setup packet.
.TH "usb_gadget_controller_number" 9 "usb_gadget_controller_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_controller_number \-  support bcdDevice id convention
.SH SYNOPSIS
.B "int" usb_gadget_controller_number
.BI "(struct usb_gadget *" gadget ");"
.SH ARGUMENTS
.IP "gadget" 12
 the controller being driven
.SH "DESCRIPTION"
Return a 2-digit BCD value associated with the peripheral controller,
suitable for use as part of a bcdDevice value, or a negative error code.
.SH "NOTE"
  this convention is purely optional, and has no meaning in terms of
any USB specification.  If you want to use a different convention in your
gadget driver firmware -- maybe a more formal revision ID -- feel free.

Hosts see these bcdDevice numbers, and are allowed (but not encouraged!)
to change their behavior accordingly.  For example it might help avoiding
some chip bug.
.TH "usb_descriptor_fillbuf" 9 "usb_descriptor_fillbuf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_descriptor_fillbuf \-  fill buffer with descriptors
.SH SYNOPSIS
.B "int" usb_descriptor_fillbuf
.BI "(void *" buf ","
.BI "unsigned " buflen ","
.BI "const struct usb_descriptor_header **" src ");"
.SH ARGUMENTS
.IP "buf" 12
 Buffer to be filled
.IP "buflen" 12
 Size of buf
.IP "src" 12
 Array of descriptor pointers, terminated by null pointer.
.SH "DESCRIPTION"
Copies descriptors into the buffer, returning the length or a
negative error code if they can't all be copied.  Useful when
assembling descriptors for an associated set of interfaces used
as part of configuring a composite device; or in other cases where
sets of descriptors need to be marshaled.
.TH "usb_gadget_config_buf" 9 "usb_gadget_config_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_config_buf \-  builts a complete configuration descriptor
.SH SYNOPSIS
.B "int" usb_gadget_config_buf
.BI "(const struct usb_config_descriptor *" config ","
.BI "void *" buf ","
.BI "unsigned " length ","
.BI "const struct usb_descriptor_header **" desc ");"
.SH ARGUMENTS
.IP "config" 12
 Header for the descriptor, including characteristics such
as power requirements and number of interfaces.
.IP "buf" 12
 Buffer for the resulting configuration descriptor.
.IP "length" 12
 Length of buffer.  If this is not big enough to hold the
entire configuration descriptor, an error code will be returned.
.IP "desc" 12
 Null-terminated vector of pointers to the descriptors (interface,
endpoint, etc) defining all functions in this device configuration.
.SH "DESCRIPTION"
This copies descriptors into the response buffer, building a descriptor
for that configuration.  It returns the buffer length or a negative
status code.  The config.wTotalLength field is set to match the length
of the result, but other descriptor fields (including power usage and
interface count) must be set by the caller.

Gadget drivers could use this when constructing a config descriptor
in response to USB_REQ_GET_DESCRIPTOR.  They will need to patch the
resulting bDescriptorType value if USB_DT_OTHER_SPEED_CONFIG is needed.
.TH "usb_gadget_get_string" 9 "usb_gadget_get_string" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_gadget_get_string \-  fill out a string descriptor 
.SH SYNOPSIS
.B "int" usb_gadget_get_string
.BI "(struct usb_gadget_strings *" table ","
.BI "int " id ","
.BI "u8 *" buf ");"
.SH ARGUMENTS
.IP "table" 12
 of c strings encoded using UTF-8
.IP "id" 12
 string id, from low byte of wValue in get string descriptor
.IP "buf" 12
 at least 256 bytes
.SH "DESCRIPTION"
Finds the UTF-8 string matching the ID, and converts it into a
string descriptor in utf16-le.
Returns length of descriptor (always even) or negative errno

If your driver needs stings in multiple languages, you'll probably
"switch (wIndex) { ... }"  in your ep0 string descriptor logic,
using this routine after choosing which set of UTF-8 strings to use.
Note that US-ASCII is a strict subset of UTF-8; any string bytes with
the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
characters (which are also widely used in C strings).
.TH "net2280_set_fifo_mode" 9 "net2280_set_fifo_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
net2280_set_fifo_mode \-  change allocation of fifo buffers
.SH SYNOPSIS
.B "int" net2280_set_fifo_mode
.BI "(struct usb_gadget *" gadget ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "gadget" 12
 access to the net2280 device that will be updated
.IP "mode" 12
 0 for default, four 1kB buffers (ep-a through ep-d);
1 for two 2kB buffers (ep-a and ep-b only);
2 for one 2kB buffer (ep-a) and two 1kB ones (ep-b, ep-c).
.SH "DESCRIPTION"
returns zero on success, else negative errno.  when this succeeds,
the contents of gadget-&gt;ep_list may have changed.

you may only call this function when endpoints a-d are all disabled.
use it whenever extra hardware buffering can help performance, such
as before enabling "high bandwidth" interrupt endpoints that use
maxpacket bigger than 512 (when double buffering would otherwise
be unavailable).
.TH "vicam_probe" 9 "vicam_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vicam_probe \- 
.SH SYNOPSIS
.B "int" vicam_probe
.BI "(struct usb_interface *" intf ","
.BI "const struct usb_device_id *" id ");"
.SH ARGUMENTS
.IP "intf" 12
 the interface
.IP "id" 12
 the device id
.SH "DESCRIPTION"
Called by the usb core when a new device is connected that it thinks
this driver might be interested in.
.TH "usb_control_msg" 9 "usb_control_msg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_control_msg \-  Builds a control urb, sends it off and waits for completion
.SH SYNOPSIS
.B "int" usb_control_msg
.BI "(struct usb_device *" dev ","
.BI "unsigned int " pipe ","
.BI "__u8 " request ","
.BI "__u8 " requesttype ","
.BI "__u16 " value ","
.BI "__u16 " index ","
.BI "void *" data ","
.BI "__u16 " size ","
.BI "int " timeout ");"
.SH ARGUMENTS
.IP "dev" 12
 pointer to the usb device to send the message to
.IP "pipe" 12
 endpoint "pipe" to send the message to
.IP "request" 12
 USB message request value
.IP "requesttype" 12
 USB message request type value
.IP "value" 12
 USB message value
.IP "index" 12
 USB message index value
.IP "data" 12
 pointer to the data to send
.IP "size" 12
 length in bytes of the data to send
.IP "timeout" 12
 time in msecs to wait for the message to complete before
timing out (if 0 the wait is forever)
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
This function sends a simple control message to a specified endpoint
and waits for the message to complete, or timeout.

If successful, it returns the number of bytes transferred, otherwise a negative error number.

Don't use this function from within an interrupt context, like a
bottom half handler.  If you need an asynchronous message, or need to send
a message from within interrupt context, use \fBusb_submit_urb\fP
If a thread in your driver uses this call, make sure your \fBdisconnect\fP
method can wait for it to complete.  Since you don't have a handle on
the URB used, you can't cancel the request.
.TH "usb_bulk_msg" 9 "usb_bulk_msg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_bulk_msg \-  Builds a bulk urb, sends it off and waits for completion
.SH SYNOPSIS
.B "int" usb_bulk_msg
.BI "(struct usb_device *" usb_dev ","
.BI "unsigned int " pipe ","
.BI "void *" data ","
.BI "int " len ","
.BI "int *" actual_length ","
.BI "int " timeout ");"
.SH ARGUMENTS
.IP "usb_dev" 12
 pointer to the usb device to send the message to
.IP "pipe" 12
 endpoint "pipe" to send the message to
.IP "data" 12
 pointer to the data to send
.IP "len" 12
 length in bytes of the data to send
.IP "actual_length" 12
 pointer to a location to put the actual length transferred in bytes
.IP "timeout" 12
 time in msecs to wait for the message to complete before
timing out (if 0 the wait is forever)
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
This function sends a simple bulk message to a specified endpoint
and waits for the message to complete, or timeout.

If successful, it returns 0, otherwise a negative error number.
The number of actual bytes transferred will be stored in the 
actual_length paramater.

Don't use this function from within an interrupt context, like a
bottom half handler.  If you need an asynchronous message, or need to
send a message from within interrupt context, use \fBusb_submit_urb\fP
If a thread in your driver uses this call, make sure your \fBdisconnect\fP
method can wait for it to complete.  Since you don't have a handle on
the URB used, you can't cancel the request.
.TH "usb_sg_init" 9 "usb_sg_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_sg_init \-  initializes scatterlist-based bulk/interrupt I/O request
.SH SYNOPSIS
.B "int" usb_sg_init
.BI "(struct usb_sg_request *" io ","
.BI "struct usb_device *" dev ","
.BI "unsigned " pipe ","
.BI "unsigned " period ","
.BI "struct scatterlist *" sg ","
.BI "int " nents ","
.BI "size_t " length ","
.BI "unsigned " mem_flags ");"
.SH ARGUMENTS
.IP "io" 12
 request block being initialized.  until \fBusb_sg_wait\fP returns,
treat this as a pointer to an opaque block of memory,
.IP "dev" 12
 the usb device that will send or receive the data
.IP "pipe" 12
 endpoint "pipe" used to transfer the data
.IP "period" 12
 polling rate for interrupt endpoints, in frames or
(for high speed endpoints) microframes; ignored for bulk
.IP "sg" 12
 scatterlist entries
.IP "nents" 12
 how many entries in the scatterlist
.IP "length" 12
 how many bytes to send from the scatterlist, or zero to
send every byte identified in the list.
.IP "mem_flags" 12
 SLAB_* flags affecting memory allocations in this call
.SH "DESCRIPTION"
Returns zero for success, else a negative errno value.  This initializes a
scatter/gather request, allocating resources such as I/O mappings and urb
memory (except maybe memory used by USB controller drivers).

The request must be issued using \fBusb_sg_wait\fP, which waits for the I/O to
complete (or to be canceled) and then cleans up all resources allocated by
\fBusb_sg_init\fP.

The request may be canceled with \fBusb_sg_cancel\fP, either before or after
\fBusb_sg_wait\fP is called.
.TH "usb_sg_wait" 9 "usb_sg_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_sg_wait \-  synchronously execute scatter/gather request
.SH SYNOPSIS
.B "void" usb_sg_wait
.BI "(struct usb_sg_request *" io ");"
.SH ARGUMENTS
.IP "io" 12
 request block handle, as initialized with \fBusb_sg_init\fP.
some fields become accessible when this call returns.
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
This function blocks until the specified I/O operation completes.  It
leverages the grouping of the related I/O requests to get good transfer
rates, by queueing the requests.  At higher speeds, such queuing can
significantly improve USB throughput.

There are three kinds of completion for this function.
(1) success, where io-&gt;status is zero.  The number of io-&gt;bytes
transferred is as requested.
(2) error, where io-&gt;status is a negative errno value.  The number
of io-&gt;bytes transferred before the error is usually less
than requested, and can be nonzero.
(3) cancellation, a type of error with status -ECONNRESET that
is initiated by \fBusb_sg_cancel\fP.

When this function returns, all memory allocated through \fBusb_sg_init\fP or
this call will have been freed.  The request block parameter may still be
passed to \fBusb_sg_cancel\fP, or it may be freed.  It could also be
reinitialized and then reused.
.SH "DATA TRANSFER RATES"

Bulk transfers are valid for full or high speed endpoints.
The best full speed data rate is 19 packets of 64 bytes each
per frame, or 1216 bytes per millisecond.
The best high speed data rate is 13 packets of 512 bytes each
per microframe, or 52 KBytes per millisecond.

The reason to use interrupt transfers through this API would most likely
be to reserve high speed bandwidth, where up to 24 KBytes per millisecond
could be transferred.  That capability is less useful for low or full
speed interrupt endpoints, which allow at most one packet per millisecond,
of at most 8 or 64 bytes (respectively).
.TH "usb_sg_cancel" 9 "usb_sg_cancel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_sg_cancel \-  stop scatter/gather i/o issued by usb_sg_wait()
.SH SYNOPSIS
.B "void" usb_sg_cancel
.BI "(struct usb_sg_request *" io ");"
.SH ARGUMENTS
.IP "io" 12
 request block, initialized with \fBusb_sg_init\fP
.SH "DESCRIPTION"
This stops a request after it has been started by \fBusb_sg_wait\fP.
It can also prevents one initialized by \fBusb_sg_init\fP from starting,
so that call just frees resources allocated to the request.
.TH "usb_get_descriptor" 9 "usb_get_descriptor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_get_descriptor \-  issues a generic GET_DESCRIPTOR request
.SH SYNOPSIS
.B "int" usb_get_descriptor
.BI "(struct usb_device *" dev ","
.BI "unsigned char " type ","
.BI "unsigned char " index ","
.BI "void *" buf ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose descriptor is being retrieved
.IP "type" 12
 the descriptor type (USB_DT_*)
.IP "index" 12
 the number of the descriptor
.IP "buf" 12
 where to put the descriptor
.IP "size" 12
 how big is "buf"?
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
Gets a USB descriptor.  Convenience functions exist to simplify
getting some types of descriptors.  Use
\fBusb_get_string\fP or \fBusb_string\fP for USB_DT_STRING.
Device (USB_DT_DEVICE) and configuration descriptors (USB_DT_CONFIG)
are part of the device structure.
In addition to a number of USB-standard descriptors, some
devices also use class-specific or vendor-specific descriptors.

This call is synchronous, and may not be used in an interrupt context.

Returns the number of bytes received on success, or else the status code
returned by the underlying \fBusb_control_msg\fP call.
.TH "usb_get_string" 9 "usb_get_string" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_get_string \-  gets a string descriptor
.SH SYNOPSIS
.B "int" usb_get_string
.BI "(struct usb_device *" dev ","
.BI "unsigned short " langid ","
.BI "unsigned char " index ","
.BI "void *" buf ","
.BI "int " size ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose string descriptor is being retrieved
.IP "langid" 12
 code for language chosen (from string descriptor zero)
.IP "index" 12
 the number of the descriptor
.IP "buf" 12
 where to put the string
.IP "size" 12
 how big is "buf"?
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
Retrieves a string, encoded using UTF-16LE (Unicode, 16 bits per character,
in little-endian byte order).
The \fBusb_string\fP function will often be a convenient way to turn
these strings into kernel-printable form.

Strings may be referenced in device, configuration, interface, or other
descriptors, and could also be used in vendor-specific ways.

This call is synchronous, and may not be used in an interrupt context.

Returns the number of bytes received on success, or else the status code
returned by the underlying \fBusb_control_msg\fP call.
.TH "usb_string" 9 "usb_string" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_string \-  returns ISO 8859-1 version of a string descriptor
.SH SYNOPSIS
.B "int" usb_string
.BI "(struct usb_device *" dev ","
.BI "int " index ","
.BI "char *" buf ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose string descriptor is being retrieved
.IP "index" 12
 the number of the descriptor
.IP "buf" 12
 where to put the string
.IP "size" 12
 how big is "buf"?
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
This converts the UTF-16LE encoded strings returned by devices, from
\fBusb_get_string_descriptor\fP, to null-terminated ISO-8859-1 encoded ones
that are more usable in most kernel contexts.  Note that all characters
in the chosen descriptor that can't be encoded using ISO-8859-1
are converted to the question mark ("?") character, and this function
chooses strings in the first language supported by the device.

The ASCII (or, redundantly, "US-ASCII") character set is the seven-bit
subset of ISO 8859-1. ISO-8859-1 is the eight-bit subset of Unicode,
and is appropriate for use many uses of English and several other
Western European languages.  (But it doesn't include the "Euro" symbol.)

This call is synchronous, and may not be used in an interrupt context.

Returns length of the string (&gt;= 0) or usb_control_msg status (&lt; 0).
.TH "usb_get_status" 9 "usb_get_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_get_status \-  issues a GET_STATUS call
.SH SYNOPSIS
.B "int" usb_get_status
.BI "(struct usb_device *" dev ","
.BI "int " type ","
.BI "int " target ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose status is being checked
.IP "type" 12
 USB_RECIP_*; for device, interface, or endpoint
.IP "target" 12
 zero (for device), else interface or endpoint number
.IP "data" 12
 pointer to two bytes of bitmap data
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
Returns device, interface, or endpoint status.  Normally only of
interest to see if the device is self powered, or has enabled the
remote wakeup facility; or whether a bulk or interrupt endpoint
is halted ("stalled").

Bits in these status bitmaps are set using the SET_FEATURE request,
and cleared using the CLEAR_FEATURE request.  The \fBusb_clear_halt\fP
function should be used to clear halt ("stall") status.

This call is synchronous, and may not be used in an interrupt context.

Returns the number of bytes received on success, or else the status code
returned by the underlying \fBusb_control_msg\fP call.
.TH "usb_clear_halt" 9 "usb_clear_halt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_clear_halt \-  tells device to clear endpoint halt/stall condition
.SH SYNOPSIS
.B "int" usb_clear_halt
.BI "(struct usb_device *" dev ","
.BI "int " pipe ");"
.SH ARGUMENTS
.IP "dev" 12
 device whose endpoint is halted
.IP "pipe" 12
 endpoint "pipe" being cleared
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
This is used to clear halt conditions for bulk and interrupt endpoints,
as reported by URB completion status.  Endpoints that are halted are
sometimes referred to as being "stalled".  Such endpoints are unable
to transmit or receive data until the halt status is cleared.  Any URBs
queued for such an endpoint should normally be unlinked by the driver
before clearing the halt condition, as described in sections 5.7.5
and 5.8.5 of the USB 2.0 spec.

Note that control and isochronous endpoints don't halt, although control
endpoints report "protocol stall" (for unsupported requests) using the
same status code used to report a true stall.

This call is synchronous, and may not be used in an interrupt context.

Returns zero on success, or else the status code returned by the
underlying \fBusb_control_msg\fP call.
.TH "usb_disable_endpoint" 9 "usb_disable_endpoint" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_disable_endpoint \- - Disable an endpoint by address
.SH SYNOPSIS
.B "void" usb_disable_endpoint
.BI "(struct usb_device *" dev ","
.BI "unsigned int " epaddr ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose endpoint is being disabled
.IP "epaddr" 12
 the endpoint's address.  Endpoint number for output,
endpoint number + USB_DIR_IN for input
.SH "DESCRIPTION"
Deallocates hcd/hardware state for this endpoint ... and nukes all
pending urbs.

If the HCD hasn't registered a \fBdisable\fP function, this sets the
endpoint's maxpacket size to 0 to prevent further submissions.
.TH "usb_disable_interface" 9 "usb_disable_interface" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_disable_interface \- - Disable all endpoints for an interface
.SH SYNOPSIS
.B "void" usb_disable_interface
.BI "(struct usb_device *" dev ","
.BI "struct usb_interface *" intf ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose interface is being disabled
.IP "intf" 12
 pointer to the interface descriptor
.SH "DESCRIPTION"
Disables all the endpoints for the interface's current altsetting.
.TH "usb_set_interface" 9 "usb_set_interface" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_set_interface \-  Makes a particular alternate setting be current
.SH SYNOPSIS
.B "int" usb_set_interface
.BI "(struct usb_device *" dev ","
.BI "int " interface ","
.BI "int " alternate ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose interface is being updated
.IP "interface" 12
 the interface being updated
.IP "alternate" 12
 the setting being chosen.
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
This is used to enable data transfers on interfaces that may not
be enabled by default.  Not all devices support such configurability.
Only the driver bound to an interface may change its setting.

Within any given configuration, each interface may have several
alternative settings.  These are often used to control levels of
bandwidth consumption.  For example, the default setting for a high
speed interrupt endpoint may not send more than 64 bytes per microframe,
while interrupt transfers of up to 3KBytes per microframe are legal.
Also, isochronous endpoints may never be part of an
interface's default setting.  To access such bandwidth, alternate
interface settings must be made current.

Note that in the Linux USB subsystem, bandwidth associated with
an endpoint in a given alternate setting is not reserved until an URB
is submitted that needs that bandwidth.  Some other operating systems
allocate bandwidth early, when a configuration is chosen.

This call is synchronous, and may not be used in an interrupt context.
Also, drivers must not change altsettings while urbs are scheduled for
endpoints in that interface; all such urbs must first be completed
(perhaps forced by unlinking).

Returns zero on success, or else the status code returned by the
underlying \fBusb_control_msg\fP call.
.TH "usb_reset_configuration" 9 "usb_reset_configuration" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_reset_configuration \-  lightweight device reset
.SH SYNOPSIS
.B "int" usb_reset_configuration
.BI "(struct usb_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose configuration is being reset
.SH "DESCRIPTION"
This issues a standard SET_CONFIGURATION request to the device using
the current configuration.  The effect is to reset most USB-related
state in the device, including interface altsettings (reset to zero),
endpoint halts (cleared), and data toggle (only for bulk and interrupt
endpoints).  Other usbcore state is unchanged, including bindings of
usb device drivers to interfaces.

Because this affects multiple interfaces, avoid using this with composite
(multi-interface) devices.  Instead, the driver for each interface may
use \fBusb_set_interface\fP on the interfaces it claims.  Be careful though;
some devices don't support the SET_INTERFACE request, and others won't
reset all the interface state (notably data toggles).  Resetting the whole
configuration would affect other drivers' interfaces.

The caller must own the device lock.

Returns zero on success, else a negative error code.
.TH "usb_hcd_pci_probe" 9 "usb_hcd_pci_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_pci_probe \-  initialize PCI-based HCDs
.SH SYNOPSIS
.B "int" usb_hcd_pci_probe
.BI "(struct pci_dev *" dev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "dev" 12
 USB Host Controller being probed
.IP "id" 12
 pci hotplug id connecting controller to HCD framework
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic PCI resources for this USB host controller, and
then invokes the \fBstart\fP method for the HCD associated with it
through the hotplug entry's driver_data.

Store this function in the HCD's struct pci_driver as \fBprobe\fP.
.TH "usb_hcd_pci_remove" 9 "usb_hcd_pci_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_pci_remove \-  shutdown processing for PCI-based HCDs
.SH SYNOPSIS
.B "void" usb_hcd_pci_remove
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 USB Host Controller being removed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Reverses the effect of \fBusb_hcd_pci_probe\fP, first invoking
the HCD's \fBstop\fP method.  It is always called from a thread
context, normally "rmmod", "apmd", or something similar.

Store this function in the HCD's struct pci_driver as \fBremove\fP.
.TH "usb_hcd_pci_suspend" 9 "usb_hcd_pci_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_pci_suspend \-  power management suspend of a PCI-based HCD
.SH SYNOPSIS
.B "int" usb_hcd_pci_suspend
.BI "(struct pci_dev *" dev ","
.BI "pm_message_t " message ");"
.SH ARGUMENTS
.IP "dev" 12
 USB Host Controller being suspended
.IP "message" 12
 semantics in flux
.SH "DESCRIPTION"
Store this function in the HCD's struct pci_driver as \fBsuspend\fP.
.TH "usb_hcd_pci_resume" 9 "usb_hcd_pci_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_pci_resume \-  power management resume of a PCI-based HCD
.SH SYNOPSIS
.B "int" usb_hcd_pci_resume
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 USB Host Controller being resumed
.SH "DESCRIPTION"
Store this function in the HCD's struct pci_driver as \fBresume\fP.
.TH "usb_hub_tt_clear_buffer" 9 "usb_hub_tt_clear_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hub_tt_clear_buffer \-  clear control/bulk TT state in high speed hub
.SH SYNOPSIS
.B "void" usb_hub_tt_clear_buffer
.BI "(struct usb_device *" udev ","
.BI "int " pipe ");"
.SH ARGUMENTS
.IP "udev" 12
 the device whose split transaction failed
.IP "pipe" 12
 identifies the endpoint of the failed transaction
.SH "DESCRIPTION"
High speed HCDs use this to tell the hub driver that some split control or
bulk transaction failed in a way that requires clearing internal state of
a transaction translator.  This is normally detected (and reported) from
interrupt context.

It may not be possible for that hub to handle additional full (or low)
speed transactions until that state is fully cleared out.
.TH "usb_set_device_state" 9 "usb_set_device_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_set_device_state \-  change a device's current state (usbcore, hcds)
.SH SYNOPSIS
.B "void" usb_set_device_state
.BI "(struct usb_device *" udev ","
.BI "enum usb_device_state " new_state ");"
.SH ARGUMENTS
.IP "udev" 12
 pointer to device whose state should be changed
.IP "new_state" 12
 new state value to be stored
.SH "DESCRIPTION"
udev-&gt;state is _not_ fully protected by the device lock.  Although
most transitions are made only while holding the lock, the state can
can change to USB_STATE_NOTATTACHED at almost any time.  This
is so that devices can be marked as disconnected as soon as possible,
without having to wait for any semaphores to be released.  As a result,
all changes to any device's state must be protected by the
device_state_lock spinlock.

Once a device has been added to the device tree, all changes to its state
should be made using this routine.  The state should _not_ be set directly.

If udev-&gt;state is already USB_STATE_NOTATTACHED then no change is made.
Otherwise udev-&gt;state is set to new_state, and if new_state is
USB_STATE_NOTATTACHED then all of udev's descendants' states are also set
to USB_STATE_NOTATTACHED.
.TH "usb_disconnect" 9 "usb_disconnect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_disconnect \-  disconnect a device (usbcore-internal)
.SH SYNOPSIS
.B "void" usb_disconnect
.BI "(struct usb_device **" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
 pointer to device being disconnected
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
Something got disconnected. Get rid of it and all of its children.

If *pdev is a normal device then the parent hub must already be locked.
If *pdev is a root hub then this routine will acquire the
usb_bus_list_lock on behalf of the caller.

Only hub drivers (including virtual root hub drivers for host
controllers) should ever call this.

This call is synchronous, and may not be used in an interrupt context.
.TH "usb_new_device" 9 "usb_new_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_new_device \-  perform initial device setup (usbcore-internal)
.SH SYNOPSIS
.B "int" usb_new_device
.BI "(struct usb_device *" udev ");"
.SH ARGUMENTS
.IP "udev" 12
 newly addressed device (in ADDRESS state)
.SH "DESCRIPTION"
This is called with devices which have been enumerated, but not yet
configured.  The device descriptor is available, but not descriptors
for any device configuration.  The caller must have locked udev and
either the parent hub (if udev is a normal device) or else the
usb_bus_list_lock (if udev is a root hub).  The parent's pointer to
udev has already been installed, but udev is not yet visible through
sysfs or other filesystem code.

Returns 0 for success (device is configured and listed, with its
interfaces, in sysfs); else a negative errno value.

This call is synchronous, and may not be used in an interrupt context.

Only the hub driver should ever call this; root hub registration
uses it indirectly.
.TH "usb_suspend_device" 9 "usb_suspend_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_suspend_device \-  suspend a usb device
.SH SYNOPSIS
.B "int" usb_suspend_device
.BI "(struct usb_device *" udev ","
.BI "pm_message_t " state ");"
.SH ARGUMENTS
.IP "udev" 12
 device that's no longer in active use
.IP "state" 12
 PMSG_SUSPEND to suspend
.SH "CONTEXT"
 must be able to sleep; device not locked
.SH "DESCRIPTION"
Suspends a USB device that isn't in active use, conserving power.
Devices may wake out of a suspend, if anything important happens,
using the remote wakeup mechanism.  They may also be taken out of
suspend by the host, using \fBusb_resume_device\fP.  It's also routine
to disconnect devices while they are suspended.

Suspending OTG devices may trigger HNP, if that's been enabled
between a pair of dual-role devices.  That will change roles, such
as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.

Returns 0 on success, else negative errno.
.TH "usb_resume_device" 9 "usb_resume_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_resume_device \-  re-activate a suspended usb device
.SH SYNOPSIS
.B "int" usb_resume_device
.BI "(struct usb_device *" udev ");"
.SH ARGUMENTS
.IP "udev" 12
 device to re-activate
.SH "CONTEXT"
 must be able to sleep; device not locked
.SH "DESCRIPTION"
This will re-activate the suspended device, increasing power usage
while letting drivers communicate again with its endpoints.
USB resume explicitly guarantees that the power session between
the host and the device is the same as it was when the device
suspended.

Returns 0 on success, else negative errno.
.TH "usb_reset_device" 9 "usb_reset_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_reset_device \-  perform a USB port reset to reinitialize a device
.SH SYNOPSIS
.B "int" usb_reset_device
.BI "(struct usb_device *" udev ");"
.SH ARGUMENTS
.IP "udev" 12
 device to reset (not in SUSPENDED or NOTATTACHED state)
.SH "DESCRIPTION"
WARNING - don't reset any device unless drivers for all of its
interfaces are expecting that reset!  Maybe some driver-&gt;\fBreset\fP
method should eventually help ensure sufficient cooperation.

Do a port reset, reassign the device's address, and establish its
former operating configuration.  If the reset fails, or the device's
descriptors change from their values before the reset, or the original
configuration and altsettings cannot be restored, a flag will be set
telling khubd to pretend the device has been disconnected and then
re-connected.  All drivers will be unbound, and the device will be
re-enumerated and probed all over again.

Returns 0 if the reset succeeded, -ENODEV if the device has been
flagged for logical disconnection, or some other negative error code
if the reset wasn't even attempted.

The caller must own the device lock.  For example, it's safe to use
this from a driver \fBprobe\fP routine after downloading new firmware.
For calls that might not occur during \fBprobe\fP, drivers should lock
the device using \fBusb_lock_device_for_reset\fP.
.TH "usb_register" 9 "usb_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_register \-  register a USB driver
.SH SYNOPSIS
.B "int" usb_register
.BI "(struct usb_driver *" new_driver ");"
.SH ARGUMENTS
.IP "new_driver" 12
 USB operations for the driver
.SH "DESCRIPTION"
Registers a USB driver with the USB core.  The list of unattached
interfaces will be rescanned whenever a new driver is added, allowing
the new driver to attach to any recognized devices.
Returns a negative error code on failure and 0 on success.
.SH "NOTE"
 if you want your driver to use the USB major number, you must call
\fBusb_register_dev\fP to enable that functionality.  This function no longer
takes care of that.
.TH "usb_deregister" 9 "usb_deregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_deregister \-  unregister a USB driver
.SH SYNOPSIS
.B "void" usb_deregister
.BI "(struct usb_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
 USB operations of the driver to unregister
.SH "CONTEXT"
 must be able to sleep
.SH "DESCRIPTION"
Unlinks the specified driver from the internal USB driver list.
.SH "NOTE"
 If you called \fBusb_register_dev\fP, you still need to call
\fBusb_deregister_dev\fP to clean up your driver's allocated minor numbers,
this * call will no longer do it for you.
.TH "usb_ifnum_to_if" 9 "usb_ifnum_to_if" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_ifnum_to_if \-  get the interface object with a given interface number
.SH SYNOPSIS
.B "struct usb_interface *" usb_ifnum_to_if
.BI "(struct usb_device *" dev ","
.BI "unsigned " ifnum ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose current configuration is considered
.IP "ifnum" 12
 the desired interface
.SH "DESCRIPTION"
This walks the device descriptor for the currently active configuration
and returns a pointer to the interface with that particular interface
number, or null.

Note that configuration descriptors are not required to assign interface
numbers sequentially, so that it would be incorrect to assume that
the first interface in that descriptor corresponds to interface zero.
This routine helps device drivers avoid such mistakes.
However, you should make sure that you do the right thing with any
alternate settings available for this interfaces.

Don't call this function unless you are bound to one of the interfaces
on this device or you have locked the device!
.TH "usb_altnum_to_altsetting" 9 "usb_altnum_to_altsetting" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_altnum_to_altsetting \-  get the altsetting structure with a given
.SH SYNOPSIS
.B "struct usb_host_interface *" usb_altnum_to_altsetting
.BI "(struct usb_interface *" intf ","
.BI "unsigned int " altnum ");"
.SH ARGUMENTS
.IP "intf" 12
 the interface containing the altsetting in question
.IP "altnum" 12
 the desired alternate setting number
.SH "DESCRIPTION"
This searches the altsetting array of the specified interface for
an entry with the correct bAlternateSetting value and returns a pointer
to that entry, or null.

Note that altsettings need not be stored sequentially by number, so
it would be incorrect to assume that the first altsetting entry in
the array corresponds to altsetting zero.  This routine helps device
drivers avoid such mistakes.

Don't call this function unless you are bound to the intf interface
or you have locked the device!
.SH "DESCRIPTION"
This searches the altsetting array of the specified interface for
an entry with the correct bAlternateSetting value and returns a pointer
to that entry, or null.

Note that altsettings need not be stored sequentially by number, so
it would be incorrect to assume that the first altsetting entry in
the array corresponds to altsetting zero.  This routine helps device
drivers avoid such mistakes.

Don't call this function unless you are bound to the intf interface
or you have locked the device!
.TH "usb_driver_claim_interface" 9 "usb_driver_claim_interface" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_driver_claim_interface \-  bind a driver to an interface
.SH SYNOPSIS
.B "int" usb_driver_claim_interface
.BI "(struct usb_driver *" driver ","
.BI "struct usb_interface *" iface ","
.BI "void *" priv ");"
.SH ARGUMENTS
.IP "driver" 12
 the driver to be bound
.IP "iface" 12
 the interface to which it will be bound; must be in the
usb device's active configuration
.IP "priv" 12
 driver data associated with that interface
.SH "DESCRIPTION"
This is used by usb device drivers that need to claim more than one
interface on a device when probing (audio and acm are current examples).
No device driver should directly modify internal usb_interface or
usb_device structure members.

Few drivers should need to use this routine, since the most natural
way to bind to an interface is to return the private data from
the driver's \fBprobe\fP method.

Callers must own the device lock and the driver model's usb_bus_type.subsys
writelock.  So driver \fBprobe\fP entries don't need extra locking,
but other call contexts may need to explicitly claim those locks.
.TH "usb_driver_release_interface" 9 "usb_driver_release_interface" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_driver_release_interface \-  unbind a driver from an interface
.SH SYNOPSIS
.B "void" usb_driver_release_interface
.BI "(struct usb_driver *" driver ","
.BI "struct usb_interface *" iface ");"
.SH ARGUMENTS
.IP "driver" 12
 the driver to be unbound
.IP "iface" 12
 the interface from which it will be unbound
.SH "DESCRIPTION"
This can be used by drivers to release an interface without waiting
for their \fBdisconnect\fP methods to be called.  In typical cases this
also causes the driver \fBdisconnect\fP method to be called.

This call is synchronous, and may not be used in an interrupt context.
Callers must own the device lock and the driver model's usb_bus_type.subsys
writelock.  So driver \fBdisconnect\fP entries don't need extra locking,
but other call contexts may need to explicitly claim those locks.
.TH "usb_match_id" 9 "usb_match_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_match_id \-  find first usb_device_id matching device or interface
.SH SYNOPSIS
.B "const struct usb_device_id *" usb_match_id
.BI "(struct usb_interface *" interface ","
.BI "const struct usb_device_id *" id ");"
.SH ARGUMENTS
.IP "interface" 12
 the interface of interest
.IP "id" 12
 array of usb_device_id structures, terminated by zero entry
.SH "DESCRIPTION"
usb_match_id searches an array of usb_device_id's and returns
the first one matching the device or interface, or null.
This is used when binding (or rebinding) a driver to an interface.
Most USB device drivers will use this indirectly, through the usb core,
but some layered driver frameworks use it directly.
These device tables are exported with MODULE_DEVICE_TABLE, through
modutils and "modules.usbmap", to support the driver loading
functionality of USB hotplugging.
.SH "WHAT MATCHES"

The "match_flags" element in a usb_device_id controls which
members are used.  If the corresponding bit is set, the
value in the device_id must match its corresponding member
in the device or interface descriptor, or else the device_id
does not match.

"driver_info" is normally used only by device drivers,
but you can create a wildcard "matches anything" usb_device_id
as a driver's "modules.usbmap" entry if you provide an id with
only a nonzero "driver_info" field.  If you do this, the USB device
driver's \fBprobe\fP routine should use additional intelligence to
decide whether to bind to the specified interface.
.SH "WHAT MAKES GOOD USB_DEVICE_ID TABLES"

The match algorithm is very simple, so that intelligence in
driver selection must come from smart driver id records.
Unless you have good reasons to use another selection policy,
provide match elements only in related groups, and order match
specifiers from specific to general.  Use the macros provided
for that purpose if you can.

The most specific match specifiers use device descriptor
data.  These are commonly used with product-specific matches;
the USB_DEVICE macro lets you provide vendor and product IDs,
and you can also match against ranges of product revisions.
These are widely used for devices with application or vendor
specific bDeviceClass values.

Matches based on device class/subclass/protocol specifications
are slightly more general; use the USB_DEVICE_INFO macro, or
its siblings.  These are used with single-function devices
where bDeviceClass doesn't specify that each interface has
its own class. 

Matches based on interface class/subclass/protocol are the
most general; they let drivers bind to any interface on a
multiple-function device.  Use the USB_INTERFACE_INFO
macro, or its siblings, to match class-per-interface style 
devices (as recorded in bDeviceClass).

Within those groups, remember that not all combinations are
meaningful.  For example, don't give a product version range
without vendor and product IDs; or specify a protocol without
its associated class and subclass.
.TH "usb_find_interface" 9 "usb_find_interface" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_find_interface \-  find usb_interface pointer for driver and device
.SH SYNOPSIS
.B "struct usb_interface *" usb_find_interface
.BI "(struct usb_driver *" drv ","
.BI "int " minor ");"
.SH ARGUMENTS
.IP "drv" 12
 the driver whose current configuration is considered
.IP "minor" 12
 the minor number of the desired device
.SH "DESCRIPTION"
This walks the driver device list and returns a pointer to the interface 
with the matching minor.  Note, this only works for devices that share the
USB major number.
.TH "usb_release_dev" 9 "usb_release_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_release_dev \-  free a usb device structure when all users of it are finished.
.SH SYNOPSIS
.B "void" usb_release_dev
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device that's been disconnected
.SH "DESCRIPTION"
Will be called only by the device core when all users of this usb device are
done.
.TH "usb_alloc_dev" 9 "usb_alloc_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_alloc_dev \-  usb device constructor (usbcore-internal)
.SH SYNOPSIS
.B "struct usb_device *" usb_alloc_dev
.BI "(struct usb_device *" parent ","
.BI "struct usb_bus *" bus ","
.BI "unsigned " port1 ");"
.SH ARGUMENTS
.IP "parent" 12
 hub to which device is connected; null to allocate a root hub
.IP "bus" 12
 bus used to access the device
.IP "port1" 12
 one-based index of port; ignored for root hubs
.SH "CONTEXT"
 !in_interrupt ()
.SH "DESCRIPTION"
Only hub drivers (including virtual root hub drivers for host
controllers) should ever call this.

This call may not be used in a non-sleeping context.
.TH "usb_get_dev" 9 "usb_get_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_get_dev \-  increments the reference count of the usb device structure
.SH SYNOPSIS
.B "struct usb_device *" usb_get_dev
.BI "(struct usb_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device being referenced
.SH "DESCRIPTION"
Each live reference to a device should be refcounted.

Drivers for USB interfaces should normally record such references in
their \fBprobe\fP methods, when they bind to an interface, and release
them by calling \fBusb_put_dev\fP, in their \fBdisconnect\fP methods.

A pointer to the device with the incremented reference counter is returned.
.TH "usb_put_dev" 9 "usb_put_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_put_dev \-  release a use of the usb device structure
.SH SYNOPSIS
.B "void" usb_put_dev
.BI "(struct usb_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device that's been disconnected
.SH "DESCRIPTION"
Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.
.TH "usb_get_intf" 9 "usb_get_intf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_get_intf \-  increments the reference count of the usb interface structure
.SH SYNOPSIS
.B "struct usb_interface *" usb_get_intf
.BI "(struct usb_interface *" intf ");"
.SH ARGUMENTS
.IP "intf" 12
 the interface being referenced
.SH "DESCRIPTION"
Each live reference to a interface must be refcounted.

Drivers for USB interfaces should normally record such references in
their \fBprobe\fP methods, when they bind to an interface, and release
them by calling \fBusb_put_intf\fP, in their \fBdisconnect\fP methods.

A pointer to the interface with the incremented reference counter is
returned.
.TH "usb_put_intf" 9 "usb_put_intf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_put_intf \-  release a use of the usb interface structure
.SH SYNOPSIS
.B "void" usb_put_intf
.BI "(struct usb_interface *" intf ");"
.SH ARGUMENTS
.IP "intf" 12
 interface that's been decremented
.SH "DESCRIPTION"
Must be called when a user of an interface is finished with it.  When the
last user of the interface calls this function, the memory of the interface
is freed.
.TH "usb_lock_device" 9 "usb_lock_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_lock_device \-  acquire the lock for a usb device structure
.SH SYNOPSIS
.B "void" usb_lock_device
.BI "(struct usb_device *" udev ");"
.SH ARGUMENTS
.IP "udev" 12
 device that's being locked
.SH "DESCRIPTION"
Use this routine when you don't hold any other device locks;
to acquire nested inner locks call down(&amp;udev-&gt;serialize) directly.
This is necessary for proper interaction with \fBusb_lock_all_devices\fP.
.TH "usb_trylock_device" 9 "usb_trylock_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_trylock_device \-  attempt to acquire the lock for a usb device structure
.SH SYNOPSIS
.B "int" usb_trylock_device
.BI "(struct usb_device *" udev ");"
.SH ARGUMENTS
.IP "udev" 12
 device that's being locked
.SH "DESCRIPTION"
Don't use this routine if you already hold a device lock;
use down_trylock(&amp;udev-&gt;serialize) instead.
This is necessary for proper interaction with \fBusb_lock_all_devices\fP.

Returns 1 if successful, 0 if contention.
.TH "usb_lock_device_for_reset" 9 "usb_lock_device_for_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_lock_device_for_reset \-  cautiously acquire the lock for a
.SH SYNOPSIS
.B "int" usb_lock_device_for_reset
.BI "(struct usb_device *" udev ","
.BI "struct usb_interface *" iface ");"
.SH ARGUMENTS
.IP "udev" 12
 device that's being locked
.IP "iface" 12
 interface bound to the driver making the request (optional)
.SH "DESCRIPTION"
Attempts to acquire the device lock, but fails if the device is
NOTATTACHED or SUSPENDED, or if iface is specified and the interface
is neither BINDING nor BOUND.  Rather than sleeping to wait for the
lock, the routine polls repeatedly.  This is to prevent deadlock with
disconnect; in some drivers (such as usb-storage) the \fBdisconnect\fP
or \fBsuspend\fP method will block waiting for a device reset to complete.

Returns a negative error code for failure, otherwise 1 or 0 to indicate
that the device will or will not have to be unlocked.  (0 can be
returned when an interface is given and is BINDING, because in that
case the driver already owns the device lock.)
.SH "DESCRIPTION"
Attempts to acquire the device lock, but fails if the device is
NOTATTACHED or SUSPENDED, or if iface is specified and the interface
is neither BINDING nor BOUND.  Rather than sleeping to wait for the
lock, the routine polls repeatedly.  This is to prevent deadlock with
disconnect; in some drivers (such as usb-storage) the \fBdisconnect\fP
or \fBsuspend\fP method will block waiting for a device reset to complete.

Returns a negative error code for failure, otherwise 1 or 0 to indicate
that the device will or will not have to be unlocked.  (0 can be
returned when an interface is given and is BINDING, because in that
case the driver already owns the device lock.)
.TH "usb_unlock_device" 9 "usb_unlock_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_unlock_device \-  release the lock for a usb device structure
.SH SYNOPSIS
.B "void" usb_unlock_device
.BI "(struct usb_device *" udev ");"
.SH ARGUMENTS
.IP "udev" 12
 device that's being unlocked
.SH "DESCRIPTION"
Use this routine when releasing the only device lock you hold;
to release inner nested locks call up(&amp;udev-&gt;serialize) directly.
This is necessary for proper interaction with \fBusb_lock_all_devices\fP.
.TH "usb_lock_all_devices" 9 "usb_lock_all_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_lock_all_devices \-  acquire the lock for all usb device structures
.SH SYNOPSIS
.B "void" usb_lock_all_devices
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This is necessary when registering a new driver or probing a bus,
since the driver-model core may try to use any usb_device.
.TH "usb_unlock_all_devices" 9 "usb_unlock_all_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_unlock_all_devices \-  release the lock for all usb device structures
.SH SYNOPSIS
.B "void" usb_unlock_all_devices
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "usb_find_device" 9 "usb_find_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_find_device \-  find a specific usb device in the system
.SH SYNOPSIS
.B "struct usb_device *" usb_find_device
.BI "(u16 " vendor_id ","
.BI "u16 " product_id ");"
.SH ARGUMENTS
.IP "vendor_id" 12
 the vendor id of the device to find
.IP "product_id" 12
 the product id of the device to find
.SH "DESCRIPTION"
Returns a pointer to a struct usb_device if such a specified usb
device is present in the system currently.  The usage count of the
device will be incremented if a device is found.  Make sure to call
\fBusb_put_dev\fP when the caller is finished with the device.

If a device with the specified vendor and product id is not found,
NULL is returned.
.TH "usb_get_current_frame_number" 9 "usb_get_current_frame_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_get_current_frame_number \-  return current bus frame number
.SH SYNOPSIS
.B "int" usb_get_current_frame_number
.BI "(struct usb_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device whose bus is being queried
.SH "DESCRIPTION"
Returns the current frame number for the USB host controller
used with the given USB device.  This can be used when scheduling
isochronous requests.

Note that different kinds of host controller have different
"scheduling horizons".  While one type might support scheduling only
32 frames into the future, others could support scheduling up to
1024 frames into the future.
.TH "usb_buffer_alloc" 9 "usb_buffer_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_alloc \-  allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP
.SH SYNOPSIS
.B "void *" usb_buffer_alloc
.BI "(struct usb_device *" dev ","
.BI "size_t " size ","
.BI "unsigned " mem_flags ","
.BI "dma_addr_t *" dma ");"
.SH ARGUMENTS
.IP "dev" 12
 device the buffer will be used with
.IP "size" 12
 requested buffer size
.IP "mem_flags" 12
 affect whether allocation may block
.IP "dma" 12
 used to return DMA address of buffer
.SH "DESCRIPTION"
Return value is either null (indicating no buffer could be allocated), or
the cpu-space pointer to a buffer that may be used to perform DMA to the
specified device.  Such cpu-space buffers are returned along with the DMA
address (through the pointer provided).

These buffers are used with URB_NO_xxx_DMA_MAP set in urb-&gt;transfer_flags
to avoid behaviors like using "DMA bounce buffers", or tying down I/O
mapping hardware for long idle periods.  The implementation varies between
platforms, depending on details of how DMA will work to this device.
Using these buffers also helps prevent cacheline sharing problems on
architectures where CPU caches are not DMA-coherent.

When the buffer is no longer used, free it with \fBusb_buffer_free\fP.
.TH "usb_buffer_free" 9 "usb_buffer_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_free \-  free memory allocated with usb_buffer_alloc()
.SH SYNOPSIS
.B "void" usb_buffer_free
.BI "(struct usb_device *" dev ","
.BI "size_t " size ","
.BI "void *" addr ","
.BI "dma_addr_t " dma ");"
.SH ARGUMENTS
.IP "dev" 12
 device the buffer was used with
.IP "size" 12
 requested buffer size
.IP "addr" 12
 CPU address of buffer
.IP "dma" 12
 DMA address of buffer
.SH "DESCRIPTION"
This reclaims an I/O buffer, letting it be reused.  The memory must have
been allocated using \fBusb_buffer_alloc\fP, and the parameters must match
those provided in that allocation request. 
.TH "usb_buffer_map" 9 "usb_buffer_map" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_map \-  create DMA mapping(s) for an urb
.SH SYNOPSIS
.B "struct urb *" usb_buffer_map
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 urb whose transfer_buffer/setup_packet will be mapped
.SH "DESCRIPTION"
Return value is either null (indicating no buffer could be mapped), or
the parameter.  URB_NO_TRANSFER_DMA_MAP and URB_NO_SETUP_DMA_MAP are
added to urb-&gt;transfer_flags if the operation succeeds.  If the device
is connected to this system through a non-DMA controller, this operation
always succeeds.

This call would normally be used for an urb which is reused, perhaps
as the target of a large periodic transfer, with \fBusb_buffer_dmasync\fP
calls to synchronize memory and dma state.

Reverse the effect of this call with \fBusb_buffer_unmap\fP.
.TH "usb_buffer_dmasync" 9 "usb_buffer_dmasync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_dmasync \-  synchronize DMA and CPU view of buffer(s)
.SH SYNOPSIS
.B "void" usb_buffer_dmasync
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 urb whose transfer_buffer/setup_packet will be synchronized
.TH "usb_buffer_unmap" 9 "usb_buffer_unmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_unmap \-  free DMA mapping(s) for an urb
.SH SYNOPSIS
.B "void" usb_buffer_unmap
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 urb whose transfer_buffer will be unmapped
.SH "DESCRIPTION"
Reverses the effect of \fBusb_buffer_map\fP.
.TH "usb_buffer_map_sg" 9 "usb_buffer_map_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_map_sg \-  create scatterlist DMA mapping(s) for an endpoint
.SH SYNOPSIS
.B "int" usb_buffer_map_sg
.BI "(struct usb_device *" dev ","
.BI "unsigned " pipe ","
.BI "struct scatterlist *" sg ","
.BI "int " nents ");"
.SH ARGUMENTS
.IP "dev" 12
 device to which the scatterlist will be mapped
.IP "pipe" 12
 endpoint defining the mapping direction
.IP "sg" 12
 the scatterlist to map
.IP "nents" 12
 the number of entries in the scatterlist
.SH "DESCRIPTION"
Return value is either &lt; 0 (indicating no buffers could be mapped), or
the number of DMA mapping array entries in the scatterlist.

The caller is responsible for placing the resulting DMA addresses from
the scatterlist into URB transfer buffer pointers, and for setting the
URB_NO_TRANSFER_DMA_MAP transfer flag in each of those URBs.

Top I/O rates come from queuing URBs, instead of waiting for each one
to complete before starting the next I/O.   This is particularly easy
to do with scatterlists.  Just allocate and submit one URB for each DMA
mapping entry returned, stopping on the first error or when all succeed.
Better yet, use the usb_sg_*() calls, which do that (and more) for you.

This call would normally be used when translating scatterlist requests,
rather than \fBusb_buffer_map\fP, since on some hardware (with IOMMUs) it
may be able to coalesce mappings for improved I/O efficiency.

Reverse the effect of this call with \fBusb_buffer_unmap_sg\fP.
.TH "usb_buffer_dmasync_sg" 9 "usb_buffer_dmasync_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_dmasync_sg \-  synchronize DMA and CPU view of scatterlist buffer(s)
.SH SYNOPSIS
.B "void" usb_buffer_dmasync_sg
.BI "(struct usb_device *" dev ","
.BI "unsigned " pipe ","
.BI "struct scatterlist *" sg ","
.BI "int " n_hw_ents ");"
.SH ARGUMENTS
.IP "dev" 12
 device to which the scatterlist will be mapped
.IP "pipe" 12
 endpoint defining the mapping direction
.IP "sg" 12
 the scatterlist to synchronize
.IP "n_hw_ents" 12
 the positive return value from usb_buffer_map_sg
.SH "DESCRIPTION"
Use this when you are re-using a scatterlist's data buffers for
another USB request.
.TH "usb_buffer_unmap_sg" 9 "usb_buffer_unmap_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_buffer_unmap_sg \-  free DMA mapping(s) for a scatterlist
.SH SYNOPSIS
.B "void" usb_buffer_unmap_sg
.BI "(struct usb_device *" dev ","
.BI "unsigned " pipe ","
.BI "struct scatterlist *" sg ","
.BI "int " n_hw_ents ");"
.SH ARGUMENTS
.IP "dev" 12
 device to which the scatterlist will be mapped
.IP "pipe" 12
 endpoint defining the mapping direction
.IP "sg" 12
 the scatterlist to unmap
.IP "n_hw_ents" 12
 the positive return value from usb_buffer_map_sg
.SH "DESCRIPTION"
Reverses the effect of \fBusb_buffer_map_sg\fP.
.TH "usb_init_urb" 9 "usb_init_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_init_urb \-  initializes a urb so that it can be used by a USB driver
.SH SYNOPSIS
.B "void" usb_init_urb
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to the urb to initialize
.SH "DESCRIPTION"
Initializes a urb so that the USB subsystem can use it properly.

If a urb is created with a call to \fBusb_alloc_urb\fP it is not
necessary to call this function.  Only use this if you allocate the
space for a struct urb on your own.  If you call this function, be
careful when freeing the memory for your urb that it is no longer in
use by the USB core.

Only use this function if you _really_ understand what you are doing.
.TH "usb_alloc_urb" 9 "usb_alloc_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_alloc_urb \-  creates a new urb for a USB driver to use
.SH SYNOPSIS
.B "struct urb *" usb_alloc_urb
.BI "(int " iso_packets ","
.BI "unsigned " mem_flags ");"
.SH ARGUMENTS
.IP "iso_packets" 12
 number of iso packets for this urb
.IP "mem_flags" 12
 the type of memory to allocate, see \fBkmalloc\fP for a list of
valid options for this.
.SH "DESCRIPTION"
Creates an urb for the USB driver to use, initializes a few internal
structures, incrementes the usage counter, and returns a pointer to it.

If no memory is available, NULL is returned.

If the driver want to use this urb for interrupt, control, or bulk
endpoints, pass '0' as the number of iso packets.

The driver must call \fBusb_free_urb\fP when it is finished with the urb.
.TH "usb_free_urb" 9 "usb_free_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_free_urb \-  frees the memory used by a urb when all users of it are finished
.SH SYNOPSIS
.B "void" usb_free_urb
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to the urb to free, may be NULL
.SH "DESCRIPTION"
Must be called when a user of a urb is finished with it.  When the last user
of the urb calls this function, the memory of the urb is freed.
.SH "NOTE"
 The transfer buffer associated with the urb is not freed, that must be
done elsewhere.
.TH "usb_get_urb" 9 "usb_get_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_get_urb \-  increments the reference count of the urb
.SH SYNOPSIS
.B "struct urb *" usb_get_urb
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to the urb to modify, may be NULL
.SH "DESCRIPTION"
This must be  called whenever a urb is transferred from a device driver to a
host controller driver.  This allows proper reference counting to happen
for urbs.

A pointer to the urb with the incremented reference counter is returned.
.TH "usb_submit_urb" 9 "usb_submit_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_submit_urb \-  issue an asynchronous transfer request for an endpoint
.SH SYNOPSIS
.B "int" usb_submit_urb
.BI "(struct urb *" urb ","
.BI "unsigned " mem_flags ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to the urb describing the request
.IP "mem_flags" 12
 the type of memory to allocate, see \fBkmalloc\fP for a list
of valid options for this.
.SH "DESCRIPTION"
This submits a transfer request, and transfers control of the URB
describing that request to the USB subsystem.  Request completion will
be indicated later, asynchronously, by calling the completion handler.
The three types of completion are success, error, and unlink
(a software-induced fault, also called "request cancellation").  

URBs may be submitted in interrupt context.

The caller must have correctly initialized the URB before submitting
it.  Functions such as \fBusb_fill_bulk_urb\fP and \fBusb_fill_control_urb\fP are
available to ensure that most fields are correctly initialized, for
the particular kind of transfer, although they will not initialize
any transfer flags.

Successful submissions return 0; otherwise this routine returns a
negative error number.  If the submission is successful, the \fBcomplete\fP
callback from the URB will be called exactly once, when the USB core and
Host Controller Driver (HCD) are finished with the URB.  When the completion
function is called, control of the URB is returned to the device
driver which issued the request.  The completion handler may then
immediately free or reuse that URB.

With few exceptions, USB device drivers should never access URB fields
provided by usbcore or the HCD until its \fBcomplete\fP is called.
The exceptions relate to periodic transfer scheduling.  For both
interrupt and isochronous urbs, as part of successful URB submission
urb-&gt;interval is modified to reflect the actual transfer period used
(normally some power of two units).  And for isochronous urbs,
urb-&gt;start_frame is modified to reflect when the URB's transfers were
scheduled to start.  Not all isochronous transfer scheduling policies
will work, but most host controller drivers should easily handle ISO
queues going from now until 10-200 msec into the future.

For control endpoints, the synchronous \fBusb_control_msg\fP call is
often used (in non-interrupt context) instead of this call.
That is often used through convenience wrappers, for the requests
that are standardized in the USB 2.0 specification.  For bulk
endpoints, a synchronous \fBusb_bulk_msg\fP call is available.
.SH "REQUEST QUEUING"

URBs may be submitted to endpoints before previous ones complete, to
minimize the impact of interrupt latencies and system overhead on data
throughput.  With that queuing policy, an endpoint's queue would never
be empty.  This is required for continuous isochronous data streams,
and may also be required for some kinds of interrupt transfers. Such
queuing also maximizes bandwidth utilization by letting USB controllers
start work on later requests before driver software has finished the
completion processing for earlier (successful) requests.

As of Linux 2.6, all USB endpoint transfer queues support depths greater
than one.  This was previously a HCD-specific behavior, except for ISO
transfers.  Non-isochronous endpoint queues are inactive during cleanup
after faults (transfer errors or cancellation).
.SH "RESERVED BANDWIDTH TRANSFERS"

Periodic transfers (interrupt or isochronous) are performed repeatedly,
using the interval specified in the urb.  Submitting the first urb to
the endpoint reserves the bandwidth necessary to make those transfers.
If the USB subsystem can't allocate sufficient bandwidth to perform
the periodic request, submitting such a periodic request should fail.

Device drivers must explicitly request that repetition, by ensuring that
some URB is always on the endpoint's queue (except possibly for short
periods during completion callacks).  When there is no longer an urb
queued, the endpoint's bandwidth reservation is canceled.  This means
drivers can use their completion handlers to ensure they keep bandwidth
they need, by reinitializing and resubmitting the just-completed urb
until the driver longer needs that periodic bandwidth.
.SH "MEMORY FLAGS"

The general rules for how to decide which mem_flags to use
are the same as for kmalloc.  There are four
different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and
GFP_ATOMIC.

GFP_NOFS is not ever used, as it has not been implemented yet.

GFP_ATOMIC is used when
(a) you are inside a completion handler, an interrupt, bottom half,
tasklet or timer, or
(b) you are holding a spinlock or rwlock (does not apply to
semaphores), or
(c) current-&gt;state != TASK_RUNNING, this is the case only after
you've changed it.

GFP_NOIO is used in the block io path and error handling of storage
devices.

All other situations use GFP_KERNEL.

Some more specific rules for mem_flags can be inferred, such as
(1) start_xmit, timeout, and receive methods of network drivers must
use GFP_ATOMIC (they are called with a spinlock held);
(2) queuecommand methods of scsi drivers must use GFP_ATOMIC (also
called with a spinlock held);
(3) If you use a kernel thread with a network driver you must use
GFP_NOIO, unless (b) or (c) apply;
(4) after you have done a \fBdown\fP you can use GFP_KERNEL, unless (b) or (c)
apply or your are in a storage driver's block io path;
(5) USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and
(6) changing firmware on a running storage or net device uses
GFP_NOIO, unless b) or c) apply
.TH "usb_unlink_urb" 9 "usb_unlink_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_unlink_urb \-  abort/cancel a transfer request for an endpoint
.SH SYNOPSIS
.B "int" usb_unlink_urb
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to urb describing a previously submitted request,
may be NULL
.SH "DESCRIPTION"
This routine cancels an in-progress request.  URBs complete only
once per submission, and may be canceled only once per submission.
Successful cancellation means the requests's completion handler will
be called with a status code indicating that the request has been
canceled (rather than any other code) and will quickly be removed
from host controller data structures.

This request is always asynchronous.
Success is indicated by returning -EINPROGRESS,
at which time the URB will normally have been unlinked but not yet
given back to the device driver.  When it is called, the completion
function will see urb-&gt;status == -ECONNRESET.  Failure is indicated
by any other return value.  Unlinking will fail when the URB is not
currently "linked" (i.e., it was never submitted, or it was unlinked
before, or the hardware is already finished with it), even if the
completion handler has not yet run.
.SH "UNLINKING AND ENDPOINT QUEUES"

Host Controller Drivers (HCDs) place all the URBs for a particular
endpoint in a queue.  Normally the queue advances as the controller
hardware processes each request.  But when an URB terminates with an
error its queue stops, at least until that URB's completion routine
returns.  It is guaranteed that the queue will not restart until all
its unlinked URBs have been fully retired, with their completion
routines run, even if that's not until some time after the original
completion handler returns.  Normally the same behavior and guarantees
apply when an URB terminates because it was unlinked; however if an
URB is unlinked before the hardware has started to execute it, then
its queue is not guaranteed to stop until all the preceding URBs have
completed.

This means that USB device drivers can safely build deep queues for
large or complex transfers, and clean them up reliably after any sort
of aborted transfer by unlinking all pending URBs at the first fault.

Note that an URB terminating early because a short packet was received
will count as an error if and only if the URB_SHORT_NOT_OK flag is set.
Also, that all unlinks performed in any URB completion handler must
be asynchronous.

Queues for isochronous endpoints are treated differently, because they
advance at fixed rates.  Such queues do not stop when an URB is unlinked.
An unlinked URB may leave a gap in the stream of packets.  It is undefined
whether such gaps can be filled in.

When a control URB terminates with an error, it is likely that the
status stage of the transfer will not take place, even if it is merely
a soft error resulting from a short-packet with URB_SHORT_NOT_OK set.
.TH "usb_kill_urb" 9 "usb_kill_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_kill_urb \-  cancel a transfer request and wait for it to finish
.SH SYNOPSIS
.B "void" usb_kill_urb
.BI "(struct urb *" urb ");"
.SH ARGUMENTS
.IP "urb" 12
 pointer to URB describing a previously submitted request,
may be NULL
.SH "DESCRIPTION"
This routine cancels an in-progress request.  It is guaranteed that
upon return all completion handlers will have finished and the URB
will be totally idle and available for reuse.  These features make
this an ideal way to stop I/O in a \fBdisconnect\fP callback or \fBclose\fP
function.  If the request has not already finished or been unlinked
the completion handler will see urb-&gt;status == -ENOENT.

While the routine is running, attempts to resubmit the URB will fail
with error -EPERM.  Thus even if the URB's completion handler always
tries to resubmit, it will not succeed and the URB will become idle.

This routine may not be used in an interrupt context (such as a bottom
half or a completion handler), or when holding a spinlock, or in other
situations where the caller can't \fBschedule\fP.
.TH "usb_register_dev" 9 "usb_register_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_register_dev \-  register a USB device, and ask for a minor number
.SH SYNOPSIS
.B "int" usb_register_dev
.BI "(struct usb_interface *" intf ","
.BI "struct usb_class_driver *" class_driver ");"
.SH ARGUMENTS
.IP "intf" 12
 pointer to the usb_interface that is being registered
.IP "class_driver" 12
 pointer to the usb_class_driver for this device
.SH "DESCRIPTION"
This should be called by all USB drivers that use the USB major number.
If CONFIG_USB_DYNAMIC_MINORS is enabled, the minor number will be
dynamically allocated out of the list of available ones.  If it is not
enabled, the minor number will be based on the next available free minor,
starting at the class_driver-&gt;minor_base.

This function also creates the devfs file for the usb device, if devfs
is enabled, and creates a usb class device in the sysfs tree.

\fBusb_deregister_dev\fP must be called when the driver is done with
the minor numbers given out by this function.

Returns -EINVAL if something bad happens with trying to register a
device, and 0 on success.
.TH "usb_deregister_dev" 9 "usb_deregister_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_deregister_dev \-  deregister a USB device's dynamic minor.
.SH SYNOPSIS
.B "void" usb_deregister_dev
.BI "(struct usb_interface *" intf ","
.BI "struct usb_class_driver *" class_driver ");"
.SH ARGUMENTS
.IP "intf" 12
 pointer to the usb_interface that is being deregistered
.IP "class_driver" 12
 pointer to the usb_class_driver for this device
.SH "DESCRIPTION"
Used in conjunction with \fBusb_register_dev\fP.  This function is called
when the USB driver is finished with the minor numbers gotten from a
call to \fBusb_register_dev\fP (usually when the device is disconnected
from the system.)

This function also cleans up the devfs file for the usb device, if devfs
is enabled, and removes the usb class device from the sysfs tree.

This should be called by all drivers that use the USB major number.
.TH "hcd_buffer_create" 9 "hcd_buffer_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hcd_buffer_create \-  initialize buffer pools
.SH SYNOPSIS
.B "int" hcd_buffer_create
.BI "(struct usb_hcd *" hcd ");"
.SH ARGUMENTS
.IP "hcd" 12
 the bus whose buffer pools are to be initialized
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Call this as part of initializing a host controller that uses the dma
memory allocators.  It initializes some pools of dma-coherent memory that
will be shared by all drivers using that controller, or returns a negative
errno value on error.

Call \fBhcd_buffer_destroy\fP to clean up after using those pools.
.TH "hcd_buffer_destroy" 9 "hcd_buffer_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hcd_buffer_destroy \-  deallocate buffer pools
.SH SYNOPSIS
.B "void" hcd_buffer_destroy
.BI "(struct usb_hcd *" hcd ");"
.SH ARGUMENTS
.IP "hcd" 12
 the bus whose buffer pools are to be destroyed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
This frees the buffer pools created by \fBhcd_buffer_create\fP.
.TH "usb_bus_init" 9 "usb_bus_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_bus_init \-  shared initialization code
.SH SYNOPSIS
.B "void" usb_bus_init
.BI "(struct usb_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 the bus structure being initialized
.SH "DESCRIPTION"
This code is used to initialize a usb_bus structure, memory for which is
separately managed.
.TH "usb_alloc_bus" 9 "usb_alloc_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_alloc_bus \-  creates a new USB host controller structure
.SH SYNOPSIS
.B "struct usb_bus *" usb_alloc_bus
.BI "(struct usb_operations *" op ");"
.SH ARGUMENTS
.IP "op" 12
 pointer to a struct usb_operations that this bus structure should use
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Creates a USB host controller bus structure with the specified 
usb_operations and initializes all the necessary internal objects.

If no memory is available, NULL is returned.

The caller should call \fBusb_put_bus\fP when it is finished with the structure.
.TH "usb_register_bus" 9 "usb_register_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_register_bus \-  registers the USB host controller with the usb core
.SH SYNOPSIS
.B "int" usb_register_bus
.BI "(struct usb_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 pointer to the bus to register
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Assigns a bus number, and links the controller into usbcore data
structures so that it can be seen by scanning the bus list.
.TH "usb_deregister_bus" 9 "usb_deregister_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_deregister_bus \-  deregisters the USB host controller
.SH SYNOPSIS
.B "void" usb_deregister_bus
.BI "(struct usb_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 pointer to the bus to deregister
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Recycles the bus number, and unlinks the controller from usbcore data
structures so that it won't be seen by scanning the bus list.
.TH "register_root_hub" 9 "register_root_hub" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_root_hub \-  called by usb_add_hcd() to register a root hub
.SH SYNOPSIS
.B "int" register_root_hub
.BI "(struct usb_device *" usb_dev ","
.BI "struct usb_hcd *" hcd ");"
.SH ARGUMENTS
.IP "usb_dev" 12
 the usb root hub device to be registered.
.IP "hcd" 12
 host controller for this root hub
.SH "DESCRIPTION"
This function registers the root hub with the USB subsystem.  It sets up
the device properly in the device tree and stores the root_hub pointer
in the bus structure, then calls \fBusb_new_device\fP to register the usb
device.  It also assigns the root hub's USB address (always 1).
.TH "usb_calc_bus_time" 9 "usb_calc_bus_time" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_calc_bus_time \-  approximate periodic transaction time in nanoseconds
.SH SYNOPSIS
.B "long" usb_calc_bus_time
.BI "(int " speed ","
.BI "int " is_input ","
.BI "int " isoc ","
.BI "int " bytecount ");"
.SH ARGUMENTS
.IP "speed" 12
 from dev-&gt;speed; USB_SPEED_{LOW,FULL,HIGH}
.IP "is_input" 12
 true iff the transaction sends data to the host
.IP "isoc" 12
 true for isochronous transactions, false for interrupt ones
.IP "bytecount" 12
 how many bytes in the transaction.
.SH "DESCRIPTION"
Returns approximate bus time in nanoseconds for a periodic transaction.
See USB 2.0 spec section 5.11.3; only periodic transfers need to be
scheduled in software, this function is only used for such scheduling.
.TH "usb_claim_bandwidth" 9 "usb_claim_bandwidth" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_claim_bandwidth \-  records bandwidth for a periodic transfer
.SH SYNOPSIS
.B "void" usb_claim_bandwidth
.BI "(struct usb_device *" dev ","
.BI "struct urb *" urb ","
.BI "int " bustime ","
.BI "int " isoc ");"
.SH ARGUMENTS
.IP "dev" 12
 source/target of request
.IP "urb" 12
 request (urb-&gt;dev == dev)
.IP "bustime" 12
 bandwidth consumed, in (average) microseconds per frame
.IP "isoc" 12
 true iff the request is isochronous
.SH "DESCRIPTION"
Bus bandwidth reservations are recorded purely for diagnostic purposes.
HCDs are expected not to overcommit periodic bandwidth, and to record such
reservations whenever endpoints are added to the periodic schedule.

FIXME averaging per-frame is suboptimal.  Better to sum over the HCD's
entire periodic schedule ... 32 frames for OHCI, 1024 for UHCI, settable
for EHCI (256/512/1024 frames, default 1024) and have the bus expose how
large its periodic schedule is.
.TH "usb_release_bandwidth" 9 "usb_release_bandwidth" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_release_bandwidth \-  reverses effect of usb_claim_bandwidth()
.SH SYNOPSIS
.B "void" usb_release_bandwidth
.BI "(struct usb_device *" dev ","
.BI "struct urb *" urb ","
.BI "int " isoc ");"
.SH ARGUMENTS
.IP "dev" 12
 source/target of request
.IP "urb" 12
 request (urb-&gt;dev == dev)
.IP "isoc" 12
 true iff the request is isochronous
.SH "DESCRIPTION"
This records that previously allocated bandwidth has been released.
Bandwidth is released when endpoints are removed from the host controller's
periodic schedule.
.TH "usb_hcd_resume_root_hub" 9 "usb_hcd_resume_root_hub" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_resume_root_hub \-  called by HCD to resume its root hub 
.SH SYNOPSIS
.B "void" usb_hcd_resume_root_hub
.BI "(struct usb_hcd *" hcd ");"
.SH ARGUMENTS
.IP "hcd" 12
 host controller for this root hub
.SH "DESCRIPTION"
The USB host controller calls this function when its root hub is
suspended (with the remote wakeup feature enabled) and a remote
wakeup request is received.  It queues a request for khubd to
resume the root hub.
.TH "usb_bus_start_enum" 9 "usb_bus_start_enum" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_bus_start_enum \-  start immediate enumeration (for OTG)
.SH SYNOPSIS
.B "int" usb_bus_start_enum
.BI "(struct usb_bus *" bus ","
.BI "unsigned " port_num ");"
.SH ARGUMENTS
.IP "bus" 12
 the bus (must use hcd framework)
.IP "port_num" 12
 1-based number of port; usually bus-&gt;otg_port
.SH "CONTEXT"
 \fBin_interrupt\fP
.SH "DESCRIPTION"
Starts enumeration, with an immediate reset followed later by
khubd identifying and possibly configuring the device.
This is needed by OTG controller drivers, where it helps meet
HNP protocol timing requirements for starting a port reset.
.TH "usb_hcd_giveback_urb" 9 "usb_hcd_giveback_urb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_giveback_urb \-  return URB from HCD to device driver
.SH SYNOPSIS
.B "void" usb_hcd_giveback_urb
.BI "(struct usb_hcd *" hcd ","
.BI "struct urb *" urb ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "hcd" 12
 host controller returning the URB
.IP "urb" 12
 urb being returned to the USB device driver.
.IP "regs" 12
 pt_regs, passed down to the URB completion handler
.SH "CONTEXT"
 \fBin_interrupt\fP
.SH "DESCRIPTION"
This hands the URB from HCD to its USB device driver, using its
completion function.  The HCD has freed all per-urb resources
(and is done using urb-&gt;hcpriv).  It also released all HCD locks;
the device driver won't cause problems if it frees, modifies,
or resubmits this URB.
.TH "usb_hcd_irq" 9 "usb_hcd_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_irq \-  hook IRQs to HCD framework (bus glue)
.SH SYNOPSIS
.B "irqreturn_t" usb_hcd_irq
.BI "(int " irq ","
.BI "void *" __hcd ","
.BI "struct pt_regs *" r ");"
.SH ARGUMENTS
.IP "irq" 12
 the IRQ being raised
.IP "__hcd" 12
 pointer to the HCD whose IRQ is being signaled
.IP "r" 12
 saved hardware registers
.SH "DESCRIPTION"
If the controller isn't HALTed, calls the driver's irq handler.
Checks whether the controller is now dead.
.TH "usb_hc_died" 9 "usb_hc_died" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hc_died \-  report abnormal shutdown of a host controller (bus glue)
.SH SYNOPSIS
.B "void" usb_hc_died
.BI "(struct usb_hcd *" hcd ");"
.SH ARGUMENTS
.IP "hcd" 12
 pointer to the HCD representing the controller
.SH "DESCRIPTION"
This is called by bus glue to report a USB host controller that died
while operations may still have been pending.  It's called automatically
by the PCI glue, so only glue for non-PCI busses should need to call it. 
.TH "usb_create_hcd" 9 "usb_create_hcd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_create_hcd \-  create and initialize an HCD structure
.SH SYNOPSIS
.B "struct usb_hcd *" usb_create_hcd
.BI "(const struct hc_driver *" driver ","
.BI "struct device *" dev ","
.BI "char *" bus_name ");"
.SH ARGUMENTS
.IP "driver" 12
 HC driver that will use this hcd
.IP "dev" 12
 device for this HC, stored in hcd-&gt;self.controller
.IP "bus_name" 12
 value to store in hcd-&gt;self.bus_name
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocate a struct usb_hcd, with extra space at the end for the
HC driver's private data.  Initialize the generic members of the
hcd structure.

If memory is unavailable, returns NULL.
.TH "usb_add_hcd" 9 "usb_add_hcd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_add_hcd \-  finish generic HCD structure initialization and register
.SH SYNOPSIS
.B "int" usb_add_hcd
.BI "(struct usb_hcd *" hcd ","
.BI "unsigned int " irqnum ","
.BI "unsigned long " irqflags ");"
.SH ARGUMENTS
.IP "hcd" 12
 the usb_hcd structure to initialize
.IP "irqnum" 12
 Interrupt line to allocate
.IP "irqflags" 12
 Interrupt type flags
.SH "FINISH THE REMAINING PARTS OF GENERIC HCD INITIALIZATION"
 allocate the
buffers of consistent memory, register the bus, request the IRQ line,
and call the driver's \fBreset\fP and \fBstart\fP routines.
.TH "usb_remove_hcd" 9 "usb_remove_hcd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_remove_hcd \-  shutdown processing for generic HCDs
.SH SYNOPSIS
.B "void" usb_remove_hcd
.BI "(struct usb_hcd *" hcd ");"
.SH ARGUMENTS
.IP "hcd" 12
 the usb_hcd structure to remove
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Disconnects the root hub, then reverses the effects of \fBusb_add_hcd\fP,
invoking the HCD's \fBstop\fP method.
.TH "usb_hcd_omap_probe" 9 "usb_hcd_omap_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_omap_probe \-  initialize OMAP-based HCDs
.SH SYNOPSIS
.B "int" usb_hcd_omap_probe
.BI "(const struct hc_driver *" driver ","
.BI "struct platform_device *" pdev ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "pdev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic resources for this USB host controller, and
then invokes the \fBstart\fP method for the HCD associated with it
through the hotplug entry's driver_data.
.TH "usb_hcd_omap_remove" 9 "usb_hcd_omap_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_omap_remove \-  shutdown processing for OMAP-based HCDs
.SH SYNOPSIS
.B "void" usb_hcd_omap_remove
.BI "(struct usb_hcd *" hcd ","
.BI "struct platform_device *" pdev ");"
.SH ARGUMENTS
.IP "hcd" 12
-- undescribed --
.IP "pdev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Reverses the effect of \fBusb_hcd_omap_probe\fP, first invoking
the HCD's \fBstop\fP method.  It is always called from a thread
context, normally "rmmod", "apmd", or something similar.
.TH "usb_hcd_pxa27x_probe" 9 "usb_hcd_pxa27x_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_pxa27x_probe \-  initialize pxa27x-based HCDs
.SH SYNOPSIS
.B "int" usb_hcd_pxa27x_probe
.BI "(const struct hc_driver *" driver ","
.BI "struct platform_device *" dev ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic resources for this USB host controller, and
then invokes the \fBstart\fP method for the HCD associated with it
through the hotplug entry's driver_data.
.TH "usb_hcd_pxa27x_remove" 9 "usb_hcd_pxa27x_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_pxa27x_remove \-  shutdown processing for pxa27x-based HCDs
.SH SYNOPSIS
.B "void" usb_hcd_pxa27x_remove
.BI "(struct usb_hcd *" hcd ","
.BI "struct platform_device *" dev ");"
.SH ARGUMENTS
.IP "hcd" 12
-- undescribed --
.IP "dev" 12
 USB Host Controller being removed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Reverses the effect of \fBusb_hcd_pxa27x_probe\fP, first invoking
the HCD's \fBstop\fP method.  It is always called from a thread
context, normally "rmmod", "apmd", or something similar.
.TH "usb_hcd_au1xxx_probe" 9 "usb_hcd_au1xxx_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_au1xxx_probe \-  initialize Au1xxx-based HCDs
.SH SYNOPSIS
.B "int" usb_hcd_au1xxx_probe
.BI "(const struct hc_driver *" driver ","
.BI "struct platform_device *" dev ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic resources for this USB host controller, and
then invokes the \fBstart\fP method for the HCD associated with it
through the hotplug entry's driver_data.
.TH "usb_hcd_au1xxx_remove" 9 "usb_hcd_au1xxx_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_au1xxx_remove \-  shutdown processing for Au1xxx-based HCDs
.SH SYNOPSIS
.B "void" usb_hcd_au1xxx_remove
.BI "(struct usb_hcd *" hcd ","
.BI "struct platform_device *" dev ");"
.SH ARGUMENTS
.IP "hcd" 12
-- undescribed --
.IP "dev" 12
 USB Host Controller being removed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Reverses the effect of \fBusb_hcd_au1xxx_probe\fP, first invoking
the HCD's \fBstop\fP method.  It is always called from a thread
context, normally "rmmod", "apmd", or something similar.
.TH "usb_hcd_lh7a404_probe" 9 "usb_hcd_lh7a404_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_lh7a404_probe \-  initialize LH7A404-based HCDs
.SH SYNOPSIS
.B "int" usb_hcd_lh7a404_probe
.BI "(const struct hc_driver *" driver ","
.BI "struct platform_device *" dev ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic resources for this USB host controller, and
then invokes the \fBstart\fP method for the HCD associated with it
through the hotplug entry's driver_data.
.TH "usb_hcd_lh7a404_remove" 9 "usb_hcd_lh7a404_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_lh7a404_remove \-  shutdown processing for LH7A404-based HCDs
.SH SYNOPSIS
.B "void" usb_hcd_lh7a404_remove
.BI "(struct usb_hcd *" hcd ","
.BI "struct platform_device *" dev ");"
.SH ARGUMENTS
.IP "hcd" 12
-- undescribed --
.IP "dev" 12
 USB Host Controller being removed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Reverses the effect of \fBusb_hcd_lh7a404_probe\fP, first invoking
the HCD's \fBstop\fP method.  It is always called from a thread
context, normally "rmmod", "apmd", or something similar.
.TH "usb_hcd_s3c2410_probe" 9 "usb_hcd_s3c2410_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_s3c2410_probe \-  initialize S3C2410-based HCDs
.SH SYNOPSIS
.B "int" usb_hcd_s3c2410_probe
.BI "(const struct hc_driver *" driver ","
.BI "struct platform_device *" dev ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic resources for this USB host controller, and
then invokes the \fBstart\fP method for the HCD associated with it
through the hotplug entry's driver_data.
.TH "usb_hcd_ppc_soc_probe" 9 "usb_hcd_ppc_soc_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_ppc_soc_probe \-  initialize On-Chip HCDs
.SH SYNOPSIS
.B "int" usb_hcd_ppc_soc_probe
.BI "(const struct hc_driver *" driver ","
.BI "struct platform_device *" pdev ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "pdev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic resources for this USB host controller.

Store this function in the HCD's struct pci_driver as \fBprobe\fP.
.TH "usb_hcd_ppc_soc_remove" 9 "usb_hcd_ppc_soc_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_ppc_soc_remove \-  shutdown processing for On-Chip HCDs
.SH SYNOPSIS
.B "void" usb_hcd_ppc_soc_remove
.BI "(struct usb_hcd *" hcd ","
.BI "struct platform_device *" pdev ");"
.SH ARGUMENTS
.IP "hcd" 12
-- undescribed --
.IP "pdev" 12
 USB Host Controller being removed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Reverses the effect of \fBusb_hcd_ppc_soc_probe\fP.
It is always called from a thread
context, normally "rmmod", "apmd", or something similar.
.TH "usb_hcd_sa1111_probe" 9 "usb_hcd_sa1111_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_sa1111_probe \-  initialize SA-1111-based HCDs
.SH SYNOPSIS
.B "int" usb_hcd_sa1111_probe
.BI "(const struct hc_driver *" driver ","
.BI "struct sa1111_dev *" dev ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Allocates basic resources for this USB host controller, and
then invokes the \fBstart\fP method for the HCD associated with it
through the hotplug entry's driver_data.

Store this function in the HCD's struct pci_driver as \fBprobe\fP.
.TH "usb_hcd_sa1111_remove" 9 "usb_hcd_sa1111_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
usb_hcd_sa1111_remove \-  shutdown processing for SA-1111-based HCDs
.SH SYNOPSIS
.B "void" usb_hcd_sa1111_remove
.BI "(struct usb_hcd *" hcd ","
.BI "struct sa1111_dev *" dev ");"
.SH ARGUMENTS
.IP "hcd" 12
-- undescribed --
.IP "dev" 12
 USB Host Controller being removed
.SH "CONTEXT"
 !\fBin_interrupt\fP
.SH "DESCRIPTION"
Reverses the effect of \fBusb_hcd_sa1111_probe\fP, first invoking
the HCD's \fBstop\fP method.  It is always called from a thread
context, normally "rmmod", "apmd", or something similar.
.TH "hwmon_device_register" 9 "hwmon_device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hwmon_device_register \-  register w/ hwmon sysfs class
.SH SYNOPSIS
.B "struct class_device *" hwmon_device_register
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the device to register
.SH "DESCRIPTION"
\fBhwmon_device_unregister\fP must be called when the class device is no
longer needed.

Returns the pointer to the new struct class device.
.TH "hwmon_device_unregister" 9 "hwmon_device_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hwmon_device_unregister \-  removes the previously registered class device
.SH SYNOPSIS
.B "void" hwmon_device_unregister
.BI "(struct class_device *" cdev ");"
.SH ARGUMENTS
.IP "cdev" 12
 the class device to destroy
.SH "DESCRIPTION"
.TH "linear_mergeable_bvec" 9 "linear_mergeable_bvec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
linear_mergeable_bvec \- - tell bio layer if two requests can be merged
.SH SYNOPSIS
.B "int" linear_mergeable_bvec
.BI "(request_queue_t *" q ","
.BI "struct bio *" bio ","
.BI "struct bio_vec *" biovec ");"
.SH ARGUMENTS
.IP "q" 12
 request queue
.IP "bio" 12
 the buffer head that's been built up so far
.IP "biovec" 12
 the request that could be merged to it.
.SH "DESCRIPTION"
Return amount of bytes we can take at this offset
.TH "raid0_mergeable_bvec" 9 "raid0_mergeable_bvec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
raid0_mergeable_bvec \- - tell bio layer if a two requests can be merged
.SH SYNOPSIS
.B "int" raid0_mergeable_bvec
.BI "(request_queue_t *" q ","
.BI "struct bio *" bio ","
.BI "struct bio_vec *" biovec ");"
.SH ARGUMENTS
.IP "q" 12
 request queue
.IP "bio" 12
 the buffer head that's been built up so far
.IP "biovec" 12
 the request that could be merged to it.
.SH "DESCRIPTION"
Return amount of bytes we can accept at this offset
.TH "raid10_mergeable_bvec" 9 "raid10_mergeable_bvec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
raid10_mergeable_bvec \- - tell bio layer if a two requests can be merged
.SH SYNOPSIS
.B "int" raid10_mergeable_bvec
.BI "(request_queue_t *" q ","
.BI "struct bio *" bio ","
.BI "struct bio_vec *" bio_vec ");"
.SH ARGUMENTS
.IP "q" 12
 request queue
.IP "bio" 12
 the buffer head that's been built up so far
.IP "bio_vec" 12
-- undescribed --
.SH "DESCRIPTION"
Return amount of bytes we can accept at this offset
If near_copies == raid_disk, there are no striping issues,
but in that case, the function isn't called at all.
.TH "acpi_enable_wakeup_device_prep" 9 "acpi_enable_wakeup_device_prep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_enable_wakeup_device_prep \-  prepare wakeup devices
.SH SYNOPSIS
.B "void" acpi_enable_wakeup_device_prep
.BI "(u8 " sleep_state ");"
.SH ARGUMENTS
.IP "sleep_state" 12
	ACPI state
Enable all wakup devices power if the devices' wakeup level
is higher than requested sleep level
.TH "acpi_enable_wakeup_device" 9 "acpi_enable_wakeup_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_enable_wakeup_device \-  enable wakeup devices
.SH SYNOPSIS
.B "void" acpi_enable_wakeup_device
.BI "(u8 " sleep_state ");"
.SH ARGUMENTS
.IP "sleep_state" 12
	ACPI state
Enable all wakup devices's GPE
.TH "acpi_disable_wakeup_device" 9 "acpi_disable_wakeup_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_disable_wakeup_device \-  disable devices' wakeup capability
.SH SYNOPSIS
.B "void" acpi_disable_wakeup_device
.BI "(u8 " sleep_state ");"
.SH ARGUMENTS
.IP "sleep_state" 12
	ACPI state
Disable all wakup devices's GPE and wakeup capability
.TH "acpi_sleep_prepare" 9 "acpi_sleep_prepare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_sleep_prepare \-  Do preliminary suspend work.
.SH SYNOPSIS
.B "int" acpi_sleep_prepare
.BI "(u32 " acpi_state ");"
.SH ARGUMENTS
.IP "acpi_state" 12
-- undescribed --
.SH "DESCRIPTION"
Make sure we support the state. If we do, and we need it, set the
firmware waking vector and do arch-specific nastiness to get the 
wakeup code to the waking vector. 
.TH "acpi_pm_enter" 9 "acpi_pm_enter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_pm_enter \-  Actually enter a sleep state.
.SH SYNOPSIS
.B "int" acpi_pm_enter
.BI "(suspend_state_t " pm_state ");"
.SH ARGUMENTS
.IP "pm_state" 12
		State we're entering.
.SH "DESCRIPTION"
Flush caches and go to sleep. For STR or STD, we have to call 
arch-specific assembly, which in turn call \fBacpi_enter_sleep_state\fP.
It's unfortunate, but it works. Please fix if you're feeling frisky.
.TH "acpi_pm_finish" 9 "acpi_pm_finish" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_pm_finish \-  Finish up suspend sequence.
.SH SYNOPSIS
.B "int" acpi_pm_finish
.BI "(suspend_state_t " pm_state ");"
.SH ARGUMENTS
.IP "pm_state" 12
		State we're coming out of.
.SH "DESCRIPTION"
This is called after we wake back up (or if entering the sleep state
failed). 
.TH "acpi_bus_notify" 9 "acpi_bus_notify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_bus_notify \- 
.SH SYNOPSIS
.B "void" acpi_bus_notify
.BI "(acpi_handle " handle ","
.BI "u32 " type ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "handle" 12
-- undescribed --
.IP "type" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
---------------
Callback for all 'system-level' device notifications (values 0x00-0x7F).
.TH "IS_RESERVED_ADDR" 9 "IS_RESERVED_ADDR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
IS_RESERVED_ADDR \- 
.SH SYNOPSIS
.B "" IS_RESERVED_ADDR
.BI "(" base ","
.BI "" len ");"
.SH ARGUMENTS
.IP "base" 12
.IP "len" 12
.SH "DESCRIPTION"
Doesn't care about the failure of 'request_region', since other may reserve 
the io ports as well
.TH "fs_initcall" 9 "fs_initcall" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fs_initcall \- 
.SH SYNOPSIS
.B "" fs_initcall
.BI "(" acpi_motherboard_init ");"
.SH ARGUMENTS
.IP "acpi_motherboard_init" 12
.SH "DESCRIPTION"
but before PCI assign resources for uninitialized PCI devices
.TH "setup_sys_fs_device_files" 9 "setup_sys_fs_device_files" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
setup_sys_fs_device_files \-  sets up the device files under device namespace
.SH SYNOPSIS
.B "void" setup_sys_fs_device_files
.BI "(struct acpi_device *" dev ","
.BI "acpi_device_sysfs_files *" func ");"
.SH ARGUMENTS
.IP "dev" 12
	acpi_device object
.IP "func" 12
	function pointer to create or destroy the device file
.TH "acpi_bus_match" 9 "acpi_bus_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_bus_match \- 
.SH SYNOPSIS
.B "int" acpi_bus_match
.BI "(struct acpi_device *" device ","
.BI "struct acpi_driver *" driver ");"
.SH ARGUMENTS
.IP "device" 12
-- undescribed --
.IP "driver" 12
-- undescribed --
.SH "DESCRIPTION"
--------------
Checks the device's hardware (_HID) or compatible (_CID) ids to see if it
matches the specified driver's criteria.
.TH "acpi_bus_driver_init" 9 "acpi_bus_driver_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_bus_driver_init \- 
.SH SYNOPSIS
.B "int" acpi_bus_driver_init
.BI "(struct acpi_device *" device ","
.BI "struct acpi_driver *" driver ");"
.SH ARGUMENTS
.IP "device" 12
-- undescribed --
.IP "driver" 12
-- undescribed --
.SH "DESCRIPTION"
--------------------
Used to initialize a device via its device driver.  Called whenever a 
driver is bound to a device.  Invokes the driver's \fBadd\fP and \fBstart\fP ops.
.TH "acpi_bus_register_driver" 9 "acpi_bus_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_bus_register_driver \- 
.SH SYNOPSIS
.B "int" acpi_bus_register_driver
.BI "(struct acpi_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.SH "DESCRIPTION"
------------------------ 
Registers a driver with the ACPI bus.  Searches the namespace for all
devices that match the driver's criteria and binds.  Returns the
number of devices that were claimed by the driver, or a negative
error status for failure.
.TH "acpi_bus_unregister_driver" 9 "acpi_bus_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_bus_unregister_driver \- 
.SH SYNOPSIS
.B "int" acpi_bus_unregister_driver
.BI "(struct acpi_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
-- undescribed --
.SH "DESCRIPTION"
--------------------------
Unregisters a driver with the ACPI bus.  Searches the namespace for all
devices that match the driver's criteria and unbinds.
.TH "acpi_bus_find_driver" 9 "acpi_bus_find_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_bus_find_driver \- 
.SH SYNOPSIS
.B "int" acpi_bus_find_driver
.BI "(struct acpi_device *" device ");"
.SH ARGUMENTS
.IP "device" 12
-- undescribed --
.SH "DESCRIPTION"
--------------------
Parses the list of registered drivers looking for a driver applicable for
the specified device.
.TH "acpi_get_pci_id" 9 "acpi_get_pci_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_get_pci_id \- 
.SH SYNOPSIS
.B "acpi_status" acpi_get_pci_id
.BI "(acpi_handle " handle ","
.BI "struct acpi_pci_id *" id ");"
.SH ARGUMENTS
.IP "handle" 12
-- undescribed --
.IP "id" 12
-- undescribed --
.SH "DESCRIPTION"
------------------
This function is used by the ACPI Interpreter (a.k.a. Core Subsystem)
to resolve PCI information for ACPI-PCI devices defined in the namespace.
This typically occurs when resolving PCI operation region information.
.TH "xxxfb_open" 9 "xxxfb_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_open \-  Optional function. Called when the framebuffer is
.SH SYNOPSIS
.B "int" xxxfb_open
.BI "(const struct fb_info *" info ","
.BI "int " user ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "user" 12
 tell us if the userland (value=1) or the console is accessing
the framebuffer. 
.SH "DESCRIPTION"
This function is the first function called in the framebuffer api.
Usually you don't need to provide this function. The case where it 
is used is to change from a text mode hardware state to a graphics
mode state. 

Returns negative errno on error, or zero on success.
.SH "DESCRIPTION"
This function is the first function called in the framebuffer api.
Usually you don't need to provide this function. The case where it 
is used is to change from a text mode hardware state to a graphics
mode state. 

Returns negative errno on error, or zero on success.
.TH "xxxfb_release" 9 "xxxfb_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_release \-  Optional function. Called when the framebuffer 
.SH SYNOPSIS
.B "int" xxxfb_release
.BI "(const struct fb_info *" info ","
.BI "int " user ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "user" 12
 tell us if the userland (value=1) or the console is accessing
the framebuffer. 
.SH "DESCRIPTION"
Thus function is called when we close /dev/fb or the framebuffer 
console system is released. Usually you don't need this function.
The case where it is usually used is to go from a graphics state
to a text mode state.

Returns negative errno on error, or zero on success.
.SH "DESCRIPTION"
Thus function is called when we close /dev/fb or the framebuffer 
console system is released. Usually you don't need this function.
The case where it is usually used is to go from a graphics state
to a text mode state.

Returns negative errno on error, or zero on success.
.TH "xxxfb_check_var" 9 "xxxfb_check_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_check_var \-  Optional function. Validates a var passed in. 
.SH SYNOPSIS
.B "int" xxxfb_check_var
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer 
.SH "DESCRIPTION"
Checks to see if the hardware supports the state requested by
var passed in. This function does not alter the hardware state!!! 
This means the data stored in struct fb_info and struct xxx_par do 
not change. This includes the var inside of struct fb_info. 
Do NOT change these. This function can be called on its own if we
intent to only test a mode and not actually set it. The stuff in 
modedb.c is a example of this. If the var passed in is slightly 
off by what the hardware can support then we alter the var PASSED in
to what we can do. If the hardware doesn't support mode change 
a -EINVAL will be returned by the upper layers. You don't need to 
implement this function then. If you hardware doesn't support 
changing the resolution then this function is not needed. In this
case the driver woudl just provide a var that represents the static
state the screen is in.

Returns negative errno on error, or zero on success.
.TH "xxxfb_set_par" 9 "xxxfb_set_par" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_set_par \-  Optional function. Alters the hardware state.
.SH SYNOPSIS
.B "int" xxxfb_set_par
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Using the fb_var_screeninfo in fb_info we set the resolution of the
this particular framebuffer. This function alters the par AND the
fb_fix_screeninfo stored in fb_info. It doesn't not alter var in 
fb_info since we are using that data. This means we depend on the
data in var inside fb_info to be supported by the hardware. 
xxxfb_check_var is always called before xxxfb_set_par to ensure this.
Again if you can't change the resolution you don't need this function.

Returns negative errno on error, or zero on success.
.TH "xxxfb_setcolreg" 9 "xxxfb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" xxxfb_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "const struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 Which register in the CLUT we are programming 
.IP "red" 12
 The red value which can be up to 16 bits wide 
.IP "green" 12
 The green value which can be up to 16 bits wide 
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported, the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Set a single color register. The values supplied have a 16 bit
magnitude which needs to be scaled in this function for the hardware. 
Things to take into consideration are how many color registers, if
any, are supported with the current color visual. With truecolor mode
no color palettes are supported. Here a pseudo palette is created
which we store the value in pseudo_palette in struct fb_info. For
pseudocolor mode we have a limited color palette. To deal with this
we can program what color is displayed for a particular pixel value.
DirectColor is similar in that we can program each color field. If
we have a static colormap we don't need to implement this function. 

Returns negative errno on error, or zero on success.
.TH "xxxfb_pan_display" 9 "xxxfb_pan_display" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_pan_display \-  NOT a required function. Pans the display.
.SH SYNOPSIS
.B "int" xxxfb_pan_display
.BI "(struct fb_var_screeninfo *" var ","
.BI "const struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Pan (or wrap, depending on the `vmode' field) the display using the
`xoffset' and `yoffset' fields of the `var' structure.
If the values don't fit, return -EINVAL.

Returns negative errno on error, or zero on success.
.TH "xxxfb_blank" 9 "xxxfb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_blank \-  NOT a required function. Blanks the display.
.SH SYNOPSIS
.B "int" xxxfb_blank
.BI "(int " blank_mode ","
.BI "const struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank_mode" 12
 the blank mode we want. 
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Blank the screen if blank_mode != 0, else unblank. Return 0 if
blanking succeeded, != 0 if un-/blanking failed due to e.g. a 
video mode which doesn't support it. Implements VESA suspend
and powerdown modes on hardware that supports disabling hsync/vsync:
blank_mode == 2: suspend vsync
blank_mode == 3: suspend hsync
blank_mode == 4: powerdown

Returns negative errno on error, or zero on success.
.TH "xxfb_fillrect" 9 "xxfb_fillrect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxfb_fillrect \-  REQUIRED function. Can use generic routines if 
.SH SYNOPSIS
.B "void" xxfb_fillrect
.BI "(struct fb_info *" p ","
.BI "const struct fb_fillrect *" region ");"
.SH ARGUMENTS
.IP "p" 12
-- undescribed --
.IP "region" 12
 The structure representing the rectangular region we 
wish to draw to.
.SH "DESCRIPTION"
This drawing operation places/removes a retangle on the screen 
depending on the rastering operation with the value of color which
is in the current color depth format.
.SH "DESCRIPTION"
This drawing operation places/removes a retangle on the screen 
depending on the rastering operation with the value of color which
is in the current color depth format.
.TH "xxxfb_copyarea" 9 "xxxfb_copyarea" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_copyarea \-  REQUIRED function. Can use generic routines if
.SH SYNOPSIS
.B "void" xxxfb_copyarea
.BI "(struct fb_info *" p ","
.BI "const struct fb_copyarea *" area ");"
.SH ARGUMENTS
.IP "p" 12
-- undescribed --
.IP "area" 12
 Structure providing the data to copy the framebuffer contents
from one region to another.
.SH "DESCRIPTION"
This drawing operation copies a rectangular area from one area of the
screen to another area.
.SH "DESCRIPTION"
This drawing operation copies a rectangular area from one area of the
screen to another area.
.TH "xxxfb_imageblit" 9 "xxxfb_imageblit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_imageblit \-  REQUIRED function. Can use generic routines if
.SH SYNOPSIS
.B "void" xxxfb_imageblit
.BI "(struct fb_info *" p ","
.BI "const struct fb_image *" image ");"
.SH ARGUMENTS
.IP "p" 12
-- undescribed --
.IP "image" 12
	structure defining the image.
.SH "DESCRIPTION"
This drawing operation draws a image on the screen. It can be a 
mono image (needed for font handling) or a color image (needed for
tux). 
.SH "DESCRIPTION"
This drawing operation draws a image on the screen. It can be a 
mono image (needed for font handling) or a color image (needed for
tux). 
.TH "xxxfb_cursor" 9 "xxxfb_cursor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_cursor \-  	REQUIRED function. If your hardware lacks support
.SH SYNOPSIS
.B "int" xxxfb_cursor
.BI "(struct fb_info *" info ","
.BI "struct fb_cursor *" cursor ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "cursor" 12
 structure defining the cursor to draw.
.SH "DESCRIPTION"
This operation is used to set or alter the properities of the
cursor.

Returns negative errno on error, or zero on success.
.SH "DESCRIPTION"
This operation is used to set or alter the properities of the
cursor.

Returns negative errno on error, or zero on success.
.TH "xxxfb_rotate" 9 "xxxfb_rotate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_rotate \-   NOT a required function. If your hardware
.SH SYNOPSIS
.B "void" xxxfb_rotate
.BI "(struct fb_info *" info ","
.BI "int " angle ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "angle" 12
 The angle we rotate the screen.   
.SH "DESCRIPTION"
This operation is used to set or alter the properities of the
cursor.
.SH "DESCRIPTION"
This operation is used to set or alter the properities of the
cursor.
.TH "xxxfb_poll" 9 "xxxfb_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_poll \-  NOT a required function. The purpose of this
.SH SYNOPSIS
.B "void" xxxfb_poll
.BI "(struct fb_info *" info ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "wait" 12
 poll table where we store process that await a event.     
.SH "DESCRIPTION"
function is to provide a way for some process
to wait until a specific hardware event occurs
for the framebuffer device.
.TH "xxxfb_sync" 9 "xxxfb_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xxxfb_sync \-  NOT a required function. Normally the accel engine 
.SH SYNOPSIS
.B "void" xxxfb_sync
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
for a graphics card take a specific amount of time.
Often we have to wait for the accelerator to finish
its operation before we can write to the framebuffer
so we can have consistent display output. 
.TH "leo_setcolreg" 9 "leo_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
leo_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" leo_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "leo_blank" 9 "leo_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
leo_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" leo_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "hgafb_open" 9 "hgafb_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hgafb_open \-  open the framebuffer device
.SH SYNOPSIS
.B "int" hgafb_open
.BI "(struct fb_info *" info ","
.BI "int " init ");"
.SH ARGUMENTS
.IP "info" 12
pointer to fb_info object containing info for current hga board
.IP "init" 12
-- undescribed --
.TH "hgafb_release" 9 "hgafb_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hgafb_release \-  open the framebuffer device
.SH SYNOPSIS
.B "int" hgafb_release
.BI "(struct fb_info *" info ","
.BI "int " init ");"
.SH ARGUMENTS
.IP "info" 12
pointer to fb_info object containing info for current hga board
.IP "init" 12
-- undescribed --
.TH "hgafb_setcolreg" 9 "hgafb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hgafb_setcolreg \-  set color registers
.SH SYNOPSIS
.B "int" hgafb_setcolreg
.BI "(u_int " regno ","
.BI "u_int " red ","
.BI "u_int " green ","
.BI "u_int " blue ","
.BI "u_int " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
register index to set
.IP "red" 12
red value, unused
.IP "green" 12
green value, unused
.IP "blue" 12
blue value, unused
.IP "transp" 12
transparency value, unused
.IP "info" 12
unused
.SH "DESCRIPTION"
This callback function is used to set the color registers of a HGA
board. Since we have only two fixed colors only \fIregno\fP is checked.
A zero is returned on success and 1 for failure.
.TH "hgafb_pan_display" 9 "hgafb_pan_display" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hgafb_pan_display \-  pan or wrap the display
.SH SYNOPSIS
.B "int" hgafb_pan_display
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
contains new xoffset, yoffset and vmode values
.IP "info" 12
pointer to fb_info object containing info for current hga board
.SH "DESCRIPTION"
This function looks only at xoffset, yoffset and the FB_VMODE_YWRAP
flag in \fIvar\fP. If input parameters are correct it calls \fBhga_pan\fP to 
program the hardware. \fIinfo\fP-&gt;var is updated to the new values.
A zero is returned on success and -EINVAL for failure.
.TH "hgafb_blank" 9 "hgafb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hgafb_blank \-  (un)blank the screen
.SH SYNOPSIS
.B "int" hgafb_blank
.BI "(int " blank_mode ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank_mode" 12
blanking method to use
.IP "info" 12
unused
.SH "DESCRIPTION"
Blank the screen if blank_mode != 0, else unblank. 
Implements VESA suspend and powerdown modes on hardware that supports 
disabling hsync/vsync:
\fIblank_mode\fP == 2 means suspend vsync,
\fIblank_mode\fP == 3 means suspend hsync,
\fIblank_mode\fP == 4 means powerdown.
.TH "i810fb_encode_registers" 9 "i810fb_encode_registers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810fb_encode_registers \-  encode @var to hardware register values
.SH SYNOPSIS
.B "void" i810fb_encode_registers
.BI "(const struct fb_var_screeninfo *" var ","
.BI "struct i810fb_par *" par ","
.BI "u32 " xres ","
.BI "u32 " yres ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to var structure
.IP "par" 12
 pointer to hardware par structure
.IP "xres" 12
-- undescribed --
.IP "yres" 12
-- undescribed --
.SH "DESCRIPTION"
 
Timing values in \fIvar\fP will be converted to appropriate
register values of \fIpar\fP.  
.TH "i810_get_watermark" 9 "i810_get_watermark" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_get_watermark \-  gets watermark
.SH SYNOPSIS
.B "u32" i810_get_watermark
.BI "(const struct fb_var_screeninfo *" var ","
.BI "struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to fb_var_screeninfo
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Gets the required watermark based on 
pixelclock and RAMBUS frequency.
.SH "RETURNS"
watermark
.TH "i810_screen_off" 9 "i810_screen_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_screen_off \-  turns off/on display
.SH SYNOPSIS
.B "void" i810_screen_off
.BI "(u8 __iomem *" mmio ","
.BI "u8 " mode ");"
.SH ARGUMENTS
.IP "mmio" 12
 address of register space
.IP "mode" 12
 on or off
.SH "DESCRIPTION"
Blanks/unblanks the display
.TH "i810_dram_off" 9 "i810_dram_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_dram_off \-  turns off/on dram refresh
.SH SYNOPSIS
.B "void" i810_dram_off
.BI "(u8 __iomem *" mmio ","
.BI "u8 " mode ");"
.SH ARGUMENTS
.IP "mmio" 12
 address of register space
.IP "mode" 12
 on or off
.SH "DESCRIPTION"
Turns off DRAM refresh.  Must be off for only 2 vsyncs
before data becomes corrupt
.TH "i810_protect_regs" 9 "i810_protect_regs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_protect_regs \-  allows rw/ro mode of certain VGA registers
.SH SYNOPSIS
.B "void" i810_protect_regs
.BI "(u8 __iomem *" mmio ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "mmio" 12
 address of register space
.IP "mode" 12
 protect/unprotect
.SH "DESCRIPTION"
The IBM VGA standard allows protection of certain VGA registers.  
This will  protect or unprotect them. 
.TH "i810_load_pll" 9 "i810_load_pll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_load_pll \-  loads values for the hardware PLL clock
.SH SYNOPSIS
.B "void" i810_load_pll
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Loads the P, M, and N registers.  
.TH "i810_load_vga" 9 "i810_load_vga" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_load_vga \-  load standard VGA registers
.SH SYNOPSIS
.B "void" i810_load_vga
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Load values to VGA registers
.TH "i810_load_vgax" 9 "i810_load_vgax" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_load_vgax \-  load extended VGA registers
.SH SYNOPSIS
.B "void" i810_load_vgax
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Load values to extended VGA registers
.TH "i810_load_2d" 9 "i810_load_2d" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_load_2d \-  load grahics registers
.SH SYNOPSIS
.B "void" i810_load_2d
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Load values to graphics registers
.TH "i810_hires" 9 "i810_hires" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_hires \-  enables high resolution mode
.SH SYNOPSIS
.B "void" i810_hires
.BI "(u8 __iomem *" mmio ");"
.SH ARGUMENTS
.IP "mmio" 12
 address of register space
.TH "i810_load_pitch" 9 "i810_load_pitch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_load_pitch \-  loads the characters per line of the display
.SH SYNOPSIS
.B "void" i810_load_pitch
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Loads the characters per line
.TH "i810_load_color" 9 "i810_load_color" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_load_color \-  loads the color depth of the display
.SH SYNOPSIS
.B "void" i810_load_color
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Loads the color depth of the display and the graphics engine
.TH "i810_load_regs" 9 "i810_load_regs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_load_regs \-  loads all registers for the mode
.SH SYNOPSIS
.B "void" i810_load_regs
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Loads registers
.TH "get_line_length" 9 "get_line_length" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_line_length \-  calculates buffer pitch in bytes
.SH SYNOPSIS
.B "u32" get_line_length
.BI "(struct i810fb_par *" par ","
.BI "int " xres_virtual ","
.BI "int " bpp ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.IP "xres_virtual" 12
 virtual resolution of the frame
.IP "bpp" 12
 bits per pixel
.SH "DESCRIPTION"
Calculates buffer pitch in bytes.  
.TH "i810_calc_dclk" 9 "i810_calc_dclk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_calc_dclk \-  calculates the P, M, and N values of a pixelclock value
.SH SYNOPSIS
.B "void" i810_calc_dclk
.BI "(u32 " freq ","
.BI "u32 *" m ","
.BI "u32 *" n ","
.BI "u32 *" p ");"
.SH ARGUMENTS
.IP "freq" 12
 target pixelclock in picoseconds
.IP "m" 12
 where to write M register
.IP "n" 12
 where to write N register
.IP "p" 12
 where to write P register
.SH "DESCRIPTION"
Based on the formula Freq_actual = (4*M*Freq_ref)/(N^P)
Repeatedly computes the Freq until the actual Freq is equal to
the target Freq or until the loop count is zero.  In the latter
case, the actual frequency nearest the target will be used.
.TH "i810_enable_cursor" 9 "i810_enable_cursor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_enable_cursor \-  show or hide the hardware cursor
.SH SYNOPSIS
.B "void" i810_enable_cursor
.BI "(u8 __iomem *" mmio ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "mmio" 12
 address of register space
.IP "mode" 12
 show (1) or hide (0)
.SH "DESCRIPTION"
Shows or hides the hardware cursor
.TH "i810_init_cursor" 9 "i810_init_cursor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_init_cursor \-  initializes the cursor
.SH SYNOPSIS
.B "void" i810_init_cursor
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
Initializes the cursor registers
.TH "i810_round_off" 9 "i810_round_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_round_off \-   Round off values to capability of hardware
.SH SYNOPSIS
.B "void" i810_round_off
.BI "(struct fb_var_screeninfo *" var ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to fb_var_screeninfo structure
.SH "DESCRIPTION"
\fIvar\fP contains user-defined information for the mode to be set.
This will try modify those values to ones nearest the
capability of the hardware
.TH "set_color_bitfields" 9 "set_color_bitfields" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_color_bitfields \-  sets rgba fields
.SH SYNOPSIS
.B "void" set_color_bitfields
.BI "(struct fb_var_screeninfo *" var ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to fb_var_screeninfo
.SH "DESCRIPTION"
The length, offset and ordering  for each color field 
(red, green, blue)  will be set as specified 
by the hardware
.TH "i810_check_params" 9 "i810_check_params" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_check_params \-  check if contents in var are valid
.SH SYNOPSIS
.B "int" i810_check_params
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to fb_var_screeninfo
.IP "info" 12
 pointer to fb_info
.SH "DESCRIPTION"
This will check if the framebuffer size is sufficient 
for the current mode and if the user's monitor has the 
required specifications to display the current mode.
.TH "encode_fix" 9 "encode_fix" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
encode_fix \-  fill up fb_fix_screeninfo structure
.SH SYNOPSIS
.B "int" encode_fix
.BI "(struct fb_fix_screeninfo *" fix ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "fix" 12
 pointer to fb_fix_screeninfo
.IP "info" 12
 pointer to fb_info
.SH "DESCRIPTION"
This will set up parameters that are unmodifiable by the user.
.TH "decode_var" 9 "decode_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
decode_var \-  modify par according to contents of var
.SH SYNOPSIS
.B "void" decode_var
.BI "(const struct fb_var_screeninfo *" var ","
.BI "struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to fb_var_screeninfo
.IP "par" 12
 pointer to i810fb_par
.SH "DESCRIPTION"
Based on the contents of \fIvar\fP, \fIpar\fP will be dynamically filled up.
\fIpar\fP contains all information necessary to modify the hardware. 
.TH "i810fb_getcolreg" 9 "i810fb_getcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810fb_getcolreg \-  gets red, green and blue values of the hardware DAC
.SH SYNOPSIS
.B "int" i810fb_getcolreg
.BI "(u8 " regno ","
.BI "u8 *" red ","
.BI "u8 *" green ","
.BI "u8 *" blue ","
.BI "u8 *" transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 DAC index
.IP "red" 12
 red
.IP "green" 12
 green
.IP "blue" 12
 blue
.IP "transp" 12
 transparency (alpha)
.IP "info" 12
 pointer to fb_info
.SH "DESCRIPTION"
Gets the red, green and blue values of the hardware DAC as pointed by \fIregno\fP
and writes them to \fIred\fP, \fIgreen\fP and \fIblue\fP respectively
.TH "i810_init_monspecs" 9 "i810_init_monspecs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_init_monspecs \- 
.SH SYNOPSIS
.B "void __devinit" i810_init_monspecs
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 pointer to device specific info structure
.SH "DESCRIPTION"
Sets the the user monitor's horizontal and vertical
frequency limits
.TH "i810_init_defaults" 9 "i810_init_defaults" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_init_defaults \-  initializes default values to use
.SH SYNOPSIS
.B "void __devinit" i810_init_defaults
.BI "(struct i810fb_par *" par ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.IP "info" 12
 pointer to current fb_info structure
.TH "i810_init_device" 9 "i810_init_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_init_device \-  initialize device
.SH SYNOPSIS
.B "void __devinit" i810_init_device
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.TH "wait_for_space" 9 "wait_for_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_for_space \-  check ring buffer free space
.SH SYNOPSIS
.B "int" wait_for_space
.BI "(struct fb_info *" info ","
.BI "u32 " space ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.IP "space" 12
 amount of ringbuffer space needed in bytes
.SH "DESCRIPTION"
The function waits until a free space from the ringbuffer
is available 
.TH "wait_for_engine_idle" 9 "wait_for_engine_idle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wait_for_engine_idle \-  waits for all hardware engines to finish
.SH SYNOPSIS
.B "int" wait_for_engine_idle
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
This waits for lring(0), iring(1), and batch(3), etc to finish and
waits until ringbuffer is empty.
.TH "end_iring" 9 "end_iring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
end_iring \-  advances the buffer
.SH SYNOPSIS
.B "void" end_iring
.BI "(struct i810fb_par *" par ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.SH "DESCRIPTION"
This advances the tail of the ringbuffer, effectively
beginning the execution of the graphics instruction sequence.
.TH "source_copy_blit" 9 "source_copy_blit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
source_copy_blit \-  BLIT transfer operation
.SH SYNOPSIS
.B "void" source_copy_blit
.BI "(int " dwidth ","
.BI "int " dheight ","
.BI "int " dpitch ","
.BI "int " xdir ","
.BI "int " src ","
.BI "int " dest ","
.BI "int " rop ","
.BI "int " blit_bpp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "dwidth" 12
 width of rectangular graphics data
.IP "dheight" 12
 height of rectangular graphics data
.IP "dpitch" 12
 bytes per line of destination buffer
.IP "xdir" 12
 direction of copy (left to right or right to left)
.IP "src" 12
 address of first pixel to read from
.IP "dest" 12
 address of first pixel to write to
.IP "rop" 12
 raster operation
.IP "blit_bpp" 12
 pixel format which can be different from the 
framebuffer's pixelformat
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
This is a BLIT operation typically used when doing
a 'Copy and Paste'
.TH "color_blit" 9 "color_blit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
color_blit \-  solid color BLIT operation
.SH SYNOPSIS
.B "void" color_blit
.BI "(int " width ","
.BI "int " height ","
.BI "int " pitch ","
.BI "int " dest ","
.BI "int " rop ","
.BI "int " what ","
.BI "int " blit_bpp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "width" 12
 width of destination
.IP "height" 12
 height of destination
.IP "pitch" 12
 pixels per line of the buffer
.IP "dest" 12
 address of first pixel to write to
.IP "rop" 12
 raster operation
.IP "what" 12
 color to transfer
.IP "blit_bpp" 12
 pixel format which can be different from the 
framebuffer's pixelformat
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
A BLIT operation which can be used for  color fill/rectangular fill
.TH "mono_src_copy_imm_blit" 9 "mono_src_copy_imm_blit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mono_src_copy_imm_blit \-  color expand from system memory to framebuffer
.SH SYNOPSIS
.B "void" mono_src_copy_imm_blit
.BI "(int " dwidth ","
.BI "int " dheight ","
.BI "int " dpitch ","
.BI "int " dsize ","
.BI "int " blit_bpp ","
.BI "int " rop ","
.BI "int " dest ","
.BI "const u32 *" src ","
.BI "int " bg ","
.BI "int " fg ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "dwidth" 12
 width of destination
.IP "dheight" 12
 height of destination
.IP "dpitch" 12
 pixels per line of the buffer
.IP "dsize" 12
 size of bitmap in double words
.IP "blit_bpp" 12
 pixelformat to use which can be different from the 
framebuffer's pixelformat
.IP "rop" 12
 raster operation
.IP "dest" 12
 address of first byte of pixel;
.IP "src" 12
 address of image data
.IP "bg" 12
 backgound color
.IP "fg" 12
 forground color
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
A color expand operation where the  source data is placed in the 
ringbuffer itself. Useful for drawing text. 
.SH "REQUIREMENT"
The end of a scanline must be padded to the next word.
.TH "i810fb_iring_enable" 9 "i810fb_iring_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810fb_iring_enable \-  enables/disables the ringbuffer
.SH SYNOPSIS
.B "void" i810fb_iring_enable
.BI "(struct i810fb_par *" par ","
.BI "u32 " mode ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to i810fb_par structure
.IP "mode" 12
 enable or disable
.SH "DESCRIPTION"
Enables or disables the ringbuffer, effectively enabling or
disabling the instruction/acceleration engine.
.TH "i810fb_init_ringbuffer" 9 "i810fb_init_ringbuffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810fb_init_ringbuffer \-  initialize the ringbuffer
.SH SYNOPSIS
.B "void" i810fb_init_ringbuffer
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
-- undescribed --
.SH "DESCRIPTION"
Initializes the ringbuffer by telling the device the
size and location of the ringbuffer.  It also sets 
the head and tail pointers = 0
.TH "rivafb_load_cursor_image" 9 "rivafb_load_cursor_image" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_load_cursor_image \-  load cursor image to hardware
.SH SYNOPSIS
.B "void" rivafb_load_cursor_image
.BI "(struct riva_par *" par ","
.BI "u8 *" data8 ","
.BI "u16 " bg ","
.BI "u16 " fg ","
.BI "u32 " w ","
.BI "u32 " h ");"
.SH ARGUMENTS
.IP "par" 12
  pointer to private data
.IP "data8" 12
-- undescribed --
.IP "bg" 12
   background color (ARGB1555) - alpha bit determines opacity
.IP "fg" 12
   foreground color (ARGB1555)
.IP "w" 12
    width of cursor image in pixels
.IP "h" 12
    height of cursor image in scanlines
.SH "DESCRIPTION"
Loads cursor image based on a monochrome source and mask bitmap.  The
image bits determines the color of the pixel, 0 for background, 1 for
foreground.  Only the affected region (as determined by \fIw\fP and \fIh\fP 
parameters) will be updated.
.SH "CALLED FROM"
\fBrivafb_cursor\fP
.TH "riva_wclut" 9 "riva_wclut" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
riva_wclut \-  set CLUT entry
.SH SYNOPSIS
.B "void" riva_wclut
.BI "(RIVA_HW_INST *" chip ","
.BI "unsigned char " regnum ","
.BI "unsigned char " red ","
.BI "unsigned char " green ","
.BI "unsigned char " blue ");"
.SH ARGUMENTS
.IP "chip" 12
 pointer to RIVA_HW_INST object
.IP "regnum" 12
 register number
.IP "red" 12
 red component
.IP "green" 12
 green component
.IP "blue" 12
 blue component
.SH "DESCRIPTION"
Sets color register \fIregnum\fP.
.SH "CALLED FROM"
\fBrivafb_setcolreg\fP
.TH "riva_rclut" 9 "riva_rclut" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
riva_rclut \-  read fromCLUT register
.SH SYNOPSIS
.B "void" riva_rclut
.BI "(RIVA_HW_INST *" chip ","
.BI "unsigned char " regnum ","
.BI "unsigned char *" red ","
.BI "unsigned char *" green ","
.BI "unsigned char *" blue ");"
.SH ARGUMENTS
.IP "chip" 12
 pointer to RIVA_HW_INST object
.IP "regnum" 12
 register number
.IP "red" 12
 red component
.IP "green" 12
 green component
.IP "blue" 12
 blue component
.SH "DESCRIPTION"
Reads red, green, and blue from color register \fIregnum\fP.
.SH "CALLED FROM"
\fBrivafb_setcolreg\fP
.TH "riva_save_state" 9 "riva_save_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
riva_save_state \-  saves current chip state
.SH SYNOPSIS
.B "void" riva_save_state
.BI "(struct riva_par *" par ","
.BI "struct riva_regs *" regs ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to riva_par object containing info for current riva board
.IP "regs" 12
 pointer to riva_regs object
.SH "DESCRIPTION"
Saves current chip state to \fIregs\fP.
.SH "CALLED FROM"
\fBrivafb_probe\fP
.TH "riva_load_state" 9 "riva_load_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
riva_load_state \-  loads current chip state
.SH SYNOPSIS
.B "void" riva_load_state
.BI "(struct riva_par *" par ","
.BI "struct riva_regs *" regs ");"
.SH ARGUMENTS
.IP "par" 12
 pointer to riva_par object containing info for current riva board
.IP "regs" 12
 pointer to riva_regs object
.SH "DESCRIPTION"
Loads chip state from \fIregs\fP.
.SH "CALLED FROM"
\fBriva_load_video_mode\fP
\fBrivafb_probe\fP
\fBrivafb_remove\fP
.TH "riva_load_video_mode" 9 "riva_load_video_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
riva_load_video_mode \-  calculate timings
.SH SYNOPSIS
.B "void" riva_load_video_mode
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 pointer to fb_info object containing info for current riva board
.SH "DESCRIPTION"
Calculate some timings and then send em off to \fBriva_load_state\fP.
.SH "CALLED FROM"
\fBrivafb_set_par\fP
.TH "rivafb_do_maximize" 9 "rivafb_do_maximize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_do_maximize \-  
.SH SYNOPSIS
.B "int" rivafb_do_maximize
.BI "(struct fb_info *" info ","
.BI "struct fb_var_screeninfo *" var ","
.BI "int " nom ","
.BI "int " den ");"
.SH ARGUMENTS
.IP "info" 12
 pointer to fb_info object containing info for current riva board
.IP "var" 12
-- undescribed --
.IP "nom" 12
-- undescribed --
.IP "den" 12
.SH "DESCRIPTION"
.
.SH "RETURNS"
-EINVAL on failure, 0 on success
.SH "CALLED FROM"
\fBrivafb_check_var\fP
.TH "riva_get_cmap_len" 9 "riva_get_cmap_len" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
riva_get_cmap_len \-  query current color map length
.SH SYNOPSIS
.B "int" riva_get_cmap_len
.BI "(const struct fb_var_screeninfo *" var ");"
.SH ARGUMENTS
.IP "var" 12
 standard kernel fb changeable data
.SH "DESCRIPTION"
Get current color map length.
.SH "RETURNS"
Length of color map
.SH "CALLED FROM"
\fBrivafb_setcolreg\fP
.TH "rivafb_pan_display" 9 "rivafb_pan_display" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_pan_display \- 
.SH SYNOPSIS
.B "int" rivafb_pan_display
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 standard kernel fb changeable data
.IP "info" 12
 pointer to fb_info object containing info for current riva board
.SH "DESCRIPTION"
Pan (or wrap, depending on the `vmode' field) the display using the
`xoffset' and `yoffset' fields of the `var' structure.
If the values don't fit, return -EINVAL.

This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
.TH "rivafb_setcolreg" 9 "rivafb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_setcolreg \- 
.SH SYNOPSIS
.B "int" rivafb_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 register index
.IP "red" 12
 red component
.IP "green" 12
 green component
.IP "blue" 12
 blue component
.IP "transp" 12
 transparency
.IP "info" 12
 pointer to fb_info object containing info for current riva board
.SH "DESCRIPTION"
Set a single color register. The values supplied have a 16 bit
magnitude.
.SH "RETURNS"
Return != 0 for invalid regno.
.SH "CALLED FROM"
fbcmap.c:\fBfb_set_cmap\fP
.TH "rivafb_fillrect" 9 "rivafb_fillrect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_fillrect \-  hardware accelerated color fill function
.SH SYNOPSIS
.B "void" rivafb_fillrect
.BI "(struct fb_info *" info ","
.BI "const struct fb_fillrect *" rect ");"
.SH ARGUMENTS
.IP "info" 12
 pointer to fb_info structure
.IP "rect" 12
 pointer to fb_fillrect structure
.SH "DESCRIPTION"
This function fills up a region of framebuffer memory with a solid
color with a choice of two different ROP's, copy or invert.
.SH "CALLED FROM"
framebuffer hook
.TH "rivafb_copyarea" 9 "rivafb_copyarea" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_copyarea \-  hardware accelerated blit function
.SH SYNOPSIS
.B "void" rivafb_copyarea
.BI "(struct fb_info *" info ","
.BI "const struct fb_copyarea *" region ");"
.SH ARGUMENTS
.IP "info" 12
 pointer to fb_info structure
.IP "region" 12
 pointer to fb_copyarea structure
.SH "DESCRIPTION"
This copies an area of pixels from one location to another
.SH "CALLED FROM"
framebuffer hook
.TH "rivafb_imageblit" 9 "rivafb_imageblit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_imageblit \- 
.SH SYNOPSIS
.B "void" rivafb_imageblit
.BI "(struct fb_info *" info ","
.BI "const struct fb_image *" image ");"
.SH ARGUMENTS
.IP "info" 12
 pointer to fb_info structure
.IP "image" 12
 pointer to fb_image structure
.SH "DESCRIPTION"
If the source is a monochrome bitmap, the function fills up a a region
of framebuffer memory with pixels whose color is determined by the bit
setting of the bitmap, 1 - foreground, 0 - background.

If the source is not a monochrome bitmap, color expansion is not done.
In this case, it is channeled to a software function.
.SH "CALLED FROM"
framebuffer hook
.TH "rivafb_cursor" 9 "rivafb_cursor" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rivafb_cursor \-  hardware cursor function
.SH SYNOPSIS
.B "int" rivafb_cursor
.BI "(struct fb_info *" info ","
.BI "struct fb_cursor *" cursor ");"
.SH ARGUMENTS
.IP "info" 12
 pointer to info structure
.IP "cursor" 12
 pointer to fbcursor structure
.SH "DESCRIPTION"
A cursor function that supports displaying a cursor image via hardware.
Within the kernel, copy and invert rops are supported.  If exported
to user space, only the copy rop will be supported.

CALLED FROM
framebuffer hook
.TH "sstfb_check_var" 9 "sstfb_check_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sstfb_check_var \-  Optional function.  Validates a var passed in.
.SH SYNOPSIS
.B "int" sstfb_check_var
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "sstfb_set_par" 9 "sstfb_set_par" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sstfb_set_par \-  Optional function.  Alters the hardware state.
.SH SYNOPSIS
.B "int" sstfb_set_par
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "sstfb_setcolreg" 9 "sstfb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sstfb_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" sstfb_setcolreg
.BI "(u_int " regno ","
.BI "u_int " red ","
.BI "u_int " green ","
.BI "u_int " blue ","
.BI "u_int " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 hardware colormap register
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "cg3_setcolreg" 9 "cg3_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cg3_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" cg3_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.SH "DESCRIPTION"
The cg3 palette is loaded with 4 color values at each time
.SH "SO YOU END UP WITH"
 (rgb)(r), (gb)(rg), (b)(rgb), and so on.
We keep a sw copy of the hw cmap to assist us in this esoteric
loading procedure.
.TH "cg3_blank" 9 "cg3_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cg3_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" cg3_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "tdfxfb_probe" 9 "tdfxfb_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tdfxfb_probe \-  Device Initializiation
.SH SYNOPSIS
.B "int __devinit" tdfxfb_probe
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "pdev" 12
  PCI Device to initialize
.IP "id" 12
    PCI Device ID
.SH "DESCRIPTION"
Initializes and allocates resources for PCI device \fIpdev\fP.
.SH "DESCRIPTION"
Initializes and allocates resources for PCI device \fIpdev\fP.
.TH "tdfxfb_remove" 9 "tdfxfb_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tdfxfb_remove \-  Device removal
.SH SYNOPSIS
.B "void __devexit" tdfxfb_remove
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
  PCI Device to cleanup
.SH "DESCRIPTION"
Releases all resources allocated during the course of the driver's
lifetime for the PCI device \fIpdev\fP.
.SH "DESCRIPTION"
Releases all resources allocated during the course of the driver's
lifetime for the PCI device \fIpdev\fP.
.TH "bw2_blank" 9 "bw2_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bw2_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" bw2_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "pvr2fb_common_init" 9 "pvr2fb_common_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pvr2fb_common_init \- 
.SH SYNOPSIS
.B "int __init" pvr2fb_common_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Common init code for the PVR2 chips.

This mostly takes care of the common aspects of the fb setup and
registration. It's expected that the board-specific init code has
already setup pvr2_fix with something meaningful at this point.

Device info reporting is also done here, as well as picking a sane
default from the modedb. For board-specific modelines, simply define
a per-board modedb.

Also worth noting is that the cable and video output types are likely
always going to be VGA for the PCI-based PVR2 boards, but we leave this
in for flexibility anyways. Who knows, maybe someone has tv-out on a
PCI-based version of these things ;-)
.TH "register_framebuffer" 9 "register_framebuffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_framebuffer \-  registers a frame buffer device
.SH SYNOPSIS
.B "int" register_framebuffer
.BI "(struct fb_info *" fb_info ");"
.SH ARGUMENTS
.IP "fb_info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Registers a frame buffer device \fIfb_info\fP.

Returns negative errno on error, or zero for success.
.TH "unregister_framebuffer" 9 "unregister_framebuffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_framebuffer \-  releases a frame buffer device
.SH SYNOPSIS
.B "int" unregister_framebuffer
.BI "(struct fb_info *" fb_info ");"
.SH ARGUMENTS
.IP "fb_info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Unregisters a frame buffer device \fIfb_info\fP.

Returns negative errno on error, or zero for success.
.TH "fb_register_client" 9 "fb_register_client" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_register_client \-  register a client notifier
.SH SYNOPSIS
.B "int" fb_register_client
.BI "(struct notifier_block *" nb ");"
.SH ARGUMENTS
.IP "nb" 12
 notifier block to callback on events
.TH "fb_unregister_client" 9 "fb_unregister_client" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_unregister_client \-  unregister a client notifier
.SH SYNOPSIS
.B "int" fb_unregister_client
.BI "(struct notifier_block *" nb ");"
.SH ARGUMENTS
.IP "nb" 12
 notifier block to callback on events
.TH "fb_set_suspend" 9 "fb_set_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_set_suspend \-  low level driver signals suspend
.SH SYNOPSIS
.B "void" fb_set_suspend
.BI "(struct fb_info *" info ","
.BI "int " state ");"
.SH ARGUMENTS
.IP "info" 12
 framebuffer affected
.IP "state" 12
 0 = resuming, !=0 = suspending
.SH "DESCRIPTION"
This is meant to be used by low level drivers to
signal suspend/resume to the core &amp; clients.
It must be called with the console semaphore held
.TH "fbmem_init" 9 "fbmem_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fbmem_init \-  init frame buffer subsystem
.SH SYNOPSIS
.B "int __init" fbmem_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initialize the frame buffer subsystem.
.SH "NOTE"
 This function is _only_ to be called by drivers/char/mem.c.
.TH "fb_get_options" 9 "fb_get_options" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_get_options \-  get kernel boot parameters
.SH SYNOPSIS
.B "int" fb_get_options
.BI "(char *" name ","
.BI "char **" option ");"
.SH ARGUMENTS
.IP "name" 12
   framebuffer name as it would appear in
the boot parameter line
(video=&lt;name&gt;:&lt;options&gt;)
.IP "option" 12
 the option will be stored here
.SH "NOTE"
 Needed to maintain backwards compatibility
.TH "video_setup" 9 "video_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
video_setup \-  process command line options
.SH SYNOPSIS
.B "int __init" video_setup
.BI "(char *" options ");"
.SH ARGUMENTS
.IP "options" 12
 string of options
.SH "DESCRIPTION"
Process command line options for frame buffer subsystem.
.SH "NOTE"
 This function is a __setup and __init function.
It only stores the options.  Drivers have to call
\fBfb_get_options\fP as necessary.

Returns zero.
.TH "ffb_fillrect" 9 "ffb_fillrect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffb_fillrect \-  REQUIRED function. Can use generic routines if 
.SH SYNOPSIS
.B "void" ffb_fillrect
.BI "(struct fb_info *" info ","
.BI "const struct fb_fillrect *" rect ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "rect" 12
 structure defining the rectagle and operation.
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Draws a rectangle on the screen.               
.TH "ffb_copyarea" 9 "ffb_copyarea" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffb_copyarea \-  REQUIRED function. Can use generic routines if
.SH SYNOPSIS
.B "void" ffb_copyarea
.BI "(struct fb_info *" info ","
.BI "const struct fb_copyarea *" area ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "area" 12
 structure defining the source and destination.
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Copies on area of the screen to another area.
.TH "ffb_imageblit" 9 "ffb_imageblit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffb_imageblit \-  REQUIRED function. Can use generic routines if
.SH SYNOPSIS
.B "void" ffb_imageblit
.BI "(struct fb_info *" info ","
.BI "const struct fb_image *" image ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "image" 12
 structure defining the image.
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Copies a image from system memory to the screen. 
.TH "ffb_setcolreg" 9 "ffb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffb_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" ffb_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "ffb_blank" 9 "ffb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ffb_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" ffb_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "tgafb_check_var" 9 "tgafb_check_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tgafb_check_var \-  Optional function.  Validates a var passed in.
.SH SYNOPSIS
.B "int" tgafb_check_var
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "tgafb_set_par" 9 "tgafb_set_par" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tgafb_set_par \-  Optional function.  Alters the hardware state.
.SH SYNOPSIS
.B "int" tgafb_set_par
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "tgafb_setcolreg" 9 "tgafb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tgafb_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" tgafb_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "tgafb_blank" 9 "tgafb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tgafb_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" tgafb_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "tgafb_imageblit" 9 "tgafb_imageblit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tgafb_imageblit \-  REQUIRED function. Can use generic routines if
.SH SYNOPSIS
.B "void" tgafb_imageblit
.BI "(struct fb_info *" info ","
.BI "const struct fb_image *" image ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "image" 12
 structure defining the image.
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Copies a image from system memory to the screen. 
.TH "tgafb_fillrect" 9 "tgafb_fillrect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tgafb_fillrect \-  REQUIRED function. Can use generic routines if 
.SH SYNOPSIS
.B "void" tgafb_fillrect
.BI "(struct fb_info *" info ","
.BI "const struct fb_fillrect *" rect ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "rect" 12
 structure defining the rectagle and operation.
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Draws a rectangle on the screen.               
.TH "copyarea_line_8bpp" 9 "copyarea_line_8bpp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copyarea_line_8bpp \-  REQUIRED function. Can use generic routines if
.SH SYNOPSIS
.B "void" copyarea_line_8bpp
.BI "(struct fb_info *" info ","
.BI "u32 " dy ","
.BI "u32 " sy ","
.BI "u32 " height ","
.BI "u32 " width ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "dy" 12
-- undescribed --
.IP "sy" 12
-- undescribed --
.IP "height" 12
-- undescribed --
.IP "width" 12
-- undescribed --
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Copies on area of the screen to another area.
.TH "fb_alloc_cmap" 9 "fb_alloc_cmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_alloc_cmap \-  allocate a colormap
.SH SYNOPSIS
.B "int" fb_alloc_cmap
.BI "(struct fb_cmap *" cmap ","
.BI "int " len ","
.BI "int " transp ");"
.SH ARGUMENTS
.IP "cmap" 12
 frame buffer colormap structure
.IP "len" 12
 length of \fIcmap\fP
.IP "transp" 12
 boolean, 1 if there is transparency, 0 otherwise
.SH "DESCRIPTION"
Allocates memory for a colormap \fIcmap\fP.  \fIlen\fP is the
number of entries in the palette.

Returns -1 errno on error, or zero on success.
.TH "fb_dealloc_cmap" 9 "fb_dealloc_cmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_dealloc_cmap \-  deallocate a colormap
.SH SYNOPSIS
.B "void" fb_dealloc_cmap
.BI "(struct fb_cmap *" cmap ");"
.SH ARGUMENTS
.IP "cmap" 12
 frame buffer colormap structure
.SH "DESCRIPTION"
Deallocates a colormap that was previously allocated with
\fBfb_alloc_cmap\fP.
.TH "fb_copy_cmap" 9 "fb_copy_cmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_copy_cmap \-  copy a colormap
.SH SYNOPSIS
.B "int" fb_copy_cmap
.BI "(struct fb_cmap *" from ","
.BI "struct fb_cmap *" to ");"
.SH ARGUMENTS
.IP "from" 12
 frame buffer colormap structure
.IP "to" 12
 frame buffer colormap structure
.SH "DESCRIPTION"
Copy contents of colormap from \fIfrom\fP to \fIto\fP.
.TH "fb_set_cmap" 9 "fb_set_cmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_set_cmap \-  set the colormap
.SH SYNOPSIS
.B "int" fb_set_cmap
.BI "(struct fb_cmap *" cmap ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "cmap" 12
 frame buffer colormap structure
.IP "info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Sets the colormap \fIcmap\fP for a screen of device \fIinfo\fP.

Returns negative errno on error, or zero on success.
.TH "fb_default_cmap" 9 "fb_default_cmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_default_cmap \-  get default colormap
.SH SYNOPSIS
.B "struct fb_cmap *" fb_default_cmap
.BI "(int " len ");"
.SH ARGUMENTS
.IP "len" 12
 size of palette for a depth
.SH "DESCRIPTION"
Gets the default colormap for a specific screen depth.  \fIlen\fP
is the size of the palette for a particular screen depth.

Returns pointer to a frame buffer colormap structure.
.TH "fb_invert_cmaps" 9 "fb_invert_cmaps" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_invert_cmaps \-  invert all defaults colormaps
.SH SYNOPSIS
.B "void" fb_invert_cmaps
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Invert all default colormaps.
.TH "cg14_setcolreg" 9 "cg14_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cg14_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" cg14_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "cg6_fillrect" 9 "cg6_fillrect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cg6_fillrect \-  REQUIRED function. Can use generic routines if 
.SH SYNOPSIS
.B "void" cg6_fillrect
.BI "(struct fb_info *" info ","
.BI "const struct fb_fillrect *" rect ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "rect" 12
 structure defining the rectagle and operation.
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Draws a rectangle on the screen.               
.TH "cg6_imageblit" 9 "cg6_imageblit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cg6_imageblit \-  REQUIRED function. Can use generic routines if
.SH SYNOPSIS
.B "void" cg6_imageblit
.BI "(struct fb_info *" info ","
.BI "const struct fb_image *" image ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.IP "image" 12
 structure defining the image.
.SH "DESCRIPTION"
non acclerated hardware and packed pixel based.
Copies a image from system memory to the screen. 
.TH "cg6_setcolreg" 9 "cg6_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cg6_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" cg6_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "cg6_blank" 9 "cg6_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cg6_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" cg6_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "epson1355fb_setcolreg" 9 "epson1355fb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
epson1355fb_setcolreg \-  sets a color register.
.SH SYNOPSIS
.B "int" epson1355fb_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " r ","
.BI "unsigned " g ","
.BI "unsigned " b ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 Which register in the CLUT we are programming
.IP "r" 12
-- undescribed --
.IP "g" 12
-- undescribed --
.IP "b" 12
-- undescribed --
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Returns negative errno on error, or zero on success.
.TH "epson1355fb_pan_display" 9 "epson1355fb_pan_display" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
epson1355fb_pan_display \-  Pans the display.
.SH SYNOPSIS
.B "int" epson1355fb_pan_display
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Pan (or wrap, depending on the `vmode' field) the display using the
`xoffset' and `yoffset' fields of the `var' structure.
If the values don't fit, return -EINVAL.

Returns negative errno on error, or zero on success.
.TH "epson1355fb_blank" 9 "epson1355fb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
epson1355fb_blank \-  blanks the display.
.SH SYNOPSIS
.B "int" epson1355fb_blank
.BI "(int " blank_mode ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank_mode" 12
 the blank mode we want.
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Blank the screen if blank_mode != 0, else unblank. Return 0 if
blanking succeeded, != 0 if un-/blanking failed due to e.g. a
video mode which doesn't support it. Implements VESA suspend
and powerdown modes on hardware that supports disabling hsync/vsync:
blank_mode == 2: suspend vsync
blank_mode == 3: suspend hsync
blank_mode == 4: powerdown

Returns negative errno on error, or zero on success.
.TH "find_font" 9 "find_font" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_font \-  find a font
.SH SYNOPSIS
.B "const struct font_desc *" find_font
.BI "(const char *" name ");"
.SH ARGUMENTS
.IP "name" 12
 string name of a font
.SH "DESCRIPTION"
Find a specified font with string name \fIname\fP.

Returns NULL if no font found, or a pointer to the
specified font.
.TH "get_default_font" 9 "get_default_font" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_default_font \-  get default font
.SH SYNOPSIS
.B "const struct font_desc *" get_default_font
.BI "(int " xres ","
.BI "int " yres ");"
.SH ARGUMENTS
.IP "xres" 12
 screen size of X
.IP "yres" 12
 screen size of Y
.SH "DESCRIPTION"
Get the default font for a specified screen size.
Dimensions are in pixels.

Returns NULL if no font is found, or a pointer to the
chosen font.
.TH "set_con2fb_map" 9 "set_con2fb_map" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_con2fb_map \-  map console to frame buffer device
.SH SYNOPSIS
.B "int" set_con2fb_map
.BI "(int " unit ","
.BI "int " newidx ","
.BI "int " user ");"
.SH ARGUMENTS
.IP "unit" 12
 virtual console number to map
.IP "newidx" 12
 frame buffer index to map virtual console to
.IP "user" 12
 user request
.SH "DESCRIPTION"
Maps a virtual console \fIunit\fP to a frame buffer device
\fInewidx\fP.
.TH "p9100_setcolreg" 9 "p9100_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
p9100_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" p9100_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "p9100_blank" 9 "p9100_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
p9100_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" p9100_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "pm2fb_check_var" 9 "pm2fb_check_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_check_var \-  Optional function. Validates a var passed in. 
.SH SYNOPSIS
.B "int" pm2fb_check_var
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer 
.SH "DESCRIPTION"
Checks to see if the hardware supports the state requested by
var passed in.

Returns negative errno on error, or zero on success.
.TH "pm2fb_set_par" 9 "pm2fb_set_par" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_set_par \-  Alters the hardware state.
.SH SYNOPSIS
.B "int" pm2fb_set_par
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Using the fb_var_screeninfo in fb_info we set the resolution of the
this particular framebuffer.
.TH "pm2fb_setcolreg" 9 "pm2fb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_setcolreg \-  Sets a color register.
.SH SYNOPSIS
.B "int" pm2fb_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide 
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.	
.IP "info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Set a single color register. The values supplied have a 16 bit
magnitude which needs to be scaled in this function for the hardware.
Pretty much a direct lift from tdfxfb.c.

Returns negative errno on error, or zero on success.
.TH "pm2fb_pan_display" 9 "pm2fb_pan_display" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_pan_display \-  Pans the display.
.SH SYNOPSIS
.B "int" pm2fb_pan_display
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Pan (or wrap, depending on the `vmode' field) the display using the
`xoffset' and `yoffset' fields of the `var' structure.
If the values don't fit, return -EINVAL.

Returns negative errno on error, or zero on success.
.TH "pm2fb_blank" 9 "pm2fb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_blank \-  Blanks the display.
.SH SYNOPSIS
.B "int" pm2fb_blank
.BI "(int " blank_mode ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank_mode" 12
 the blank mode we want. 
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Blank the screen if blank_mode != 0, else unblank. Return 0 if
blanking succeeded, != 0 if un-/blanking failed due to e.g. a 
video mode which doesn't support it. Implements VESA suspend
and powerdown modes on hardware that supports disabling hsync/vsync:
blank_mode == 2: suspend vsync
blank_mode == 3: suspend hsync
blank_mode == 4: powerdown

Returns negative errno on error, or zero on success.
.TH "pm2fb_probe" 9 "pm2fb_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_probe \- 
.SH SYNOPSIS
.B "int __devinit" pm2fb_probe
.BI "(struct pci_dev *" pdev ","
.BI "const struct pci_device_id *" id ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.IP "id" 12
-- undescribed --
.SH "DESCRIPTION"

Initialise and allocate resource for PCI device.

\fIparam\fP	pdev	PCI device.
\fIparam\fP	id	PCI device ID.
.TH "pm2fb_remove" 9 "pm2fb_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_remove \- 
.SH SYNOPSIS
.B "void __devexit" pm2fb_remove
.BI "(struct pci_dev *" pdev ");"
.SH ARGUMENTS
.IP "pdev" 12
-- undescribed --
.SH "DESCRIPTION"

Release all device resources.

\fIparam\fP	pdev	PCI device to clean up.
.TH "pm2fb_setup" 9 "pm2fb_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm2fb_setup \- 
.SH SYNOPSIS
.B "int __init" pm2fb_setup
.BI "(char *" options ");"
.SH ARGUMENTS
.IP "options" 12
-- undescribed --
.SH "DESCRIPTION"

This is, comma-separated options following `video=pm2fb:'.
.TH "tcx_setcolreg" 9 "tcx_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcx_setcolreg \-  Optional function. Sets a color register.
.SH SYNOPSIS
.B "int" tcx_setcolreg
.BI "(unsigned " regno ","
.BI "unsigned " red ","
.BI "unsigned " green ","
.BI "unsigned " blue ","
.BI "unsigned " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 boolean, 0 copy local, 1 \fBget_user\fP function
.IP "red" 12
 frame buffer colormap structure
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.TH "tcx_blank" 9 "tcx_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcx_blank \-  Optional function.  Blanks the display.
.SH SYNOPSIS
.B "int" tcx_blank
.BI "(int " blank ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank" 12
-- undescribed --
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.TH "mac_vmode_to_var" 9 "mac_vmode_to_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_vmode_to_var \-  converts vmode/cmode pair to var structure
.SH SYNOPSIS
.B "int" mac_vmode_to_var
.BI "(int " vmode ","
.BI "int " cmode ","
.BI "struct fb_var_screeninfo *" var ");"
.SH ARGUMENTS
.IP "vmode" 12
 MacOS video mode
.IP "cmode" 12
 MacOS color mode
.IP "var" 12
 frame buffer video mode structure
.SH "DESCRIPTION"
Converts a MacOS vmode/cmode pair to a frame buffer video
mode structure.

Returns negative errno on error, or zero for success.
.TH "mac_var_to_vmode" 9 "mac_var_to_vmode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_var_to_vmode \-  convert var structure to MacOS vmode/cmode pair
.SH SYNOPSIS
.B "int" mac_var_to_vmode
.BI "(const struct fb_var_screeninfo *" var ","
.BI "int *" vmode ","
.BI "int *" cmode ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer video mode structure
.IP "vmode" 12
 MacOS video mode
.IP "cmode" 12
 MacOS color mode
.SH "DESCRIPTION"
Converts a frame buffer video mode structure to a MacOS
vmode/cmode pair.

Returns negative errno on error, or zero for success.
.TH "mac_map_monitor_sense" 9 "mac_map_monitor_sense" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_map_monitor_sense \-  Convert monitor sense to vmode
.SH SYNOPSIS
.B "int" mac_map_monitor_sense
.BI "(int " sense ");"
.SH ARGUMENTS
.IP "sense" 12
 Macintosh monitor sense number
.SH "DESCRIPTION"
Converts a Macintosh monitor sense number to a MacOS
vmode number.

Returns MacOS vmode video mode number.
.TH "mac_find_mode" 9 "mac_find_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mac_find_mode \-  find a video mode
.SH SYNOPSIS
.B "int __init" mac_find_mode
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ","
.BI "const char *" mode_option ","
.BI "unsigned int " default_bpp ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer user defined part of display
.IP "info" 12
 frame buffer info structure
.IP "mode_option" 12
 video mode name (see mac_modedb[])
.IP "default_bpp" 12
 default color depth in bits per pixel
.SH "DESCRIPTION"
Finds a suitable video mode.  Tries to set mode specified
by \fImode_option\fP.  If the name of the wanted mode begins with
'mac', the Mac video mode database will be used, otherwise it
will fall back to the standard video mode database.
.SH "NOTE"
 Function marked as __init and can only be used during
system boot.

Returns error code from fb_find_mode (see fb_find_mode
function).
.TH "s1d13xxxfb_set_par" 9 "s1d13xxxfb_set_par" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
s1d13xxxfb_set_par \-  Alters the hardware state.
.SH SYNOPSIS
.B "int" s1d13xxxfb_set_par
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure
.SH "DESCRIPTION"
Using the fb_var_screeninfo in fb_info we set the depth of the
framebuffer. This function alters the par AND the
fb_fix_screeninfo stored in fb_info. It doesn't not alter var in
fb_info since we are using that data. This means we depend on the
data in var inside fb_info to be supported by the hardware.
xxxfb_check_var is always called before xxxfb_set_par to ensure this.
.SH "XXX TODO"
 write proper \fBs1d13xxxfb_check_var\fP, without which that
function is quite useless.
.TH "s1d13xxxfb_setcolreg" 9 "s1d13xxxfb_setcolreg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
s1d13xxxfb_setcolreg \-  sets a color register.
.SH SYNOPSIS
.B "int" s1d13xxxfb_setcolreg
.BI "(u_int " regno ","
.BI "u_int " red ","
.BI "u_int " green ","
.BI "u_int " blue ","
.BI "u_int " transp ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "regno" 12
 Which register in the CLUT we are programming
.IP "red" 12
 The red value which can be up to 16 bits wide
.IP "green" 12
 The green value which can be up to 16 bits wide
.IP "blue" 12
  The blue value which can be up to 16 bits wide.
.IP "transp" 12
 If supported the alpha value which can be up to 16 bits wide.
.IP "info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Returns negative errno on error, or zero on success.
.TH "s1d13xxxfb_blank" 9 "s1d13xxxfb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
s1d13xxxfb_blank \-  blanks the display.
.SH SYNOPSIS
.B "int" s1d13xxxfb_blank
.BI "(int " blank_mode ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank_mode" 12
 the blank mode we want.
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Blank the screen if blank_mode != 0, else unblank. Return 0 if
blanking succeeded, != 0 if un-/blanking failed due to e.g. a
video mode which doesn't support it. Implements VESA suspend
and powerdown modes on hardware that supports disabling hsync/vsync:
blank_mode == 2: suspend vsync
blank_mode == 3: suspend hsync
blank_mode == 4: powerdown

Returns negative errno on error, or zero on success.
.TH "s1d13xxxfb_pan_display" 9 "s1d13xxxfb_pan_display" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
s1d13xxxfb_pan_display \-  Pans the display.
.SH SYNOPSIS
.B "int" s1d13xxxfb_pan_display
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer variable screen structure
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Pan (or wrap, depending on the `vmode' field) the display using the
`yoffset' field of the `var' structure (`xoffset'  not yet supported).
If the values don't fit, return -EINVAL.

Returns negative errno on error, or zero on success.
.TH "s1d13xxxfb_fetch_hw_state" 9 "s1d13xxxfb_fetch_hw_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
s1d13xxxfb_fetch_hw_state \-  Configure the framebuffer according to
.SH SYNOPSIS
.B "void __devinit" s1d13xxxfb_fetch_hw_state
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer structure
.SH "DESCRIPTION"
We setup the framebuffer structures according to the current
hardware setup. On some machines, the BIOS will have filled
the chip registers with such info, on others, these values will
have been written in some init procedure. In any case, the
software values needs to match the hardware ones. This is what
this function ensures.
.SH "DESCRIPTION"
We setup the framebuffer structures according to the current
hardware setup. On some machines, the BIOS will have filled
the chip registers with such info, on others, these values will
have been written in some init procedure. In any case, the
software values needs to match the hardware ones. This is what
this function ensures.
.SH "NOTE"
 some of the hardcoded values here might need some love to
work on various chips, and might need to no longer be hardcoded.
.TH "backlight_device_register" 9 "backlight_device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
backlight_device_register \-  create and register a new object of
.SH SYNOPSIS
.B "struct backlight_device *" backlight_device_register
.BI "(const char *" name ","
.BI "void *" devdata ","
.BI "struct backlight_properties *" bp ");"
.SH ARGUMENTS
.IP "name" 12
 the name of the new object(must be the same as the name of the
respective framebuffer device).
.IP "devdata" 12
 an optional pointer to be stored in the class_device. The
methods may retrieve it by using class_get_devdata(&amp;bd-&gt;class_dev).
.IP "bp" 12
 the backlight properties structure.
.SH "DESCRIPTION"
Creates and registers new backlight class_device. Returns either an
\fBERR_PTR\fP or a pointer to the newly allocated device.
.SH "DESCRIPTION"
Creates and registers new backlight class_device. Returns either an
\fBERR_PTR\fP or a pointer to the newly allocated device.
.TH "backlight_device_unregister" 9 "backlight_device_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
backlight_device_unregister \-  unregisters a backlight device object.
.SH SYNOPSIS
.B "void" backlight_device_unregister
.BI "(struct backlight_device *" bd ");"
.SH ARGUMENTS
.IP "bd" 12
 the backlight device object to be unregistered and freed.
.SH "DESCRIPTION"
Unregisters a previously registered via backlight_device_register object.
.TH "lcd_device_register" 9 "lcd_device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lcd_device_register \-  register a new object of lcd_device class.
.SH SYNOPSIS
.B "struct lcd_device *" lcd_device_register
.BI "(const char *" name ","
.BI "void *" devdata ","
.BI "struct lcd_properties *" lp ");"
.SH ARGUMENTS
.IP "name" 12
 the name of the new object(must be the same as the name of the
respective framebuffer device).
.IP "devdata" 12
 an optional pointer to be stored in the class_device. The
methods may retrieve it by using class_get_devdata(ld-&gt;class_dev).
.IP "lp" 12
 the lcd properties structure.
.SH "DESCRIPTION"
Creates and registers a new lcd class_device. Returns either an \fBERR_PTR\fP
or a pointer to the newly allocated device.
.TH "lcd_device_unregister" 9 "lcd_device_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
lcd_device_unregister \-  unregisters a object of lcd_device class.
.SH SYNOPSIS
.B "void" lcd_device_unregister
.BI "(struct lcd_device *" ld ");"
.SH ARGUMENTS
.IP "ld" 12
 the lcd device object to be unregistered and freed.
.SH "DESCRIPTION"
Unregisters a previously registered via lcd_device_register object.
.TH "cirrusfb_dbg_print_byte" 9 "cirrusfb_dbg_print_byte" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cirrusfb_dbg_print_byte \- 
.SH SYNOPSIS
.B "void" cirrusfb_dbg_print_byte
.BI "(const char *" name ","
.BI "unsigned char " val ");"
.SH ARGUMENTS
.IP "name" 12
 name associated with byte value to be displayed
.IP "val" 12
 byte value to be displayed
.SH "DESCRIPTION"
Display an indented string, along with a hexidecimal byte value, and
its decoded bits.  Bits 7 through 0 are listed in left-to-right
order.
.TH "cirrusfb_dbg_print_regs" 9 "cirrusfb_dbg_print_regs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cirrusfb_dbg_print_regs \- 
.SH SYNOPSIS
.B "void" cirrusfb_dbg_print_regs
.BI "(caddr_t " regbase ","
.BI "cirrusfb_dbg_reg_class_t " reg_class ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "regbase" 12
-- undescribed --
.IP "reg_class" 12
 type of registers to read: CRT, or SEQ
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Dumps the given list of VGA CRTC registers.  If \fIbase\fP is NULL,
old-style I/O ports are queried for information, otherwise MMIO is
used at the given \fIbase\fP address to query the information.
.TH "cirrusfb_dump" 9 "cirrusfb_dump" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cirrusfb_dump \- 
.SH SYNOPSIS
.B "void" cirrusfb_dump
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "cirrusfb_dbg_reg_dump" 9 "cirrusfb_dbg_reg_dump" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cirrusfb_dbg_reg_dump \- 
.SH SYNOPSIS
.B "void" cirrusfb_dbg_reg_dump
.BI "(caddr_t " regbase ");"
.SH ARGUMENTS
.IP "regbase" 12
-- undescribed --
.SH "DESCRIPTION"
Dumps a list of interesting VGA and CIRRUSFB registers.  If \fIbase\fP is NULL,
old-style I/O ports are queried for information, otherwise MMIO is
used at the given \fIbase\fP address to query the information.
.TH "framebuffer_alloc" 9 "framebuffer_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
framebuffer_alloc \-  creates a new frame buffer info structure
.SH SYNOPSIS
.B "struct fb_info *" framebuffer_alloc
.BI "(size_t " size ","
.BI "struct device *" dev ");"
.SH ARGUMENTS
.IP "size" 12
 size of driver private data, can be zero
.IP "dev" 12
 pointer to the device for this fb, this can be NULL
.SH "DESCRIPTION"
Creates a new frame buffer info structure. Also reserves \fIsize\fP bytes
for driver private data (info-&gt;par). info-&gt;par (if any) will be
aligned to sizeof(long).

Returns the new structure, or NULL if an error occured.
.SH "DESCRIPTION"
Creates a new frame buffer info structure. Also reserves \fIsize\fP bytes
for driver private data (info-&gt;par). info-&gt;par (if any) will be
aligned to sizeof(long).

Returns the new structure, or NULL if an error occured.
.TH "framebuffer_release" 9 "framebuffer_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
framebuffer_release \-  marks the structure available for freeing
.SH SYNOPSIS
.B "void" framebuffer_release
.BI "(struct fb_info *" info ");"
.SH ARGUMENTS
.IP "info" 12
 frame buffer info structure
.SH "DESCRIPTION"
Drop the reference count of the class_device embedded in the
framebuffer info structure.
.SH "DESCRIPTION"
Drop the reference count of the class_device embedded in the
framebuffer info structure.
.TH "fb_try_mode" 9 "fb_try_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_try_mode \-  test a video mode
.SH SYNOPSIS
.B "int" fb_try_mode
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ","
.BI "const struct fb_videomode *" mode ","
.BI "unsigned int " bpp ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer user defined part of display
.IP "info" 12
 frame buffer info structure
.IP "mode" 12
 frame buffer video mode structure
.IP "bpp" 12
 color depth in bits per pixel
.SH "DESCRIPTION"
Tries a video mode to test it's validity for device \fIinfo\fP.

Returns 1 on success.
.TH "fb_find_mode" 9 "fb_find_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_find_mode \-  finds a valid video mode
.SH SYNOPSIS
.B "int" fb_find_mode
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_info *" info ","
.BI "const char *" mode_option ","
.BI "const struct fb_videomode *" db ","
.BI "unsigned int " dbsize ","
.BI "const struct fb_videomode *" default_mode ","
.BI "unsigned int " default_bpp ");"
.SH ARGUMENTS
.IP "var" 12
 frame buffer user defined part of display
.IP "info" 12
 frame buffer info structure
.IP "mode_option" 12
 string video mode to find
.IP "db" 12
 video mode database
.IP "dbsize" 12
 size of \fIdb\fP
.IP "default_mode" 12
 default video mode to fall back to
.IP "default_bpp" 12
 default color depth in bits per pixel
.SH "DESCRIPTION"
Finds a suitable video mode, starting with the specified mode
in \fImode_option\fP with fallback to \fIdefault_mode\fP.  If
\fIdefault_mode\fP fails, all modes in the video mode database will
be tried.

Valid mode specifiers for \fImode_option\fP:

&lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m] or
&lt;name&gt;[-&lt;bpp&gt;][@&lt;refresh&gt;]

with &lt;xres&gt;, &lt;yres&gt;, &lt;bpp&gt; and &lt;refresh&gt; decimal numbers and
&lt;name&gt; a string.

If 'M' is present after yres (and before refresh/bpp if present),
the function will compute the timings using VESA(tm) Coordinated
Video Timings (CVT).  If 'R' is present after 'M', will compute with
reduced blanking (for flatpanels).  If 'i' is present, compute
interlaced mode.  If 'm' is present, add margins equal to 1.8%
of xres rounded down to 8 pixels, and 1.8% of yres. The char
'i' and 'm' must be after 'M' and 'R'. Example:

1024x768MR-8\fI60m\fP - Reduced blank with margins at 60Hz.
.SH "NOTE"
 The passed struct \fIvar\fP is _not_ cleared!  This allows you
to supply values for e.g. the grayscale and accel_flags fields.

Returns zero for failure, 1 if using specified \fImode_option\fP,
2 if using specified \fImode_option\fP with an ignored refresh rate,
3 if default mode is used, 4 if fall back to any valid mode.
.TH "fb_var_to_videomode" 9 "fb_var_to_videomode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_var_to_videomode \-  convert fb_var_screeninfo to fb_videomode
.SH SYNOPSIS
.B "void" fb_var_to_videomode
.BI "(struct fb_videomode *" mode ","
.BI "struct fb_var_screeninfo *" var ");"
.SH ARGUMENTS
.IP "mode" 12
 pointer to struct fb_videomode
.IP "var" 12
 pointer to struct fb_var_screeninfo
.TH "fb_videomode_to_var" 9 "fb_videomode_to_var" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_videomode_to_var \-  convert fb_videomode to fb_var_screeninfo
.SH SYNOPSIS
.B "void" fb_videomode_to_var
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct fb_videomode *" mode ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to struct fb_var_screeninfo
.IP "mode" 12
 pointer to struct fb_videomode
.TH "fb_mode_is_equal" 9 "fb_mode_is_equal" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_mode_is_equal \-  compare 2 videomodes
.SH SYNOPSIS
.B "int" fb_mode_is_equal
.BI "(struct fb_videomode *" mode1 ","
.BI "struct fb_videomode *" mode2 ");"
.SH ARGUMENTS
.IP "mode1" 12
 first videomode
.IP "mode2" 12
 second videomode
.SH "RETURNS"
1 if equal, 0 if not
.TH "fb_find_best_mode" 9 "fb_find_best_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_find_best_mode \-  find best matching videomode
.SH SYNOPSIS
.B "struct fb_videomode *" fb_find_best_mode
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to struct fb_var_screeninfo
.IP "head" 12
 pointer to struct list_head of modelist
.SH "RETURNS"
struct fb_videomode, NULL if none found
.SH "IMPORTANT"
This function assumes that all modelist entries in
info-&gt;modelist are valid.
.SH "NOTES"
Finds best matching videomode which has an equal or greater dimension than
var-&gt;xres and var-&gt;yres.  If more than 1 videomode is found, will return
the videomode with the highest refresh rate
.TH "fb_find_nearest_mode" 9 "fb_find_nearest_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_find_nearest_mode \-  find mode closest video mode
.SH SYNOPSIS
.B "struct fb_videomode *" fb_find_nearest_mode
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to struct fb_var_screeninfo
.IP "head" 12
 pointer to modelist
.SH "DESCRIPTION"
Finds best matching videomode, smaller or greater in dimension.
If more than 1 videomode is found, will return the videomode with
the closest refresh rate
.SH "DESCRIPTION"
Finds best matching videomode, smaller or greater in dimension.
If more than 1 videomode is found, will return the videomode with
the closest refresh rate
.TH "fb_match_mode" 9 "fb_match_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_match_mode \-  find a videomode which exactly matches the timings in var
.SH SYNOPSIS
.B "struct fb_videomode *" fb_match_mode
.BI "(struct fb_var_screeninfo *" var ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "var" 12
 pointer to struct fb_var_screeninfo
.IP "head" 12
 pointer to struct list_head of modelist
.SH "RETURNS"
struct fb_videomode, NULL if none found
.TH "fb_add_videomode" 9 "fb_add_videomode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_add_videomode \- 
.SH SYNOPSIS
.B "int" fb_add_videomode
.BI "(struct fb_videomode *" mode ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "mode" 12
 videomode to add
.IP "head" 12
 struct list_head of modelist
.SH "NOTES"
Will only add unmatched mode entries
.TH "fb_delete_videomode" 9 "fb_delete_videomode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_delete_videomode \- 
.SH SYNOPSIS
.B "void" fb_delete_videomode
.BI "(struct fb_videomode *" mode ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "mode" 12
 videomode to remove
.IP "head" 12
 struct list_head of modelist
.SH "NOTES"
Will remove all matching mode entries
.TH "fb_destroy_modelist" 9 "fb_destroy_modelist" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_destroy_modelist \- 
.SH SYNOPSIS
.B "void" fb_destroy_modelist
.BI "(struct list_head *" head ");"
.SH ARGUMENTS
.IP "head" 12
 struct list_head of modelist
.TH "fb_videomode_to_modelist" 9 "fb_videomode_to_modelist" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_videomode_to_modelist \- 
.SH SYNOPSIS
.B "void" fb_videomode_to_modelist
.BI "(struct fb_videomode *" modedb ","
.BI "int " num ","
.BI "struct list_head *" head ");"
.SH ARGUMENTS
.IP "modedb" 12
 array of struct fb_videomode
.IP "num" 12
 number of entries in array
.IP "head" 12
 struct list_head of modelist
.TH "s3c2410fb_blank" 9 "s3c2410fb_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
s3c2410fb_blank \- 
.SH SYNOPSIS
.B "int" s3c2410fb_blank
.BI "(int " blank_mode ","
.BI "struct fb_info *" info ");"
.SH ARGUMENTS
.IP "blank_mode" 12
 the blank mode we want.
.IP "info" 12
 frame buffer structure that represents a single frame buffer
.SH "DESCRIPTION"
Blank the screen if blank_mode != 0, else unblank. Return 0 if
blanking succeeded, != 0 if un-/blanking failed due to e.g. a
video mode which doesn't support it. Implements VESA suspend
and powerdown modes on hardware that supports disabling hsync/vsync:
blank_mode == 2: suspend vsync
blank_mode == 3: suspend hsync
blank_mode == 4: powerdown

Returns negative errno on error, or zero on success.
.TH "fb_create_modedb" 9 "fb_create_modedb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_create_modedb \-  create video mode database
.SH SYNOPSIS
.B "struct fb_videomode *" fb_create_modedb
.BI "(unsigned char *" edid ","
.BI "int *" dbsize ");"
.SH ARGUMENTS
.IP "edid" 12
 EDID data
.IP "dbsize" 12
 database size
.SH "RETURNS"
 struct fb_videomode, \fIdbsize\fP contains length of database
.SH "DESCRIPTION"
This function builds a mode database using the contents of the EDID
data
.TH "fb_destroy_modedb" 9 "fb_destroy_modedb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_destroy_modedb \-  destroys mode database
.SH SYNOPSIS
.B "void" fb_destroy_modedb
.BI "(struct fb_videomode *" modedb ");"
.SH ARGUMENTS
.IP "modedb" 12
 mode database to destroy
.SH "DESCRIPTION"
Destroy mode database created by fb_create_modedb
.TH "fb_get_vblank" 9 "fb_get_vblank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_get_vblank \-  get vertical blank time
.SH SYNOPSIS
.B "u32" fb_get_vblank
.BI "(u32 " hfreq ");"
.SH ARGUMENTS
.IP "hfreq" 12
 horizontal freq
.SH "DESCRIPTION"
vblank = right_margin + vsync_len + left_margin 
.SH "GIVEN"
 right_margin = 1 (V_FRONTPORCH)
vsync_len    = 3
flyback      = 550

flyback * hfreq
left_margin  = --------------- - vsync_len
1000000
.TH "fb_get_hblank_by_hfreq" 9 "fb_get_hblank_by_hfreq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_get_hblank_by_hfreq \-  get horizontal blank time given hfreq
.SH SYNOPSIS
.B "u32" fb_get_hblank_by_hfreq
.BI "(u32 " hfreq ","
.BI "u32 " xres ");"
.SH ARGUMENTS
.IP "hfreq" 12
 horizontal freq
.IP "xres" 12
 horizontal resolution in pixels
.SH "DESCRIPTION"

xres * duty_cycle
hblank = ------------------
100 - duty_cycle

duty cycle = percent of htotal assigned to inactive display
duty cycle = C - (M/Hfreq)
.SH "WHERE"
 C = ((offset - scale factor) * blank_scale)
-------------------------------------- + scale factor
256 
M = blank_scale * gradient
.TH "fb_get_hblank_by_dclk" 9 "fb_get_hblank_by_dclk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_get_hblank_by_dclk \-  get horizontal blank time given pixelclock
.SH SYNOPSIS
.B "u32" fb_get_hblank_by_dclk
.BI "(u32 " dclk ","
.BI "u32 " xres ");"
.SH ARGUMENTS
.IP "dclk" 12
 pixelclock in Hz
.IP "xres" 12
 horizontal resolution in pixels
.SH "DESCRIPTION"

xres * duty_cycle
hblank = ------------------
100 - duty_cycle

duty cycle = percent of htotal assigned to inactive display
duty cycle = C - (M * h_period)
.SH "WHERE"
 h_period = SQRT(100 - C + (0.4 * xres * M)/dclk) + C - 100
-----------------------------------------------
2 * M
M = 300;
C = 30;
.TH "fb_get_hfreq" 9 "fb_get_hfreq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fb_get_hfreq \-  estimate hsync
.SH SYNOPSIS
.B "u32" fb_get_hfreq
.BI "(u32 " vfreq ","
.BI "u32 " yres ");"
.SH ARGUMENTS
.IP "vfreq" 12
 vertical refresh rate
.IP "yres" 12
 vertical resolution
.SH "DESCRIPTION"

(yres + front_port) * vfreq * 1000000
hfreq = -------------------------------------
(1000000 - (vfreq * FLYBACK)
.TH "dev_add_pack" 9 "dev_add_pack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_add_pack \-  add packet handler
.SH SYNOPSIS
.B "void" dev_add_pack
.BI "(struct packet_type *" pt ");"
.SH ARGUMENTS
.IP "pt" 12
 packet type declaration
.SH "DESCRIPTION"
Add a protocol handler to the networking stack. The passed &amp;packet_type
is linked into kernel lists and may not be freed until it has been
removed from the kernel lists.

This call does not sleep therefore it can not 
guarantee all CPU's that are in middle of receiving packets
will see the new packet type (until the next received packet).
.TH "__dev_remove_pack" 9 "__dev_remove_pack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__dev_remove_pack \-  remove packet handler
.SH SYNOPSIS
.B "void" __dev_remove_pack
.BI "(struct packet_type *" pt ");"
.SH ARGUMENTS
.IP "pt" 12
 packet type declaration
.SH "DESCRIPTION"
Remove a protocol handler that was previously added to the kernel
protocol handlers by \fBdev_add_pack\fP. The passed &amp;packet_type is removed
from the kernel lists and can be freed or reused once this function
returns. 

The packet type might still be in use by receivers
and must not be freed until after all the CPU's have gone
through a quiescent state.
.TH "dev_remove_pack" 9 "dev_remove_pack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_remove_pack \-  remove packet handler
.SH SYNOPSIS
.B "void" dev_remove_pack
.BI "(struct packet_type *" pt ");"
.SH ARGUMENTS
.IP "pt" 12
 packet type declaration
.SH "DESCRIPTION"
Remove a protocol handler that was previously added to the kernel
protocol handlers by \fBdev_add_pack\fP. The passed &amp;packet_type is removed
from the kernel lists and can be freed or reused once this function
returns.

This call sleeps to guarantee that no CPU is looking at the packet
type after return.
.TH "netdev_boot_setup_add" 9 "netdev_boot_setup_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
netdev_boot_setup_add \-  add new setup entry
.SH SYNOPSIS
.B "int" netdev_boot_setup_add
.BI "(char *" name ","
.BI "struct ifmap *" map ");"
.SH ARGUMENTS
.IP "name" 12
 name of the device
.IP "map" 12
 configured settings for the device
.SH "DESCRIPTION"
Adds new setup entry to the dev_boot_setup list.  The function
returns 0 on error and 1 on success.  This is a generic routine to
all netdevices.
.TH "netdev_boot_setup_check" 9 "netdev_boot_setup_check" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
netdev_boot_setup_check \-  check boot time settings
.SH SYNOPSIS
.B "int" netdev_boot_setup_check
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the netdevice
.SH "DESCRIPTION"
Check boot time settings for the device.
The found settings are set for the device to be used
later in the device probing.
Returns 0 if no settings found, 1 if they are.
.TH "netdev_boot_base" 9 "netdev_boot_base" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
netdev_boot_base \-  get address from boot time settings
.SH SYNOPSIS
.B "unsigned long" netdev_boot_base
.BI "(const char *" prefix ","
.BI "int " unit ");"
.SH ARGUMENTS
.IP "prefix" 12
 prefix for network device
.IP "unit" 12
 id for network device
.SH "DESCRIPTION"
Check boot time settings for the base address of device.
The found settings are set for the device to be used
later in the device probing.
Returns 0 if no settings found.
.TH "__dev_get_by_name" 9 "__dev_get_by_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__dev_get_by_name \-  find a device by its name
.SH SYNOPSIS
.B "struct net_device *" __dev_get_by_name
.BI "(const char *" name ");"
.SH ARGUMENTS
.IP "name" 12
 name to find
.SH "DESCRIPTION"
Find an interface by name. Must be called under RTNL semaphore
or \fIdev_base_lock\fP. If the name is found a pointer to the device
is returned. If the name is not found then NULL is returned. The
reference counters are not incremented so the caller must be
careful with locks.
.TH "dev_get_by_name" 9 "dev_get_by_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_get_by_name \-  find a device by its name
.SH SYNOPSIS
.B "struct net_device *" dev_get_by_name
.BI "(const char *" name ");"
.SH ARGUMENTS
.IP "name" 12
 name to find
.SH "DESCRIPTION"
Find an interface by name. This can be called from any
context and does its own locking. The returned handle has
the usage count incremented and the caller must use \fBdev_put\fP to
release it when it is no longer needed. NULL is returned if no
matching device is found.
.TH "__dev_get_by_index" 9 "__dev_get_by_index" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__dev_get_by_index \-  find a device by its ifindex
.SH SYNOPSIS
.B "struct net_device *" __dev_get_by_index
.BI "(int " ifindex ");"
.SH ARGUMENTS
.IP "ifindex" 12
 index of device
.SH "DESCRIPTION"
Search for an interface by index. Returns NULL if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold either the RTNL semaphore
or \fIdev_base_lock\fP.
.TH "dev_get_by_index" 9 "dev_get_by_index" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_get_by_index \-  find a device by its ifindex
.SH SYNOPSIS
.B "struct net_device *" dev_get_by_index
.BI "(int " ifindex ");"
.SH ARGUMENTS
.IP "ifindex" 12
 index of device
.SH "DESCRIPTION"
Search for an interface by index. Returns NULL if the device
is not found or a pointer to the device. The device returned has
had a reference added and the pointer is safe until the user calls
dev_put to indicate they have finished with it.
.TH "dev_getbyhwaddr" 9 "dev_getbyhwaddr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_getbyhwaddr \-  find a device by its hardware address
.SH SYNOPSIS
.B "struct net_device *" dev_getbyhwaddr
.BI "(unsigned short " type ","
.BI "char *" ha ");"
.SH ARGUMENTS
.IP "type" 12
 media type of device
.IP "ha" 12
 hardware address
.SH "DESCRIPTION"
Search for an interface by MAC address. Returns NULL if the device
is not found or a pointer to the device. The caller must hold the
rtnl semaphore. The returned device has not had its ref count increased
and the caller must therefore be careful about locking
.SH "BUGS"
If the API was consistent this would be __dev_get_by_hwaddr
.TH "dev_get_by_flags" 9 "dev_get_by_flags" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_get_by_flags \-  find any device with given flags
.SH SYNOPSIS
.B "struct net_device *" dev_get_by_flags
.BI "(unsigned short " if_flags ","
.BI "unsigned short " mask ");"
.SH ARGUMENTS
.IP "if_flags" 12
 IFF_* values
.IP "mask" 12
 bitmask of bits in if_flags to check
.SH "DESCRIPTION"
Search for any interface with the given flags. Returns NULL if a device
is not found or a pointer to the device. The device returned has 
had a reference added and the pointer is safe until the user calls
dev_put to indicate they have finished with it.
.TH "dev_valid_name" 9 "dev_valid_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_valid_name \-  check if name is okay for network device
.SH SYNOPSIS
.B "int" dev_valid_name
.BI "(const char *" name ");"
.SH ARGUMENTS
.IP "name" 12
 name string
.SH "DESCRIPTION"
Network device names need to be valid file names to
to allow sysfs to work
.TH "dev_alloc_name" 9 "dev_alloc_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_alloc_name \-  allocate a name for a device
.SH SYNOPSIS
.B "int" dev_alloc_name
.BI "(struct net_device *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.IP "name" 12
 name format string
.SH "DESCRIPTION"
Passed a format string - eg "ltd" it will try and find a suitable
id. Not efficient for many devices, not called a lot. The caller
must hold the dev_base or rtnl lock while allocating the name and
adding the device in order to avoid duplicates. Returns the number
of the unit assigned or a negative errno code.
.TH "dev_change_name" 9 "dev_change_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_change_name \-  change name of a device
.SH SYNOPSIS
.B "int" dev_change_name
.BI "(struct net_device *" dev ","
.BI "char *" newname ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.IP "newname" 12
 name (or format string) must be at least IFNAMSIZ
.SH "DESCRIPTION"
Change name of a device, can pass format strings "ethd".
for wildcarding.
.TH "netdev_features_change" 9 "netdev_features_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
netdev_features_change \-  device changes fatures
.SH SYNOPSIS
.B "void" netdev_features_change
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to cause notification
.SH "DESCRIPTION"
Called to indicate a device has changed features.
.TH "netdev_state_change" 9 "netdev_state_change" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
netdev_state_change \-  device changes state
.SH SYNOPSIS
.B "void" netdev_state_change
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to cause notification
.SH "DESCRIPTION"
Called to indicate a device has changed state. This function calls
the notifier chains for netdev_chain and sends a NEWLINK message
to the routing socket.
.TH "dev_load" 9 "dev_load" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_load \-  load a network module
.SH SYNOPSIS
.B "void" dev_load
.BI "(const char *" name ");"
.SH ARGUMENTS
.IP "name" 12
 name of interface
.SH "DESCRIPTION"
If a network interface is not present and the process has suitable
privileges this function loads the module. If module loading is not
available in this kernel then it becomes a nop.
.TH "dev_open" 9 "dev_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_open \-  prepare an interface for use.
.SH SYNOPSIS
.B "int" dev_open
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
	device to open
.SH "DESCRIPTION"
Takes a device from down to up state. The device's private open
function is invoked and then the multicast lists are loaded. Finally
the device is moved into the up state and a NETDEV_UP message is
sent to the netdev notifier chain.

Calling this function on an active interface is a nop. On a failure
a negative errno code is returned.
.TH "dev_close" 9 "dev_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_close \-  shutdown an interface.
.SH SYNOPSIS
.B "int" dev_close
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to shutdown
.SH "DESCRIPTION"
This function moves an active device into down state. A
NETDEV_GOING_DOWN is sent to the netdev notifier chain. The device
is then deactivated and finally a NETDEV_DOWN is sent to the notifier
chain.
.TH "register_netdevice_notifier" 9 "register_netdevice_notifier" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_netdevice_notifier \-  register a network notifier block
.SH SYNOPSIS
.B "int" register_netdevice_notifier
.BI "(struct notifier_block *" nb ");"
.SH ARGUMENTS
.IP "nb" 12
 notifier
.SH "DESCRIPTION"
Register a notifier to be called when network device events occur.
The notifier passed is linked into the kernel structures and must
not be reused until it has been unregistered. A negative errno code
is returned on a failure.

When registered all registration and up events are replayed
to the new notifier to allow device to have a race free 
view of the network device list.
.TH "unregister_netdevice_notifier" 9 "unregister_netdevice_notifier" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_netdevice_notifier \-  unregister a network notifier block
.SH SYNOPSIS
.B "int" unregister_netdevice_notifier
.BI "(struct notifier_block *" nb ");"
.SH ARGUMENTS
.IP "nb" 12
 notifier
.SH "DESCRIPTION"
Unregister a notifier previously registered by
\fBregister_netdevice_notifier\fP. The notifier is unlinked into the
kernel structures and may then be reused. A negative errno code
is returned on a failure.
.TH "call_netdevice_notifiers" 9 "call_netdevice_notifiers" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
call_netdevice_notifiers \-  call all network notifier blocks
.SH SYNOPSIS
.B "int" call_netdevice_notifiers
.BI "(unsigned long " val ","
.BI "void *" v ");"
.SH ARGUMENTS
.IP "val" 12
 value passed unmodified to notifier function
.IP "v" 12
   pointer passed unmodified to notifier function
.SH "DESCRIPTION"
Call all network notifier blocks.  Parameters and return value
are as for \fBnotifier_call_chain\fP.
.TH "dev_queue_xmit" 9 "dev_queue_xmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_queue_xmit \-  transmit a buffer
.SH SYNOPSIS
.B "int" dev_queue_xmit
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to transmit
.SH "DESCRIPTION"
Queue a buffer for transmission to a network device. The caller must
have set the device and priority and built the buffer before calling
this function. The function can be called from an interrupt.

A negative errno code is returned on a failure. A success does not
guarantee the frame will be transmitted as it may be dropped due
to congestion or traffic shaping.

-----------------------------------------------------------------------------------
I notice this method can also return errors from the queue disciplines,
including NET_XMIT_DROP, which is a positive value.  So, errors can also
be positive.

Regardless of the return value, the skb is consumed, so it is currently
difficult to retry a send to this method.  (You can bump the ref count
before sending to hold a reference for retry if you are careful.)

When calling this method, interrupts MUST be enabled.  This is because
the BH enable code must have IRQs enabled so that it will not deadlock.
--BLG
.TH "netif_rx" 9 "netif_rx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
netif_rx \- 	post buffer to the network code
.SH SYNOPSIS
.B "int" netif_rx
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to post
.SH "DESCRIPTION"
This function receives a packet from a device driver and queues it for
the upper (protocol) levels to process.  It always succeeds. The buffer
may be dropped during processing for congestion control or by the
protocol layers.
.SH "RETURN VALUES"
NET_RX_SUCCESS	(no congestion)
NET_RX_CN_LOW   (low congestion)
NET_RX_CN_MOD   (moderate congestion)
NET_RX_CN_HIGH  (high congestion)
NET_RX_DROP     (packet was dropped)
.TH "register_gifconf" 9 "register_gifconf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_gifconf \- 	register a SIOCGIF handler
.SH SYNOPSIS
.B "int" register_gifconf
.BI "(unsigned int " family ","
.BI "gifconf_func_t *" gifconf ");"
.SH ARGUMENTS
.IP "family" 12
 Address family
.IP "gifconf" 12
 Function handler
.SH "DESCRIPTION"
Register protocol dependent address dumping routines. The handler
that is passed must not be freed or reused until it has been replaced
by another handler.
.TH "netdev_set_master" 9 "netdev_set_master" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
netdev_set_master \- 	set up master/slave pair
.SH SYNOPSIS
.B "int" netdev_set_master
.BI "(struct net_device *" slave ","
.BI "struct net_device *" master ");"
.SH ARGUMENTS
.IP "slave" 12
 slave device
.IP "master" 12
 new master device
.SH "DESCRIPTION"
Changes the master device of the slave. Pass NULL to break the
bonding. The caller must hold the RTNL semaphore. On a failure
a negative errno code is returned. On success the reference counts
are adjusted, RTM_NEWLINK is sent to the routing socket and the
function returns zero.
.TH "dev_set_promiscuity" 9 "dev_set_promiscuity" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_set_promiscuity \-  update promiscuity count on a device
.SH SYNOPSIS
.B "void" dev_set_promiscuity
.BI "(struct net_device *" dev ","
.BI "int " inc ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.IP "inc" 12
 modifier
.SH "DESCRIPTION"
Add or remove promsicuity from a device. While the count in the device
remains above zero the interface remains promiscuous. Once it hits zero
the device reverts back to normal filtering operation. A negative inc
value is used to drop promiscuity on the device.
.TH "dev_set_allmulti" 9 "dev_set_allmulti" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_set_allmulti \-  update allmulti count on a device
.SH SYNOPSIS
.B "void" dev_set_allmulti
.BI "(struct net_device *" dev ","
.BI "int " inc ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.IP "inc" 12
 modifier
.SH "DESCRIPTION"
Add or remove reception of all multicast frames to a device. While the
count in the device remains above zero the interface remains listening
to all interfaces. Once it hits zero the device reverts back to normal
filtering operation. A negative \fIinc\fP value is used to drop the counter
when releasing a resource needing all multicasts.
.TH "dev_ioctl" 9 "dev_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_ioctl \- 	network device ioctl
.SH SYNOPSIS
.B "int" dev_ioctl
.BI "(unsigned int " cmd ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "cmd" 12
 command to issue
.IP "arg" 12
 pointer to a struct ifreq in user space
.SH "DESCRIPTION"
Issue ioctl functions to devices. This is normally called by the
user space syscall interfaces but can sometimes be useful for
other purposes. The return value is the return from the syscall if
positive or a negative errno code on error.
.TH "dev_new_index" 9 "dev_new_index" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dev_new_index \- 	allocate an ifindex
.SH SYNOPSIS
.B "int" dev_new_index
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns a suitable unique value for a new device interface
number.  The caller must hold the rtnl semaphore or the
dev_base_lock to be sure it remains unique.
.TH "register_netdevice" 9 "register_netdevice" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_netdevice \-  register a network device
.SH SYNOPSIS
.B "int" register_netdevice
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to register
.SH "DESCRIPTION"
Take a completed network device structure and add it to the kernel
interfaces. A NETDEV_REGISTER message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.

Callers must hold the rtnl semaphore. You may want
\fBregister_netdev\fP instead of this.
.SH "BUGS"
The locking appears insufficient to guarantee two parallel registers
will not get the same name.
.TH "register_netdev" 9 "register_netdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_netdev \-  register a network device
.SH SYNOPSIS
.B "int" register_netdev
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to register
.SH "DESCRIPTION"
Take a completed network device structure and add it to the kernel
interfaces. A NETDEV_REGISTER message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.

This is a wrapper around register_netdev that takes the rtnl semaphore
and expands the device name if you passed a format string to
alloc_netdev.
.TH "alloc_netdev" 9 "alloc_netdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_netdev \-  allocate network device
.SH SYNOPSIS
.B "struct net_device *" alloc_netdev
.BI "(int " sizeof_priv ","
.BI "const char *" name ","
.BI "void (*" setup ") (struct net_device *));"
.SH ARGUMENTS
.IP "sizeof_priv" 12
	size of private data to allocate space for
.IP "name" 12
		device name format string
.IP "setup" 12
		callback to initialize device
.SH "DESCRIPTION"
Allocates a struct net_device with private data area for driver use
and performs basic initialization.
.TH "free_netdev" 9 "free_netdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_netdev \-  free network device
.SH SYNOPSIS
.B "void" free_netdev
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.SH "DESCRIPTION"
This function does the last stage of destroying an allocated device 
interface. The reference to the device object is released.  
If this is the last reference then it will be freed.
.TH "unregister_netdevice" 9 "unregister_netdevice" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_netdevice \-  remove device from the kernel
.SH SYNOPSIS
.B "int" unregister_netdevice
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.SH "DESCRIPTION"
This function shuts down a device interface and removes it
from the kernel tables. On success 0 is returned, on a failure
a negative errno code is returned.

Callers must hold the rtnl semaphore.  You may want
\fBunregister_netdev\fP instead of this.
.TH "unregister_netdev" 9 "unregister_netdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_netdev \-  remove device from the kernel
.SH SYNOPSIS
.B "void" unregister_netdev
.BI "(struct net_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.SH "DESCRIPTION"
This function shuts down a device interface and removes it
from the kernel tables. On success 0 is returned, on a failure
a negative errno code is returned.

This is just a wrapper for unregister_netdevice that takes
the rtnl semaphore.  In general you want to use this and not
unregister_netdevice.
.TH "skb_over_panic" 9 "skb_over_panic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_over_panic \-  	private function
.SH SYNOPSIS
.B "void" skb_over_panic
.BI "(struct sk_buff *" skb ","
.BI "int " sz ","
.BI "void *" here ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer
.IP "sz" 12
 size
.IP "here" 12
 address
.SH "DESCRIPTION"
Out of line support code for \fBskb_put\fP. Not user callable.
.TH "skb_under_panic" 9 "skb_under_panic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_under_panic \-  	private function
.SH SYNOPSIS
.B "void" skb_under_panic
.BI "(struct sk_buff *" skb ","
.BI "int " sz ","
.BI "void *" here ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer
.IP "sz" 12
 size
.IP "here" 12
 address
.SH "DESCRIPTION"
Out of line support code for \fBskb_push\fP. Not user callable.
.TH "__alloc_skb" 9 "__alloc_skb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__alloc_skb \- 	allocate a network buffer
.SH SYNOPSIS
.B "struct sk_buff *" __alloc_skb
.BI "(unsigned int " size ","
.BI "gfp_t " gfp_mask ","
.BI "int " fclone ");"
.SH ARGUMENTS
.IP "size" 12
 size to allocate
.IP "gfp_mask" 12
 allocation mask
.IP "fclone" 12
-- undescribed --
.SH "DESCRIPTION"
Allocate a new &amp;sk_buff. The returned buffer has no headroom and a
tail room of size bytes. The object has a reference count of one.
The return is the buffer. On a failure the return is NULL.

Buffers may only be allocated from interrupts using a \fIgfp_mask\fP of
GFP_ATOMIC.
.TH "alloc_skb_from_cache" 9 "alloc_skb_from_cache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_skb_from_cache \- 	allocate a network buffer
.SH SYNOPSIS
.B "struct sk_buff *" alloc_skb_from_cache
.BI "(kmem_cache_t *" cp ","
.BI "unsigned int " size ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "cp" 12
 kmem_cache from which to allocate the data area
(object size must be big enough for \fIsize\fP bytes + skb overheads)
.IP "size" 12
 size to allocate
.IP "gfp_mask" 12
 allocation mask
.SH "DESCRIPTION"
Allocate a new &amp;sk_buff. The returned buffer has no headroom and
tail room of size bytes. The object has a reference count of one.
The return is the buffer. On a failure the return is NULL.

Buffers may only be allocated from interrupts using a \fIgfp_mask\fP of
GFP_ATOMIC.
.TH "__kfree_skb" 9 "__kfree_skb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__kfree_skb \-  private function
.SH SYNOPSIS
.B "void" __kfree_skb
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer
.SH "DESCRIPTION"
Free an sk_buff. Release anything attached to the buffer.
Clean the state. This is an internal helper function. Users should
always call kfree_skb
.TH "skb_clone" 9 "skb_clone" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_clone \- 	duplicate an sk_buff
.SH SYNOPSIS
.B "struct sk_buff *" skb_clone
.BI "(struct sk_buff *" skb ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to clone
.IP "gfp_mask" 12
 allocation priority
.SH "DESCRIPTION"
Duplicate an &amp;sk_buff. The new one is not owned by a socket. Both
copies share the same packet data but not structure. The new
buffer has a reference count of 1. If the allocation fails the
function returns NULL otherwise the new buffer is returned.

If this function is called from an interrupt \fBgfp_mask\fP must be
GFP_ATOMIC.
.TH "skb_copy" 9 "skb_copy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_copy \- 	create private copy of an sk_buff
.SH SYNOPSIS
.B "struct sk_buff *" skb_copy
.BI "(const struct sk_buff *" skb ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to copy
.IP "gfp_mask" 12
 allocation priority
.SH "DESCRIPTION"
Make a copy of both an &amp;sk_buff and its data. This is used when the
caller wishes to modify the data and needs a private copy of the
data to alter. Returns NULL on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.

As by-product this function converts non-linear &amp;sk_buff to linear
one, so that &amp;sk_buff becomes completely private and caller is allowed
to modify all the data of returned buffer. This means that this
function is not recommended for use in circumstances when only
header is going to be modified. Use \fBpskb_copy\fP instead.
.TH "pskb_copy" 9 "pskb_copy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pskb_copy \- 	create copy of an sk_buff with private head.
.SH SYNOPSIS
.B "struct sk_buff *" pskb_copy
.BI "(struct sk_buff *" skb ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to copy
.IP "gfp_mask" 12
 allocation priority
.SH "DESCRIPTION"
Make a copy of both an &amp;sk_buff and part of its data, located
in header. Fragmented data remain shared. This is used when
the caller wishes to modify only header of &amp;sk_buff and needs
private copy of the header to alter. Returns NULL on failure
or the pointer to the buffer on success.
The returned buffer has a reference count of 1.
.TH "pskb_expand_head" 9 "pskb_expand_head" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pskb_expand_head \-  reallocate header of \\\amp;sk_buff
.SH SYNOPSIS
.B "int" pskb_expand_head
.BI "(struct sk_buff *" skb ","
.BI "int " nhead ","
.BI "int " ntail ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to reallocate
.IP "nhead" 12
 room to add at head
.IP "ntail" 12
 room to add at tail
.IP "gfp_mask" 12
 allocation priority
.SH "DESCRIPTION"
Expands (or creates identical copy, if &amp;nhead and &amp;ntail are zero)
header of skb. &amp;sk_buff itself is not changed. &amp;sk_buff MUST have
reference count of 1. Returns zero in the case of success or error,
if expansion failed. In the last case, &amp;sk_buff is not changed.

All the pointers pointing into skb header may change and must be
reloaded after call to this function.
.TH "skb_copy_expand" 9 "skb_copy_expand" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_copy_expand \- 	copy and expand sk_buff
.SH SYNOPSIS
.B "struct sk_buff *" skb_copy_expand
.BI "(const struct sk_buff *" skb ","
.BI "int " newheadroom ","
.BI "int " newtailroom ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to copy
.IP "newheadroom" 12
 new free bytes at head
.IP "newtailroom" 12
 new free bytes at tail
.IP "gfp_mask" 12
 allocation priority
.SH "DESCRIPTION"
Make a copy of both an &amp;sk_buff and its data and while doing so
allocate additional space.

This is used when the caller wishes to modify the data and needs a
private copy of the data to alter as well as more space for new fields.
Returns NULL on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.

You must pass GFP_ATOMIC as the allocation priority if this function
is called from an interrupt.
.SH "BUG ALERT"
 ip_summed is not copied. Why does this work? Is it used
only by netfilter in the cases when checksum is recalculated? --ANK
.TH "skb_pad" 9 "skb_pad" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_pad \- 	zero pad the tail of an skb
.SH SYNOPSIS
.B "struct sk_buff *" skb_pad
.BI "(struct sk_buff *" skb ","
.BI "int " pad ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to pad
.IP "pad" 12
 space to pad
.SH "DESCRIPTION"
Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.

May return NULL in out of memory cases.
.TH "__pskb_pull_tail" 9 "__pskb_pull_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__pskb_pull_tail \-  advance tail of skb header
.SH SYNOPSIS
.B "unsigned char *" __pskb_pull_tail
.BI "(struct sk_buff *" skb ","
.BI "int " delta ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to reallocate
.IP "delta" 12
 number of bytes to advance tail
.SH "DESCRIPTION"
The function makes a sense only on a fragmented &amp;sk_buff,
it expands header moving its tail forward and copying necessary
data from fragmented part.

&amp;sk_buff MUST have reference count of 1.

Returns NULL (and &amp;sk_buff does not change) if pull failed
or value of new tail of skb in the case of success.

All the pointers pointing into skb header may change and must be
reloaded after call to this function.
.TH "skb_store_bits" 9 "skb_store_bits" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_store_bits \-  store bits from kernel buffer to skb
.SH SYNOPSIS
.B "int" skb_store_bits
.BI "(const struct sk_buff *" skb ","
.BI "int " offset ","
.BI "void *" from ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 destination buffer
.IP "offset" 12
 offset in destination
.IP "from" 12
 source buffer
.IP "len" 12
 number of bytes to copy
.SH "DESCRIPTION"
Copy the specified number of bytes from the source buffer to the
destination skb.  This function handles all the messy bits of
traversing fragment lists and such.
.TH "skb_dequeue" 9 "skb_dequeue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_dequeue \-  remove from the head of the queue
.SH SYNOPSIS
.B "struct sk_buff *" skb_dequeue
.BI "(struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list to dequeue from
.SH "DESCRIPTION"
Remove the head of the list. The list lock is taken so the function
may be used safely with other locking list functions. The head item is
returned or NULL if the list is empty.
.TH "skb_dequeue_tail" 9 "skb_dequeue_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_dequeue_tail \-  remove from the tail of the queue
.SH SYNOPSIS
.B "struct sk_buff *" skb_dequeue_tail
.BI "(struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list to dequeue from
.SH "DESCRIPTION"
Remove the tail of the list. The list lock is taken so the function
may be used safely with other locking list functions. The tail item is
returned or NULL if the list is empty.
.TH "skb_queue_purge" 9 "skb_queue_purge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_purge \-  empty a list
.SH SYNOPSIS
.B "void" skb_queue_purge
.BI "(struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "list" 12
 list to empty
.SH "DESCRIPTION"
Delete all buffers on an &amp;sk_buff list. Each buffer is removed from
the list and one reference dropped. This function takes the list
lock and is atomic with respect to other list locking functions.
.TH "skb_queue_head" 9 "skb_queue_head" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_head \-  queue a buffer at the list head
.SH SYNOPSIS
.B "void" skb_queue_head
.BI "(struct sk_buff_head *" list ","
.BI "struct sk_buff *" newsk ");"
.SH ARGUMENTS
.IP "list" 12
 list to use
.IP "newsk" 12
 buffer to queue
.SH "DESCRIPTION"
Queue a buffer at the start of the list. This function takes the
list lock and can be used safely with other locking &amp;sk_buff functions
safely.

A buffer cannot be placed on two lists at the same time.
.TH "skb_queue_tail" 9 "skb_queue_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_queue_tail \-  queue a buffer at the list tail
.SH SYNOPSIS
.B "void" skb_queue_tail
.BI "(struct sk_buff_head *" list ","
.BI "struct sk_buff *" newsk ");"
.SH ARGUMENTS
.IP "list" 12
 list to use
.IP "newsk" 12
 buffer to queue
.SH "DESCRIPTION"
Queue a buffer at the tail of the list. This function takes the
list lock and can be used safely with other locking &amp;sk_buff functions
safely.

A buffer cannot be placed on two lists at the same time.
.TH "skb_unlink" 9 "skb_unlink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_unlink \- 	remove a buffer from a list
.SH SYNOPSIS
.B "void" skb_unlink
.BI "(struct sk_buff *" skb ","
.BI "struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to remove
.IP "list" 12
 list to use
.SH "DESCRIPTION"
Remove a packet from a list. The list locks are taken and this
function is atomic with respect to other list locked calls

You must know what list the SKB is on.
.TH "skb_append" 9 "skb_append" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_append \- 	append a buffer
.SH SYNOPSIS
.B "void" skb_append
.BI "(struct sk_buff *" old ","
.BI "struct sk_buff *" newsk ","
.BI "struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "old" 12
 buffer to insert after
.IP "newsk" 12
 buffer to insert
.IP "list" 12
 list to use
.SH "DESCRIPTION"
Place a packet after a given packet in a list. The list locks are taken
and this function is atomic with respect to other list locked calls.
A buffer cannot be placed on two lists at the same time.
.TH "skb_insert" 9 "skb_insert" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_insert \- 	insert a buffer
.SH SYNOPSIS
.B "void" skb_insert
.BI "(struct sk_buff *" old ","
.BI "struct sk_buff *" newsk ","
.BI "struct sk_buff_head *" list ");"
.SH ARGUMENTS
.IP "old" 12
 buffer to insert before
.IP "newsk" 12
 buffer to insert
.IP "list" 12
 list to use
.SH "DESCRIPTION"
Place a packet before a given packet in a list. The list locks are
taken and this function is atomic with respect to other list locked
calls.

A buffer cannot be placed on two lists at the same time.
.TH "skb_split" 9 "skb_split" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_split \-  Split fragmented skb to two parts at length len.
.SH SYNOPSIS
.B "void" skb_split
.BI "(struct sk_buff *" skb ","
.BI "struct sk_buff *" skb1 ","
.BI "const u32 " len ");"
.SH ARGUMENTS
.IP "skb" 12
 the buffer to split
.IP "skb1" 12
 the buffer to receive the second part
.IP "len" 12
 new length for skb
.TH "skb_prepare_seq_read" 9 "skb_prepare_seq_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_prepare_seq_read \-  Prepare a sequential read of skb data
.SH SYNOPSIS
.B "void" skb_prepare_seq_read
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " from ","
.BI "unsigned int " to ","
.BI "struct skb_seq_state *" st ");"
.SH ARGUMENTS
.IP "skb" 12
 the buffer to read
.IP "from" 12
 lower offset of data to be read
.IP "to" 12
 upper offset of data to be read
.IP "st" 12
 state variable
.SH "DESCRIPTION"
Initializes the specified state variable. Must be called before
invoking \fBskb_seq_read\fP for the first time.
.TH "skb_seq_read" 9 "skb_seq_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_seq_read \-  Sequentially read skb data
.SH SYNOPSIS
.B "unsigned int" skb_seq_read
.BI "(unsigned int " consumed ","
.BI "const u8 **" data ","
.BI "struct skb_seq_state *" st ");"
.SH ARGUMENTS
.IP "consumed" 12
 number of bytes consumed by the caller so far
.IP "data" 12
 destination pointer for data to be returned
.IP "st" 12
 state variable
.SH "DESCRIPTION"
Reads a block of skb data at &amp;consumed relative to the
lower offset specified to \fBskb_prepare_seq_read\fP. Assigns
the head of the data block to &amp;data and returns the length
of the block or 0 if the end of the skb data or the upper
offset has been reached.

The caller is not required to consume all of the data
returned, i.e. &amp;consumed is typically set to the number
of bytes already consumed and the next call to
\fBskb_seq_read\fP will return the remaining part of the block.
.SH "NOTE"
 Fragment lists within fragments are not implemented
at the moment, state-&gt;root_skb could be replaced with
a stack for this purpose.
.SH "NOTE"
 Fragment lists within fragments are not implemented
at the moment, state-&gt;root_skb could be replaced with
a stack for this purpose.
.TH "skb_abort_seq_read" 9 "skb_abort_seq_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_abort_seq_read \-  Abort a sequential read of skb data
.SH SYNOPSIS
.B "void" skb_abort_seq_read
.BI "(struct skb_seq_state *" st ");"
.SH ARGUMENTS
.IP "st" 12
 state variable
.SH "DESCRIPTION"
Must be called if \fBskb_seq_read\fP was not called until it
returned 0.
.TH "skb_find_text" 9 "skb_find_text" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_find_text \-  Find a text pattern in skb data
.SH SYNOPSIS
.B "unsigned int" skb_find_text
.BI "(struct sk_buff *" skb ","
.BI "unsigned int " from ","
.BI "unsigned int " to ","
.BI "struct ts_config *" config ","
.BI "struct ts_state *" state ");"
.SH ARGUMENTS
.IP "skb" 12
 the buffer to look in
.IP "from" 12
 search offset
.IP "to" 12
 search limit
.IP "config" 12
 textsearch configuration
.IP "state" 12
 uninitialized textsearch state variable
.SH "DESCRIPTION"
Finds a pattern in the skb data according to the specified
textsearch configuration. Use \fBtextsearch_next\fP to retrieve
subsequent occurrences of the pattern. Returns the offset
to the first occurrence or UINT_MAX if no match was found.
.TH "sk_stream_write_space" 9 "sk_stream_write_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_stream_write_space \-  stream socket write_space callback.
.SH SYNOPSIS
.B "void" sk_stream_write_space
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
 socket
.SH "FIXME"
 write proper description
.TH "sk_stream_wait_connect" 9 "sk_stream_wait_connect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_stream_wait_connect \-  Wait for a socket to get into the connected state
.SH SYNOPSIS
.B "int" sk_stream_wait_connect
.BI "(struct sock *" sk ","
.BI "long *" timeo_p ");"
.SH ARGUMENTS
.IP "sk" 12
 sock to wait on
.IP "timeo_p" 12
 for how long to wait
.SH "DESCRIPTION"
Must be called with the socket locked.
.TH "sk_stream_closing" 9 "sk_stream_closing" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_stream_closing \-  Return 1 if we still have things to send in our buffers.
.SH SYNOPSIS
.B "int" sk_stream_closing
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
 socket to verify
.TH "sk_stream_wait_memory" 9 "sk_stream_wait_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_stream_wait_memory \-  Wait for more memory for a socket
.SH SYNOPSIS
.B "int" sk_stream_wait_memory
.BI "(struct sock *" sk ","
.BI "long *" timeo_p ");"
.SH ARGUMENTS
.IP "sk" 12
 socket to wait for memory
.IP "timeo_p" 12
 for how long
.TH "skb_recv_datagram" 9 "skb_recv_datagram" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_recv_datagram \-  Receive a datagram skbuff
.SH SYNOPSIS
.B "struct sk_buff *" skb_recv_datagram
.BI "(struct sock *" sk ","
.BI "unsigned " flags ","
.BI "int " noblock ","
.BI "int *" err ");"
.SH ARGUMENTS
.IP "sk" 12
 socket
.IP "flags" 12
 MSG_ flags
.IP "noblock" 12
 blocking operation?
.IP "err" 12
 error code returned
.SH "DESCRIPTION"
Get a datagram skbuff, understands the peeking, nonblocking wakeups
and possible races. This replaces identical code in packet, raw and
udp, as well as the IPX AX.25 and Appletalk. It also finally fixes
the long standing peek and read race for datagram sockets. If you
alter this routine remember it must be re-entrant.

This function will lock the socket if a skb is returned, so the caller
needs to unlock the socket in that case (usually by calling
skb_free_datagram)

* It does not lock socket since today. This function is
* free of race conditions. This measure should/can improve
* significantly datagram socket latencies at high loads,
* when data copying to user space takes lots of time.
* (BTW I've just killed the last \fBcli\fP in IP/IPv6/core/netlink/packet
*  8) Great win.)
*			                    --ANK (980729)

The order of the tests when we find no data waiting are specified
quite explicitly by POSIX 1003.1g, don't change them without having
the standard around please.
.TH "skb_copy_datagram_iovec" 9 "skb_copy_datagram_iovec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_copy_datagram_iovec \-  Copy a datagram to an iovec.
.SH SYNOPSIS
.B "int" skb_copy_datagram_iovec
.BI "(const struct sk_buff *" skb ","
.BI "int " offset ","
.BI "struct iovec *" to ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to copy
.IP "offset" 12
 offset in the buffer to start copying from
.IP "to" 12
 io vector to copy to
.IP "len" 12
 amount of data to copy from buffer to iovec
.SH "NOTE"
 the iovec is modified during the copy.
.TH "skb_copy_and_csum_datagram_iovec" 9 "skb_copy_and_csum_datagram_iovec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
skb_copy_and_csum_datagram_iovec \-  Copy and checkum skb to user iovec.
.SH SYNOPSIS
.B "int" skb_copy_and_csum_datagram_iovec
.BI "(const struct sk_buff *" skb ","
.BI "int " hlen ","
.BI "struct iovec *" iov ");"
.SH ARGUMENTS
.IP "skb" 12
 skbuff
.IP "hlen" 12
 hardware length
.IP "iov" 12
 io vector
.SH "DESCRIPTION"
Caller _must_ check that skb will fit to this iovec.
.SH "RETURNS"
 0       - success.
-EINVAL - checksum failure.
-EFAULT - fault during copy. Beware, in this case iovec
can be modified!
.TH "datagram_poll" 9 "datagram_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
datagram_poll \-  generic datagram poll
.SH SYNOPSIS
.B "unsigned int" datagram_poll
.BI "(struct file *" file ","
.BI "struct socket *" sock ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "file" 12
 file struct
.IP "sock" 12
 socket
.IP "wait" 12
 poll table
.SH "DATAGRAM POLL"
 Again totally generic. This also handles
sequenced packet sockets providing the socket receive queue
is only ever holding data ready to receive.
.SH "NOTE"
 when you _don't_ use this routine for this protocol,
and you use a different write policy from \fBsock_writeable\fP
then please supply your own write_space callback.
.TH "gen_new_estimator" 9 "gen_new_estimator" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gen_new_estimator \-  create a new rate estimator
.SH SYNOPSIS
.B "int" gen_new_estimator
.BI "(struct gnet_stats_basic *" bstats ","
.BI "struct gnet_stats_rate_est *" rate_est ","
.BI "spinlock_t *" stats_lock ","
.BI "struct rtattr *" opt ");"
.SH ARGUMENTS
.IP "bstats" 12
 basic statistics
.IP "rate_est" 12
 rate estimator statistics
.IP "stats_lock" 12
 statistics lock
.IP "opt" 12
 rate estimator configuration TLV
.SH "DESCRIPTION"
Creates a new rate estimator with &amp;bstats as source and &amp;rate_est
as destination. A new timer with the interval specified in the
configuration TLV is created. Upon each interval, the latest statistics
will be read from &amp;bstats and the estimated rate will be stored in
&amp;rate_est with the statistics lock grabed during this period.

Returns 0 on success or a negative error code.
.TH "gen_kill_estimator" 9 "gen_kill_estimator" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gen_kill_estimator \-  remove a rate estimator
.SH SYNOPSIS
.B "void" gen_kill_estimator
.BI "(struct gnet_stats_basic *" bstats ","
.BI "struct gnet_stats_rate_est *" rate_est ");"
.SH ARGUMENTS
.IP "bstats" 12
 basic statistics
.IP "rate_est" 12
 rate estimator statistics
.SH "DESCRIPTION"
Removes the rate estimator specified by &amp;bstats and &amp;rate_est
and deletes the timer.
.TH "gen_replace_estimator" 9 "gen_replace_estimator" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gen_replace_estimator \-  replace rate estimator configruation
.SH SYNOPSIS
.B "int" gen_replace_estimator
.BI "(struct gnet_stats_basic *" bstats ","
.BI "struct gnet_stats_rate_est *" rate_est ","
.BI "spinlock_t *" stats_lock ","
.BI "struct rtattr *" opt ");"
.SH ARGUMENTS
.IP "bstats" 12
 basic statistics
.IP "rate_est" 12
 rate estimator statistics
.IP "stats_lock" 12
 statistics lock
.IP "opt" 12
 rate estimator configuration TLV
.SH "DESCRIPTION"
Replaces the configuration of a rate estimator by calling
\fBgen_kill_estimator\fP and \fBgen_new_estimator\fP.

Returns 0 on success or a negative error code.
.TH "sk_alloc" 9 "sk_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_alloc \-  All socket objects are allocated here
.SH SYNOPSIS
.B "struct sock *" sk_alloc
.BI "(int " family ","
.BI "gfp_t " priority ","
.BI "struct proto *" prot ","
.BI "int " zero_it ");"
.SH ARGUMENTS
.IP "family" 12
 protocol family
.IP "priority" 12
 for allocation (GFP_KERNEL, GFP_ATOMIC, etc)
.IP "prot" 12
 struct proto associated with this new sock instance
.IP "zero_it" 12
 if we should zero the newly allocated sock
.TH "sk_wait_data" 9 "sk_wait_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_wait_data \-  wait for data to arrive at sk_receive_queue
.SH SYNOPSIS
.B "int" sk_wait_data
.BI "(struct sock *" sk ","
.BI "long *" timeo ");"
.SH ARGUMENTS
.IP "sk" 12
    sock to wait on
.IP "timeo" 12
 for how long
.SH "DESCRIPTION"
Now socket state including sk-&gt;sk_err is changed only under lock,
hence we may omit checks after joining wait queue.
We check receive queue before \fBschedule\fP only as optimization;
it is very likely that \fBrelease_sock\fP added new data.
.TH "sk_run_filter" 9 "sk_run_filter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_run_filter \-  	run a filter on a socket
.SH SYNOPSIS
.B "int" sk_run_filter
.BI "(struct sk_buff *" skb ","
.BI "struct sock_filter *" filter ","
.BI "int " flen ");"
.SH ARGUMENTS
.IP "skb" 12
 buffer to run the filter on
.IP "filter" 12
 filter to apply
.IP "flen" 12
 length of filter
.SH "DESCRIPTION"
Decode and apply filter instructions to the skb-&gt;data.
Return length to keep, 0 for none. skb is the data we are
filtering, filter is the array of filter instructions, and
len is the number of filter blocks in the array.
.TH "sk_chk_filter" 9 "sk_chk_filter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_chk_filter \-  verify socket filter code
.SH SYNOPSIS
.B "int" sk_chk_filter
.BI "(struct sock_filter *" filter ","
.BI "int " flen ");"
.SH ARGUMENTS
.IP "filter" 12
 filter to verify
.IP "flen" 12
 length of filter
.SH "DESCRIPTION"
Check the user's filter code. If we let some ugly
filter code slip through kaboom! The filter must contain
no references or jumps that are out of range, no illegal instructions
and no backward jumps. It must end with a RET instruction

Returns 0 if the rule set is legal or a negative errno code if not.
.TH "sk_attach_filter" 9 "sk_attach_filter" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sk_attach_filter \-  attach a socket filter
.SH SYNOPSIS
.B "int" sk_attach_filter
.BI "(struct sock_fprog *" fprog ","
.BI "struct sock *" sk ");"
.SH ARGUMENTS
.IP "fprog" 12
 the filter program
.IP "sk" 12
 the socket to use
.SH "DESCRIPTION"
Attach the user's filter code. We first run some sanity checks on
it to make sure it does not explode on us later. If an error
occurs or there is insufficient memory for the filter a negative
errno code is returned. On success the return is zero.
.TH "gnet_stats_start_copy_compat" 9 "gnet_stats_start_copy_compat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gnet_stats_start_copy_compat \-  start dumping procedure in compatibility mode
.SH SYNOPSIS
.B "int" gnet_stats_start_copy_compat
.BI "(struct sk_buff *" skb ","
.BI "int " type ","
.BI "int " tc_stats_type ","
.BI "int " xstats_type ","
.BI "spinlock_t *" lock ","
.BI "struct gnet_dump *" d ");"
.SH ARGUMENTS
.IP "skb" 12
 socket buffer to put statistics TLVs into
.IP "type" 12
 TLV type for top level statistic TLV
.IP "tc_stats_type" 12
 TLV type for backward compatibility struct tc_stats TLV
.IP "xstats_type" 12
 TLV type for backward compatibility xstats TLV
.IP "lock" 12
 statistics lock
.IP "d" 12
 dumping handle
.SH "DESCRIPTION"
Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.

The dumping handle is marked to be in backward compatibility mode telling
all \fBgnet_stats_copy_XXX\fP functions to fill a local copy of struct tc_stats.

Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
.TH "gnet_stats_start_copy" 9 "gnet_stats_start_copy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gnet_stats_start_copy \-  start dumping procedure in compatibility mode
.SH SYNOPSIS
.B "int" gnet_stats_start_copy
.BI "(struct sk_buff *" skb ","
.BI "int " type ","
.BI "spinlock_t *" lock ","
.BI "struct gnet_dump *" d ");"
.SH ARGUMENTS
.IP "skb" 12
 socket buffer to put statistics TLVs into
.IP "type" 12
 TLV type for top level statistic TLV
.IP "lock" 12
 statistics lock
.IP "d" 12
 dumping handle
.SH "DESCRIPTION"
Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.

Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
.TH "gnet_stats_copy_basic" 9 "gnet_stats_copy_basic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gnet_stats_copy_basic \-  copy basic statistics into statistic TLV
.SH SYNOPSIS
.B "int" gnet_stats_copy_basic
.BI "(struct gnet_dump *" d ","
.BI "struct gnet_stats_basic *" b ");"
.SH ARGUMENTS
.IP "d" 12
 dumping handle
.IP "b" 12
 basic statistics
.SH "DESCRIPTION"
Appends the basic statistics to the top level TLV created by
\fBgnet_stats_start_copy\fP.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
.TH "gnet_stats_copy_rate_est" 9 "gnet_stats_copy_rate_est" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gnet_stats_copy_rate_est \-  copy rate estimator statistics into statistics TLV
.SH SYNOPSIS
.B "int" gnet_stats_copy_rate_est
.BI "(struct gnet_dump *" d ","
.BI "struct gnet_stats_rate_est *" r ");"
.SH ARGUMENTS
.IP "d" 12
 dumping handle
.IP "r" 12
 rate estimator statistics
.SH "DESCRIPTION"
Appends the rate estimator statistics to the top level TLV created by
\fBgnet_stats_start_copy\fP.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
.TH "gnet_stats_copy_queue" 9 "gnet_stats_copy_queue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gnet_stats_copy_queue \-  copy queue statistics into statistics TLV
.SH SYNOPSIS
.B "int" gnet_stats_copy_queue
.BI "(struct gnet_dump *" d ","
.BI "struct gnet_stats_queue *" q ");"
.SH ARGUMENTS
.IP "d" 12
 dumping handle
.IP "q" 12
 queue statistics
.SH "DESCRIPTION"
Appends the queue statistics to the top level TLV created by
\fBgnet_stats_start_copy\fP.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
.TH "gnet_stats_copy_app" 9 "gnet_stats_copy_app" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gnet_stats_copy_app \-  copy application specific statistics into statistics TLV
.SH SYNOPSIS
.B "int" gnet_stats_copy_app
.BI "(struct gnet_dump *" d ","
.BI "void *" st ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "d" 12
 dumping handle
.IP "st" 12
 application specific statistics data
.IP "len" 12
 length of data
.SH "DESCRIPTION"
Appends the application sepecific statistics to the top level TLV created by
\fBgnet_stats_start_copy\fP and remembers the data for XSTATS if the dumping
handle is in backward compatibility mode.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
.TH "gnet_stats_finish_copy" 9 "gnet_stats_finish_copy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
gnet_stats_finish_copy \-  finish dumping procedure
.SH SYNOPSIS
.B "int" gnet_stats_finish_copy
.BI "(struct gnet_dump *" d ");"
.SH ARGUMENTS
.IP "d" 12
 dumping handle
.SH "DESCRIPTION"
Corrects the length of the top level TLV to include all TLVs added
by \fBgnet_stats_copy_XXX\fP calls. Adds the backward compatibility TLVs
if \fBgnet_stats_start_copy_compat\fP was used and releases the statistics
lock.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
.TH "dccp_wait_for_ccid" 9 "dccp_wait_for_ccid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dccp_wait_for_ccid \-  Wait for ccid to tell us we can send a packet
.SH SYNOPSIS
.B "int" dccp_wait_for_ccid
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ","
.BI "long *" timeo ");"
.SH ARGUMENTS
.IP "sk" 12
 socket to wait for
.IP "skb" 12
-- undescribed --
.IP "timeo" 12
 for how long
.TH "alloc_ltalkdev" 9 "alloc_ltalkdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_ltalkdev \-  Allocates and sets up an localtalk device
.SH SYNOPSIS
.B "struct net_device *" alloc_ltalkdev
.BI "(int " sizeof_priv ");"
.SH ARGUMENTS
.IP "sizeof_priv" 12
 Size of additional driver-private structure to be allocated
for this localtalk device
.SH "DESCRIPTION"
Fill in the fields of the device structure with localtalk-generic
values. Basically does everything except registering the device.

Constructs a new net device, complete with a private data area of
size \fIsizeof_priv\fP.  A 32-byte (not bit) alignment is enforced for
this private data area.
.TH "Kernel API" 9 "struct aarp_entry" "January 2021" "API Manual" LINUX
.SH NAME
struct aarp_entry \-  AARP entry
.SH SYNOPSIS
struct aarp_entry {
.br
};
.br
.SH Arguments
.SH "Description"
\fIlast_sent\fP - Last time we xmitted the aarp request
\fIpacket_queue\fP - Queue of frames wait for resolution
\fIstatus\fP - Used for proxy AARP
expires_at - Entry expiry time
target_addr - DDP Address
dev - Device to use
hwaddr - Physical i/f address of target/router
xmit_count - When this hits 10 we give up
next - Next entry in chain
.TH "atalk_find_or_insert_socket" 9 "atalk_find_or_insert_socket" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atalk_find_or_insert_socket \-  Try to find a socket matching ADDR
.SH SYNOPSIS
.B "struct sock *" atalk_find_or_insert_socket
.BI "(struct sock *" sk ","
.BI "struct sockaddr_at *" sat ");"
.SH ARGUMENTS
.IP "sk" 12
-- undescribed --
.IP "sat" 12
-- undescribed --
.SH "DESCRIPTION"
\fIsk\fP - socket to insert in the list if it is not there already
\fIsat\fP - address to search for

Try to find a socket matching ADDR in the socket list, if found then return
it. If not, insert SK into the socket list.

This entire operation must execute atomically.
.TH "atalk_pick_and_bind_port" 9 "atalk_pick_and_bind_port" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atalk_pick_and_bind_port \-  Pick a source port when one is not given
.SH SYNOPSIS
.B "int" atalk_pick_and_bind_port
.BI "(struct sock *" sk ","
.BI "struct sockaddr_at *" sat ");"
.SH ARGUMENTS
.IP "sk" 12
-- undescribed --
.IP "sat" 12
-- undescribed --
.SH "DESCRIPTION"
\fIsk\fP - socket to insert into the tables
\fIsat\fP - address to search for

Pick a source port when one is not given. If we can find a suitable free
one, we insert the socket into the tables using it.

This whole operation must be atomic.
.TH "atalk_rcv" 9 "atalk_rcv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
atalk_rcv \-  Receive a packet (in skb) from device dev
.SH SYNOPSIS
.B "int" atalk_rcv
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ","
.BI "struct packet_type *" pt ","
.BI "struct net_device *" orig_dev ");"
.SH ARGUMENTS
.IP "skb" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.IP "pt" 12
-- undescribed --
.IP "orig_dev" 12
-- undescribed --
.SH "DESCRIPTION"
\fIskb\fP - packet received
\fIdev\fP - network device where the packet comes from
\fIpt\fP - packet type

Receive a packet (in skb) from device dev. This has come from the SNAP
decoder, and on entry skb-&gt;h.raw is the DDP header, skb-&gt;len is the DDP
header, skb-&gt;len is the DDP length. The physical headers have been
extracted. PPP should probably pass frames marked as for this layer.
[ie ARPHRD_ETHERTALK]
.TH "llc_alloc_frame" 9 "llc_alloc_frame" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_alloc_frame \-  allocates sk_buff for frame
.SH SYNOPSIS
.B "struct sk_buff *" llc_alloc_frame
.BI "(struct sock *" sk ","
.BI "struct net_device *" dev ");"
.SH ARGUMENTS
.IP "sk" 12
-- undescribed --
.IP "dev" 12
 network device this skb will be sent over
.SH "DESCRIPTION"
Allocates an sk_buff for frame and initializes sk_buff fields.
Returns allocated skb or NULL when out of memory.
.TH "llc_sap_rtn_pdu" 9 "llc_sap_rtn_pdu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_rtn_pdu \-  Informs upper layer on rx of an UI, XID or TEST pdu.
.SH SYNOPSIS
.B "void" llc_sap_rtn_pdu
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 pointer to SAP
.IP "skb" 12
 received pdu
.TH "llc_find_sap_trans" 9 "llc_find_sap_trans" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_find_sap_trans \-  finds transition for event
.SH SYNOPSIS
.B "struct llc_sap_state_trans *" llc_find_sap_trans
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 pointer to SAP
.IP "skb" 12
 happened event
.SH "DESCRIPTION"
This function finds transition that matches with happened event.
Returns the pointer to found transition on success or NULL for
failure.
.TH "llc_exec_sap_trans_actions" 9 "llc_exec_sap_trans_actions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_exec_sap_trans_actions \-  execute actions related to event
.SH SYNOPSIS
.B "int" llc_exec_sap_trans_actions
.BI "(struct llc_sap *" sap ","
.BI "struct llc_sap_state_trans *" trans ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 pointer to SAP
.IP "trans" 12
 pointer to transition that it's actions must be performed
.IP "skb" 12
 happened event.
.SH "DESCRIPTION"
This function executes actions that is related to happened event.
Returns 0 for success and 1 for failure of at least one action.
.TH "llc_sap_next_state" 9 "llc_sap_next_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_next_state \-  finds transition, execs actions \\\amp; change SAP state
.SH SYNOPSIS
.B "int" llc_sap_next_state
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 pointer to SAP
.IP "skb" 12
 happened event
.SH "DESCRIPTION"
This function finds transition that matches with happened event, then
executes related actions and finally changes state of SAP. It returns
0 on success and 1 for failure.
.TH "llc_sap_state_process" 9 "llc_sap_state_process" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_state_process \-  sends event to SAP state machine
.SH SYNOPSIS
.B "void" llc_sap_state_process
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 sap to use
.IP "skb" 12
 pointer to occurred event
.SH "DESCRIPTION"
After executing actions of the event, upper layer will be indicated
if needed(on receiving an UI frame). sk can be null for the
datalink_proto case.
.TH "llc_build_and_send_test_pkt" 9 "llc_build_and_send_test_pkt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_build_and_send_test_pkt \-  TEST interface for upper layers.
.SH SYNOPSIS
.B "void" llc_build_and_send_test_pkt
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ","
.BI "u8 *" dmac ","
.BI "u8 " dsap ");"
.SH ARGUMENTS
.IP "sap" 12
 sap to use
.IP "skb" 12
 packet to send
.IP "dmac" 12
 destination mac address
.IP "dsap" 12
 destination sap
.SH "DESCRIPTION"
This function is called when upper layer wants to send a TEST pdu.
Returns 0 for success, 1 otherwise.
.TH "llc_build_and_send_xid_pkt" 9 "llc_build_and_send_xid_pkt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_build_and_send_xid_pkt \-  XID interface for upper layers
.SH SYNOPSIS
.B "void" llc_build_and_send_xid_pkt
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ","
.BI "u8 *" dmac ","
.BI "u8 " dsap ");"
.SH ARGUMENTS
.IP "sap" 12
 sap to use
.IP "skb" 12
 packet to send
.IP "dmac" 12
 destination mac address
.IP "dsap" 12
 destination sap
.SH "DESCRIPTION"
This function is called when upper layer wants to send a XID pdu.
Returns 0 for success, 1 otherwise.
.TH "llc_sap_rcv" 9 "llc_sap_rcv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_rcv \-  sends received pdus to the sap state machine
.SH SYNOPSIS
.B "void" llc_sap_rcv
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 current sap component structure.
.IP "skb" 12
 received frame.
.SH "DESCRIPTION"
Sends received pdus to the sap state machine.
.TH "llc_lookup_dgram" 9 "llc_lookup_dgram" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_lookup_dgram \-  Finds dgram socket for the local sap/mac
.SH SYNOPSIS
.B "struct sock *" llc_lookup_dgram
.BI "(struct llc_sap *" sap ","
.BI "struct llc_addr *" laddr ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "laddr" 12
 address of local LLC (MAC + SAP)
.SH "DESCRIPTION"
Search socket list of the SAP and finds connection using the local
mac, and local sap. Returns pointer for socket found, NULL otherwise.
.TH "llc_mac_hdr_init" 9 "llc_mac_hdr_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_mac_hdr_init \-  fills MAC header fields
.SH SYNOPSIS
.B "int" llc_mac_hdr_init
.BI "(struct sk_buff *" skb ","
.BI "unsigned char *" sa ","
.BI "unsigned char *" da ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the frame to initialize its MAC header
.IP "sa" 12
 The MAC source address
.IP "da" 12
 The MAC destination address
.SH "DESCRIPTION"
Fills MAC header fields, depending on MAC type. Returns 0, If MAC type
is a valid type and initialization completes correctly 1, otherwise.
.TH "llc_build_and_send_ui_pkt" 9 "llc_build_and_send_ui_pkt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_build_and_send_ui_pkt \-  unitdata request interface for upper layers
.SH SYNOPSIS
.B "int" llc_build_and_send_ui_pkt
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ","
.BI "unsigned char *" dmac ","
.BI "unsigned char " dsap ");"
.SH ARGUMENTS
.IP "sap" 12
 sap to use
.IP "skb" 12
 packet to send
.IP "dmac" 12
 destination mac address
.IP "dsap" 12
 destination sap
.SH "DESCRIPTION"
Upper layers calls this function when upper layer wants to send data
using connection-less mode communication (UI pdu).

Accept data frame from network layer to be sent using connection-
less mode communication; timeout/retries handled by network layer;
package primitive as an event and send to SAP event handler
.TH "llc_build_and_send_pkt" 9 "llc_build_and_send_pkt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_build_and_send_pkt \-  Connection data sending for upper layers.
.SH SYNOPSIS
.B "int" llc_build_and_send_pkt
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 connection
.IP "skb" 12
 packet to send
.SH "DESCRIPTION"
This function is called when upper layer wants to send data using
connection oriented communication mode. During sending data, connection
will be locked and received frames and expired timers will be queued.
Returns 0 for success, -ECONNABORTED when the connection already
closed and -EBUSY when sending data is not permitted in this state or
LLC has send an I pdu with p bit set to 1 and is waiting for it's
response.
.TH "llc_establish_connection" 9 "llc_establish_connection" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_establish_connection \-  Called by upper layer to establish a conn
.SH SYNOPSIS
.B "int" llc_establish_connection
.BI "(struct sock *" sk ","
.BI "u8 *" lmac ","
.BI "u8 *" dmac ","
.BI "u8 " dsap ");"
.SH ARGUMENTS
.IP "sk" 12
 connection
.IP "lmac" 12
 local mac address
.IP "dmac" 12
 destination mac address
.IP "dsap" 12
 destination sap
.SH "DESCRIPTION"
Upper layer calls this to establish an LLC connection with a remote
machine. This function packages a proper event and sends it connection
component state machine. Success or failure of connection
establishment will inform to upper layer via calling it's confirm
function and passing proper information.
.TH "llc_send_disc" 9 "llc_send_disc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_send_disc \-  Called by upper layer to close a connection
.SH SYNOPSIS
.B "int" llc_send_disc
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
 connection to be closed
.SH "DESCRIPTION"
Upper layer calls this when it wants to close an established LLC
connection with a remote machine. This function packages a proper event
and sends it to connection component state machine. Returns 0 for
success, 1 otherwise.
.TH "llc_sap_alloc" 9 "llc_sap_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_alloc \-  allocates and initializes sap.
.SH SYNOPSIS
.B "struct llc_sap *" llc_sap_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocates and initializes sap.
.TH "llc_add_sap" 9 "llc_add_sap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_add_sap \-  add sap to station list
.SH SYNOPSIS
.B "void" llc_add_sap
.BI "(struct llc_sap *" sap ");"
.SH ARGUMENTS
.IP "sap" 12
 Address of the sap
.SH "DESCRIPTION"
Adds a sap to the LLC's station sap list.
.TH "llc_del_sap" 9 "llc_del_sap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_del_sap \-  del sap from station list
.SH SYNOPSIS
.B "void" llc_del_sap
.BI "(struct llc_sap *" sap ");"
.SH ARGUMENTS
.IP "sap" 12
 Address of the sap
.SH "DESCRIPTION"
Removes a sap to the LLC's station sap list.
.TH "llc_sap_find" 9 "llc_sap_find" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_find \-  searchs a SAP in station
.SH SYNOPSIS
.B "struct llc_sap *" llc_sap_find
.BI "(unsigned char " sap_value ");"
.SH ARGUMENTS
.IP "sap_value" 12
 sap to be found
.SH "DESCRIPTION"
Searchs for a sap in the sap list of the LLC's station upon the sap ID.
If the sap is found it will be refcounted and the user will have to do
a llc_sap_put after use.
Returns the sap or NULL if not found.
.TH "llc_sap_open" 9 "llc_sap_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_open \-  open interface to the upper layers.
.SH SYNOPSIS
.B "struct llc_sap *" llc_sap_open
.BI "(unsigned char " lsap ","
.BI "int (*" func ") (struct sk_buff *skb, 					 struct net_device *dev, 					 struct packet_type *pt, 					 struct net_device *orig_dev));"
.SH ARGUMENTS
.IP "lsap" 12
 SAP number.
.IP "func" 12
 rcv func for datalink protos
.SH "DESCRIPTION"
Interface function to upper layer. Each one who wants to get a SAP
(for example NetBEUI) should call this function. Returns the opened
SAP for success, NULL for failure.
.TH "llc_sap_close" 9 "llc_sap_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_close \-  close interface for upper layers.
.SH SYNOPSIS
.B "void" llc_sap_close
.BI "(struct llc_sap *" sap ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP to be closed.
.SH "DESCRIPTION"
Close interface function to upper layer. Each one who wants to
close an open SAP (for example NetBEUI) should call this function.
Removes this sap from the list of saps in the station and then
frees the memory for this sap.
.TH "Kernel API" 9 "struct llc_station" "January 2021" "API Manual" LINUX
.SH NAME
struct llc_station \-  LLC station component
.SH SYNOPSIS
struct llc_station {
.br
};
.br
.SH Arguments
.SH "Description"

SAP and connection resource manager, one per adapter.

\fIstate\fP - state of station
\fIxid_r_count\fP - XID response PDU counter
\fImac_sa\fP - MAC source address
\fIsap_list\fP - list of related SAPs
\fIev_q\fP - events entering state mach.
\fImac_pdu_q\fP - PDUs ready to send to MAC
.TH "llc_station_send_pdu" 9 "llc_station_send_pdu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_station_send_pdu \-  queues PDU to send
.SH SYNOPSIS
.B "void" llc_station_send_pdu
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the PDU
.SH "DESCRIPTION"
Queues a PDU to send to the MAC layer.
.TH "llc_exec_station_trans_actions" 9 "llc_exec_station_trans_actions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_exec_station_trans_actions \-  executes actions for transition
.SH SYNOPSIS
.B "u16" llc_exec_station_trans_actions
.BI "(struct llc_station_state_trans *" trans ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "trans" 12
 Address of the transition
.IP "skb" 12
 Address of the event that caused the transition
.SH "DESCRIPTION"
Executes actions of a transition of the station state machine. Returns
0 if all actions complete successfully, nonzero otherwise.
.TH "llc_find_station_trans" 9 "llc_find_station_trans" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_find_station_trans \-  finds transition for this event
.SH SYNOPSIS
.B "struct llc_station_state_trans *" llc_find_station_trans
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the event
.SH "DESCRIPTION"
Search thru events of the current state of the station until list
exhausted or it's obvious that the event is not valid for the current
state. Returns the address of the transition if cound, NULL otherwise.
.TH "llc_station_free_ev" 9 "llc_station_free_ev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_station_free_ev \-  frees an event
.SH SYNOPSIS
.B "void" llc_station_free_ev
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the event
.SH "DESCRIPTION"
Frees an event.
.TH "llc_station_next_state" 9 "llc_station_next_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_station_next_state \-  processes event and goes to the next state
.SH SYNOPSIS
.B "u16" llc_station_next_state
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the event
.SH "DESCRIPTION"
Processes an event, executes any transitions related to that event and
updates the state of the station.
.TH "llc_station_service_events" 9 "llc_station_service_events" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_station_service_events \-  service events in the queue
.SH SYNOPSIS
.B "void" llc_station_service_events
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Get an event from the station event queue (if any); attempt to service
the event; if event serviced, get the next event (if any) on the event
queue; if event not service, re-queue the event on the event queue and
attempt to service the next event; when serviced all events in queue,
finished; if don't transition to different state, just service all
events once; if transition to new state, service all events again.
Caller must hold llc_main_station.ev_q.lock.
.TH "llc_station_state_process" 9 "llc_station_state_process" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_station_state_process \- 
.SH SYNOPSIS
.B "void" llc_station_state_process
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the event
.SH "DESCRIPTION"
Queues an event (on the station event queue) for handling by the
station state machine and attempts to process any queued-up events.
.TH "llc_pdu_type" 9 "llc_pdu_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_type \-  returns which LLC component must handle for PDU
.SH SYNOPSIS
.B "int" llc_pdu_type
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb
.SH "DESCRIPTION"
This function returns which LLC component must handle this PDU.
.TH "llc_fixup_skb" 9 "llc_fixup_skb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_fixup_skb \-  initializes skb pointers
.SH SYNOPSIS
.B "int" llc_fixup_skb
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 This argument points to incoming skb
.SH "DESCRIPTION"
Initializes internal skb pointer to start of network layer by deriving
length of LLC header; finds length of LLC control field in LLC header
by looking at the two lowest-order bits of the first control field
byte; field is either 3 or 4 bytes long.
.TH "llc_rcv" 9 "llc_rcv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_rcv \-  802.2 entry point from net lower layers
.SH SYNOPSIS
.B "int" llc_rcv
.BI "(struct sk_buff *" skb ","
.BI "struct net_device *" dev ","
.BI "struct packet_type *" pt ","
.BI "struct net_device *" orig_dev ");"
.SH ARGUMENTS
.IP "skb" 12
 received pdu
.IP "dev" 12
 device that receive pdu
.IP "pt" 12
 packet type
.IP "orig_dev" 12
-- undescribed --
.SH "DESCRIPTION"
When the system receives a 802.2 frame this function is called. It
checks SAP and connection of received pdu and passes frame to
llc_{station,sap,conn}_rcv for sending to proper state machine. If
the frame is related to a busy connection (a connection is sending
data now), it queues this frame in the connection's backlog.
.TH "llc_pdu_set_pf_bit" 9 "llc_pdu_set_pf_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_set_pf_bit \-  sets poll/final bit in LLC header
.SH SYNOPSIS
.B "void" llc_pdu_set_pf_bit
.BI "(struct sk_buff *" skb ","
.BI "u8 " bit_value ");"
.SH ARGUMENTS
.IP "skb" 12
-- undescribed --
.IP "bit_value" 12
 poll/final bit (0 or 1).
.SH "DESCRIPTION"
This function sets poll/final bit in LLC header (based on type of PDU).
in I or S pdus, p/f bit is right bit of fourth byte in header. in U
pdus p/f bit is fifth bit of third byte.
.TH "llc_pdu_decode_pf_bit" 9 "llc_pdu_decode_pf_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_decode_pf_bit \-  extracs poll/final bit from LLC header
.SH SYNOPSIS
.B "void" llc_pdu_decode_pf_bit
.BI "(struct sk_buff *" skb ","
.BI "u8 *" pf_bit ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that p/f bit must be extracted from it
.IP "pf_bit" 12
 poll/final bit (0 or 1)
.SH "DESCRIPTION"
This function extracts poll/final bit from LLC header (based on type of
PDU). In I or S pdus, p/f bit is right bit of fourth byte in header. In
U pdus p/f bit is fifth bit of third byte.
.TH "llc_pdu_init_as_disc_cmd" 9 "llc_pdu_init_as_disc_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_disc_cmd \-  Builds DISC PDU
.SH SYNOPSIS
.B "void" llc_pdu_init_as_disc_cmd
.BI "(struct sk_buff *" skb ","
.BI "u8 " p_bit ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "p_bit" 12
 The P bit to set in the PDU
.SH "DESCRIPTION"
Builds a pdu frame as a DISC command.
.TH "llc_pdu_init_as_i_cmd" 9 "llc_pdu_init_as_i_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_i_cmd \-  builds I pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_i_cmd
.BI "(struct sk_buff *" skb ","
.BI "u8 " p_bit ","
.BI "u8 " ns ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "p_bit" 12
 The P bit to set in the PDU
.IP "ns" 12
 The sequence number of the data PDU
.IP "nr" 12
 The seq. number of the expected I PDU from the remote
.SH "DESCRIPTION"
Builds a pdu frame as an I command.
.TH "llc_pdu_init_as_rej_cmd" 9 "llc_pdu_init_as_rej_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_rej_cmd \-  builds REJ PDU
.SH SYNOPSIS
.B "void" llc_pdu_init_as_rej_cmd
.BI "(struct sk_buff *" skb ","
.BI "u8 " p_bit ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "p_bit" 12
 The P bit to set in the PDU
.IP "nr" 12
 The seq. number of the expected I PDU from the remote
.SH "DESCRIPTION"
Builds a pdu frame as a REJ command.
.TH "llc_pdu_init_as_rnr_cmd" 9 "llc_pdu_init_as_rnr_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_rnr_cmd \-  builds RNR pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_rnr_cmd
.BI "(struct sk_buff *" skb ","
.BI "u8 " p_bit ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "p_bit" 12
 The P bit to set in the PDU
.IP "nr" 12
 The seq. number of the expected I PDU from the remote
.SH "DESCRIPTION"
Builds a pdu frame as an RNR command.
.TH "llc_pdu_init_as_rr_cmd" 9 "llc_pdu_init_as_rr_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_rr_cmd \-  Builds RR pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_rr_cmd
.BI "(struct sk_buff *" skb ","
.BI "u8 " p_bit ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "p_bit" 12
 The P bit to set in the PDU
.IP "nr" 12
 The seq. number of the expected I PDU from the remote
.SH "DESCRIPTION"
Builds a pdu frame as an RR command.
.TH "llc_pdu_init_as_sabme_cmd" 9 "llc_pdu_init_as_sabme_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_sabme_cmd \-  builds SABME pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_sabme_cmd
.BI "(struct sk_buff *" skb ","
.BI "u8 " p_bit ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "p_bit" 12
 The P bit to set in the PDU
.SH "DESCRIPTION"
Builds a pdu frame as an SABME command.
.TH "llc_pdu_init_as_dm_rsp" 9 "llc_pdu_init_as_dm_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_dm_rsp \-  builds DM response pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_dm_rsp
.BI "(struct sk_buff *" skb ","
.BI "u8 " f_bit ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "f_bit" 12
 The F bit to set in the PDU
.SH "DESCRIPTION"
Builds a pdu frame as a DM response.
.TH "llc_pdu_init_as_frmr_rsp" 9 "llc_pdu_init_as_frmr_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_frmr_rsp \-  builds FRMR response PDU
.SH SYNOPSIS
.B "void" llc_pdu_init_as_frmr_rsp
.BI "(struct sk_buff *" skb ","
.BI "struct llc_pdu_sn *" prev_pdu ","
.BI "u8 " f_bit ","
.BI "u8 " vs ","
.BI "u8 " vr ","
.BI "u8 " vzyxw ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the frame to build
.IP "prev_pdu" 12
 The rejected PDU frame
.IP "f_bit" 12
 The F bit to set in the PDU
.IP "vs" 12
 tx state vari value for the data link conn at the rejecting LLC
.IP "vr" 12
 rx state var value for the data link conn at the rejecting LLC
.IP "vzyxw" 12
 completely described in the IEEE Std 802.2 document (Pg 55)
.SH "DESCRIPTION"
Builds a pdu frame as a FRMR response.
.TH "llc_pdu_init_as_rr_rsp" 9 "llc_pdu_init_as_rr_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_rr_rsp \-  builds RR response pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_rr_rsp
.BI "(struct sk_buff *" skb ","
.BI "u8 " f_bit ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "f_bit" 12
 The F bit to set in the PDU
.IP "nr" 12
 The seq. number of the expected data PDU from the remote
.SH "DESCRIPTION"
Builds a pdu frame as an RR response.
.TH "llc_pdu_init_as_rej_rsp" 9 "llc_pdu_init_as_rej_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_rej_rsp \-  builds REJ response pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_rej_rsp
.BI "(struct sk_buff *" skb ","
.BI "u8 " f_bit ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the skb to build
.IP "f_bit" 12
 The F bit to set in the PDU
.IP "nr" 12
 The seq. number of the expected data PDU from the remote
.SH "DESCRIPTION"
Builds a pdu frame as a REJ response.
.TH "llc_pdu_init_as_rnr_rsp" 9 "llc_pdu_init_as_rnr_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_rnr_rsp \-  builds RNR response pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_rnr_rsp
.BI "(struct sk_buff *" skb ","
.BI "u8 " f_bit ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the frame to build
.IP "f_bit" 12
 The F bit to set in the PDU
.IP "nr" 12
 The seq. number of the expected data PDU from the remote
.SH "DESCRIPTION"
Builds a pdu frame as an RNR response.
.TH "llc_pdu_init_as_ua_rsp" 9 "llc_pdu_init_as_ua_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_init_as_ua_rsp \-  builds UA response pdu
.SH SYNOPSIS
.B "void" llc_pdu_init_as_ua_rsp
.BI "(struct sk_buff *" skb ","
.BI "u8 " f_bit ");"
.SH ARGUMENTS
.IP "skb" 12
 Address of the frame to build
.IP "f_bit" 12
 The F bit to set in the PDU
.SH "DESCRIPTION"
Builds a pdu frame as a UA response.
.TH "llc_pdu_decode_pdu_type" 9 "llc_pdu_decode_pdu_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_decode_pdu_type \-  designates PDU type
.SH SYNOPSIS
.B "void" llc_pdu_decode_pdu_type
.BI "(struct sk_buff *" skb ","
.BI "u8 *" type ");"
.SH ARGUMENTS
.IP "skb" 12
 input skb that type of it must be designated.
.IP "type" 12
 type of PDU (output argument).
.SH "DESCRIPTION"
This function designates type of PDU (I, S or U).
.TH "llc_pdu_get_pf_bit" 9 "llc_pdu_get_pf_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_pdu_get_pf_bit \-  extracts p/f bit of input PDU
.SH SYNOPSIS
.B "u8" llc_pdu_get_pf_bit
.BI "(struct llc_pdu_sn *" pdu ");"
.SH ARGUMENTS
.IP "pdu" 12
 pointer to LLC header.
.SH "DESCRIPTION"
This function extracts p/f bit of input PDU. at first examines type of
PDU and then extracts p/f bit. Returns the p/f bit.
.TH "llc_ui_next_link_no" 9 "llc_ui_next_link_no" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_next_link_no \-  return the next unused link number for a sap
.SH SYNOPSIS
.B "u16" llc_ui_next_link_no
.BI "(int " sap ");"
.SH ARGUMENTS
.IP "sap" 12
 Address of sap to get link number from.
.SH "DESCRIPTION"
Return the next unused link number for a given sap.
.TH "llc_proto_type" 9 "llc_proto_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_proto_type \-  return eth protocol for ARP header type
.SH SYNOPSIS
.B "u16" llc_proto_type
.BI "(u16 " arphrd ");"
.SH ARGUMENTS
.IP "arphrd" 12
 ARP header type.
.SH "DESCRIPTION"
Given an ARP header type return the corresponding ethernet protocol.
.TH "llc_ui_addr_null" 9 "llc_ui_addr_null" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_addr_null \-  determines if a address structure is null
.SH SYNOPSIS
.B "u8" llc_ui_addr_null
.BI "(struct sockaddr_llc *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
 Address to test if null.
.TH "llc_ui_header_len" 9 "llc_ui_header_len" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_header_len \-  return length of llc header based on operation
.SH SYNOPSIS
.B "u8" llc_ui_header_len
.BI "(struct sock *" sk ","
.BI "struct sockaddr_llc *" addr ");"
.SH ARGUMENTS
.IP "sk" 12
 Socket which contains a valid llc socket type.
.IP "addr" 12
 Complete sockaddr_llc structure received from the user.
.SH "DESCRIPTION"
Provide the length of the llc header depending on what kind of
operation the user would like to perform and the type of socket.
Returns the correct llc header length.
.TH "llc_ui_send_data" 9 "llc_ui_send_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_send_data \-  send data via reliable llc2 connection
.SH SYNOPSIS
.B "int" llc_ui_send_data
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ","
.BI "int " noblock ");"
.SH ARGUMENTS
.IP "sk" 12
 Connection the socket is using.
.IP "skb" 12
 Data the user wishes to send.
.IP "noblock" 12
 can we block waiting for data?
.SH "DESCRIPTION"
Send data via reliable llc2 connection.
Returns 0 upon success, non-zero if action did not succeed.
.TH "llc_ui_create" 9 "llc_ui_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_create \-  alloc and init a new llc_ui socket
.SH SYNOPSIS
.B "int" llc_ui_create
.BI "(struct socket *" sock ","
.BI "int " protocol ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to initialize and attach allocated sk to.
.IP "protocol" 12
 Unused.
.SH "DESCRIPTION"
Allocate and initialize a new llc_ui socket, validate the user wants a
socket type we have available.
Returns 0 upon success, negative upon failure.
.TH "llc_ui_release" 9 "llc_ui_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_release \-  shutdown socket
.SH SYNOPSIS
.B "int" llc_ui_release
.BI "(struct socket *" sock ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to release.
.SH "DESCRIPTION"
Shutdown and deallocate an existing socket.
.TH "llc_ui_autoport" 9 "llc_ui_autoport" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_autoport \-  provide dynamically allocate SAP number
.SH SYNOPSIS
.B "int" llc_ui_autoport
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Provide the caller with a dynamically allocated SAP number according
to the rules that are set in this function. Returns: 0, upon failure,
SAP number otherwise.
.TH "llc_ui_autobind" 9 "llc_ui_autobind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_autobind \-  automatically bind a socket to a sap
.SH SYNOPSIS
.B "int" llc_ui_autobind
.BI "(struct socket *" sock ","
.BI "struct sockaddr_llc *" addr ");"
.SH ARGUMENTS
.IP "sock" 12
 socket to bind
.IP "addr" 12
 address to connect to
.SH "DESCRIPTION"
Used by llc_ui_connect and llc_ui_sendmsg when the user hasn't
specifically used llc_ui_bind to bind to an specific address/sap
.SH "RETURNS"
 0 upon success, negative otherwise.
.TH "llc_ui_bind" 9 "llc_ui_bind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_bind \-  bind a socket to a specific address.
.SH SYNOPSIS
.B "int" llc_ui_bind
.BI "(struct socket *" sock ","
.BI "struct sockaddr *" uaddr ","
.BI "int " addrlen ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to bind an address to.
.IP "uaddr" 12
 Address the user wants the socket bound to.
.IP "addrlen" 12
 Length of the uaddr structure.
.SH "DESCRIPTION"
Bind a socket to a specific address. For llc a user is able to bind to
a specific sap only or mac + sap.
If the user desires to bind to a specific mac + sap, it is possible to
have multiple sap connections via multiple macs.
Bind and autobind for that matter must enforce the correct sap usage
otherwise all hell will break loose.
.SH "RETURNS"
 0 upon success, negative otherwise.
.TH "llc_ui_shutdown" 9 "llc_ui_shutdown" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_shutdown \-  shutdown a connect llc2 socket.
.SH SYNOPSIS
.B "int" llc_ui_shutdown
.BI "(struct socket *" sock ","
.BI "int " how ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to shutdown.
.IP "how" 12
 What part of the socket to shutdown.
.SH "DESCRIPTION"
Shutdown a connected llc2 socket. Currently this function only supports
shutting down both sends and receives (2), we could probably make this
function such that a user can shutdown only half the connection but not
right now.
.SH "RETURNS"
 0 upon success, negative otherwise.
.TH "llc_ui_connect" 9 "llc_ui_connect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_connect \-  Connect to a remote llc2 mac + sap.
.SH SYNOPSIS
.B "int" llc_ui_connect
.BI "(struct socket *" sock ","
.BI "struct sockaddr *" uaddr ","
.BI "int " addrlen ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket which will be connected to the remote destination.
.IP "uaddr" 12
 Remote and possibly the local address of the new connection.
.IP "addrlen" 12
 Size of uaddr structure.
.IP "flags" 12
 Operational flags specified by the user.
.SH "DESCRIPTION"
Connect to a remote llc2 mac + sap. The caller must specify the
destination mac and address to connect to. If the user hasn't previously
called bind(2) with a smac the address of the first interface of the
specified arp type will be used.
This function will autobind if user did not previously call bind.
.SH "RETURNS"
 0 upon success, negative otherwise.
.TH "llc_ui_listen" 9 "llc_ui_listen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_listen \-  allow a normal socket to accept incoming connections
.SH SYNOPSIS
.B "int" llc_ui_listen
.BI "(struct socket *" sock ","
.BI "int " backlog ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to allow incoming connections on.
.IP "backlog" 12
 Number of connections to queue.
.SH "DESCRIPTION"
Allow a normal socket to accept incoming connections.
Returns 0 upon success, negative otherwise.
.TH "llc_ui_accept" 9 "llc_ui_accept" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_accept \-  accept a new incoming connection.
.SH SYNOPSIS
.B "int" llc_ui_accept
.BI "(struct socket *" sock ","
.BI "struct socket *" newsock ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket which connections arrive on.
.IP "newsock" 12
 Socket to move incoming connection to.
.IP "flags" 12
 User specified operational flags.
.SH "DESCRIPTION"
Accept a new incoming connection.
Returns 0 upon success, negative otherwise.
.TH "llc_ui_recvmsg" 9 "llc_ui_recvmsg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_recvmsg \-  copy received data to the socket user.
.SH SYNOPSIS
.B "int" llc_ui_recvmsg
.BI "(struct kiocb *" iocb ","
.BI "struct socket *" sock ","
.BI "struct msghdr *" msg ","
.BI "size_t " len ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "iocb" 12
-- undescribed --
.IP "sock" 12
 Socket to copy data from.
.IP "msg" 12
 Various user space related information.
.IP "len" 12
 Size of user buffer.
.IP "flags" 12
 User specified flags.
.SH "DESCRIPTION"
Copy received data to the socket user.
Returns non-negative upon success, negative otherwise.
.TH "llc_ui_sendmsg" 9 "llc_ui_sendmsg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_sendmsg \-  Transmit data provided by the socket user.
.SH SYNOPSIS
.B "int" llc_ui_sendmsg
.BI "(struct kiocb *" iocb ","
.BI "struct socket *" sock ","
.BI "struct msghdr *" msg ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "iocb" 12
-- undescribed --
.IP "sock" 12
 Socket to transmit data from.
.IP "msg" 12
 Various user related information.
.IP "len" 12
 Length of data to transmit.
.SH "DESCRIPTION"
Transmit data provided by the socket user.
Returns non-negative upon success, negative otherwise.
.TH "llc_ui_getname" 9 "llc_ui_getname" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_getname \-  return the address info of a socket
.SH SYNOPSIS
.B "int" llc_ui_getname
.BI "(struct socket *" sock ","
.BI "struct sockaddr *" uaddr ","
.BI "int *" uaddrlen ","
.BI "int " peer ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to get address of.
.IP "uaddr" 12
 Address structure to return information.
.IP "uaddrlen" 12
 Length of address structure.
.IP "peer" 12
 Does user want local or remote address information.
.SH "DESCRIPTION"
Return the address information of a socket.
.TH "llc_ui_ioctl" 9 "llc_ui_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_ioctl \-  io controls for PF_LLC
.SH SYNOPSIS
.B "int" llc_ui_ioctl
.BI "(struct socket *" sock ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to get/set info
.IP "cmd" 12
 command
.IP "arg" 12
 optional argument for cmd
.SH "DESCRIPTION"
get/set info on llc sockets
.TH "llc_ui_setsockopt" 9 "llc_ui_setsockopt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_setsockopt \-  set various connection specific parameters.
.SH SYNOPSIS
.B "int" llc_ui_setsockopt
.BI "(struct socket *" sock ","
.BI "int " level ","
.BI "int " optname ","
.BI "char __user *" optval ","
.BI "int " optlen ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to set options on.
.IP "level" 12
 Socket level user is requesting operations on.
.IP "optname" 12
 Operation name.
\fIoptval\fP User provided operation data.
.IP "optval" 12
-- undescribed --
.IP "optlen" 12
 Length of optval.
.SH "DESCRIPTION"
Set various connection specific parameters.
.TH "llc_ui_getsockopt" 9 "llc_ui_getsockopt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_ui_getsockopt \-  get connection specific socket info
.SH SYNOPSIS
.B "int" llc_ui_getsockopt
.BI "(struct socket *" sock ","
.BI "int " level ","
.BI "int " optname ","
.BI "char __user *" optval ","
.BI "int __user *" optlen ");"
.SH ARGUMENTS
.IP "sock" 12
 Socket to get information from.
.IP "level" 12
 Socket level user is requesting operations on.
.IP "optname" 12
 Operation name.
.IP "optval" 12
 Variable to return operation data in.
.IP "optlen" 12
 Length of optval.
.SH "DESCRIPTION"
Get connection specific socket information.
.TH "llc_sap_action_unitdata_ind" 9 "llc_sap_action_unitdata_ind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_unitdata_ind \-  forward UI PDU to network layer
.SH SYNOPSIS
.B "int" llc_sap_action_unitdata_ind
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to forward
.SH "DESCRIPTION"
Received a UI PDU from MAC layer; forward to network layer as a
UNITDATA INDICATION; verify our event is the kind we expect
.TH "llc_sap_action_send_ui" 9 "llc_sap_action_send_ui" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_send_ui \-  sends UI PDU resp to UNITDATA REQ to MAC layer
.SH SYNOPSIS
.B "int" llc_sap_action_send_ui
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to send
.SH "DESCRIPTION"
Sends a UI PDU to the MAC layer in response to a UNITDATA REQUEST
primitive from the network layer. Verifies event is a primitive type of
event. Verify the primitive is a UNITDATA REQUEST.
.TH "llc_sap_action_send_xid_c" 9 "llc_sap_action_send_xid_c" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_send_xid_c \-  send XID PDU as response to XID REQ
.SH SYNOPSIS
.B "int" llc_sap_action_send_xid_c
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to send
.SH "DESCRIPTION"
Send a XID command PDU to MAC layer in response to a XID REQUEST
primitive from the network layer. Verify event is a primitive type
event. Verify the primitive is a XID REQUEST.
.TH "llc_sap_action_send_xid_r" 9 "llc_sap_action_send_xid_r" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_send_xid_r \-  send XID PDU resp to MAC for received XID
.SH SYNOPSIS
.B "int" llc_sap_action_send_xid_r
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to send
.SH "DESCRIPTION"
Send XID response PDU to MAC in response to an earlier received XID
command PDU. Verify event is a PDU type event
.TH "llc_sap_action_send_test_c" 9 "llc_sap_action_send_test_c" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_send_test_c \-  send TEST PDU to MAC in resp to TEST REQ
.SH SYNOPSIS
.B "int" llc_sap_action_send_test_c
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to send
.SH "DESCRIPTION"
Send a TEST command PDU to the MAC layer in response to a TEST REQUEST
primitive from the network layer. Verify event is a primitive type
event; verify the primitive is a TEST REQUEST.
.TH "llc_sap_action_report_status" 9 "llc_sap_action_report_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_report_status \-  report data link status to layer mgmt
.SH SYNOPSIS
.B "int" llc_sap_action_report_status
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to send
.SH "DESCRIPTION"
Report data link status to layer management. Verify our event is the
kind we expect.
.TH "llc_sap_action_xid_ind" 9 "llc_sap_action_xid_ind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_xid_ind \-  send XID PDU resp to net layer via XID IND
.SH SYNOPSIS
.B "int" llc_sap_action_xid_ind
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to send
.SH "DESCRIPTION"
Send a XID response PDU to the network layer via a XID INDICATION
primitive.
.TH "llc_sap_action_test_ind" 9 "llc_sap_action_test_ind" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_action_test_ind \-  send TEST PDU to net layer via TEST IND
.SH SYNOPSIS
.B "int" llc_sap_action_test_ind
.BI "(struct llc_sap *" sap ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "skb" 12
 the event to send
.SH "DESCRIPTION"
Send a TEST response PDU to the network layer via a TEST INDICATION
primitive. Verify our event is a PDU type event.
.TH "llc_util_ns_inside_rx_window" 9 "llc_util_ns_inside_rx_window" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_util_ns_inside_rx_window \-  check if sequence number is in rx window
.SH SYNOPSIS
.B "u16" llc_util_ns_inside_rx_window
.BI "(u8 " ns ","
.BI "u8 " vr ","
.BI "u8 " rw ");"
.SH ARGUMENTS
.IP "ns" 12
 sequence number of received pdu.
.IP "vr" 12
 sequence number which receiver expects to receive.
.IP "rw" 12
 receive window size of receiver.
.SH "DESCRIPTION"
Checks if sequence number of received PDU is in range of receive
window. Returns 0 for success, 1 otherwise
.TH "llc_util_nr_inside_tx_window" 9 "llc_util_nr_inside_tx_window" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_util_nr_inside_tx_window \-  check if sequence number is in tx window
.SH SYNOPSIS
.B "u16" llc_util_nr_inside_tx_window
.BI "(struct sock *" sk ","
.BI "u8 " nr ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection.
.IP "nr" 12
 N(R) of received PDU.
.SH "DESCRIPTION"
This routine checks if N(R) of received PDU is in range of transmit
window; on the other hand checks if received PDU acknowledges some
outstanding PDUs that are in transmit window. Returns 0 for success, 1
otherwise.
.TH "llc_conn_ev_qlfy_last_frame_eq_1" 9 "llc_conn_ev_qlfy_last_frame_eq_1" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ev_qlfy_last_frame_eq_1 \-  checks if frame is last in tx window
.SH SYNOPSIS
.B "int" llc_conn_ev_qlfy_last_frame_eq_1
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
This function determines when frame which is sent, is last frame of
transmit window, if it is then this function return zero else return
one.  This function is used for sending last frame of transmit window
as I-format command with p-bit set to one. Returns 0 if frame is last
frame, 1 otherwise.
.TH "llc_conn_ev_qlfy_last_frame_eq_0" 9 "llc_conn_ev_qlfy_last_frame_eq_0" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ev_qlfy_last_frame_eq_0 \-  checks if frame isn't last in tx window
.SH SYNOPSIS
.B "int" llc_conn_ev_qlfy_last_frame_eq_0
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
This function determines when frame which is sent, isn't last frame of
transmit window, if it isn't then this function return zero else return
one. Returns 0 if frame isn't last frame, 1 otherwise.
.TH "llc_conn_state_process" 9 "llc_conn_state_process" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_state_process \-  sends event to connection state machine
.SH SYNOPSIS
.B "int" llc_conn_state_process
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 connection
.IP "skb" 12
 occurred event
.SH "DESCRIPTION"
Sends an event to connection state machine. After processing event
(executing it's actions and changing state), upper layer will be
indicated or confirmed, if needed. Returns 0 for success, 1 for
failure. The socket lock has to be held before calling this function.
.TH "llc_conn_rtn_pdu" 9 "llc_conn_rtn_pdu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_rtn_pdu \-  sends received data pdu to upper layer
.SH SYNOPSIS
.B "void" llc_conn_rtn_pdu
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 Active connection
.IP "skb" 12
 Received data frame
.SH "DESCRIPTION"
Sends received data pdu to upper layer (by using indicate function).
Prepares service parameters (prim and prim_data). calling indication
function will be done in llc_conn_state_process.
.TH "llc_conn_resend_i_pdu_as_cmd" 9 "llc_conn_resend_i_pdu_as_cmd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_resend_i_pdu_as_cmd \-  resend all all unacknowledged I PDUs
.SH SYNOPSIS
.B "void" llc_conn_resend_i_pdu_as_cmd
.BI "(struct sock *" sk ","
.BI "u8 " nr ","
.BI "u8 " first_p_bit ");"
.SH ARGUMENTS
.IP "sk" 12
 active connection
.IP "nr" 12
 NR
.IP "first_p_bit" 12
 p_bit value of first pdu
.SH "DESCRIPTION"
Resend all unacknowledged I PDUs, starting with the NR; send first as
command PDU with P bit equal first_p_bit; if more than one send
subsequent as command PDUs with P bit equal zero (0).
.TH "llc_conn_resend_i_pdu_as_rsp" 9 "llc_conn_resend_i_pdu_as_rsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_resend_i_pdu_as_rsp \-  Resend all unacknowledged I PDUs
.SH SYNOPSIS
.B "void" llc_conn_resend_i_pdu_as_rsp
.BI "(struct sock *" sk ","
.BI "u8 " nr ","
.BI "u8 " first_f_bit ");"
.SH ARGUMENTS
.IP "sk" 12
 active connection.
.IP "nr" 12
 NR
.IP "first_f_bit" 12
 f_bit value of first pdu.
.SH "DESCRIPTION"
Resend all unacknowledged I PDUs, starting with the NR; send first as
response PDU with F bit equal first_f_bit; if more than one send
subsequent as response PDUs with F bit equal zero (0).
.TH "llc_conn_remove_acked_pdus" 9 "llc_conn_remove_acked_pdus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_remove_acked_pdus \-  Removes acknowledged pdus from tx queue
.SH SYNOPSIS
.B "int" llc_conn_remove_acked_pdus
.BI "(struct sock *" sk ","
.BI "u8 " nr ","
.BI "u16 *" how_many_unacked ");"
.SH ARGUMENTS
.IP "sk" 12
 active connection
.IP "nr" 12
-- undescribed --
.IP "how_many_unacked" 12
-- undescribed --
.SH "NR"
 NR
.SH "HOW_MANY_UNACKED"
 size of pdu_unack_q after removing acked pdus

Removes acknowledged pdus from transmit queue (pdu_unack_q). Returns
the number of pdus that removed from queue.
.TH "llc_conn_send_pdus" 9 "llc_conn_send_pdus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_send_pdus \-  Sends queued PDUs
.SH SYNOPSIS
.B "void" llc_conn_send_pdus
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
 active connection
.SH "DESCRIPTION"
Sends queued pdus to MAC layer for transmission.
.TH "llc_conn_service" 9 "llc_conn_service" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_service \-  finds transition and changes state of connection
.SH SYNOPSIS
.B "int" llc_conn_service
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 connection
.IP "skb" 12
 happened event
.SH "DESCRIPTION"
This function finds transition that matches with happened event, then
executes related actions and finally changes state of connection.
Returns 0 for success, 1 for failure.
.TH "llc_qualify_conn_ev" 9 "llc_qualify_conn_ev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_qualify_conn_ev \-  finds transition for event
.SH SYNOPSIS
.B "struct llc_conn_state_trans *" llc_qualify_conn_ev
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 connection
.IP "skb" 12
 happened event
.SH "DESCRIPTION"
This function finds transition that matches with happened event.
Returns pointer to found transition on success, NULL otherwise.
.TH "llc_exec_conn_trans_actions" 9 "llc_exec_conn_trans_actions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_exec_conn_trans_actions \-  executes related actions
.SH SYNOPSIS
.B "int" llc_exec_conn_trans_actions
.BI "(struct sock *" sk ","
.BI "struct llc_conn_state_trans *" trans ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 connection
.IP "trans" 12
 transition that it's actions must be performed
.IP "skb" 12
 event
.SH "DESCRIPTION"
Executes actions that is related to happened event. Returns 0 for
success, 1 to indicate failure of at least one action.
.TH "__llc_lookup_established" 9 "__llc_lookup_established" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__llc_lookup_established \-  Finds connection for the remote/local sap/mac
.SH SYNOPSIS
.B "struct sock *" __llc_lookup_established
.BI "(struct llc_sap *" sap ","
.BI "struct llc_addr *" daddr ","
.BI "struct llc_addr *" laddr ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "daddr" 12
 address of remote LLC (MAC + SAP)
.IP "laddr" 12
 address of local LLC (MAC + SAP)
.SH "DESCRIPTION"
Search connection list of the SAP and finds connection using the remote
mac, remote sap, local mac, and local sap. Returns pointer for
connection found, NULL otherwise.
Caller has to make sure local_bh is disabled.
.TH "llc_lookup_listener" 9 "llc_lookup_listener" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_lookup_listener \-  Finds listener for local MAC + SAP
.SH SYNOPSIS
.B "struct sock *" llc_lookup_listener
.BI "(struct llc_sap *" sap ","
.BI "struct llc_addr *" laddr ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "laddr" 12
 address of local LLC (MAC + SAP)
.SH "DESCRIPTION"
Search connection list of the SAP and finds connection listening on
local mac, and local sap. Returns pointer for parent socket found,
NULL otherwise.
Caller has to make sure local_bh is disabled.
.TH "llc_data_accept_state" 9 "llc_data_accept_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_data_accept_state \-  designates if in this state data can be sent.
.SH SYNOPSIS
.B "u8" llc_data_accept_state
.BI "(u8 " state ");"
.SH ARGUMENTS
.IP "state" 12
 state of connection.
.SH "DESCRIPTION"
Returns 0 if data can be sent, 1 otherwise.
.TH "llc_find_next_offset" 9 "llc_find_next_offset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_find_next_offset \-  finds offset for next category of transitions
.SH SYNOPSIS
.B "u16 __init" llc_find_next_offset
.BI "(struct llc_conn_state *" state ","
.BI "u16 " offset ");"
.SH ARGUMENTS
.IP "state" 12
 state table.
.IP "offset" 12
 start offset.
.SH "DESCRIPTION"
Finds offset of next category of transitions in transition table.
Returns the start index of next category.
.TH "llc_build_offset_table" 9 "llc_build_offset_table" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_build_offset_table \-  builds offset table of connection
.SH SYNOPSIS
.B "void __init" llc_build_offset_table
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Fills offset table of connection state transition table
(llc_offset_table).
.TH "llc_find_offset" 9 "llc_find_offset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_find_offset \-  finds start offset of category of transitions
.SH SYNOPSIS
.B "int" llc_find_offset
.BI "(int " state ","
.BI "int " ev_type ");"
.SH ARGUMENTS
.IP "state" 12
 state of connection
.IP "ev_type" 12
 type of happened event
.SH "DESCRIPTION"
Finds start offset of desired category of transitions. Returns the
desired start offset.
.TH "llc_sap_add_socket" 9 "llc_sap_add_socket" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_add_socket \-  adds a socket to a SAP
.SH SYNOPSIS
.B "void" llc_sap_add_socket
.BI "(struct llc_sap *" sap ","
.BI "struct sock *" sk ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "sk" 12
 socket
.SH "DESCRIPTION"
This function adds a socket to sk_list of a SAP.
.TH "llc_sap_remove_socket" 9 "llc_sap_remove_socket" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sap_remove_socket \-  removes a socket from SAP
.SH SYNOPSIS
.B "void" llc_sap_remove_socket
.BI "(struct llc_sap *" sap ","
.BI "struct sock *" sk ");"
.SH ARGUMENTS
.IP "sap" 12
 SAP
.IP "sk" 12
 socket
.SH "DESCRIPTION"
This function removes a connection from sk_list.list of a SAP if
the connection was in this list.
.TH "llc_conn_rcv" 9 "llc_conn_rcv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_rcv \-  sends received pdus to the connection state machine
.SH SYNOPSIS
.B "int" llc_conn_rcv
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 received frame.
.SH "DESCRIPTION"
Sends received pdus to the connection state machine.
.TH "llc_backlog_rcv" 9 "llc_backlog_rcv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_backlog_rcv \-  Processes rx frames and expired timers.
.SH SYNOPSIS
.B "int" llc_backlog_rcv
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 LLC sock (p8022 connection)
.IP "skb" 12
 queued rx frame or event
.SH "DESCRIPTION"
This function processes frames that has received and timers that has
expired during sending an I pdu (refer to data_req_handler).  frames
queue by llc_rcv function (llc_mac.c) and timers queue by timer
callback functions(llc_c_ac.c).
.TH "llc_sk_init" 9 "llc_sk_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sk_init \-  Initializes a socket with default llc values.
.SH SYNOPSIS
.B "void" llc_sk_init
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
 socket to initialize.
.SH "DESCRIPTION"
Initializes a socket with default llc values.
.TH "llc_sk_alloc" 9 "llc_sk_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sk_alloc \-  Allocates LLC sock
.SH SYNOPSIS
.B "struct sock *" llc_sk_alloc
.BI "(int " family ","
.BI "gfp_t " priority ","
.BI "struct proto *" prot ");"
.SH ARGUMENTS
.IP "family" 12
 upper layer protocol family
.IP "priority" 12
 for allocation (GFP_KERNEL, GFP_ATOMIC, etc)
.IP "prot" 12
-- undescribed --
.SH "DESCRIPTION"
Allocates a LLC sock and initializes it. Returns the new LLC sock
or NULL if there's no memory available for one
.TH "llc_sk_free" 9 "llc_sk_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sk_free \-  Frees a LLC socket
.SH SYNOPSIS
.B "void" llc_sk_free
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
-- undescribed --
.SH "DESCRIPTION"
\fIsk\fP - socket to free

Frees a LLC socket
.TH "llc_sk_reset" 9 "llc_sk_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_sk_reset \-  resets a connection
.SH SYNOPSIS
.B "void" llc_sk_reset
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
 LLC socket to reset
.SH "DESCRIPTION"
Resets a connection to the out of service state. Stops its timers
and frees any frames in the queues of the connection.
.TH "llc_conn_ac_send_ack_if_needed" 9 "llc_conn_ac_send_ack_if_needed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_send_ack_if_needed \-  check if ack is needed
.SH SYNOPSIS
.B "int" llc_conn_ac_send_ack_if_needed
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure
.IP "skb" 12
 current event
.SH "DESCRIPTION"
Checks number of received PDUs which have not been acknowledged, yet,
If number of them reaches to "npta"(Number of PDUs To Acknowledge) then
sends an RR response as acknowledgement for them.  Returns 0 for
success, 1 otherwise.
.TH "llc_conn_ac_rst_sendack_flag" 9 "llc_conn_ac_rst_sendack_flag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_rst_sendack_flag \-  resets ack_must_be_send flag
.SH SYNOPSIS
.B "int" llc_conn_ac_rst_sendack_flag
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure
.IP "skb" 12
 current event
.SH "DESCRIPTION"
This action resets ack_must_be_send flag of given connection, this flag
indicates if there is any PDU which has not been acknowledged yet.
Returns 0 for success, 1 otherwise.
.TH "llc_conn_ac_send_i_rsp_f_set_ackpf" 9 "llc_conn_ac_send_i_rsp_f_set_ackpf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_send_i_rsp_f_set_ackpf \-  acknowledge received PDUs
.SH SYNOPSIS
.B "int" llc_conn_ac_send_i_rsp_f_set_ackpf
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure
.IP "skb" 12
 current event
.SH "DESCRIPTION"
Sends an I response PDU with f-bit set to ack_pf flag as acknowledge to
all received PDUs which have not been acknowledged, yet. ack_pf flag is
set to one if one PDU with p-bit set to one is received.  Returns 0 for
success, 1 otherwise.
.TH "llc_conn_ac_send_i_as_ack" 9 "llc_conn_ac_send_i_as_ack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_send_i_as_ack \-  sends an I-format PDU to acknowledge rx PDUs
.SH SYNOPSIS
.B "int" llc_conn_ac_send_i_as_ack
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
This action sends an I-format PDU as acknowledge to received PDUs which
have not been acknowledged, yet, if there is any. By using of this
action number of acknowledgements decreases, this technic is called
piggy backing. Returns 0 for success, 1 otherwise.
.TH "llc_conn_ac_send_rr_rsp_f_set_ackpf" 9 "llc_conn_ac_send_rr_rsp_f_set_ackpf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_send_rr_rsp_f_set_ackpf \-  ack all rx PDUs not yet acked
.SH SYNOPSIS
.B "int" llc_conn_ac_send_rr_rsp_f_set_ackpf
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
This action sends an RR response with f-bit set to ack_pf flag as
acknowledge to all received PDUs which have not been acknowledged, yet,
if there is any. ack_pf flag indicates if a PDU has been received with
p-bit set to one. Returns 0 for success, 1 otherwise.
.TH "llc_conn_ac_inc_npta_value" 9 "llc_conn_ac_inc_npta_value" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_inc_npta_value \-  tries to make value of npta greater
.SH SYNOPSIS
.B "int" llc_conn_ac_inc_npta_value
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
After "inc_cntr" times calling of this action, "npta" increase by one.
this action tries to make vale of "npta" greater as possible; number of
acknowledgements decreases by increasing of "npta". Returns 0 for
success, 1 otherwise.
.TH "llc_conn_ac_adjust_npta_by_rr" 9 "llc_conn_ac_adjust_npta_by_rr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_adjust_npta_by_rr \-  decreases "npta" by one
.SH SYNOPSIS
.B "int" llc_conn_ac_adjust_npta_by_rr
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
After receiving "dec_cntr" times RR command, this action decreases
"npta" by one. Returns 0 for success, 1 otherwise.
.TH "llc_conn_ac_adjust_npta_by_rnr" 9 "llc_conn_ac_adjust_npta_by_rnr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_adjust_npta_by_rnr \-  decreases "npta" by one
.SH SYNOPSIS
.B "int" llc_conn_ac_adjust_npta_by_rnr
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
After receiving "dec_cntr" times RNR command, this action decreases
"npta" by one. Returns 0 for success, 1 otherwise.
.TH "llc_conn_ac_dec_tx_win_size" 9 "llc_conn_ac_dec_tx_win_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_dec_tx_win_size \-  decreases tx window size
.SH SYNOPSIS
.B "int" llc_conn_ac_dec_tx_win_size
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
After receiving of a REJ command or response, transmit window size is
decreased by number of PDUs which are outstanding yet. Returns 0 for
success, 1 otherwise.
.TH "llc_conn_ac_inc_tx_win_size" 9 "llc_conn_ac_inc_tx_win_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_ac_inc_tx_win_size \-  tx window size is inc by 1
.SH SYNOPSIS
.B "int" llc_conn_ac_inc_tx_win_size
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 current connection structure.
.IP "skb" 12
 current event.
.SH "DESCRIPTION"
After receiving an RR response with f-bit set to one, transmit window
size is increased by one. Returns 0 for success, 1 otherwise.
.TH "llc_conn_disc" 9 "llc_conn_disc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_disc \-  removes connection from SAP list and frees it
.SH SYNOPSIS
.B "int" llc_conn_disc
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 closed connection
.IP "skb" 12
 occurred event
.TH "llc_conn_reset" 9 "llc_conn_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_conn_reset \-  resets connection
.SH SYNOPSIS
.B "int" llc_conn_reset
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 reseting connection.
.IP "skb" 12
 occurred event.
.SH "DESCRIPTION"
Stop all timers, empty all queues and reset all flags.
.TH "llc_circular_between" 9 "llc_circular_between" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_circular_between \-  designates that b is between a and c or not
.SH SYNOPSIS
.B "u8" llc_circular_between
.BI "(u8 " a ","
.BI "u8 " b ","
.BI "u8 " c ");"
.SH ARGUMENTS
.IP "a" 12
 lower bound
.IP "b" 12
 element to see if is between a and b
.IP "c" 12
 upper bound
.SH "DESCRIPTION"
This function designates that b is between a and c or not (for example,
0 is between 127 and 1). Returns 1 if b is between a and c, 0
otherwise.
.TH "llc_process_tmr_ev" 9 "llc_process_tmr_ev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
llc_process_tmr_ev \-  timer backend
.SH SYNOPSIS
.B "void" llc_process_tmr_ev
.BI "(struct sock *" sk ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "sk" 12
 active connection
.IP "skb" 12
 occurred event
.SH "DESCRIPTION"
This function is called from timer callback functions. When connection
is busy (during sending a data frame) timer expiration event must be
queued. Otherwise this event can be sent to connection state machine.
Queued events will process by llc_backlog_rcv function after sending
data frame.
.TH "xdr_encode_opaque_fixed" 9 "xdr_encode_opaque_fixed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_encode_opaque_fixed \-  Encode fixed length opaque data
.SH SYNOPSIS
.B "u32 *" xdr_encode_opaque_fixed
.BI "(u32 *" p ","
.BI "const void *" ptr ","
.BI "unsigned int " nbytes ");"
.SH ARGUMENTS
.IP "p" 12
 pointer to current position in XDR buffer.
.IP "ptr" 12
 pointer to data to encode (or NULL)
.IP "nbytes" 12
 size of data.
.SH "DESCRIPTION"
Copy the array of data of length nbytes at ptr to the XDR buffer
at position p, then align to the next 32-bit boundary by padding
with zero bytes (see RFC1832).
.SH "NOTE"
 if ptr is NULL, only the padding is performed.

Returns the updated current XDR buffer position
.TH "xdr_encode_opaque" 9 "xdr_encode_opaque" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_encode_opaque \-  Encode variable length opaque data
.SH SYNOPSIS
.B "u32 *" xdr_encode_opaque
.BI "(u32 *" p ","
.BI "const void *" ptr ","
.BI "unsigned int " nbytes ");"
.SH ARGUMENTS
.IP "p" 12
 pointer to current position in XDR buffer.
.IP "ptr" 12
 pointer to data to encode (or NULL)
.IP "nbytes" 12
 size of data.
.SH "DESCRIPTION"
Returns the updated current XDR buffer position
.TH "xdr_init_encode" 9 "xdr_init_encode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_init_encode \-  Initialize a struct xdr_stream for sending data.
.SH SYNOPSIS
.B "void" xdr_init_encode
.BI "(struct xdr_stream *" xdr ","
.BI "struct xdr_buf *" buf ","
.BI "uint32_t *" p ");"
.SH ARGUMENTS
.IP "xdr" 12
 pointer to xdr_stream struct
.IP "buf" 12
 pointer to XDR buffer in which to encode data
.IP "p" 12
 current pointer inside XDR buffer
.SH "NOTE"
 at the moment the RPC client only passes the length of our
scratch buffer in the xdr_buf's header kvec. Previously this
meant we needed to call \fBxdr_adjust_iovec\fP after encoding the
data. With the new scheme, the xdr_stream manages the details
of the buffer length, and takes care of adjusting the kvec
length for us.
.TH "xdr_reserve_space" 9 "xdr_reserve_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_reserve_space \-  Reserve buffer space for sending
.SH SYNOPSIS
.B "uint32_t *" xdr_reserve_space
.BI "(struct xdr_stream *" xdr ","
.BI "size_t " nbytes ");"
.SH ARGUMENTS
.IP "xdr" 12
 pointer to xdr_stream
.IP "nbytes" 12
 number of bytes to reserve
.SH "DESCRIPTION"
Checks that we have enough buffer space to encode 'nbytes' more
bytes of data. If so, update the total xdr_buf length, and
adjust the length of the current kvec.
.TH "xdr_write_pages" 9 "xdr_write_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_write_pages \-  Insert a list of pages into an XDR buffer for sending
.SH SYNOPSIS
.B "void" xdr_write_pages
.BI "(struct xdr_stream *" xdr ","
.BI "struct page **" pages ","
.BI "unsigned int " base ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "xdr" 12
 pointer to xdr_stream
.IP "pages" 12
 list of pages
.IP "base" 12
 offset of first byte
.IP "len" 12
 length of data in bytes
.TH "xdr_init_decode" 9 "xdr_init_decode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_init_decode \-  Initialize an xdr_stream for decoding data.
.SH SYNOPSIS
.B "void" xdr_init_decode
.BI "(struct xdr_stream *" xdr ","
.BI "struct xdr_buf *" buf ","
.BI "uint32_t *" p ");"
.SH ARGUMENTS
.IP "xdr" 12
 pointer to xdr_stream struct
.IP "buf" 12
 pointer to XDR buffer from which to decode data
.IP "p" 12
 current pointer inside XDR buffer
.TH "xdr_inline_decode" 9 "xdr_inline_decode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_inline_decode \-  Retrieve non-page XDR data to decode
.SH SYNOPSIS
.B "uint32_t *" xdr_inline_decode
.BI "(struct xdr_stream *" xdr ","
.BI "size_t " nbytes ");"
.SH ARGUMENTS
.IP "xdr" 12
 pointer to xdr_stream struct
.IP "nbytes" 12
 number of bytes of data to decode
.SH "DESCRIPTION"
Check if the input buffer is long enough to enable us to decode
'nbytes' more bytes of data starting at the current position.
If so return the current pointer, then update the current
pointer position.
.TH "xdr_read_pages" 9 "xdr_read_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xdr_read_pages \-  Ensure page-based XDR data to decode is aligned at current pointer position
.SH SYNOPSIS
.B "void" xdr_read_pages
.BI "(struct xdr_stream *" xdr ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "xdr" 12
 pointer to xdr_stream struct
.IP "len" 12
 number of bytes of page data
.SH "DESCRIPTION"
Moves data beyond the current pointer position from the XDR head[] buffer
into the page list. Any data that lies beyond current position + "len"
bytes is moved into the XDR tail[]. The current pointer is then
repositioned at the beginning of the XDR tail.
.TH "rpc_create_client" 9 "rpc_create_client" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rpc_create_client \- 
.SH SYNOPSIS
.B "struct rpc_clnt *" rpc_create_client
.BI "(struct rpc_xprt *" xprt ","
.BI "char *" servname ","
.BI "struct rpc_program *" info ","
.BI "u32 " version ","
.BI "rpc_authflavor_t " authflavor ");"
.SH ARGUMENTS
.IP "xprt" 12
-- undescribed --
.IP "servname" 12
-- undescribed --
.IP "info" 12
-- undescribed --
.IP "version" 12
-- undescribed --
.IP "authflavor" 12
-- undescribed --
.SH "DESCRIPTION"
\fIxprt\fP - pointer to xprt struct
\fIservname\fP - name of server
\fIinfo\fP - rpc_program
\fIversion\fP - rpc_program version
\fIauthflavor\fP - rpc_auth flavour to use

Creates an RPC client structure, then pings the server in order to
determine if it is up, and if it supports this program and version.

This function should never be called by asynchronous tasks such as
the portmapper.
.TH "rpc_bind_new_program" 9 "rpc_bind_new_program" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rpc_bind_new_program \-  bind a new RPC program to an existing client
.SH SYNOPSIS
.B "struct rpc_clnt *" rpc_bind_new_program
.BI "(struct rpc_clnt *" old ","
.BI "struct rpc_program *" program ","
.BI "int " vers ");"
.SH ARGUMENTS
.IP "old" 12
-- undescribed --
.IP "program" 12
-- undescribed --
.IP "vers" 12
-- undescribed --
.SH "DESCRIPTION"
\fIold\fP - old rpc_client
\fIprogram\fP - rpc program to set
\fIvers\fP - rpc program version

Clones the rpc client and sets up a new RPC program. This is mainly
of use for enabling different RPC programs to share the same transport.
The Sun NFSv2/v3 ACL protocol can do this.
.TH "svc_reserve" 9 "svc_reserve" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
svc_reserve \-  change the space reserved for the reply to a request.
.SH SYNOPSIS
.B "void" svc_reserve
.BI "(struct svc_rqst *" rqstp ","
.BI "int " space ");"
.SH ARGUMENTS
.IP "rqstp" 12
  The request in question
.IP "space" 12
 new max space to reserve
.SH "DESCRIPTION"
Each request reserves some space on the output queue of the socket
to make sure the reply fits.  This function reduces that reserved
space to be the amount of space used already, plus \fIspace\fP.
.TH "__rpc_do_wake_up_task" 9 "__rpc_do_wake_up_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__rpc_do_wake_up_task \-  wake up a single rpc_task
.SH SYNOPSIS
.B "void" __rpc_do_wake_up_task
.BI "(struct rpc_task *" task ");"
.SH ARGUMENTS
.IP "task" 12
 task to be woken up
.SH "DESCRIPTION"
Caller must hold queue-&gt;lock, and have cleared the task queued flag.
.TH "rpc_wake_up" 9 "rpc_wake_up" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rpc_wake_up \-  wake up all rpc_tasks
.SH SYNOPSIS
.B "void" rpc_wake_up
.BI "(struct rpc_wait_queue *" queue ");"
.SH ARGUMENTS
.IP "queue" 12
 rpc_wait_queue on which the tasks are sleeping
.SH "DESCRIPTION"
Grabs queue-&gt;lock
.TH "rpc_wake_up_status" 9 "rpc_wake_up_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rpc_wake_up_status \-  wake up all rpc_tasks and set their status value.
.SH SYNOPSIS
.B "void" rpc_wake_up_status
.BI "(struct rpc_wait_queue *" queue ","
.BI "int " status ");"
.SH ARGUMENTS
.IP "queue" 12
 rpc_wait_queue on which the tasks are sleeping
.IP "status" 12
 status value to set
.SH "DESCRIPTION"
Grabs queue-&gt;lock
.TH "rpc_find_parent" 9 "rpc_find_parent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
rpc_find_parent \-  find the parent of a child task.
.SH SYNOPSIS
.B "struct rpc_task *" rpc_find_parent
.BI "(struct rpc_task *" child ");"
.SH ARGUMENTS
.IP "child" 12
 child task
.SH "DESCRIPTION"
Checks that the parent task is still sleeping on the
queue 'childq'. If so returns a pointer to the parent.
Upon failure returns NULL.

Caller must hold childq.lock
.TH "tcf_em_register" 9 "tcf_em_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_em_register \-  register an extended match
.SH SYNOPSIS
.B "int" tcf_em_register
.BI "(struct tcf_ematch_ops *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
 ematch operations lookup table
.SH "DESCRIPTION"
This function must be called by ematches to announce their presence.
The given \fIops\fP must have kind set to a unique identifier and the
callback \fBmatch\fP must be implemented. All other callbacks are optional
and a fallback implementation is used instead.

Returns -EEXISTS if an ematch of the same kind has already registered.
.SH "DESCRIPTION"
This function must be called by ematches to announce their presence.
The given \fIops\fP must have kind set to a unique identifier and the
callback \fBmatch\fP must be implemented. All other callbacks are optional
and a fallback implementation is used instead.

Returns -EEXISTS if an ematch of the same kind has already registered.
.TH "tcf_em_unregister" 9 "tcf_em_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_em_unregister \-  unregster and extended match
.SH SYNOPSIS
.B "int" tcf_em_unregister
.BI "(struct tcf_ematch_ops *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
 ematch operations lookup table
.SH "DESCRIPTION"
This function must be called by ematches to announce their disappearance
for examples when the module gets unloaded. The \fIops\fP parameter must be
the same as the one used for registration.

Returns -ENOENT if no matching ematch was found.
.SH "DESCRIPTION"
This function must be called by ematches to announce their disappearance
for examples when the module gets unloaded. The \fIops\fP parameter must be
the same as the one used for registration.

Returns -ENOENT if no matching ematch was found.
.TH "tcf_em_tree_validate" 9 "tcf_em_tree_validate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_em_tree_validate \-  validate ematch config TLV and build ematch tree
.SH SYNOPSIS
.B "int" tcf_em_tree_validate
.BI "(struct tcf_proto *" tp ","
.BI "struct rtattr *" rta ","
.BI "struct tcf_ematch_tree *" tree ");"
.SH ARGUMENTS
.IP "tp" 12
 classifier kind handle
.IP "rta" 12
 ematch tree configuration TLV
.IP "tree" 12
 destination ematch tree variable to store the resulting
ematch tree.
.SH "DESCRIPTION"
This function validates the given configuration TLV \fIrta\fP and builds an
ematch tree in \fItree\fP. The resulting tree must later be copied into
the private classifier data using \fBtcf_em_tree_change\fP. You MUST NOT
provide the ematch tree variable of the private classifier data directly,
the changes would not be locked properly.

Returns a negative error code if the configuration TLV contains errors.
.SH "DESCRIPTION"
This function validates the given configuration TLV \fIrta\fP and builds an
ematch tree in \fItree\fP. The resulting tree must later be copied into
the private classifier data using \fBtcf_em_tree_change\fP. You MUST NOT
provide the ematch tree variable of the private classifier data directly,
the changes would not be locked properly.

Returns a negative error code if the configuration TLV contains errors.
.TH "tcf_em_tree_destroy" 9 "tcf_em_tree_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_em_tree_destroy \-  destroy an ematch tree
.SH SYNOPSIS
.B "void" tcf_em_tree_destroy
.BI "(struct tcf_proto *" tp ","
.BI "struct tcf_ematch_tree *" tree ");"
.SH ARGUMENTS
.IP "tp" 12
 classifier kind handle
.IP "tree" 12
 ematch tree to be deleted
.SH "DESCRIPTION"
This functions destroys an ematch tree previously created by
\fBtcf_em_tree_validate\fP/\fBtcf_em_tree_change\fP. You must ensure that
the ematch tree is not in use before calling this function.
.SH "DESCRIPTION"
This functions destroys an ematch tree previously created by
\fBtcf_em_tree_validate\fP/\fBtcf_em_tree_change\fP. You must ensure that
the ematch tree is not in use before calling this function.
.TH "tcf_em_tree_dump" 9 "tcf_em_tree_dump" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tcf_em_tree_dump \-  dump ematch tree into a rtnl message
.SH SYNOPSIS
.B "int" tcf_em_tree_dump
.BI "(struct sk_buff *" skb ","
.BI "struct tcf_ematch_tree *" tree ","
.BI "int " tlv ");"
.SH ARGUMENTS
.IP "skb" 12
 skb holding the rtnl message
.IP "tree" 12
-- undescribed --
.IP "tlv" 12
 TLV type to be used to encapsulate the tree
.SH "DESCRIPTION"
This function dumps a ematch tree into a rtnl message. It is valid to
call this function while the ematch tree is in use.

Returns -1 if the skb tailroom is insufficient.
.SH "DESCRIPTION"
This function dumps a ematch tree into a rtnl message. It is valid to
call this function while the ematch tree is in use.

Returns -1 if the skb tailroom is insufficient.
.TH "HTB_DIRECT" 9 "HTB_DIRECT" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
HTB_DIRECT \-  classify a packet into class
.SH SYNOPSIS
.B "" HTB_DIRECT
.BI "(struct htb_class *"  ");"
.SH ARGUMENTS
.IP "" 12
-- undescribed --
.SH "DESCRIPTION"

It returns NULL if the packet should be dropped or -1 if the packet
should be passed directly thru. In all other cases leaf class is returned.
We allow direct class selection by classid in priority. The we examine
filters in qdisc and in inner nodes (if higher filter points to the inner
node). If we end up with classid MAJOR:0 we enqueue the skb into special
internal fifo (direct). These packets then go directly thru. If we still 
.SH "HAVE NO VALID LEAF WE TRY TO USE MAJOR"
default leaf. It still unsuccessfull
then finish and return direct queue.
.TH "htb_add_to_id_tree" 9 "htb_add_to_id_tree" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_add_to_id_tree \-  adds class to the round robin list
.SH SYNOPSIS
.B "void" htb_add_to_id_tree
.BI "(HTB_ARGQ struct rb_root *" root ","
.BI "struct htb_class *" cl ","
.BI "int " prio ");"
.SH ARGUMENTS
.IP "root" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.IP "prio" 12
-- undescribed --
.SH "DESCRIPTION"

Routine adds class to the list (actually tree) sorted by classid.
Make sure that class is not already on such list for given prio.
.TH "htb_add_to_wait_tree" 9 "htb_add_to_wait_tree" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_add_to_wait_tree \-  adds class to the event queue with delay
.SH SYNOPSIS
.B "void" htb_add_to_wait_tree
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ","
.BI "long " delay ","
.BI "int " debug_hint ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.IP "delay" 12
-- undescribed --
.IP "debug_hint" 12
-- undescribed --
.SH "DESCRIPTION"

The class is added to priority event queue to indicate that class will
change its mode in cl-&gt;pq_key microseconds. Make sure that class is not
already in the queue.
.TH "htb_next_rb_node" 9 "htb_next_rb_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_next_rb_node \-  finds next node in binary tree
.SH SYNOPSIS
.B "void" htb_next_rb_node
.BI "(struct rb_node **" n ");"
.SH ARGUMENTS
.IP "n" 12
-- undescribed --
.SH "DESCRIPTION"

When we are past last key we return NULL.
Average complexity is 2 steps per call.
.TH "htb_add_class_to_row" 9 "htb_add_class_to_row" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_add_class_to_row \-  add class to its row
.SH SYNOPSIS
.B "void" htb_add_class_to_row
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ","
.BI "int " mask ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.IP "mask" 12
-- undescribed --
.SH "DESCRIPTION"

The class is added to row at priorities marked in mask.
It does nothing if mask == 0.
.TH "htb_remove_class_from_row" 9 "htb_remove_class_from_row" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_remove_class_from_row \-  removes class from its row
.SH SYNOPSIS
.B "void" htb_remove_class_from_row
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ","
.BI "int " mask ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.IP "mask" 12
-- undescribed --
.SH "DESCRIPTION"

The class is removed from row at priorities marked in mask.
It does nothing if mask == 0.
.TH "htb_activate_prios" 9 "htb_activate_prios" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_activate_prios \-  creates active classe's feed chain
.SH SYNOPSIS
.B "void" htb_activate_prios
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.SH "DESCRIPTION"

The class is connected to ancestors and/or appropriate rows
for priorities it is participating on. cl-&gt;cmode must be new 
(activated) mode. It does nothing if cl-&gt;prio_activity == 0.
.TH "htb_deactivate_prios" 9 "htb_deactivate_prios" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_deactivate_prios \-  remove class from feed chain
.SH SYNOPSIS
.B "void" htb_deactivate_prios
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.SH "DESCRIPTION"

cl-&gt;cmode must represent old mode (before deactivation). It does 
nothing if cl-&gt;prio_activity == 0. Class is removed from all feed
chains and rows.
.TH "htb_class_mode" 9 "htb_class_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_class_mode \-  computes and returns current class mode
.SH SYNOPSIS
.B "enum htb_cmode" htb_class_mode
.BI "(struct htb_class *" cl ","
.BI "long *" diff ");"
.SH ARGUMENTS
.IP "cl" 12
-- undescribed --
.IP "diff" 12
-- undescribed --
.SH "DESCRIPTION"

It computes cl's mode at time cl-&gt;t_c+diff and returns it. If mode
is not HTB_CAN_SEND then cl-&gt;pq_key is updated to time difference
from now to time when cl will change its state. 
Also it is worth to note that class mode doesn't change simply
at cl-&gt;{c,}tokens == 0 but there can rather be hysteresis of 
0 .. -cl-&gt;{c,}buffer range. It is meant to limit number of
mode transitions per time unit. The speed gain is about 1/6.
.TH "htb_change_class_mode" 9 "htb_change_class_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_change_class_mode \-  changes classe's mode
.SH SYNOPSIS
.B "void" htb_change_class_mode
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ","
.BI "long *" diff ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.IP "diff" 12
-- undescribed --
.SH "DESCRIPTION"

This should be the only way how to change classe's mode under normal
cirsumstances. Routine will update feed lists linkage, change mode
and add class to the wait event queue if appropriate. New mode should
be different from old one and cl-&gt;pq_key has to be valid if changing
to mode other than HTB_CAN_SEND (see htb_add_to_wait_tree).
.TH "htb_activate" 9 "htb_activate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_activate \-  inserts leaf cl into appropriate active feeds 
.SH SYNOPSIS
.B "void" htb_activate
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.SH "DESCRIPTION"

Routine learns (new) priority of leaf and activates feed chain
for the prio. It can be called on already active leaf safely.
It also adds leaf into droplist.
.TH "htb_deactivate" 9 "htb_deactivate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_deactivate \-  remove leaf cl from active feeds 
.SH SYNOPSIS
.B "void" htb_deactivate
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.SH "DESCRIPTION"

Make sure that leaf is active. In the other words it can't be called
with non-active leaf. It also removes class from the drop list.
.TH "htb_charge_class" 9 "htb_charge_class" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_charge_class \-  charges amount "bytes" to leaf and ancestors
.SH SYNOPSIS
.B "void" htb_charge_class
.BI "(struct htb_sched *" q ","
.BI "struct htb_class *" cl ","
.BI "int " level ","
.BI "int " bytes ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "cl" 12
-- undescribed --
.IP "level" 12
-- undescribed --
.IP "bytes" 12
-- undescribed --
.SH "DESCRIPTION"

Routine assumes that packet "bytes" long was dequeued from leaf cl
borrowing from "level". It accounts bytes to ceil leaky bucket for
leaf and all ancestors and to rate bucket for ancestors at levels
"level" and higher. It also handles possible change of mode resulting
from the update. Note that mode can also increase here (MAY_BORROW to
CAN_SEND) because we can use more precise clock that event queue here.
In such case we remove class from event queue first.
.TH "htb_do_events" 9 "htb_do_events" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_do_events \-  make mode changes to classes at the level
.SH SYNOPSIS
.B "long" htb_do_events
.BI "(struct htb_sched *" q ","
.BI "int " level ");"
.SH ARGUMENTS
.IP "q" 12
-- undescribed --
.IP "level" 12
-- undescribed --
.SH "DESCRIPTION"

Scans event queue for pending events and applies them. Returns jiffies to
next pending event (0 for no event in pq).
.SH "NOTE"
 Aplied are events whose have cl-&gt;pq_key &lt;= jiffies.
.TH "htb_lookup_leaf" 9 "htb_lookup_leaf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
htb_lookup_leaf \-  returns next leaf class in DRR order
.SH SYNOPSIS
.B "struct htb_class *" htb_lookup_leaf
.BI "(HTB_ARGQ struct rb_root *" tree ","
.BI "int " prio ","
.BI "struct rb_node **" pptr ","
.BI "u32 *" pid ");"
.SH ARGUMENTS
.IP "tree" 12
-- undescribed --
.IP "prio" 12
-- undescribed --
.IP "pptr" 12
-- undescribed --
.IP "pid" 12
-- undescribed --
.SH "DESCRIPTION"

Find leaf where current feed pointers points to.
.TH "ipv6_rearrange_rthdr" 9 "ipv6_rearrange_rthdr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipv6_rearrange_rthdr \-  rearrange IPv6 routing header
.SH SYNOPSIS
.B "void" ipv6_rearrange_rthdr
.BI "(struct ipv6hdr *" iph ","
.BI "struct ipv6_rt_hdr *" rthdr ");"
.SH ARGUMENTS
.IP "iph" 12
 IPv6 header
.IP "rthdr" 12
 routing header
.SH "DESCRIPTION"
Rearrange the destination address in \fIiph\fP and the addresses in \fIrthdr\fP
so that they appear in the order they will at the final destination.
See Appendix A2 of RFC 2402 for details.
.TH "__x25_remove_neigh" 9 "__x25_remove_neigh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__x25_remove_neigh \-  remove neighbour from x25_neigh_list
.SH SYNOPSIS
.B "void" __x25_remove_neigh
.BI "(struct x25_neigh *" nb ");"
.SH ARGUMENTS
.IP "nb" 12
-- undescribed --
.SH "DESCRIPTION"
\fInb\fP - neigh to remove

Remove neighbour from x25_neigh_list. If it was there.
Caller must hold x25_neigh_list_lock.
.TH "__x25_remove_route" 9 "__x25_remove_route" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__x25_remove_route \-  remove route from x25_route_list
.SH SYNOPSIS
.B "void" __x25_remove_route
.BI "(struct x25_route *" rt ");"
.SH ARGUMENTS
.IP "rt" 12
-- undescribed --
.SH "DESCRIPTION"
\fIrt\fP - route to remove

Remove route from x25_route_list. If it was there.
Caller must hold x25_route_list_lock.
.TH "x25_get_route" 9 "x25_get_route" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
x25_get_route \- 	Find a route given an X.25 address.
.SH SYNOPSIS
.B "struct x25_route *" x25_get_route
.BI "(struct x25_address *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
-- undescribed --
.SH "DESCRIPTION"
\fIaddr\fP - address to find a route for

Find a route given an X.25 address.
.TH "dn_check_idf" 9 "dn_check_idf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dn_check_idf \-  Check an image data field format is correct.
.SH SYNOPSIS
.B "int" dn_check_idf
.BI "(unsigned char **" pptr ","
.BI "int *" len ","
.BI "unsigned char " max ","
.BI "unsigned char " follow_on ");"
.SH ARGUMENTS
.IP "pptr" 12
 Pointer to pointer to image data
.IP "len" 12
 Pointer to length of image data
.IP "max" 12
 The maximum allowed length of the data in the image data field
.IP "follow_on" 12
 Check that this many bytes exist beyond the end of the image data
.SH "RETURNS"
 0 if ok, -1 on error
.TH "dn_return_short" 9 "dn_return_short" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dn_return_short \-  Return a short packet to its sender
.SH SYNOPSIS
.B "int" dn_return_short
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 The packet to return
.TH "dn_return_long" 9 "dn_return_long" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dn_return_long \-  Return a long packet to its sender
.SH SYNOPSIS
.B "int" dn_return_long
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 The long format packet to return
.TH "dn_route_rx_packet" 9 "dn_route_rx_packet" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dn_route_rx_packet \-  Try and find a route for an incoming packet
.SH SYNOPSIS
.B "int" dn_route_rx_packet
.BI "(struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "skb" 12
 The packet to find a route for
.SH "RETURNS"
 result of input function if route is found, error code otherwise
.TH "dn_nsp_clone_and_send" 9 "dn_nsp_clone_and_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dn_nsp_clone_and_send \-  Send a data packet by cloning it
.SH SYNOPSIS
.B "unsigned" dn_nsp_clone_and_send
.BI "(struct sk_buff *" skb ","
.BI "gfp_t " gfp ");"
.SH ARGUMENTS
.IP "skb" 12
 The packet to clone and transmit
.IP "gfp" 12
 memory allocation flag
.SH "DESCRIPTION"
Clone a queued data or other data packet and transmit it.
.SH "RETURNS"
 The number of times the packet has been sent previously
.TH "dn_nsp_output" 9 "dn_nsp_output" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dn_nsp_output \-  Try and send something from socket queues
.SH SYNOPSIS
.B "void" dn_nsp_output
.BI "(struct sock *" sk ");"
.SH ARGUMENTS
.IP "sk" 12
 The socket whose queues are to be investigated
.SH "DESCRIPTION"
Try and send the packet on the end of the data and other data queues.
Other data gets priority over data, and if we retransmit a packet we
reduce the window by dividing it in two.
.TH "move_addr_to_kernel" 9 "move_addr_to_kernel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
move_addr_to_kernel \- 	copy a socket address into kernel space
.SH SYNOPSIS
.B "int" move_addr_to_kernel
.BI "(void __user *" uaddr ","
.BI "int " ulen ","
.BI "void *" kaddr ");"
.SH ARGUMENTS
.IP "uaddr" 12
 Address in user space
.IP "ulen" 12
 Length in user space
.IP "kaddr" 12
 Address in kernel space
.SH "DESCRIPTION"
The address is copied into kernel space. If the provided address is
too long an error code of -EINVAL is returned. If the copy gives
invalid addresses -EFAULT is returned. On a success 0 is returned.
.TH "move_addr_to_user" 9 "move_addr_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
move_addr_to_user \- 	copy an address to user space
.SH SYNOPSIS
.B "int" move_addr_to_user
.BI "(void *" kaddr ","
.BI "int " klen ","
.BI "void __user *" uaddr ","
.BI "int __user *" ulen ");"
.SH ARGUMENTS
.IP "kaddr" 12
 kernel space address
.IP "klen" 12
 length of address in kernel
.IP "uaddr" 12
 user space address
.IP "ulen" 12
 pointer to user length field
.SH "DESCRIPTION"
The value pointed to by ulen on entry is the buffer length available.
This is overwritten with the buffer space used. -EINVAL is returned
if an overlong buffer is specified or a negative buffer size. -EFAULT
is returned if either the buffer or the length field are not
accessible.
After copying the data up to the limit the user specifies, the true
length of the data is written over the length limit the user
specified. Zero is returned for a success.
.TH "sockfd_lookup" 9 "sockfd_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sockfd_lookup \-  	Go from a file number to its socket slot
.SH SYNOPSIS
.B "struct socket *" sockfd_lookup
.BI "(int " fd ","
.BI "int *" err ");"
.SH ARGUMENTS
.IP "fd" 12
 file handle
.IP "err" 12
 pointer to an error code return
.SH "DESCRIPTION"
The file handle passed in is locked and the socket it is bound
too is returned. If an error occurs the err pointer is overwritten
with a negative errno code and NULL is returned. The function checks
for both invalid handles and passing a handle which is not a socket.

On a success the socket object pointer is returned.
.TH "sock_alloc" 9 "sock_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sock_alloc \- 	allocate a socket
.SH SYNOPSIS
.B "struct socket *" sock_alloc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate a new inode and socket object. The two are bound together
and initialised. The socket is then returned. If we are out of inodes
NULL is returned.
.TH "sock_release" 9 "sock_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sock_release \- 	close a socket
.SH SYNOPSIS
.B "void" sock_release
.BI "(struct socket *" sock ");"
.SH ARGUMENTS
.IP "sock" 12
 socket to close
.SH "DESCRIPTION"
The socket is released from the protocol stack if it has a release
callback, and the inode is then released if the socket is bound to
an inode not a file. 
.TH "nfnetlink_check_attributes" 9 "nfnetlink_check_attributes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nfnetlink_check_attributes \-  check and parse nfnetlink attributes
.SH SYNOPSIS
.B "int" nfnetlink_check_attributes
.BI "(struct nfnetlink_subsystem *" subsys ","
.BI "struct nlmsghdr *" nlh ","
.BI "struct nfattr *" cda[] ");"
.SH ARGUMENTS
.IP "subsys" 12
-- undescribed --
.IP "nlh" 12
-- undescribed --
.IP "cda[]" 12
-- undescribed --
.SH "DESCRIPTION"
.SH "SUBSYS"
 nfnl subsystem for which this message is to be parsed
.SH "NLMSGHDR"
 netlink message to be checked/parsed
.SH "CDA"
 array of pointers, needs to be at least subsys-&gt;attr_count big
.TH "alloc_fddidev" 9 "alloc_fddidev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_fddidev \-  Register FDDI device
.SH SYNOPSIS
.B "struct net_device *" alloc_fddidev
.BI "(int " sizeof_priv ");"
.SH ARGUMENTS
.IP "sizeof_priv" 12
 Size of additional driver-private structure to be allocated
for this FDDI device
.SH "DESCRIPTION"
Fill in the fields of the device structure with FDDI-generic values.

Constructs a new net device, complete with a private data area of
size \fIsizeof_priv\fP.  A 32-byte (not bit) alignment is enforced for
this private data area.
.TH "alloc_trdev" 9 "alloc_trdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_trdev \-  Register token ring device
.SH SYNOPSIS
.B "struct net_device *" alloc_trdev
.BI "(int " sizeof_priv ");"
.SH ARGUMENTS
.IP "sizeof_priv" 12
 Size of additional driver-private structure to be allocated
for this token ring device
.SH "DESCRIPTION"
Fill in the fields of the device structure with token ring-generic values.

Constructs a new net device, complete with a private data area of
size \fIsizeof_priv\fP.  A 32-byte (not bit) alignment is enforced for
this private data area.
.TH "alloc_fcdev" 9 "alloc_fcdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_fcdev \-  Register fibre channel device
.SH SYNOPSIS
.B "struct net_device *" alloc_fcdev
.BI "(int " sizeof_priv ");"
.SH ARGUMENTS
.IP "sizeof_priv" 12
 Size of additional driver-private structure to be allocated
for this fibre channel device
.SH "DESCRIPTION"
Fill in the fields of the device structure with fibre channel-generic values.

Constructs a new net device, complete with a private data area of
size \fIsizeof_priv\fP.  A 32-byte (not bit) alignment is enforced for
this private data area.
.TH "alloc_hippi_dev" 9 "alloc_hippi_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_hippi_dev \-  Register HIPPI device
.SH SYNOPSIS
.B "struct net_device *" alloc_hippi_dev
.BI "(int " sizeof_priv ");"
.SH ARGUMENTS
.IP "sizeof_priv" 12
 Size of additional driver-private structure to be allocated
for this HIPPI device
.SH "DESCRIPTION"
Fill in the fields of the device structure with HIPPI-generic values.

Constructs a new net device, complete with a private data area of
size \fIsizeof_priv\fP.  A 32-byte (not bit) alignment is enforced for
this private data area.
.TH "alloc_etherdev" 9 "alloc_etherdev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_etherdev \-  Allocates and sets up an ethernet device
.SH SYNOPSIS
.B "struct net_device *" alloc_etherdev
.BI "(int " sizeof_priv ");"
.SH ARGUMENTS
.IP "sizeof_priv" 12
 Size of additional driver-private structure to be allocated
for this ethernet device
.SH "DESCRIPTION"
Fill in the fields of the device structure with ethernet-generic
values. Basically does everything except registering the device.

Constructs a new net device, complete with a private data area of
size \fIsizeof_priv\fP.  A 32-byte (not bit) alignment is enforced for
this private data area.
.TH "udp_poll" 9 "udp_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
udp_poll \-  wait for a UDP event.
.SH SYNOPSIS
.B "unsigned int" udp_poll
.BI "(struct file *" file ","
.BI "struct socket *" sock ","
.BI "poll_table *" wait ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "sock" 12
-- undescribed --
.IP "wait" 12
-- undescribed --
.SH "DESCRIPTION"
\fIfile\fP - file struct
\fIsock\fP - socket
\fIwait\fP - poll table

This is same as datagram poll, except for the special case of 
blocking sockets. If application is using a blocking fd
and a packet with checksum error is in the queue;
then it could get return from select indicating data available
but then block when reading it. Add special case code
to work around these arguably broken applications.
.TH "ipxitf_pprop" 9 "ipxitf_pprop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ipxitf_pprop \-  Process packet propagation IPX packet type 0x14, used for
.SH SYNOPSIS
.B "int" ipxitf_pprop
.BI "(struct ipx_interface *" intrfc ","
.BI "struct sk_buff *" skb ");"
.SH ARGUMENTS
.IP "intrfc" 12
 IPX interface receiving this packet
.IP "skb" 12
 Received packet
.SH "DESCRIPTION"
NetBIOS broadcasts
.SH "CHECKS IF PACKET IS VALID"
 if its more than IPX_MAX_PPROP_HOPS hops or if it
is smaller than a IPX header + the room for IPX_MAX_PPROP_HOPS hops we drop
it, not even processing it locally, if it has exact IPX_MAX_PPROP_HOPS we
don't broadcast it, but process it locally. See chapter 5 of Novell's "IPX
RIP and SAP Router Specification", Part Number 107-000029-001.

If it is valid, check if we have pprop broadcasting enabled by the user,
if not, just return zero for local processing.

If it is enabled check the packet and don't broadcast it if we have already
seen this packet.
.SH "BROADCAST"
 send it to the interfaces that aren't on the packet visited nets
array, just after the IPX header.

Returns -EINVAL for invalid packets, so that the calling function drops
the packet without local processing. 0 if packet is to be locally processed.
.TH "wake_up_bit" 9 "wake_up_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
wake_up_bit \-  wake up a waiter on a bit
.SH SYNOPSIS
.B "void fastcall" wake_up_bit
.BI "(void *" word ","
.BI "int " bit ");"
.SH ARGUMENTS
.IP "word" 12
 the word being waited on, a kernel virtual address
.IP "bit" 12
 the bit of the word being waited on
.SH "DESCRIPTION"
There is a standard hashed waitqueue table for generic use. This
is the part of the hashtable's accessor API that wakes up waiters
on a bit. For instance, if one were to have waiters on a bitflag,
one would call \fBwake_up_bit\fP after clearing the bit.

In order for this to function properly, as it uses \fBwaitqueue_active\fP
internally, some kind of memory barrier must be done prior to calling
this. Typically, this will be \fBsmp_mb__after_clear_bit\fP, but in some
cases where bitflags are manipulated non-atomically under a lock, one
may need to use a less regular barrier, such fs/inode.c's \fBsmp_mb\fP,
because \fBspin_unlock\fP does not guarantee a memory barrier.
.TH "notifier_chain_register" 9 "notifier_chain_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
notifier_chain_register \-  Add notifier to a notifier chain
.SH SYNOPSIS
.B "int" notifier_chain_register
.BI "(struct notifier_block **" list ","
.BI "struct notifier_block *" n ");"
.SH ARGUMENTS
.IP "list" 12
 Pointer to root list pointer
.IP "n" 12
 New entry in notifier chain
.SH "DESCRIPTION"
Adds a notifier to a notifier chain.

Currently always returns zero.
.TH "notifier_chain_unregister" 9 "notifier_chain_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
notifier_chain_unregister \-  Remove notifier from a notifier chain
.SH SYNOPSIS
.B "int" notifier_chain_unregister
.BI "(struct notifier_block **" nl ","
.BI "struct notifier_block *" n ");"
.SH ARGUMENTS
.IP "nl" 12
 Pointer to root list pointer
.IP "n" 12
 New entry in notifier chain
.SH "DESCRIPTION"
Removes a notifier from a notifier chain.

Returns zero on success, or -ENOENT on failure.
.TH "notifier_call_chain" 9 "notifier_call_chain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
notifier_call_chain \-  Call functions in a notifier chain
.SH SYNOPSIS
.B "int" notifier_call_chain
.BI "(struct notifier_block **" n ","
.BI "unsigned long " val ","
.BI "void *" v ");"
.SH ARGUMENTS
.IP "n" 12
 Pointer to root pointer of notifier chain
.IP "val" 12
 Value passed unmodified to notifier function
.IP "v" 12
 Pointer passed unmodified to notifier function
.SH "DESCRIPTION"
Calls each function in a notifier chain in turn.

If the return value of the notifier can be and'd
with NOTIFY_STOP_MASK, then notifier_call_chain
will return immediately, with the return value of
the notifier function which halted execution.
Otherwise, the return value is the return value
of the last notifier function called.
.TH "register_reboot_notifier" 9 "register_reboot_notifier" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_reboot_notifier \-  Register function to be called at reboot time
.SH SYNOPSIS
.B "int" register_reboot_notifier
.BI "(struct notifier_block *" nb ");"
.SH ARGUMENTS
.IP "nb" 12
 Info about notifier function to be called
.SH "DESCRIPTION"
Registers a function with the list of functions
to be called at reboot time.

Currently always returns zero, as notifier_chain_register
always returns zero.
.TH "unregister_reboot_notifier" 9 "unregister_reboot_notifier" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_reboot_notifier \-  Unregister previously registered reboot notifier
.SH SYNOPSIS
.B "int" unregister_reboot_notifier
.BI "(struct notifier_block *" nb ");"
.SH ARGUMENTS
.IP "nb" 12
 Hook to be unregistered
.SH "DESCRIPTION"
Unregisters a previously registered reboot
notifier function.

Returns zero on success, or -ENOENT on failure.
.TH "emergency_restart" 9 "emergency_restart" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
emergency_restart \-  reboot the system
.SH SYNOPSIS
.B "void" emergency_restart
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Without shutting down any hardware or taking any locks
reboot the system.  This is called when we know we are in
trouble so this is our best effort to reboot.  This is
safe to call in interrupt context.
.TH "kernel_restart_prepare" 9 "kernel_restart_prepare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kernel_restart_prepare \-  reboot the system
.SH SYNOPSIS
.B "void" kernel_restart_prepare
.BI "(char *" cmd ");"
.SH ARGUMENTS
.IP "cmd" 12
-- undescribed --
.SH "DESCRIPTION"

Shutdown everything and perform a clean reboot.
This is not safe to call in interrupt context.
.TH "kernel_kexec" 9 "kernel_kexec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kernel_kexec \-  reboot the system
.SH SYNOPSIS
.B "void" kernel_kexec
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Move into place and start executing a preloaded standalone
executable.  If nothing was preloaded return an error.
.TH "kernel_halt_prepare" 9 "kernel_halt_prepare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kernel_halt_prepare \-  halt the system
.SH SYNOPSIS
.B "void" kernel_halt_prepare
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Shutdown everything and perform a clean system halt.
.TH "kernel_power_off_prepare" 9 "kernel_power_off_prepare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kernel_power_off_prepare \-  power_off the system
.SH SYNOPSIS
.B "void" kernel_power_off_prepare
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Shutdown everything and perform a clean system power_off.
.TH "sys_getpid" 9 "sys_getpid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_getpid \-  return the thread group id of the current process
.SH SYNOPSIS
.B "long" sys_getpid
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Note, despite the name, this returns the tgid not the pid.  The tgid and
the pid are identical unless CLONE_THREAD was specified on \fBclone\fP in
which case the tgid is the same in all threads of the same group.

This is SMP safe as current-&gt;tgid does not change.
.TH "schedule_timeout" 9 "schedule_timeout" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
schedule_timeout \-  sleep until timeout
.SH SYNOPSIS
.B "signed long __sched" schedule_timeout
.BI "(signed long " timeout ");"
.SH ARGUMENTS
.IP "timeout" 12
 timeout value in jiffies
.SH "DESCRIPTION"
Make the current task sleep until \fItimeout\fP jiffies have
elapsed. The routine will return immediately unless
the current task state has been set (see \fBset_current_state\fP).

You can set the task state as follows -

TASK_UNINTERRUPTIBLE - at least \fItimeout\fP jiffies are guaranteed to
pass before the routine returns. The routine will return 0

TASK_INTERRUPTIBLE - the routine may return early if a signal is
delivered to the current task. In this case the remaining time
in jiffies will be returned, or 0 if the timer expired in time

The current task state is guaranteed to be TASK_RUNNING when this
routine returns.

Specifying a \fItimeout\fP value of MAX_SCHEDULE_TIMEOUT will schedule
the CPU away without a bound on the timeout. In this case the return
value will be MAX_SCHEDULE_TIMEOUT.

In all cases the return value is guaranteed to be non-negative.
.TH "msleep" 9 "msleep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
msleep \-  sleep safely even with waitqueue interruptions
.SH SYNOPSIS
.B "void" msleep
.BI "(unsigned int " msecs ");"
.SH ARGUMENTS
.IP "msecs" 12
 Time in milliseconds to sleep for
.TH "msleep_interruptible" 9 "msleep_interruptible" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
msleep_interruptible \-  sleep waiting for signals
.SH SYNOPSIS
.B "unsigned long" msleep_interruptible
.BI "(unsigned int " msecs ");"
.SH ARGUMENTS
.IP "msecs" 12
 Time in milliseconds to sleep for
.TH "cancel_rearming_delayed_workqueue" 9 "cancel_rearming_delayed_workqueue" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cancel_rearming_delayed_workqueue \-  reliably kill off a delayed
.SH SYNOPSIS
.B "void" cancel_rearming_delayed_workqueue
.BI "(struct workqueue_struct *" wq ","
.BI "struct work_struct *" work ");"
.SH ARGUMENTS
.IP "wq" 12
   the controlling workqueue structure
.IP "work" 12
 the delayed work struct
.SH "DESCRIPTION"
work whose handler rearms the delayed work.
.TH "cancel_rearming_delayed_work" 9 "cancel_rearming_delayed_work" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cancel_rearming_delayed_work \-  reliably kill off a delayed keventd
.SH SYNOPSIS
.B "void" cancel_rearming_delayed_work
.BI "(struct work_struct *" work ");"
.SH ARGUMENTS
.IP "work" 12
 the delayed work struct
.SH "DESCRIPTION"
work whose handler rearms the delayed work.
.TH "reparent_to_init" 9 "reparent_to_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
reparent_to_init \-  Reparent the calling kernel thread to the init task.
.SH SYNOPSIS
.B "void" reparent_to_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

If a kernel thread is launched as a result of a system call, or if
it ever exits, it should generally reparent itself to init so that
it is correctly cleaned up on exit.

The various task state such as scheduling policy and priority may have
been inherited from a user process, so we reset them to sane values here.

NOTE that \fBreparent_to_init\fP gives the caller full capabilities.
.TH "panic" 9 "panic" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
panic \-  halt the system
.SH SYNOPSIS
.B "NORET_TYPE void" panic
.BI "(const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "fmt" 12
 The text string to print
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Display a message, then perform cleanups.

This function never returns.
.TH "print_tainted" 9 "print_tainted" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
print_tainted \-  return a string to represent the kernel taint state.
.SH SYNOPSIS
.B "const char *" print_tainted
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

'P' - Proprietary module has been loaded.
'F' - Module has been forcibly loaded.
'S' - SMP with CPUs not designed for SMP.
'R' - User forced a module unload.
'M' - Machine had a machine check experience.
'B' - System has hit bad_page.

The string is overwritten by the next call to \fBprint_taint\fP.
.TH "sys_tgkill" 9 "sys_tgkill" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_tgkill \-  send signal to one specific thread
.SH SYNOPSIS
.B "long" sys_tgkill
.BI "(int " tgid ","
.BI "int " pid ","
.BI "int " sig ");"
.SH ARGUMENTS
.IP "tgid" 12
 the thread group ID of the thread
.IP "pid" 12
 the PID of the thread
.IP "sig" 12
 signal to be sent
.SH "DESCRIPTION"
This syscall also checks the tgid and returns -ESRCH even if the PID
exists but it's not belonging to the target process anymore. This
method solves the problem of threads exiting and PIDs getting reused.
.TH "audit_expand" 9 "audit_expand" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
audit_expand \-  expand skb in the audit buffer
.SH SYNOPSIS
.B "int" audit_expand
.BI "(struct audit_buffer *" ab ","
.BI "int " extra ");"
.SH ARGUMENTS
.IP "ab" 12
 audit_buffer
.IP "extra" 12
-- undescribed --
.SH "DESCRIPTION"
Returns 0 (no space) on failed expansion, or available space if
successful.
.TH "request_module" 9 "request_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
request_module \-  try to load a kernel module
.SH SYNOPSIS
.B "int" request_module
.BI "(const char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "fmt" 12
     printf style format string for the name of the module
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Load a module using the user mode module loader. The function returns
zero on success or a negative errno code on failure. Note that a
successful module load does not mean the module did not then unload
and exit on an error of its own. Callers must check that the service
they requested is now available not blindly invoke it.

If module auto-loading support is disabled then this function
becomes a no-operation.
.TH "call_usermodehelper_keys" 9 "call_usermodehelper_keys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
call_usermodehelper_keys \-  start a usermode application
.SH SYNOPSIS
.B "int" call_usermodehelper_keys
.BI "(char *" path ","
.BI "char **" argv ","
.BI "char **" envp ","
.BI "struct key *" session_keyring ","
.BI "int " wait ");"
.SH ARGUMENTS
.IP "path" 12
 pathname for the application
.IP "argv" 12
 null-terminated argument list
.IP "envp" 12
 null-terminated environment list
.IP "session_keyring" 12
 session keyring for process (NULL for an empty keyring)
.IP "wait" 12
 wait for the application to finish and return status.
.SH "DESCRIPTION"
Runs a user-space application.  The application is started
asynchronously if wait is not set, and runs as a child of keventd.
(ie. it runs with full root capabilities).

Must be called from process context.  Returns a negative error code
if program was not execed successfully, or 0.
.TH "register_sysctl_table" 9 "register_sysctl_table" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_sysctl_table \-  register a sysctl hierarchy
.SH SYNOPSIS
.B "struct ctl_table_header *" register_sysctl_table
.BI "(ctl_table *" table ","
.BI "int " insert_at_head ");"
.SH ARGUMENTS
.IP "table" 12
 the top-level table structure
.IP "insert_at_head" 12
 whether the entry should be inserted in front or at the end
.SH "DESCRIPTION"
Register a sysctl table hierarchy. \fItable\fP should be a filled in ctl_table
array. An entry with a ctl_name of 0 terminates the table. 

The members of the &amp;ctl_table structure are used as follows:

ctl_name - This is the numeric sysctl value used by sysctl(2). The number
must be unique within that level of sysctl

procname - the name of the sysctl file under /proc/sys. Set to NULL to not
enter a sysctl file

data - a pointer to data for use by proc_handler

maxlen - the maximum size in bytes of the data

mode - the file permissions for the /proc/sys file, and for sysctl(2)

child - a pointer to the child sysctl table if this entry is a directory, or
NULL.

proc_handler - the text handler routine (described below)

strategy - the strategy routine (described below)

de - for internal use by the sysctl routines

extra1, extra2 - extra pointers usable by the proc handler routines

Leaf nodes in the sysctl tree will be represented by a single file
under /proc; non-leaf nodes will be represented by directories.

sysctl(2) can automatically manage read and write requests through
the sysctl table.  The data and maxlen fields of the ctl_table
struct enable minimal validation of the values being written to be
performed, and the mode field allows minimal authentication.

More sophisticated management can be enabled by the provision of a
strategy routine with the table entry.  This will be called before
any automatic read or write of the data is performed.

The strategy routine may return

&lt; 0 - Error occurred (error is passed to user process)

0   - OK - proceed with automatic read or write.

&gt; 0 - OK - read or write has been done by the strategy routine, so
return immediately.

There must be a proc_handler routine for any terminal nodes
mirrored under /proc/sys (non-terminals are handled by a built-in
directory handler).  Several default handlers are available to
cover common cases -

\fBproc_dostring\fP, \fBproc_dointvec\fP, \fBproc_dointvec_jiffies\fP,
\fBproc_dointvec_userhz_jiffies\fP, \fBproc_dointvec_minmax\fP, 
\fBproc_doulongvec_ms_jiffies_minmax\fP, \fBproc_doulongvec_minmax\fP

It is the handler's job to read the input buffer from user memory
and process it. The handler should return 0 on success.

This routine returns NULL on a failure to register, and a pointer
to the table header on success.
.TH "unregister_sysctl_table" 9 "unregister_sysctl_table" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_sysctl_table \-  unregister a sysctl table hierarchy
.SH SYNOPSIS
.B "void" unregister_sysctl_table
.BI "(struct ctl_table_header *" header ");"
.SH ARGUMENTS
.IP "header" 12
 the header returned from register_sysctl_table
.SH "DESCRIPTION"
Unregisters the sysctl table and all children. proc entries may not
actually be removed until they are no longer used by anyone.
.TH "proc_dostring" 9 "proc_dostring" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_dostring \-  read a string sysctl
.SH SYNOPSIS
.B "int" proc_dostring
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
 file position
.SH "DESCRIPTION"
Reads/writes a string from/to the user buffer. If the kernel
buffer provided is not large enough to hold the string, the
string is truncated. The copied string is NULL-terminated.
If the string is being read by the user process, it is copied
and a newline '\n' is added. It is truncated if the buffer is
not large enough.

Returns 0 on success.
.TH "proc_dointvec" 9 "proc_dointvec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_dointvec \-  read a vector of integers
.SH SYNOPSIS
.B "int" proc_dointvec
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
 file position
.SH "DESCRIPTION"
Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string. 

Returns 0 on success.
.TH "proc_dointvec_minmax" 9 "proc_dointvec_minmax" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_dointvec_minmax \-  read a vector of integers with min/max values
.SH SYNOPSIS
.B "int" proc_dointvec_minmax
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
 file position
.SH "DESCRIPTION"
Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.

This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).

Returns 0 on success.
.TH "proc_doulongvec_minmax" 9 "proc_doulongvec_minmax" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_doulongvec_minmax \-  read a vector of long integers with min/max values
.SH SYNOPSIS
.B "int" proc_doulongvec_minmax
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
 file position
.SH "DESCRIPTION"
Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string.

This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).

Returns 0 on success.
.TH "proc_doulongvec_ms_jiffies_minmax" 9 "proc_doulongvec_ms_jiffies_minmax" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_doulongvec_ms_jiffies_minmax \-  read a vector of millisecond values with min/max values
.SH SYNOPSIS
.B "int" proc_doulongvec_ms_jiffies_minmax
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
 file position
.SH "DESCRIPTION"
Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string. The values
are treated as milliseconds, and converted to jiffies when they are stored.

This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).

Returns 0 on success.
.TH "proc_dointvec_jiffies" 9 "proc_dointvec_jiffies" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_dointvec_jiffies \-  read a vector of integers as seconds
.SH SYNOPSIS
.B "int" proc_dointvec_jiffies
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
 file position
.SH "DESCRIPTION"
Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string. 
The values read are assumed to be in seconds, and are converted into
jiffies.

Returns 0 on success.
.TH "proc_dointvec_userhz_jiffies" 9 "proc_dointvec_userhz_jiffies" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_dointvec_userhz_jiffies \-  read a vector of integers as 1/USER_HZ seconds
.SH SYNOPSIS
.B "int" proc_dointvec_userhz_jiffies
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
-- undescribed --
.SH "DESCRIPTION"
Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string. 
The values read are assumed to be in 1/USER_HZ seconds, and 
are converted into jiffies.

Returns 0 on success.
.TH "proc_dointvec_ms_jiffies" 9 "proc_dointvec_ms_jiffies" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
proc_dointvec_ms_jiffies \-  read a vector of integers as 1 milliseconds
.SH SYNOPSIS
.B "int" proc_dointvec_ms_jiffies
.BI "(ctl_table *" table ","
.BI "int " write ","
.BI "struct file *" filp ","
.BI "void __user *" buffer ","
.BI "size_t *" lenp ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "table" 12
 the sysctl table
.IP "write" 12
 TRUE if this is a write to the sysctl file
.IP "filp" 12
 the file structure
.IP "buffer" 12
 the user buffer
.IP "lenp" 12
 the size of the user buffer
.IP "ppos" 12
 the current position in the file
.SH "DESCRIPTION"
Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string. 
The values read are assumed to be in 1/1000 seconds, and 
are converted into jiffies.

Returns 0 on success.
.TH "get_insn_slot" 9 "get_insn_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_insn_slot \-  Find a slot on an executable page for an instruction.
.SH SYNOPSIS
.B "kprobe_opcode_t __kprobes *" get_insn_slot
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
We allocate an executable page if there's no room on existing ones.
.TH "inter_module_register" 9 "inter_module_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inter_module_register \-  register a new set of inter module data.
.SH SYNOPSIS
.B "void" inter_module_register
.BI "(const char *" im_name ","
.BI "struct module *" owner ","
.BI "const void *" userdata ");"
.SH ARGUMENTS
.IP "im_name" 12
 an arbitrary string to identify the data, must be unique
.IP "owner" 12
 module that is registering the data, always use THIS_MODULE
.IP "userdata" 12
 pointer to arbitrary userdata to be registered
.SH "DESCRIPTION"
 Check that the im_name has not already been registered,
complain if it has.  For new data, add it to the inter_module_entry
list.
.TH "inter_module_unregister" 9 "inter_module_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inter_module_unregister \-  unregister a set of inter module data.
.SH SYNOPSIS
.B "void" inter_module_unregister
.BI "(const char *" im_name ");"
.SH ARGUMENTS
.IP "im_name" 12
 an arbitrary string to identify the data, must be unique
.SH "DESCRIPTION"
 Check that the im_name has been registered, complain if
it has not.  For existing data, remove it from the
inter_module_entry list.
.TH "inter_module_get" 9 "inter_module_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inter_module_get \-  return arbitrary userdata from another module.
.SH SYNOPSIS
.B "const void *" inter_module_get
.BI "(const char *" im_name ");"
.SH ARGUMENTS
.IP "im_name" 12
 an arbitrary string to identify the data, must be unique
.SH "DESCRIPTION"
 If the im_name has not been registered, return NULL.
Try to increment the use count on the owning module, if that fails
then return NULL.  Otherwise return the userdata.
.TH "inter_module_get_request" 9 "inter_module_get_request" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inter_module_get_request \-  im get with automatic request_module.
.SH SYNOPSIS
.B "const void *" inter_module_get_request
.BI "(const char *" im_name ","
.BI "const char *" modname ");"
.SH ARGUMENTS
.IP "im_name" 12
 an arbitrary string to identify the data, must be unique
.IP "modname" 12
 module that is expected to register im_name
.SH "DESCRIPTION"
 If inter_module_get fails, do request_module then retry.
.TH "inter_module_put" 9 "inter_module_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
inter_module_put \-  release use of data from another module.
.SH SYNOPSIS
.B "void" inter_module_put
.BI "(const char *" im_name ");"
.SH ARGUMENTS
.IP "im_name" 12
 an arbitrary string to identify the data, must be unique
.SH "DESCRIPTION"
 If the im_name has not been registered, complain,
otherwise decrement the use count on the owning module.
.TH "current_fs_time" 9 "current_fs_time" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
current_fs_time \-  Return FS time
.SH SYNOPSIS
.B "struct timespec" current_fs_time
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 Superblock.
.SH "DESCRIPTION"
Return the current time truncated to the time granuality supported by
the fs.
.TH "timespec_trunc" 9 "timespec_trunc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
timespec_trunc \-  Truncate timespec to a granuality
.SH SYNOPSIS
.B "struct timespec" timespec_trunc
.BI "(struct timespec " t ","
.BI "unsigned " gran ");"
.SH ARGUMENTS
.IP "t" 12
 Timespec
.IP "gran" 12
 Granuality in ns.
.SH "DESCRIPTION"
Truncate a timespec to a granuality. gran must be smaller than a second.
Always rounds down.

This function should be only used for timestamps returned by
\fBcurrent_kernel_time\fP or CURRENT_TIME, not with \fBdo_gettimeofday\fP because
it doesn't handle the better resolution of the later.
.TH "sys_capget" 9 "sys_capget" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_capget \-  get the capabilities of a given process.
.SH SYNOPSIS
.B "long" sys_capget
.BI "(cap_user_header_t " header ","
.BI "cap_user_data_t " dataptr ");"
.SH ARGUMENTS
.IP "header" 12
 pointer to struct that contains capability version and
target pid data
.IP "dataptr" 12
 pointer to struct that contains the effective, permitted,
and inheritable capabilities that are returned
.SH "DESCRIPTION"
Returns 0 on success and &lt; 0 on error.
.TH "sys_capset" 9 "sys_capset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_capset \-  set capabilities for a process or a group of processes
.SH SYNOPSIS
.B "long" sys_capset
.BI "(cap_user_header_t " header ","
.BI "const cap_user_data_t " data ");"
.SH ARGUMENTS
.IP "header" 12
 pointer to struct that contains capability version and
target pid data
.IP "data" 12
 pointer to struct that contains the effective, permitted,
and inheritable capabilities
.SH "DESCRIPTION"
Set capabilities for a given process, all processes, or all
processes in a given process group.
.SH "THE RESTRICTIONS ON SETTING CAPABILITIES ARE SPECIFIED AS"

[pid is for the 'target' task.  'current' is the calling task.]
.SH "I"
 any raised capabilities must be a subset of the (old current) permitted
.SH "P"
 any raised capabilities must be a subset of the (old current) permitted
.SH "E"
 must be set to a subset of (new target) permitted

Returns 0 on success and &lt; 0 on error.
.TH "add_preferred_console" 9 "add_preferred_console" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
add_preferred_console \-  add a device to the list of preferred consoles.
.SH SYNOPSIS
.B "int __init" add_preferred_console
.BI "(char *" name ","
.BI "int " idx ","
.BI "char *" options ");"
.SH ARGUMENTS
.IP "name" 12
-- undescribed --
.IP "idx" 12
-- undescribed --
.IP "options" 12
-- undescribed --
.SH "DESCRIPTION"

The last preferred console added will be used for kernel messages
and stdin/out/err for init.  Normally this is used by console_setup
above to handle user-supplied console arguments; however it can also
be used by arch-specific code either to override the user or more
commonly to provide a default console (ie from PROM variables) when
the user has not supplied one.
.TH "acquire_console_sem" 9 "acquire_console_sem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acquire_console_sem \-  lock the console system for exclusive use.
.SH SYNOPSIS
.B "void" acquire_console_sem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Acquires a semaphore which guarantees that the caller has
exclusive access to the console system and the console_drivers list.

Can sleep, returns nothing.
.TH "release_console_sem" 9 "release_console_sem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
release_console_sem \-  unlock the console system
.SH SYNOPSIS
.B "void" release_console_sem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Releases the semaphore which the caller holds on the console system
and the console driver list.

While the semaphore was held, console output may have been buffered
by \fBprintk\fP.  If this is the case, \fBrelease_console_sem\fP emits
the output prior to releasing the semaphore.

If there is output waiting for klogd, we wake it up.

\fBrelease_console_sem\fP may be called from any context.
.TH "tty_write_message" 9 "tty_write_message" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tty_write_message \-  write a message to a certain tty, not just the console.
.SH SYNOPSIS
.B "void" tty_write_message
.BI "(struct tty_struct *" tty ","
.BI "char *" msg ");"
.SH ARGUMENTS
.IP "tty" 12
-- undescribed --
.IP "msg" 12
-- undescribed --
.SH "DESCRIPTION"

This is used for messages that need to be redirected to a specific tty.
We don't put it into the syslog queue right now maybe in the future if
really needed.
.TH "copy_oldmem_page" 9 "copy_oldmem_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_oldmem_page \-  copy one page from "oldmem"
.SH SYNOPSIS
.B "ssize_t" copy_oldmem_page
.BI "(unsigned long " pfn ","
.BI "char *" buf ","
.BI "size_t " csize ","
.BI "unsigned long " offset ","
.BI "int " userbuf ");"
.SH ARGUMENTS
.IP "pfn" 12
 page frame number to be copied
.IP "buf" 12
 target memory address for the copy; this can be in kernel address
space or user address space (see \fIuserbuf\fP)
.IP "csize" 12
 number of bytes to copy
.IP "offset" 12
 offset in bytes into the page (based on pfn) to begin the copy
.IP "userbuf" 12
 if set, \fIbuf\fP is in user address space, use \fBcopy_to_user\fP,
otherwise \fIbuf\fP is in kernel address space, use \fBmemcpy\fP.
.SH "DESCRIPTION"
Copy a page from "oldmem". For this page, there is no pte mapped
in the current kernel. We stitch up a pte, similar to kmap_atomic.
.TH "power_down" 9 "power_down" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
power_down \-  Shut machine down for hibernate.
.SH SYNOPSIS
.B "void" power_down
.BI "(suspend_disk_method_t " mode ");"
.SH ARGUMENTS
.IP "mode" 12
		Suspend-to-disk mode
.SH "DESCRIPTION"
Use the platform driver, if configured so, and return gracefully if it
fails.
Otherwise, try to power off and reboot. If they fail, halt the machine,
there ain't no turning back.
.TH "free_some_memory" 9 "free_some_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_some_memory \-   Try to free as much memory as possible
.SH SYNOPSIS
.B "void" free_some_memory
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

... but do not OOM-kill anyone
.SH "NOTICE"
 all userland should be stopped at this point, or
livelock is possible.
.TH "pm_suspend_disk" 9 "pm_suspend_disk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_suspend_disk \-  The granpappy of power management.
.SH SYNOPSIS
.B "int" pm_suspend_disk
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

If we're going through the firmware, then get it over with quickly.

If not, then call swsusp to do its thing, then figure out how
to power down the system.
.TH "software_resume" 9 "software_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
software_resume \-  Resume from a saved image.
.SH SYNOPSIS
.B "int" software_resume
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Called as a late_initcall (so all devices are discovered and
initialized), we call swsusp to see if we have a saved image or not.
If so, we quiesce devices, the restore the saved image. We will
return above (in \fBpm_suspend_disk\fP ) if everything goes well.
Otherwise, we fail gracefully and return to the normally
scheduled program.
.TH "disk_show" 9 "disk_show" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disk_show \-  Control suspend-to-disk mode
.SH SYNOPSIS
.B "ssize_t" disk_show
.BI "(struct subsystem *" subsys ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "subsys" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"

Suspend-to-disk can be handled in several ways. The greatest
distinction is who writes memory to disk - the firmware or the OS.
If the firmware does it, we assume that it also handles suspending
the system.
If the OS does it, then we have three options for putting the system
to sleep - using the platform driver (e.g. ACPI or other PM registers),
powering off the system or rebooting the system (for testing).

The system will support either 'firmware' or 'platform', and that is
known a priori (and encoded in pm_ops). But, the user may choose
'shutdown' or 'reboot' as alternatives.

\fBshow\fP will display what the mode is currently set to.
\fBstore\fP will accept one of

'firmware'
'platform'
'shutdown'
'reboot'

It will only change to 'firmware' or 'platform' if the system
supports it (as determined from pm_ops-&gt;pm_disk_mode).
.TH "pm_set_ops" 9 "pm_set_ops" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_set_ops \-  Set the global power method table. 
.SH SYNOPSIS
.B "void" pm_set_ops
.BI "(struct pm_ops *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
	Pointer to ops structure.
.TH "suspend_prepare" 9 "suspend_prepare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
suspend_prepare \-  Do prep work before entering low-power state.
.SH SYNOPSIS
.B "int" suspend_prepare
.BI "(suspend_state_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		State we're entering.
.SH "DESCRIPTION"
This is common code that is called for each state that we're 
entering. Allocate a console, stop all processes, then make sure
the platform can enter the requested state.
.TH "suspend_finish" 9 "suspend_finish" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
suspend_finish \-  Do final work before exiting suspend sequence.
.SH SYNOPSIS
.B "void" suspend_finish
.BI "(suspend_state_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		State we're coming out of.
.SH "DESCRIPTION"
Call platform code to clean up, restart processes, and free the 
console that we've allocated. This is not called for suspend-to-disk.
.TH "enter_state" 9 "enter_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enter_state \-  Do common work of entering low-power state.
.SH SYNOPSIS
.B "int" enter_state
.BI "(suspend_state_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		pm_state structure for state we're entering.
.SH "DESCRIPTION"
Make sure we're the only ones trying to enter a sleep state. Fail
if someone has beat us to it, since we don't want anything weird to
happen when we wake up.
Then, do the setup for suspend, enter the state, and cleaup (after
we've woken up).
.TH "pm_suspend" 9 "pm_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_suspend \-  Externally visible function for suspending system.
.SH SYNOPSIS
.B "int" pm_suspend
.BI "(suspend_state_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		Enumarted value of state to enter.
.SH "DESCRIPTION"
Determine whether or not value is within range, get state 
structure, and enter (above).
.TH "state_show" 9 "state_show" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
state_show \-  control system power state.
.SH SYNOPSIS
.B "ssize_t" state_show
.BI "(struct subsystem *" subsys ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "subsys" 12
-- undescribed --
.IP "buf" 12
-- undescribed --
.SH "DESCRIPTION"

\fBshow\fP returns what states are supported, which is hard-coded to
'standby' (Power-On Suspend), 'mem' (Suspend-to-RAM), and
'disk' (Suspend-to-Disk).

\fBstore\fP accepts one of those strings, translates it into the 
proper enumerated value, and initiates a suspend transition.
.TH "pm_register" 9 "pm_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_register \-  register a device with power management
.SH SYNOPSIS
.B "struct pm_dev *" pm_register
.BI "(pm_dev_t " type ","
.BI "unsigned long " id ","
.BI "pm_callback " callback ");"
.SH ARGUMENTS
.IP "type" 12
 device type 
.IP "id" 12
 device ID
.IP "callback" 12
 callback function
.SH "DESCRIPTION"
Add a device to the list of devices that wish to be notified about
power management events. A &amp;pm_dev structure is returned on success,
on failure the return is NULL.

The callback function will be called in process context and
it may sleep.
.TH "pm_unregister" 9 "pm_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_unregister \-   unregister a device with power management
.SH SYNOPSIS
.B "void" pm_unregister
.BI "(struct pm_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device to unregister
.SH "DESCRIPTION"
Remove a device from the power management notification lists. The
dev passed must be a handle previously returned by pm_register.
.TH "pm_unregister_all" 9 "pm_unregister_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_unregister_all \-  unregister all devices with matching callback
.SH SYNOPSIS
.B "void" pm_unregister_all
.BI "(pm_callback " callback ");"
.SH ARGUMENTS
.IP "callback" 12
 callback function pointer
.SH "DESCRIPTION"
Unregister every device that would call the callback passed. This
is primarily meant as a helper function for loadable modules. It
enables a module to give up all its managed devices without keeping
its own private list.
.TH "pm_send" 9 "pm_send" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_send \-  send request to a single device
.SH SYNOPSIS
.B "int" pm_send
.BI "(struct pm_dev *" dev ","
.BI "pm_request_t " rqst ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "dev" 12
 device to send to
.IP "rqst" 12
 power management request
.IP "data" 12
 data for the callback
.SH "DESCRIPTION"
Issue a power management request to a given device. The 
PM_SUSPEND and PM_RESUME events are handled specially. The
data field must hold the intended next state. No call is made
if the state matches.
.SH "BUGS"
 what stops two power management requests occurring in parallel
and conflicting.
.SH "WARNING"
 Calling pm_send directly is not generally recommended, in
particular there is no locking against the pm_dev going away. The
caller must maintain all needed locking or have 'inside knowledge'
on the safety. Also remember that this function is not locked against
pm_unregister. This means that you must handle SMP races on callback
execution and unload yourself.
.TH "pm_send_all" 9 "pm_send_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pm_send_all \-  send request to all managed devices
.SH SYNOPSIS
.B "int" pm_send_all
.BI "(pm_request_t " rqst ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "rqst" 12
 power management request
.IP "data" 12
 data for the callback
.SH "DESCRIPTION"
Issue a power management request to a all devices. The 
PM_SUSPEND events are handled specially. Any device is 
permitted to fail a suspend by returning a non zero (error)
value from its callback function. If any device vetoes a 
suspend request then all other devices that have suspended 
during the processing of this request are restored to their
previous state.
.SH "WARNING"
  This function takes the pm_devs_lock. The lock is not dropped until
the callbacks have completed. This prevents races against pm locking
functions, races against module unload pm_unregister code. It does
mean however that you must not issue pm_ functions within the callback
or you will deadlock and users will hate you.

Zero is returned on success. If a suspend fails then the status
from the device that vetoes the suspend is returned.
.SH "BUGS"
 what stops two power management requests occurring in parallel
and conflicting.
.TH "get_task_mm" 9 "get_task_mm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_task_mm \-  acquire a reference to the task's mm
.SH SYNOPSIS
.B "struct mm_struct *" get_task_mm
.BI "(struct task_struct *" task ");"
.SH ARGUMENTS
.IP "task" 12
-- undescribed --
.SH "DESCRIPTION"

Returns NULL if the task has no mm.  Checks PF_BORROWED_MM (meaning
this kernel workthread has transiently adopted a user mm with use_mm,
to do its AIO) is not set and if so returns a reference to it, after
bumping up the use count.  User must release the mm via \fBmmput\fP
after use.  Typically used by /proc and ptrace.
.TH "insert_resource" 9 "insert_resource" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
insert_resource \-  Inserts a resource in the resource tree
.SH SYNOPSIS
.B "int" insert_resource
.BI "(struct resource *" parent ","
.BI "struct resource *" new ");"
.SH ARGUMENTS
.IP "parent" 12
 parent of the new resource
.IP "new" 12
 new resource to insert
.SH "DESCRIPTION"
Returns 0 on success, -EBUSY if the resource can't be inserted.

This function is equivalent of request_resource when no conflict
happens. If a conflict happens, and the conflicting resources
entirely fit within the range of the new resource, then the new
resource is inserted and the conflicting resources become childs of
the new resource.  Otherwise the new resource becomes the child of
the conflicting resource
.TH "cpuset_init" 9 "cpuset_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_init \-  initialize cpusets at system boot
.SH SYNOPSIS
.B "int __init" cpuset_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
 Initialize top_cpuset and the cpuset internal file system,
.SH "DESCRIPTION"
 Initialize top_cpuset and the cpuset internal file system,
.TH "cpuset_init_smp" 9 "cpuset_init_smp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_init_smp \-  initialize cpus_allowed
.SH SYNOPSIS
.B "void __init" cpuset_init_smp
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
 Finish top cpuset after cpu, node maps are initialized
.SH "DESCRIPTION"
 Finish top cpuset after cpu, node maps are initialized
.TH "cpuset_fork" 9 "cpuset_fork" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_fork \-  attach newly forked task to its parents cpuset.
.SH SYNOPSIS
.B "void" cpuset_fork
.BI "(struct task_struct *" tsk ");"
.SH ARGUMENTS
.IP "tsk" 12
 pointer to task_struct of forking parent process.
.SH "DESCRIPTION"
 By default, on fork, a task inherits its
parent's cpuset.  The pointer to the shared cpuset is
automatically copied in fork.c by \fBdup_task_struct\fP.
This \fBcpuset_fork\fP routine need only increment the usage
counter in that cpuset.
.TH "cpuset_exit" 9 "cpuset_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_exit \-  detach cpuset from exiting task
.SH SYNOPSIS
.B "void" cpuset_exit
.BI "(struct task_struct *" tsk ");"
.SH ARGUMENTS
.IP "tsk" 12
 pointer to task_struct of exiting process
.SH "DESCRIPTION"
 Detach cpuset from \fItsk\fP and release it.

Note that cpusets marked notify_on_release force every task
in them to take the global cpuset_sem semaphore when exiting.
This could impact scaling on very large systems.  Be reluctant
to use notify_on_release cpusets where very high task exit
scaling is required on large systems.

Don't even think about derefencing 'cs' after the cpuset use
count goes to zero, except inside a critical section guarded
by the cpuset_sem semaphore.  If you don't hold cpuset_sem,
then a zero cpuset use count is a license to any other task to
nuke the cpuset immediately.
.TH "cpuset_cpus_allowed" 9 "cpuset_cpus_allowed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_cpus_allowed \-  return cpus_allowed mask from a tasks cpuset.
.SH SYNOPSIS
.B "cpumask_t" cpuset_cpus_allowed
.BI "(const struct task_struct *" tsk ");"
.SH ARGUMENTS
.IP "tsk" 12
 pointer to task_struct from which to obtain cpuset-&gt;cpus_allowed.
.SH "DESCRIPTION"
 Returns the cpumask_t cpus_allowed of the cpuset
attached to the specified \fItsk\fP.  Guaranteed to return some non-empty
subset of cpu_online_map, even if this means going outside the
tasks cpuset.
.TH "cpuset_update_current_mems_allowed" 9 "cpuset_update_current_mems_allowed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_update_current_mems_allowed \-  update mems parameters to new values
.SH SYNOPSIS
.B "void" cpuset_update_current_mems_allowed
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

If the current tasks cpusets mems_allowed changed behind our backs,
update current-&gt;mems_allowed and mems_generation to the new value.
Do not call this routine if \fBin_interrupt\fP.
.TH "cpuset_restrict_to_mems_allowed" 9 "cpuset_restrict_to_mems_allowed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_restrict_to_mems_allowed \-  limit nodes to current mems_allowed
.SH SYNOPSIS
.B "void" cpuset_restrict_to_mems_allowed
.BI "(unsigned long *" nodes ");"
.SH ARGUMENTS
.IP "nodes" 12
 pointer to a node bitmap that is and-ed with mems_allowed
.TH "cpuset_zonelist_valid_mems_allowed" 9 "cpuset_zonelist_valid_mems_allowed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_zonelist_valid_mems_allowed \-  check zonelist vs. curremt mems_allowed
.SH SYNOPSIS
.B "int" cpuset_zonelist_valid_mems_allowed
.BI "(struct zonelist *" zl ");"
.SH ARGUMENTS
.IP "zl" 12
 the zonelist to be checked
.SH "DESCRIPTION"
Are any of the nodes on zonelist zl allowed in current-&gt;mems_allowed?
.TH "cpuset_zone_allowed" 9 "cpuset_zone_allowed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_zone_allowed \-  Can we allocate memory on zone z's memory node?
.SH SYNOPSIS
.B "int" cpuset_zone_allowed
.BI "(struct zone *" z ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "z" 12
 is this zone on an allowed node?
.IP "gfp_mask" 12
 memory allocation flags (we use __GFP_HARDWALL)
.SH "DESCRIPTION"
If we're in interrupt, yes, we can always allocate.  If zone
z's node is in our tasks mems_allowed, yes.  If it's not a
__GFP_HARDWALL request and this zone's nodes is in the nearest
mem_exclusive cpuset ancestor to this tasks cpuset, yes.
Otherwise, no.

GFP_USER allocations are marked with the __GFP_HARDWALL bit,
and do not allow allocations outside the current tasks cpuset.
GFP_KERNEL allocations are not so marked, so can escape to the
nearest mem_exclusive ancestor cpuset.

Scanning up parent cpusets requires cpuset_sem.  The \fB__alloc_pages\fP
routine only calls here with __GFP_HARDWALL bit _not_ set if
it's a GFP_KERNEL allocation, and all nodes in the current tasks
mems_allowed came up empty on the first pass over the zonelist.
So only GFP_KERNEL allocations, if all nodes in the cpuset are
short of memory, might require taking the cpuset_sem semaphore.

The first loop over the zonelist in mm/page_alloc.c:\fB__alloc_pages\fP
calls here with __GFP_HARDWALL always set in gfp_mask, enforcing
hardwall cpusets - no allocation on a node outside the cpuset is
allowed (unless in interrupt, of course).

The second loop doesn't even call here for GFP_ATOMIC requests
(if the \fB__alloc_pages\fP local variable 'wait' is set).  That check
and the checks below have the combined affect in the second loop of
the \fB__alloc_pages\fP routine that:
in_interrupt - any node ok (current task context irrelevant)
GFP_ATOMIC   - any node ok
GFP_KERNEL   - any node in enclosing mem_exclusive cpuset ok
GFP_USER     - only nodes in current tasks mems allowed ok.
.TH "cpuset_excl_nodes_overlap" 9 "cpuset_excl_nodes_overlap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cpuset_excl_nodes_overlap \-  Do we overlap @p's mem_exclusive ancestors?
.SH SYNOPSIS
.B "int" cpuset_excl_nodes_overlap
.BI "(const struct task_struct *" p ");"
.SH ARGUMENTS
.IP "p" 12
 pointer to task_struct of some other task.
.SH "DESCRIPTION"
 Return true if the nearest mem_exclusive ancestor
cpusets of tasks \fIp\fP and current overlap.  Used by oom killer to
determine if task \fIp\fP's memory usage might impact the memory
available to the current task.

Acquires cpuset_sem - not suitable for calling from a fast path.
.TH "kfifo_init" 9 "kfifo_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfifo_init \-  allocates a new FIFO using a preallocated buffer
.SH SYNOPSIS
.B "struct kfifo *" kfifo_init
.BI "(unsigned char *" buffer ","
.BI "unsigned int " size ","
.BI "gfp_t " gfp_mask ","
.BI "spinlock_t *" lock ");"
.SH ARGUMENTS
.IP "buffer" 12
 the preallocated buffer to be used.
.IP "size" 12
 the size of the internal buffer, this have to be a power of 2.
.IP "gfp_mask" 12
 get_free_pages mask, passed to \fBkmalloc\fP
.IP "lock" 12
 the lock to be used to protect the fifo buffer
.SH "DESCRIPTION"
Do NOT pass the kfifo to \fBkfifo_free\fP after use ! Simply free the
struct kfifo with \fBkfree\fP.
.TH "kfifo_alloc" 9 "kfifo_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfifo_alloc \-  allocates a new FIFO and its internal buffer
.SH SYNOPSIS
.B "struct kfifo *" kfifo_alloc
.BI "(unsigned int " size ","
.BI "gfp_t " gfp_mask ","
.BI "spinlock_t *" lock ");"
.SH ARGUMENTS
.IP "size" 12
 the size of the internal buffer to be allocated.
.IP "gfp_mask" 12
 get_free_pages mask, passed to \fBkmalloc\fP
.IP "lock" 12
 the lock to be used to protect the fifo buffer
.SH "DESCRIPTION"
The size will be rounded-up to a power of 2.
.TH "kfifo_free" 9 "kfifo_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfifo_free \-  frees the FIFO
.SH SYNOPSIS
.B "void" kfifo_free
.BI "(struct kfifo *" fifo ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be freed.
.TH "__kfifo_put" 9 "__kfifo_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__kfifo_put \-  puts some data into the FIFO, no locking version
.SH SYNOPSIS
.B "unsigned int" __kfifo_put
.BI "(struct kfifo *" fifo ","
.BI "unsigned char *" buffer ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be used.
.IP "buffer" 12
 the data to be added.
.IP "len" 12
 the length of the data to be added.
.SH "DESCRIPTION"
This function copies at most 'len' bytes from the 'buffer' into
the FIFO depending on the free space, and returns the number of
bytes copied.

Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these functions.
.TH "__kfifo_get" 9 "__kfifo_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__kfifo_get \-  gets some data from the FIFO, no locking version
.SH SYNOPSIS
.B "unsigned int" __kfifo_get
.BI "(struct kfifo *" fifo ","
.BI "unsigned char *" buffer ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "fifo" 12
 the fifo to be used.
.IP "buffer" 12
 where the data must be copied.
.IP "len" 12
 the size of the destination buffer.
.SH "DESCRIPTION"
This function copies at most 'len' bytes from the FIFO into the
'buffer' and returns the number of copied bytes.

Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these functions.
.TH "task_curr" 9 "task_curr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
task_curr \-  is this task currently executing on a CPU?
.SH SYNOPSIS
.B "int" task_curr
.BI "(const task_t *" p ");"
.SH ARGUMENTS
.IP "p" 12
 the task in question.
.TH "prepare_task_switch" 9 "prepare_task_switch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
prepare_task_switch \-  prepare to switch tasks
.SH SYNOPSIS
.B "void" prepare_task_switch
.BI "(runqueue_t *" rq ","
.BI "task_t *" next ");"
.SH ARGUMENTS
.IP "rq" 12
 the runqueue preparing to switch
.IP "next" 12
 the task we are going to switch to.
.SH "DESCRIPTION"
This is called with the rq lock held and interrupts off. It must
be paired with a subsequent finish_task_switch after the context
switch.

prepare_task_switch sets up locking and calls architecture specific
hooks.
.TH "finish_task_switch" 9 "finish_task_switch" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
finish_task_switch \-  clean up after a task-switch
.SH SYNOPSIS
.B "void" finish_task_switch
.BI "(runqueue_t *" rq ","
.BI "task_t *" prev ");"
.SH ARGUMENTS
.IP "rq" 12
 runqueue associated with task-switch
.IP "prev" 12
 the thread we just switched away from.
.SH "DESCRIPTION"
finish_task_switch must be called after the context switch, paired
with a prepare_task_switch call before the context switch.
finish_task_switch will reconcile locking set up by prepare_task_switch,
and do any other architecture-specific cleanup actions.

Note that we may have delayed dropping an mm in \fBcontext_switch\fP. If
so, we finish that here outside of the runqueue lock.  (Doing it
with the lock held can cause deadlocks; see \fBschedule\fP for
details.)
.TH "schedule_tail" 9 "schedule_tail" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
schedule_tail \-  first thing a freshly forked thread must call.
.SH SYNOPSIS
.B "void" schedule_tail
.BI "(task_t *" prev ");"
.SH ARGUMENTS
.IP "prev" 12
 the thread we just switched away from.
.TH "__wake_up" 9 "__wake_up" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__wake_up \-  wake up threads blocked on a waitqueue.
.SH SYNOPSIS
.B "void fastcall" __wake_up
.BI "(wait_queue_head_t *" q ","
.BI "unsigned int " mode ","
.BI "int " nr_exclusive ","
.BI "void *" key ");"
.SH ARGUMENTS
.IP "q" 12
 the waitqueue
.IP "mode" 12
 which threads
.IP "nr_exclusive" 12
 how many wake-one or wake-many threads to wake up
.IP "key" 12
 is directly passed to the wakeup function
.TH "__wake_up_sync" 9 "__wake_up_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__wake_up_sync \-  wake up threads blocked on a waitqueue.
.SH SYNOPSIS
.B "void fastcall" __wake_up_sync
.BI "(wait_queue_head_t *" q ","
.BI "unsigned int " mode ","
.BI "int " nr_exclusive ");"
.SH ARGUMENTS
.IP "q" 12
 the waitqueue
.IP "mode" 12
 which threads
.IP "nr_exclusive" 12
 how many wake-one or wake-many threads to wake up
.SH "DESCRIPTION"
The sync wakeup differs that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are 'synchronized'
with each other. This can prevent needless bouncing between CPUs.

On UP it can prevent extra preemption.
.TH "task_prio" 9 "task_prio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
task_prio \-  return the priority value of a given task.
.SH SYNOPSIS
.B "int" task_prio
.BI "(const task_t *" p ");"
.SH ARGUMENTS
.IP "p" 12
 the task in question.
.SH "DESCRIPTION"
This is the priority value as seen by users in /proc.
RT tasks are offset by -200. Normal tasks are centered
around 0, value goes from -16 to +15.
.TH "task_nice" 9 "task_nice" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
task_nice \-  return the nice value of a given task.
.SH SYNOPSIS
.B "int" task_nice
.BI "(const task_t *" p ");"
.SH ARGUMENTS
.IP "p" 12
 the task in question.
.TH "idle_cpu" 9 "idle_cpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idle_cpu \-  is a given cpu idle currently?
.SH SYNOPSIS
.B "int" idle_cpu
.BI "(int " cpu ");"
.SH ARGUMENTS
.IP "cpu" 12
 the processor in question.
.TH "idle_task" 9 "idle_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
idle_task \-  return the idle task for a given cpu.
.SH SYNOPSIS
.B "task_t *" idle_task
.BI "(int " cpu ");"
.SH ARGUMENTS
.IP "cpu" 12
 the processor in question.
.TH "find_process_by_pid" 9 "find_process_by_pid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_process_by_pid \-  find a process with a matching PID value.
.SH SYNOPSIS
.B "task_t *" find_process_by_pid
.BI "(pid_t " pid ");"
.SH ARGUMENTS
.IP "pid" 12
 the pid in question.
.TH "sched_setscheduler" 9 "sched_setscheduler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sched_setscheduler \-  change the scheduling policy and/or RT priority of
.SH SYNOPSIS
.B "int" sched_setscheduler
.BI "(struct task_struct *" p ","
.BI "int " policy ","
.BI "struct sched_param *" param ");"
.SH ARGUMENTS
.IP "p" 12
 the task in question.
.IP "policy" 12
 new policy.
.IP "param" 12
 structure containing the new RT priority.
.SH "DESCRIPTION"
a thread.
.TH "sys_sched_setscheduler" 9 "sys_sched_setscheduler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_setscheduler \-  set/change the scheduler policy and RT priority
.SH SYNOPSIS
.B "long" sys_sched_setscheduler
.BI "(pid_t " pid ","
.BI "int " policy ","
.BI "struct sched_param __user *" param ");"
.SH ARGUMENTS
.IP "pid" 12
 the pid in question.
.IP "policy" 12
 new policy.
.IP "param" 12
 structure containing the new RT priority.
.TH "sys_sched_setparam" 9 "sys_sched_setparam" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_setparam \-  set/change the RT priority of a thread
.SH SYNOPSIS
.B "long" sys_sched_setparam
.BI "(pid_t " pid ","
.BI "struct sched_param __user *" param ");"
.SH ARGUMENTS
.IP "pid" 12
 the pid in question.
.IP "param" 12
 structure containing the new RT priority.
.TH "sys_sched_getscheduler" 9 "sys_sched_getscheduler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_getscheduler \-  get the policy (scheduling class) of a thread
.SH SYNOPSIS
.B "long" sys_sched_getscheduler
.BI "(pid_t " pid ");"
.SH ARGUMENTS
.IP "pid" 12
 the pid in question.
.TH "sys_sched_getparam" 9 "sys_sched_getparam" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_getparam \-  get the RT priority of a thread
.SH SYNOPSIS
.B "long" sys_sched_getparam
.BI "(pid_t " pid ","
.BI "struct sched_param __user *" param ");"
.SH ARGUMENTS
.IP "pid" 12
 the pid in question.
.IP "param" 12
 structure containing the RT priority.
.TH "sys_sched_setaffinity" 9 "sys_sched_setaffinity" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_setaffinity \-  set the cpu affinity of a process
.SH SYNOPSIS
.B "long" sys_sched_setaffinity
.BI "(pid_t " pid ","
.BI "unsigned int " len ","
.BI "unsigned long __user *" user_mask_ptr ");"
.SH ARGUMENTS
.IP "pid" 12
 pid of the process
.IP "len" 12
 length in bytes of the bitmask pointed to by user_mask_ptr
.IP "user_mask_ptr" 12
 user-space pointer to the new cpu mask
.TH "sys_sched_getaffinity" 9 "sys_sched_getaffinity" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_getaffinity \-  get the cpu affinity of a process
.SH SYNOPSIS
.B "long" sys_sched_getaffinity
.BI "(pid_t " pid ","
.BI "unsigned int " len ","
.BI "unsigned long __user *" user_mask_ptr ");"
.SH ARGUMENTS
.IP "pid" 12
 pid of the process
.IP "len" 12
 length in bytes of the bitmask pointed to by user_mask_ptr
.IP "user_mask_ptr" 12
 user-space pointer to hold the current cpu mask
.TH "sys_sched_yield" 9 "sys_sched_yield" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_yield \-  yield the current processor to other threads.
.SH SYNOPSIS
.B "long" sys_sched_yield
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

this function yields the current CPU by moving the calling thread
to the expired array. If there are no other threads running on this
CPU then this function will return.
.TH "yield" 9 "yield" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
yield \-  yield the current processor to other threads.
.SH SYNOPSIS
.B "void __sched" yield
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

this is a shortcut for kernel-space yielding - it marks the
thread runnable and calls \fBsys_sched_yield\fP.
.TH "sys_sched_get_priority_max" 9 "sys_sched_get_priority_max" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_get_priority_max \-  return maximum RT priority.
.SH SYNOPSIS
.B "long" sys_sched_get_priority_max
.BI "(int " policy ");"
.SH ARGUMENTS
.IP "policy" 12
 scheduling class.
.SH "DESCRIPTION"
this syscall returns the maximum rt_priority that can be used
by a given scheduling class.
.TH "sys_sched_get_priority_min" 9 "sys_sched_get_priority_min" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_get_priority_min \-  return minimum RT priority.
.SH SYNOPSIS
.B "long" sys_sched_get_priority_min
.BI "(int " policy ");"
.SH ARGUMENTS
.IP "policy" 12
 scheduling class.
.SH "DESCRIPTION"
this syscall returns the minimum rt_priority that can be used
by a given scheduling class.
.TH "sys_sched_rr_get_interval" 9 "sys_sched_rr_get_interval" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_sched_rr_get_interval \-  return the default timeslice of a process.
.SH SYNOPSIS
.B "long" sys_sched_rr_get_interval
.BI "(pid_t " pid ","
.BI "struct timespec __user *" interval ");"
.SH ARGUMENTS
.IP "pid" 12
 pid of the process.
.IP "interval" 12
 userspace pointer to the timeslice value.
.SH "DESCRIPTION"
this syscall writes the default timeslice value of a given process
into the user-space timespec buffer. A value of '0' means infinity.
.TH "init_idle" 9 "init_idle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_idle \-  set up an idle thread for a given CPU
.SH SYNOPSIS
.B "void __devinit" init_idle
.BI "(task_t *" idle ","
.BI "int " cpu ");"
.SH ARGUMENTS
.IP "idle" 12
 task in question
.IP "cpu" 12
 cpu the idle task belongs to
.SH "NOTE"
 this function does not set the idle thread's NEED_RESCHED
flag, to make booting more robust.
.TH "find_next_best_node" 9 "find_next_best_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_best_node \-  find the next node to include in a sched_domain
.SH SYNOPSIS
.B "int" find_next_best_node
.BI "(int " node ","
.BI "unsigned long *" used_nodes ");"
.SH ARGUMENTS
.IP "node" 12
 node whose sched_domain we're building
.IP "used_nodes" 12
 nodes already in the sched_domain
.SH "DESCRIPTION"
Find the next node to include in a given scheduling domain.  Simply
finds the closest node not already in the \fIused_nodes\fP map.

Should use nodemask_t.
.TH "sched_domain_node_span" 9 "sched_domain_node_span" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sched_domain_node_span \-  get a cpumask for a node's sched_domain
.SH SYNOPSIS
.B "cpumask_t" sched_domain_node_span
.BI "(int " node ");"
.SH ARGUMENTS
.IP "node" 12
 node whose cpumask we're constructing
.SH "DESCRIPTION"
Given a node, construct a good cpumask for its sched_domain to span.  It
should be one that prevents unnecessary balancing, but also spreads tasks
out optimally.
.TH "curr_task" 9 "curr_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
curr_task \-  return the current task for a given cpu.
.SH SYNOPSIS
.B "task_t *" curr_task
.BI "(int " cpu ");"
.SH ARGUMENTS
.IP "cpu" 12
 the processor in question.
.SH "DESCRIPTION"
ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
.TH "set_curr_task" 9 "set_curr_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_curr_task \-  set the current task for a given cpu.
.SH SYNOPSIS
.B "void" set_curr_task
.BI "(int " cpu ","
.BI "task_t *" p ");"
.SH ARGUMENTS
.IP "cpu" 12
 the processor in question.
.IP "p" 12
 the task pointer to set.
.SH "DESCRIPTION"
 This function must only be used when non-maskable interrupts
are serviced on a separate stack.  It allows the architecture to switch the
notion of the current task on a cpu in a non-blocking manner.  This function
must be called with all CPU's synchronized, and interrupts disabled, the
and caller must save the original value of the current task (see
\fBcurr_task\fP above) and restore that value before reenabling interrupts and
re-starting the system.

ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
.TH "sys_acct" 9 "sys_acct" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sys_acct \-  enable/disable process accounting
.SH SYNOPSIS
.B "long" sys_acct
.BI "(const char __user *" name ");"
.SH ARGUMENTS
.IP "name" 12
 file name for accounting records or NULL to shutdown accounting
.SH "DESCRIPTION"
Returns 0 for success or negative errno values for failure.

\fBsys_acct\fP is the only system call needed to implement process
accounting. It takes the name of the file where accounting records
should be written. If the filename is NULL, accounting will be
shutdown.
.TH "acct_auto_close" 9 "acct_auto_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acct_auto_close \-  turn off a filesystem's accounting if it is on
.SH SYNOPSIS
.B "void" acct_auto_close
.BI "(struct super_block *" sb ");"
.SH ARGUMENTS
.IP "sb" 12
 super block for the filesystem
.SH "DESCRIPTION"
If the accounting is turned on for a file in the filesystem pointed
to by sb, turn accounting off.
.TH "acct_process" 9 "acct_process" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acct_process \-  now just a wrapper around do_acct_process
.SH SYNOPSIS
.B "void" acct_process
.BI "(long " exitcode ");"
.SH ARGUMENTS
.IP "exitcode" 12
 task exit code
.SH "DESCRIPTION"
handles process accounting for an exiting task
.TH "acct_update_integrals" 9 "acct_update_integrals" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acct_update_integrals \-  update mm integral fields in task_struct
.SH SYNOPSIS
.B "void" acct_update_integrals
.BI "(struct task_struct *" tsk ");"
.SH ARGUMENTS
.IP "tsk" 12
 task_struct for accounting
.TH "acct_clear_integrals" 9 "acct_clear_integrals" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acct_clear_integrals \-  clear the mm integral fields in task_struct
.SH SYNOPSIS
.B "void" acct_clear_integrals
.BI "(struct task_struct *" tsk ");"
.SH ARGUMENTS
.IP "tsk" 12
 task_struct whose accounting fields are cleared
.TH "call_rcu" 9 "call_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
call_rcu \-  Queue an RCU callback for invocation after a grace period.
.SH SYNOPSIS
.B "void fastcall" call_rcu
.BI "(struct rcu_head *" head ","
.BI "void (*" func ") (struct rcu_head *rcu));"
.SH ARGUMENTS
.IP "head" 12
 structure to be used for queueing the RCU updates.
.IP "func" 12
 actual update function to be invoked after the grace period
.SH "DESCRIPTION"
The update function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed.  RCU read-side critical
sections are delimited by \fBrcu_read_lock\fP and \fBrcu_read_unlock\fP,
and may be nested.
.TH "call_rcu_bh" 9 "call_rcu_bh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
call_rcu_bh \-  Queue an RCU for invocation after a quicker grace period.
.SH SYNOPSIS
.B "void fastcall" call_rcu_bh
.BI "(struct rcu_head *" head ","
.BI "void (*" func ") (struct rcu_head *rcu));"
.SH ARGUMENTS
.IP "head" 12
 structure to be used for queueing the RCU updates.
.IP "func" 12
 actual update function to be invoked after the grace period
.SH "DESCRIPTION"
The update function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. \fBcall_rcu_bh\fP assumes
that the read-side critical sections end on completion of a softirq
handler. This means that read-side critical sections in process
context must not be interrupted by softirqs. This interface is to be
used when most of the read-side critical sections are in softirq context.
RCU read-side critical sections are delimited by \fBrcu_read_lock\fP and
\fBrcu_read_unlock\fP, * if in interrupt context or \fBrcu_read_lock_bh\fP
and \fBrcu_read_unlock_bh\fP, if in process context. These may be nested.
.TH "synchronize_rcu" 9 "synchronize_rcu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
synchronize_rcu \-  wait until a grace period has elapsed.
.SH SYNOPSIS
.B "void" synchronize_rcu
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Control will return to the caller some time after a full grace
period has elapsed, in other words after all currently executing RCU
read-side critical sections have completed.  RCU read-side critical
sections are delimited by \fBrcu_read_lock\fP and \fBrcu_read_unlock\fP,
and may be nested.

If your read-side code is not protected by \fBrcu_read_lock\fP, do -not-
use \fBsynchronize_rcu\fP.
.TH "synchronize_irq" 9 "synchronize_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
synchronize_irq \-  wait for pending IRQ handlers (on other CPUs)
.SH SYNOPSIS
.B "void" synchronize_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.SH "DESCRIPTION"

This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.

This function may be called - with care - from IRQ context.
.TH "disable_irq_nosync" 9 "disable_irq_nosync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq_nosync \-  disable an irq without waiting
.SH SYNOPSIS
.B "void" disable_irq_nosync
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line.  Disables and Enables are
nested.
Unlike \fBdisable_irq\fP, this function does not ensure existing
instances of the IRQ handler have completed before returning.

This function may be called from IRQ context.
.TH "disable_irq" 9 "disable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq \-  disable an irq and wait for completion
.SH SYNOPSIS
.B "void" disable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.

This function may be called - with care - from IRQ context.
.TH "enable_irq" 9 "enable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_irq \-  enable handling of an irq
.SH SYNOPSIS
.B "void" enable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to enable
.SH "DESCRIPTION"
Undoes the effect of one call to \fBdisable_irq\fP.  If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.

This function may be called from IRQ context.
.TH "free_irq" 9 "free_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_irq \-  free an interrupt
.SH SYNOPSIS
.B "void" free_irq
.BI "(unsigned int " irq ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to free
.IP "dev_id" 12
 Device identity to free
.SH "DESCRIPTION"
Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.

This function must not be called from interrupt context.
.TH "request_irq" 9 "request_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
request_irq \-  allocate an interrupt line
.SH SYNOPSIS
.B "int" request_irq
.BI "(unsigned int " irq ","
.BI "irqreturn_t (*" handler ") (int, void *, struct pt_regs *),"
.BI "unsigned long " irqflags ","
.BI "const char *" devname ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to allocate
.IP "handler" 12
 Function to be called when the IRQ occurs
.IP "irqflags" 12
 Interrupt type flags
.IP "devname" 12
 An ascii name for the claiming device
.IP "dev_id" 12
 A cookie passed back to the handler function
.SH "DESCRIPTION"
This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.

Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.

If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.
.SH "FLAGS"

SA_SHIRQ		Interrupt is shared
SA_INTERRUPT		Disable local interrupts while processing
SA_SAMPLE_RANDOM	The interrupt can be used for entropy
.TH "probe_irq_on" 9 "probe_irq_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_on \-  begin an interrupt autodetect
.SH SYNOPSIS
.B "unsigned long" probe_irq_on
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Commence probing for an interrupt. The interrupts are scanned
and a mask of potential interrupt lines is returned.
.TH "probe_irq_mask" 9 "probe_irq_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_mask \-  scan a bitmap of interrupt lines
.SH SYNOPSIS
.B "unsigned int" probe_irq_mask
.BI "(unsigned long " val ");"
.SH ARGUMENTS
.IP "val" 12
	mask of interrupts to consider
.SH "DESCRIPTION"
Scan the interrupt lines and return a bitmap of active
autodetect interrupts. The interrupt probe logic state
is then returned to its previous value.
.SH "NOTE"
 we need to scan all the irq's even though we will
only return autodetect irq numbers - just so that we reset
them all to a known state.
.TH "probe_irq_off" 9 "probe_irq_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_off \-  end an interrupt autodetect
.SH SYNOPSIS
.B "int" probe_irq_off
.BI "(unsigned long " val ");"
.SH ARGUMENTS
.IP "val" 12
 mask of potential interrupts (unused)
.SH "DESCRIPTION"
Scans the unused interrupt lines and returns the line which
appears to have triggered the interrupt. If no interrupt was
found then zero is returned. If more than one interrupt is
found then minus the first candidate is returned to indicate
their is doubt.

The interrupt probe logic state is returned to its previous
value.
.SH "BUGS"
 When used in a module (which arguably shouldn't happen)
nothing prevents two IRQ probe callers from overlapping. The
results of this are non-optimal.
.TH "security_init" 9 "security_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_init \-  initializes the security framework
.SH SYNOPSIS
.B "int __init" security_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This should be called early in the kernel initialization sequence.
.TH "register_security" 9 "register_security" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_security \-  registers a security framework with the kernel
.SH SYNOPSIS
.B "int" register_security
.BI "(struct security_operations *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
 a pointer to the struct security_options that is to be registered
.SH "DESCRIPTION"
This function is to allow a security module to register itself with the
kernel security subsystem.  Some rudimentary checking is done on the \fIops\fP
value passed to this function.  A call to \fBunregister_security\fP should be
done to remove this security_options structure from the kernel.

If there is already a security module registered with the kernel,
an error will be returned.  Otherwise 0 is returned on success.
.TH "unregister_security" 9 "unregister_security" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_security \-  unregisters a security framework with the kernel
.SH SYNOPSIS
.B "int" unregister_security
.BI "(struct security_operations *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
 a pointer to the struct security_options that is to be registered
.SH "DESCRIPTION"
This function removes a struct security_operations variable that had
previously been registered with a successful call to \fBregister_security\fP.

If \fIops\fP does not match the valued previously passed to \fBregister_security\fP
an error is returned.  Otherwise the default security options is set to the
the dummy_security_ops structure, and 0 is returned.
.TH "mod_reg_security" 9 "mod_reg_security" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mod_reg_security \-  allows security modules to be "stacked"
.SH SYNOPSIS
.B "int" mod_reg_security
.BI "(const char *" name ","
.BI "struct security_operations *" ops ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string with the name of the security_options to be registered
.IP "ops" 12
 a pointer to the struct security_options that is to be registered
.SH "DESCRIPTION"
This function allows security modules to be stacked if the currently loaded
security module allows this to happen.  It passes the \fIname\fP and \fIops\fP to the
register_security function of the currently loaded security module.

The return value depends on the currently loaded security module, with 0 as
success.
.TH "mod_unreg_security" 9 "mod_unreg_security" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mod_unreg_security \-  allows a security module registered with mod_reg_security() to be unloaded
.SH SYNOPSIS
.B "int" mod_unreg_security
.BI "(const char *" name ","
.BI "struct security_operations *" ops ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string with the name of the security_options to be removed
.IP "ops" 12
 a pointer to the struct security_options that is to be removed
.SH "DESCRIPTION"
This function allows security modules that have been successfully registered
with a call to \fBmod_reg_security\fP to be unloaded from the system.
This calls the currently loaded security module's \fBunregister_security\fP call
with the \fIname\fP and \fIops\fP variables.

The return value depends on the currently loaded security module, with 0 as
success.
.TH "capable" 9 "capable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
capable \-  calls the currently loaded security module's capable() function with the specified capability
.SH SYNOPSIS
.B "int" capable
.BI "(int " cap ");"
.SH ARGUMENTS
.IP "cap" 12
 the requested capability level.
.SH "DESCRIPTION"
This function calls the currently loaded security module's \fBcapable\fP
function with a pointer to the current task and the specified \fIcap\fP value.

This allows the security module to implement the capable function call
however it chooses to.
.TH "avc_dump_av" 9 "avc_dump_av" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_dump_av \-  Display an access vector in human-readable form.
.SH SYNOPSIS
.B "void" avc_dump_av
.BI "(struct audit_buffer *" ab ","
.BI "u16 " tclass ","
.BI "u32 " av ");"
.SH ARGUMENTS
.IP "ab" 12
-- undescribed --
.IP "tclass" 12
 target security class
.IP "av" 12
 access vector
.TH "avc_dump_query" 9 "avc_dump_query" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_dump_query \-  Display a SID pair and a class in human-readable form.
.SH SYNOPSIS
.B "void" avc_dump_query
.BI "(struct audit_buffer *" ab ","
.BI "u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ");"
.SH ARGUMENTS
.IP "ab" 12
-- undescribed --
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.TH "avc_init" 9 "avc_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_init \-  Initialize the AVC.
.SH SYNOPSIS
.B "void __init" avc_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initialize the access vector cache.
.TH "avc_lookup" 9 "avc_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_lookup \-  Look up an AVC entry.
.SH SYNOPSIS
.B "struct avc_node *" avc_lookup
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 " requested ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "requested" 12
 requested permissions, interpreted based on \fItclass\fP
.SH "DESCRIPTION"
Look up an AVC entry that is valid for the
\fIrequested\fP permissions between the SID pair
(\fIssid\fP, \fItsid\fP), interpreting the permissions
based on \fItclass\fP.  If a valid AVC entry exists,
then this function return the avc_node.
Otherwise, this function returns NULL.
.TH "avc_insert" 9 "avc_insert" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_insert \-  Insert an AVC entry.
.SH SYNOPSIS
.B "struct avc_node *" avc_insert
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "struct avc_entry *" ae ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "ae" 12
 AVC entry
.SH "DESCRIPTION"
Insert an AVC entry for the SID pair
(\fIssid\fP, \fItsid\fP) and class \fItclass\fP.
The access vectors and the sequence number are
normally provided by the security server in
response to a \fBsecurity_compute_av\fP call.  If the
sequence number \fIae\fP-&gt;avd.seqno is not less than the latest
revocation notification, then the function copies
the access vectors into a cache entry, returns
avc_node inserted. Otherwise, this function returns NULL.
.TH "avc_audit" 9 "avc_audit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_audit \-  Audit the granting or denial of permissions.
.SH SYNOPSIS
.B "void" avc_audit
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 " requested ","
.BI "struct av_decision *" avd ","
.BI "int " result ","
.BI "struct avc_audit_data *" a ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "requested" 12
 requested permissions
.IP "avd" 12
 access vector decisions
.IP "result" 12
 result from avc_has_perm_noaudit
.IP "a" 12
  auxiliary audit data
.SH "DESCRIPTION"
Audit the granting or denial of permissions in accordance
with the policy.  This function is typically called by
\fBavc_has_perm\fP after a permission check, but can also be
called directly by callers who use \fBavc_has_perm_noaudit\fP
in order to separate the permission check from the auditing.
For example, this separation is useful when the permission check must
be performed under a lock, to allow the lock to be released
before calling the auditing code.
.TH "avc_add_callback" 9 "avc_add_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_add_callback \-  Register a callback for security events.
.SH SYNOPSIS
.B "int" avc_add_callback
.BI "(int (*" callback ") (u32 event, u32 ssid, u32 tsid,                                      u16 tclass, u32 perms,                                      u32 *out_retained),"
.BI "u32 " events ","
.BI "u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 " perms ");"
.SH ARGUMENTS
.IP "callback" 12
 callback function
.IP "events" 12
 security events
.IP "ssid" 12
 source security identifier or SECSID_WILD
.IP "tsid" 12
 target security identifier or SECSID_WILD
.IP "tclass" 12
 target security class
.IP "perms" 12
 permissions
.SH "DESCRIPTION"
Register a callback function for events in the set \fIevents\fP
related to the SID pair (\fIssid\fP, \fItsid\fP) and
and the permissions \fIperms\fP, interpreting
\fIperms\fP based on \fItclass\fP.  Returns 0 on success or
-ENOMEM if insufficient memory exists to add the callback.
.TH "avc_update_node" 9 "avc_update_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_update_node \- 
.SH SYNOPSIS
.B "int" avc_update_node
.BI "(u32 " event ","
.BI "u32 " perms ","
.BI "u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ");"
.SH ARGUMENTS
.IP "event" 12
 Updating event
.IP "perms" 12
 Permission mask bits
\fIssid\fP,\fItsid\fP,\fItclass\fP : identifier of an AVC entry
.IP "ssid" 12
-- undescribed --
.IP "tsid" 12
-- undescribed --
.IP "tclass" 12
-- undescribed --
.SH "DESCRIPTION"
if a valid AVC entry doesn't exist,this function returns -ENOENT.
if \fBkmalloc\fP called internal returns NULL, this function returns -ENOMEM.
otherwise, this function update the AVC entry. The original AVC-entry object
will release later by RCU.
.TH "avc_ss_reset" 9 "avc_ss_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_ss_reset \-  Flush the cache and revalidate migrated permissions.
.SH SYNOPSIS
.B "int" avc_ss_reset
.BI "(u32 " seqno ");"
.SH ARGUMENTS
.IP "seqno" 12
 policy sequence number
.TH "avc_has_perm_noaudit" 9 "avc_has_perm_noaudit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_has_perm_noaudit \-  Check permissions but perform no auditing.
.SH SYNOPSIS
.B "int" avc_has_perm_noaudit
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 " requested ","
.BI "struct av_decision *" avd ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "requested" 12
 requested permissions, interpreted based on \fItclass\fP
.IP "avd" 12
 access vector decisions
.SH "DESCRIPTION"
Check the AVC to determine whether the \fIrequested\fP permissions are granted
for the SID pair (\fIssid\fP, \fItsid\fP), interpreting the permissions
based on \fItclass\fP, and call the security server on a cache miss to obtain
a new decision and add it to the cache.  Return a copy of the decisions
in \fIavd\fP.  Return 0 if all \fIrequested\fP permissions are granted,
-EACCES if any permissions are denied, or another -errno upon
other errors.  This function is typically called by \fBavc_has_perm\fP,
but may also be called directly to separate permission checking from
auditing, e.g. in cases where a lock must be held for the check but
should be released for the auditing.
.TH "avc_has_perm" 9 "avc_has_perm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
avc_has_perm \-  Check permissions and perform any appropriate auditing.
.SH SYNOPSIS
.B "int" avc_has_perm
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 " requested ","
.BI "struct avc_audit_data *" auditdata ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "requested" 12
 requested permissions, interpreted based on \fItclass\fP
.IP "auditdata" 12
 auxiliary audit data
.SH "DESCRIPTION"
Check the AVC to determine whether the \fIrequested\fP permissions are granted
for the SID pair (\fIssid\fP, \fItsid\fP), interpreting the permissions
based on \fItclass\fP, and call the security server on a cache miss to obtain
a new decision and add it to the cache.  Audit the granting or denial of
permissions in accordance with the policy.  Return 0 if all \fIrequested\fP
permissions are granted, -EACCES if any permissions are denied, or
another -errno upon other errors.
.TH "security_compute_av" 9 "security_compute_av" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_compute_av \-  Compute access vector decisions.
.SH SYNOPSIS
.B "int" security_compute_av
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 " requested ","
.BI "struct av_decision *" avd ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "requested" 12
 requested permissions
.IP "avd" 12
 access vector decisions
.SH "DESCRIPTION"
Compute a set of access vector decisions based on the
SID pair (\fIssid\fP, \fItsid\fP) for the permissions in \fItclass\fP.
Return -EINVAL if any of the parameters are invalid or 0
if the access vector decisions were computed successfully.
.TH "security_sid_to_context" 9 "security_sid_to_context" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_sid_to_context \-  Obtain a context for a given SID.
.SH SYNOPSIS
.B "int" security_sid_to_context
.BI "(u32 " sid ","
.BI "char **" scontext ","
.BI "u32 *" scontext_len ");"
.SH ARGUMENTS
.IP "sid" 12
 security identifier, SID
.IP "scontext" 12
 security context
.IP "scontext_len" 12
 length in bytes
.SH "DESCRIPTION"
Write the string representation of the context associated with \fIsid\fP
into a dynamically allocated string of the correct size.  Set \fIscontext\fP
to point to this string and set \fIscontext_len\fP to the length of the string.
.TH "security_context_to_sid" 9 "security_context_to_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_context_to_sid \-  Obtain a SID for a given security context.
.SH SYNOPSIS
.B "int" security_context_to_sid
.BI "(char *" scontext ","
.BI "u32 " scontext_len ","
.BI "u32 *" sid ");"
.SH ARGUMENTS
.IP "scontext" 12
 security context
.IP "scontext_len" 12
 length in bytes
.IP "sid" 12
 security identifier, SID
.SH "DESCRIPTION"
Obtains a SID associated with the security context that
has the string representation specified by \fIscontext\fP.
Returns -EINVAL if the context is invalid, -ENOMEM if insufficient
memory is available, or 0 on success.
.TH "security_context_to_sid_default" 9 "security_context_to_sid_default" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_context_to_sid_default \-  Obtain a SID for a given security context,
.SH SYNOPSIS
.B "int" security_context_to_sid_default
.BI "(char *" scontext ","
.BI "u32 " scontext_len ","
.BI "u32 *" sid ","
.BI "u32 " def_sid ");"
.SH ARGUMENTS
.IP "scontext" 12
 security context
.IP "scontext_len" 12
 length in bytes
.IP "sid" 12
 security identifier, SID
.IP "def_sid" 12
 default SID to assign on errror
.SH "DESCRIPTION"
Obtains a SID associated with the security context that
has the string representation specified by \fIscontext\fP.
The default SID is passed to the MLS layer to be used to allow
kernel labeling of the MLS field if the MLS field is not present
(for upgrading to MLS without full relabel).
Returns -EINVAL if the context is invalid, -ENOMEM if insufficient
memory is available, or 0 on success.
.SH "DESCRIPTION"
Obtains a SID associated with the security context that
has the string representation specified by \fIscontext\fP.
The default SID is passed to the MLS layer to be used to allow
kernel labeling of the MLS field if the MLS field is not present
(for upgrading to MLS without full relabel).
Returns -EINVAL if the context is invalid, -ENOMEM if insufficient
memory is available, or 0 on success.
.TH "security_transition_sid" 9 "security_transition_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_transition_sid \-  Compute the SID for a new subject/object.
.SH SYNOPSIS
.B "int" security_transition_sid
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 *" out_sid ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "out_sid" 12
 security identifier for new subject/object
.SH "DESCRIPTION"
Compute a SID to use for labeling a new subject or object in the
class \fItclass\fP based on a SID pair (\fIssid\fP, \fItsid\fP).
Return -EINVAL if any of the parameters are invalid, -ENOMEM
if insufficient memory is available, or 0 if the new SID was
computed successfully.
.TH "security_member_sid" 9 "security_member_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_member_sid \-  Compute the SID for member selection.
.SH SYNOPSIS
.B "int" security_member_sid
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 *" out_sid ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "out_sid" 12
 security identifier for selected member
.SH "DESCRIPTION"
Compute a SID to use when selecting a member of a polyinstantiated
object of class \fItclass\fP based on a SID pair (\fIssid\fP, \fItsid\fP).
Return -EINVAL if any of the parameters are invalid, -ENOMEM
if insufficient memory is available, or 0 if the SID was
computed successfully.
.TH "security_change_sid" 9 "security_change_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_change_sid \-  Compute the SID for object relabeling.
.SH SYNOPSIS
.B "int" security_change_sid
.BI "(u32 " ssid ","
.BI "u32 " tsid ","
.BI "u16 " tclass ","
.BI "u32 *" out_sid ");"
.SH ARGUMENTS
.IP "ssid" 12
 source security identifier
.IP "tsid" 12
 target security identifier
.IP "tclass" 12
 target security class
.IP "out_sid" 12
 security identifier for selected member
.SH "DESCRIPTION"
Compute a SID to use for relabeling an object of class \fItclass\fP
based on a SID pair (\fIssid\fP, \fItsid\fP).
Return -EINVAL if any of the parameters are invalid, -ENOMEM
if insufficient memory is available, or 0 if the SID was
computed successfully.
.TH "security_load_policy" 9 "security_load_policy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_load_policy \-  Load a security policy configuration.
.SH SYNOPSIS
.B "int" security_load_policy
.BI "(void *" data ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "data" 12
 binary policy data
.IP "len" 12
 length of data in bytes
.SH "DESCRIPTION"
Load a new set of security policy configuration data,
validate it and convert the SID table as necessary.
This function will flush the access vector cache after
loading the new policy.
.TH "security_port_sid" 9 "security_port_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_port_sid \-  Obtain the SID for a port.
.SH SYNOPSIS
.B "int" security_port_sid
.BI "(u16 " domain ","
.BI "u16 " type ","
.BI "u8 " protocol ","
.BI "u16 " port ","
.BI "u32 *" out_sid ");"
.SH ARGUMENTS
.IP "domain" 12
 communication domain aka address family
.IP "type" 12
 socket type
.IP "protocol" 12
 protocol number
.IP "port" 12
 port number
.IP "out_sid" 12
 security identifier
.TH "security_netif_sid" 9 "security_netif_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_netif_sid \-  Obtain the SID for a network interface.
.SH SYNOPSIS
.B "int" security_netif_sid
.BI "(char *" name ","
.BI "u32 *" if_sid ","
.BI "u32 *" msg_sid ");"
.SH ARGUMENTS
.IP "name" 12
 interface name
.IP "if_sid" 12
 interface SID
.IP "msg_sid" 12
 default SID for received packets
.TH "security_node_sid" 9 "security_node_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_node_sid \-  Obtain the SID for a node (host).
.SH SYNOPSIS
.B "int" security_node_sid
.BI "(u16 " domain ","
.BI "void *" addrp ","
.BI "u32 " addrlen ","
.BI "u32 *" out_sid ");"
.SH ARGUMENTS
.IP "domain" 12
 communication domain aka address family
.IP "addrp" 12
 address
.IP "addrlen" 12
 address length in bytes
.IP "out_sid" 12
 security identifier
.TH "security_get_user_sids" 9 "security_get_user_sids" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_get_user_sids \-  Obtain reachable SIDs for a user.
.SH SYNOPSIS
.B "int" security_get_user_sids
.BI "(u32 " fromsid ","
.BI "char *" username ","
.BI "u32 **" sids ","
.BI "u32 *" nel ");"
.SH ARGUMENTS
.IP "fromsid" 12
 starting SID
.IP "username" 12
 username
.IP "sids" 12
 array of reachable SIDs for user
.IP "nel" 12
 number of elements in \fIsids\fP
.SH "DESCRIPTION"
Generate the set of SIDs for legal security contexts
for a given user that can be reached by \fIfromsid\fP.
Set *\fIsids\fP to point to a dynamically allocated
array containing the set of SIDs.  Set *\fInel\fP to the
number of elements in the array.
.TH "security_genfs_sid" 9 "security_genfs_sid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_genfs_sid \-  Obtain a SID for a file in a filesystem
.SH SYNOPSIS
.B "int" security_genfs_sid
.BI "(const char *" fstype ","
.BI "char *" path ","
.BI "u16 " sclass ","
.BI "u32 *" sid ");"
.SH ARGUMENTS
.IP "fstype" 12
 filesystem type
.IP "path" 12
 path from root of mount
.IP "sclass" 12
 file security class
.IP "sid" 12
 SID for path
.SH "DESCRIPTION"
Obtain a SID to use for a file in a filesystem that
cannot support xattr or use a fixed labeling behavior like
transition SIDs or task SIDs.
.TH "security_fs_use" 9 "security_fs_use" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
security_fs_use \-  Determine how to handle labeling for a filesystem.
.SH SYNOPSIS
.B "int" security_fs_use
.BI "(const char *" fstype ","
.BI "unsigned int *" behavior ","
.BI "u32 *" sid ");"
.SH ARGUMENTS
.IP "fstype" 12
 filesystem type
.IP "behavior" 12
 labeling behavior
.IP "sid" 12
 SID for filesystem (superblock)
.TH "securityfs_create_file" 9 "securityfs_create_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
securityfs_create_file \-  create a file in the securityfs filesystem
.SH SYNOPSIS
.B "struct dentry *" securityfs_create_file
.BI "(const char *" name ","
.BI "mode_t " mode ","
.BI "struct dentry *" parent ","
.BI "void *" data ","
.BI "struct file_operations *" fops ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the file to create.
.IP "mode" 12
 the permission that the file should have
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
file will be created in the root of the securityfs filesystem.
.IP "data" 12
 a pointer to something that the caller will want to get to later
on.  The inode.u.generic_ip pointer will point to this value on
the \fBopen\fP call.
.IP "fops" 12
 a pointer to a struct file_operations that should be used for
this file.
.SH "DESCRIPTION"
This is the basic "create a file" function for securityfs.  It allows for a
wide range of flexibility in createing a file, or a directory (if you
want to create a directory, the \fBsecurityfs_create_dir\fP function is
recommended to be used instead.)

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBsecurityfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If securityfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This is the basic "create a file" function for securityfs.  It allows for a
wide range of flexibility in createing a file, or a directory (if you
want to create a directory, the \fBsecurityfs_create_dir\fP function is
recommended to be used instead.)

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBsecurityfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If securityfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "securityfs_create_dir" 9 "securityfs_create_dir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
securityfs_create_dir \-  create a directory in the securityfs filesystem
.SH SYNOPSIS
.B "struct dentry *" securityfs_create_dir
.BI "(const char *" name ","
.BI "struct dentry *" parent ");"
.SH ARGUMENTS
.IP "name" 12
 a pointer to a string containing the name of the directory to
create.
.IP "parent" 12
 a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this paramater is NULL, then the
directory will be created in the root of the securityfs filesystem.
.SH "DESCRIPTION"
This function creates a directory in securityfs with the given name.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBsecurityfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If securityfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.SH "DESCRIPTION"
This function creates a directory in securityfs with the given name.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the \fBsecurityfs_remove\fP function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, NULL will be returned.

If securityfs is not enabled in the kernel, the value -ENODEV will be
returned.  It is not wise to check for this value, but rather, check for
NULL or !NULL instead as to eliminate the need for #ifdef in the calling
code.
.TH "securityfs_remove" 9 "securityfs_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
securityfs_remove \-  removes a file or directory from the securityfs filesystem
.SH SYNOPSIS
.B "void" securityfs_remove
.BI "(struct dentry *" dentry ");"
.SH ARGUMENTS
.IP "dentry" 12
 a pointer to a the dentry of the file or directory to be
removed.
.SH "DESCRIPTION"
This function removes a file or directory in securityfs that was previously
created with a call to another securityfs function (like
\fBsecurityfs_create_file\fP or variants thereof.)

This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.
.SH "DESCRIPTION"
This function removes a file or directory in securityfs that was previously
created with a call to another securityfs function (like
\fBsecurityfs_create_file\fP or variants thereof.)

This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.
.TH "of_match_device" 9 "of_match_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_match_device \-  Tell if an of_device structure has a matching
.SH SYNOPSIS
.B "const struct of_device_id *" of_match_device
.BI "(const struct of_device_id *" matches ","
.BI "const struct of_device *" dev ");"
.SH ARGUMENTS
.IP "matches" 12
-- undescribed --
.IP "dev" 12
 the of device structure to match against
.SH "DESCRIPTION"
Used by a driver to check whether an of_device present in the
system is in its list of supported devices.
.SH "DESCRIPTION"
Used by a driver to check whether an of_device present in the
system is in its list of supported devices.
.TH "of_release_dev" 9 "of_release_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_release_dev \-  free an of device structure when all users of it are finished.
.SH SYNOPSIS
.B "void" of_release_dev
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device that's been disconnected
.SH "DESCRIPTION"
Will be called only by the device core when all users of this of device are
done.
.TH "setup_cpu_maps" 9 "setup_cpu_maps" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
setup_cpu_maps \-  initialize the following cpu maps:
.SH SYNOPSIS
.B "void __init" setup_cpu_maps
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
cpu_possible_map
cpu_present_map
cpu_sibling_map

Having the possible map set up early allows us to restrict allocations
of things like irqstacks to \fBnum_possible_cpus\fP rather than NR_CPUS.

We do not initialize the online map here; cpus set their own bits in
cpu_online_map as they come up.

This function is valid only for Open Firmware systems.  finish_device_tree
must be called before using this.

While we're here, we may as well set the "physical" cpu ids in the paca.
.TH "smp_startup_cpu" 9 "smp_startup_cpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
smp_startup_cpu \-  start the given cpu
.SH SYNOPSIS
.B "int __devinit" smp_startup_cpu
.BI "(unsigned int " lcpu ");"
.SH ARGUMENTS
.IP "lcpu" 12
-- undescribed --
.SH "DESCRIPTION"

At boot time, there is nothing to do for primary threads which were
started from Open Firmware.  For anything else, call RTAS with the
appropriate start location.
.SH "RETURNS"
0	- failure
1	- success
.TH "hvc_get_chars" 9 "hvc_get_chars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hvc_get_chars \-  retrieve characters from firmware for denoted vterm adatper
.SH SYNOPSIS
.B "int" hvc_get_chars
.BI "(uint32_t " vtermno ","
.BI "char *" buf ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "vtermno" 12
 The vtermno or unit_address of the adapter from which to fetch the
data.
.IP "buf" 12
 The character buffer into which to put the character data fetched from
firmware.
.IP "count" 12
 not used?
.TH "hvc_put_chars" 9 "hvc_put_chars" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hvc_put_chars \- 
.SH SYNOPSIS
.B "int" hvc_put_chars
.BI "(uint32_t " vtermno ","
.BI "const char *" buf ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "vtermno" 12
 The vtermno or unit_address of the adapter from which the data
originated.
.IP "buf" 12
 The character buffer that contains the character data to send to
firmware.
.IP "count" 12
 Send this number of characters.
.TH "vio_register_driver" 9 "vio_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vio_register_driver \-  Register a new vio driver
.SH SYNOPSIS
.B "int" vio_register_driver
.BI "(struct vio_driver *" viodrv ");"
.SH ARGUMENTS
.IP "viodrv" 12
-- undescribed --
.TH "vio_unregister_driver" 9 "vio_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vio_unregister_driver \-  Remove registration of vio driver.
.SH SYNOPSIS
.B "void" vio_unregister_driver
.BI "(struct vio_driver *" viodrv ");"
.SH ARGUMENTS
.IP "viodrv" 12
-- undescribed --
.TH "vio_match_device" 9 "vio_match_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vio_match_device \-  Tell if a VIO device has a matching
.SH SYNOPSIS
.B "const struct vio_device_id *" vio_match_device
.BI "(const struct vio_device_id *" ids ","
.BI "const struct vio_dev *" dev ");"
.SH ARGUMENTS
.IP "ids" 12
	array of VIO device id structures to search in
.IP "dev" 12
	the VIO device structure to match against
.SH "DESCRIPTION"
Used by a driver to check whether a VIO device present in the
system is in its list of supported devices. Returns the matching
vio_device_id structure or NULL if there is no match.
.SH "DESCRIPTION"
Used by a driver to check whether a VIO device present in the
system is in its list of supported devices. Returns the matching
vio_device_id structure or NULL if there is no match.
.TH "vio_bus_init" 9 "vio_bus_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vio_bus_init \-  Initialize the virtual IO bus
.SH SYNOPSIS
.B "int __init" vio_bus_init
.BI "(struct vio_bus_ops *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
-- undescribed --
.TH "hvcs_free_partner_info" 9 "hvcs_free_partner_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hvcs_free_partner_info \-  free pi allocated by hvcs_get_partner_info
.SH SYNOPSIS
.B "int" hvcs_free_partner_info
.BI "(struct list_head *" head ");"
.SH ARGUMENTS
.IP "head" 12
 list_head pointer for an allocated list of partner info structs to
free.
.SH "DESCRIPTION"
This function is used to free the partner info list that was returned by
calling \fBhvcs_get_partner_info\fP.
.TH "hvcs_get_partner_info" 9 "hvcs_get_partner_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hvcs_get_partner_info \-  Get all of the partner info for a vty-server adapter
.SH SYNOPSIS
.B "int" hvcs_get_partner_info
.BI "(uint32_t " unit_address ","
.BI "struct list_head *" head ","
.BI "unsigned long *" pi_buff ");"
.SH ARGUMENTS
.IP "unit_address" 12
 The unit_address of the vty-server adapter for which this
function is fetching partner info.
.IP "head" 12
 An initialized list_head pointer to an empty list to use to return the
list of partner info fetched from the hypervisor to the caller.
.IP "pi_buff" 12
 A page sized buffer pre-allocated prior to calling this function
that is to be used to be used by firmware as an iterator to keep track
of the partner info retrieval.
.SH "DESCRIPTION"
This function returns non-zero on success, or if there is no partner info.

The pi_buff is pre-allocated prior to calling this function because this
function may be called with a spin_lock held and kmalloc of a page is not
recommended as GFP_ATOMIC.

The first long of this buffer is used to store a partner unit address.  The
second long is used to store a partner partition ID and starting at
pi_buff[2] is the 79 character Converged Location Code (diff size than the
unsigned longs, hence the casting mumbo jumbo you see later).

Invocation of this function should always be followed by an invocation of
\fBhvcs_free_partner_info\fP using a pointer to the SAME list head instance
that was passed as a parameter to this function.
.TH "hvcs_register_connection" 9 "hvcs_register_connection" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hvcs_register_connection \-  establish a connection between this vty-server and
.SH SYNOPSIS
.B "int" hvcs_register_connection
.BI "(uint32_t " unit_address ","
.BI "uint32_t " p_partition_ID ","
.BI "uint32_t " p_unit_address ");"
.SH ARGUMENTS
.IP "unit_address" 12
 The unit address of the vty-server adapter that is to be
establish a connection.
.IP "p_partition_ID" 12
 The partition ID of the vty adapter that is to be connected.
.IP "p_unit_address" 12
 The unit address of the vty adapter to which the vty-server
is to be connected.
.SH "DESCRIPTION"
If this function is called once and -EINVAL is returned it may
indicate that the partner info needs to be refreshed for the
target unit address at which point the caller must invoke
\fBhvcs_get_partner_info\fP and then call this function again.  If,
for a second time, -EINVAL is returned then it indicates that
there is probably already a partner connection registered to a
different vty-server adapter.  It is also possible that a second
-EINVAL may indicate that one of the parms is not valid, for
instance if the link was removed between the vty-server adapter
and the vty adapter that you are trying to open.  Don't shoot the
messenger.  Firmware implemented it this way.
.SH "DESCRIPTION"
If this function is called once and -EINVAL is returned it may
indicate that the partner info needs to be refreshed for the
target unit address at which point the caller must invoke
\fBhvcs_get_partner_info\fP and then call this function again.  If,
for a second time, -EINVAL is returned then it indicates that
there is probably already a partner connection registered to a
different vty-server adapter.  It is also possible that a second
-EINVAL may indicate that one of the parms is not valid, for
instance if the link was removed between the vty-server adapter
and the vty adapter that you are trying to open.  Don't shoot the
messenger.  Firmware implemented it this way.
.TH "hvcs_free_connection" 9 "hvcs_free_connection" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hvcs_free_connection \-  free the connection between a vty-server and vty
.SH SYNOPSIS
.B "int" hvcs_free_connection
.BI "(uint32_t " unit_address ");"
.SH ARGUMENTS
.IP "unit_address" 12
 The unit address of the vty-server that is to have its
connection severed.
.SH "DESCRIPTION"
This function is used to free the partner connection between a vty-server
adapter and a vty adapter.

If -EBUSY is returned continue to call this function until 0 is returned.
.TH "derive_parent" 9 "derive_parent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
derive_parent \-  basically like dirname(1)
.SH SYNOPSIS
.B "struct device_node *" derive_parent
.BI "(const char *" path ");"
.SH ARGUMENTS
.IP "path" 12
  the full_name of a node to be added to the tree
.SH "DESCRIPTION"
Returns the node which should be the parent of the node
described by path.  E.g., for path = "/foo/bar", returns
the node with full_name = "/foo".
.TH "parse_next_property" 9 "parse_next_property" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parse_next_property \-  process the next property from raw input buffer
.SH SYNOPSIS
.B "char *" parse_next_property
.BI "(char *" buf ","
.BI "char *" end ","
.BI "char **" name ","
.BI "int *" length ","
.BI "unsigned char **" value ");"
.SH ARGUMENTS
.IP "buf" 12
 input buffer, must be nul-terminated
.IP "end" 12
 end of the input buffer + 1, for validation
.IP "name" 12
 return value; set to property name in buf
.IP "length" 12
 return value; set to length of value
.IP "value" 12
 return value; set to the property value in buf
.SH "DESCRIPTION"
Note that the caller must make copies of the name and value returned,
this function does no allocation or copying of the data.  Return value
is set to the next name in buf, or NULL on error.
.TH "ofdt_write" 9 "ofdt_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ofdt_write \-  perform operations on the Open Firmware device tree
.SH SYNOPSIS
.B "ssize_t" ofdt_write
.BI "(struct file *" file ","
.BI "const char __user *" buf ","
.BI "size_t " count ","
.BI "loff_t *" off ");"
.SH ARGUMENTS
.IP "file" 12
 not used
.IP "buf" 12
 command and arguments
.IP "count" 12
 size of the command buffer
.IP "off" 12
 not used
.SH "DESCRIPTION"
Operations supported at this time are addition and removal of
whole nodes along with their properties.  Operations on individual
properties are not implemented (yet).
.SH "DESCRIPTION"
Operations supported at this time are addition and removal of
whole nodes along with their properties.  Operations on individual
properties are not implemented (yet).
.TH "pre_intr_init_hook" 9 "pre_intr_init_hook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pre_intr_init_hook \-  initialisation prior to setting up interrupt vectors
.SH SYNOPSIS
.B "void __init" pre_intr_init_hook
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
Perform any necessary interrupt initialisation prior to setting up
the "ordinary" interrupt call gates.  For legacy reasons, the ISA
interrupts should be initialised here if the machine emulates a PC
in any way.
.SH "DESCRIPTION"
Perform any necessary interrupt initialisation prior to setting up
the "ordinary" interrupt call gates.  For legacy reasons, the ISA
interrupts should be initialised here if the machine emulates a PC
in any way.
.TH "intr_init_hook" 9 "intr_init_hook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
intr_init_hook \-  post gate setup interrupt initialisation
.SH SYNOPSIS
.B "void __init" intr_init_hook
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
Fill in any interrupts that may have been left out by the general
\fBinit_IRQ\fP routine.  interrupts having to do with the machine rather
than the devices on the I/O bus (like APIC interrupts in intel MP
systems) are started here.
.SH "DESCRIPTION"
Fill in any interrupts that may have been left out by the general
\fBinit_IRQ\fP routine.  interrupts having to do with the machine rather
than the devices on the I/O bus (like APIC interrupts in intel MP
systems) are started here.
.TH "pre_setup_arch_hook" 9 "pre_setup_arch_hook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pre_setup_arch_hook \-  hook called prior to any setup_arch() execution
.SH SYNOPSIS
.B "void __init" pre_setup_arch_hook
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
generally used to activate any machine specific identification
routines that may be needed before \fBsetup_arch\fP runs.  On VISWS
this is used to get the board revision and type.
.SH "DESCRIPTION"
generally used to activate any machine specific identification
routines that may be needed before \fBsetup_arch\fP runs.  On VISWS
this is used to get the board revision and type.
.TH "trap_init_hook" 9 "trap_init_hook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
trap_init_hook \-  initialise system specific traps
.SH SYNOPSIS
.B "void __init" trap_init_hook
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
Called as the final act of \fBtrap_init\fP.  Used in VISWS to initialise
the various board specific APIC traps.
.SH "DESCRIPTION"
Called as the final act of \fBtrap_init\fP.  Used in VISWS to initialise
the various board specific APIC traps.
.TH "time_init_hook" 9 "time_init_hook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
time_init_hook \-  do any specific initialisations for the system timer.
.SH SYNOPSIS
.B "void __init" time_init_hook
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
Must plug the system timer interrupt source at HZ into the IRQ listed
in irq_vectors.h:TIMER_IRQ
.SH "DESCRIPTION"
Must plug the system timer interrupt source at HZ into the IRQ listed
in irq_vectors.h:TIMER_IRQ
.TH "mca_nmi_hook" 9 "mca_nmi_hook" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_nmi_hook \-  hook into MCA specific NMI chain
.SH SYNOPSIS
.B "void __init" mca_nmi_hook
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
The MCA (Microchannel Arcitecture) has an NMI chain for NMI sources
along the MCA bus.  Use this to hook into that chain if you will need
it.
.SH "DESCRIPTION"
The MCA (Microchannel Arcitecture) has an NMI chain for NMI sources
along the MCA bus.  Use this to hook into that chain if you will need
it.
.TH "longhaul_setstate" 9 "longhaul_setstate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
longhaul_setstate \- 
.SH SYNOPSIS
.B "void" longhaul_setstate
.BI "(unsigned int " clock_ratio_index ");"
.SH ARGUMENTS
.IP "clock_ratio_index" 12
 bitpattern of the new multiplier.
.SH "DESCRIPTION"
Sets a new clock ratio.
.TH "speedstep_set_state" 9 "speedstep_set_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_set_state \-  set the SpeedStep state
.SH SYNOPSIS
.B "void" speedstep_set_state
.BI "(unsigned int " state ");"
.SH ARGUMENTS
.IP "state" 12
 new processor frequency state (SPEEDSTEP_LOW or SPEEDSTEP_HIGH)
.SH "DESCRIPTION"
Tries to change the SpeedStep state.
.TH "speedstep_activate" 9 "speedstep_activate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_activate \-  activate SpeedStep control in the chipset
.SH SYNOPSIS
.B "int" speedstep_activate
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Tries to activate the SpeedStep status and control registers.
Returns -EINVAL on an unsupported chipset, and zero on success.
.TH "speedstep_detect_chipset" 9 "speedstep_detect_chipset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_detect_chipset \-  detect the Southbridge which contains SpeedStep logic
.SH SYNOPSIS
.B "unsigned int" speedstep_detect_chipset
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Detects ICH2-M, ICH3-M and ICH4-M so far. The pci_dev points to
the LPC bridge / PM module which contains all power-management
functions. Returns the SPEEDSTEP_CHIPSET_-number for the detected
chipset, or zero on failure.
.TH "speedstep_target" 9 "speedstep_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_target \-  set a new CPUFreq policy
.SH SYNOPSIS
.B "int" speedstep_target
.BI "(struct cpufreq_policy *" policy ","
.BI "unsigned int " target_freq ","
.BI "unsigned int " relation ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.IP "target_freq" 12
 the target frequency
.IP "relation" 12
 how that frequency relates to achieved frequency (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
.SH "DESCRIPTION"
Sets a new CPUFreq policy.
.TH "speedstep_verify" 9 "speedstep_verify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_verify \-  verifies a new CPUFreq policy
.SH SYNOPSIS
.B "int" speedstep_verify
.BI "(struct cpufreq_policy *" policy ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.SH "DESCRIPTION"
Limit must be within speedstep_low_freq and speedstep_high_freq, with
at least one border included.
.TH "speedstep_init" 9 "speedstep_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_init \-  initializes the SpeedStep CPUFreq driver
.SH SYNOPSIS
.B "int __init" speedstep_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initializes the SpeedStep support. Returns -ENODEV on unsupported
devices, -EINVAL on problems during initiatization, and zero on
success.
.TH "speedstep_exit" 9 "speedstep_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_exit \-  unregisters SpeedStep support
.SH SYNOPSIS
.B "void __exit" speedstep_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters SpeedStep support.
.TH "centrino_verify" 9 "centrino_verify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
centrino_verify \-  verifies a new CPUFreq policy
.SH SYNOPSIS
.B "int" centrino_verify
.BI "(struct cpufreq_policy *" policy ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.SH "DESCRIPTION"
Limit must be within this model's frequency range at least one
border included.
.TH "centrino_target" 9 "centrino_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
centrino_target \-  set a new CPUFreq policy
.SH SYNOPSIS
.B "int" centrino_target
.BI "(struct cpufreq_policy *" policy ","
.BI "unsigned int " target_freq ","
.BI "unsigned int " relation ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.IP "target_freq" 12
 the target frequency
.IP "relation" 12
 how that frequency relates to achieved frequency (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
.SH "DESCRIPTION"
Sets a new CPUFreq policy.
.TH "centrino_init" 9 "centrino_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
centrino_init \-  initializes the Enhanced SpeedStep CPUFreq driver
.SH SYNOPSIS
.B "int __init" centrino_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initializes the Enhanced SpeedStep support. Returns -ENODEV on
unsupported devices, -ENOENT if there's no voltage table for this
particular CPU model, -EINVAL on problems during initiatization,
and zero on success.

This is quite picky.  Not only does the CPU have to advertise the
"est" flag in the cpuid capability flags, we look for a specific
CPU model and stepping, and we need to have the exact model name in
our voltage tables.  That is, be paranoid about not releasing
someone's valuable magic smoke.
.TH "speedstep_smi_ownership" 9 "speedstep_smi_ownership" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_smi_ownership \- 
.SH SYNOPSIS
.B "int" speedstep_smi_ownership
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "speedstep_smi_get_freqs" 9 "speedstep_smi_get_freqs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_smi_get_freqs \-  get SpeedStep preferred \\\amp; current freq.
.SH SYNOPSIS
.B "int" speedstep_smi_get_freqs
.BI "(unsigned int *" low ","
.BI "unsigned int *" high ");"
.SH ARGUMENTS
.IP "low" 12
 the low frequency value is placed here
.IP "high" 12
 the high frequency value is placed here
.SH "DESCRIPTION"
Only available on later SpeedStep-enabled systems, returns false results or
even hangs [cf. bugme.osdl.org # 1422] on earlier systems. Empirical testing
shows that the latter occurs if !(ist_info.event &amp; 0xFFFF).
.TH "speedstep_get_state" 9 "speedstep_get_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_get_state \-  set the SpeedStep state
.SH SYNOPSIS
.B "int" speedstep_get_state
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "speedstep_set_state" 9 "speedstep_set_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_set_state \-  set the SpeedStep state
.SH SYNOPSIS
.B "void" speedstep_set_state
.BI "(unsigned int " state ");"
.SH ARGUMENTS
.IP "state" 12
 new processor frequency state (SPEEDSTEP_LOW or SPEEDSTEP_HIGH)
.TH "speedstep_target" 9 "speedstep_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_target \-  set a new CPUFreq policy
.SH SYNOPSIS
.B "int" speedstep_target
.BI "(struct cpufreq_policy *" policy ","
.BI "unsigned int " target_freq ","
.BI "unsigned int " relation ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.IP "target_freq" 12
 new freq
.IP "relation" 12
 
.SH "DESCRIPTION"
Sets a new CPUFreq policy/freq.
.TH "speedstep_verify" 9 "speedstep_verify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_verify \-  verifies a new CPUFreq policy
.SH SYNOPSIS
.B "int" speedstep_verify
.BI "(struct cpufreq_policy *" policy ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.SH "DESCRIPTION"
Limit must be within speedstep_low_freq and speedstep_high_freq, with
at least one border included.
.TH "speedstep_init" 9 "speedstep_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_init \-  initializes the SpeedStep CPUFreq driver
.SH SYNOPSIS
.B "int __init" speedstep_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initializes the SpeedStep support. Returns -ENODEV on unsupported
BIOS, -EINVAL on problems during initiatization, and zero on
success.
.TH "speedstep_exit" 9 "speedstep_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
speedstep_exit \-  unregisters SpeedStep support
.SH SYNOPSIS
.B "void __exit" speedstep_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters SpeedStep support.
.TH "elanfreq_get_cpu_frequency" 9 "elanfreq_get_cpu_frequency" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
elanfreq_get_cpu_frequency \- 
.SH SYNOPSIS
.B "unsigned int" elanfreq_get_cpu_frequency
.BI "(unsigned int " cpu ");"
.SH ARGUMENTS
.IP "cpu" 12
-- undescribed --
.SH "DESCRIPTION"

Finds out at which frequency the CPU of the Elan SOC runs
at the moment. Frequencies from 1 to 33 MHz are generated 
the normal way, 66 and 99 MHz are called "Hyperspeed Mode"
and have the rest of the chip running with 33 MHz. 
.TH "elanfreq_set_cpu_state" 9 "elanfreq_set_cpu_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
elanfreq_set_cpu_state \- 
.SH SYNOPSIS
.B "void" elanfreq_set_cpu_state
.BI "(unsigned int " state ");"
.SH ARGUMENTS
.IP "state" 12
-- undescribed --
.SH "DESCRIPTION"
This function takes a frequency value and changes the CPU frequency 
according to this. Note that the frequency has to be checked by
\fBelanfreq_validatespeed\fP for correctness!

There is no return value. 
.TH "elanfreq_verify" 9 "elanfreq_verify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
elanfreq_verify \- 
.SH SYNOPSIS
.B "int" elanfreq_verify
.BI "(struct cpufreq_policy *" policy ");"
.SH ARGUMENTS
.IP "policy" 12
 the policy to validate
.SH "DESCRIPTION"
This function checks if a given frequency range in kHz is valid 
for the hardware supported by the driver. 
.TH "elanfreq_setup" 9 "elanfreq_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
elanfreq_setup \-  elanfreq command line parameter parsing
.SH SYNOPSIS
.B "int __init" elanfreq_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
-- undescribed --
.SH "DESCRIPTION"

elanfreq command line parameter.  Use:
elanfreq=66000
to set the maximum CPU frequency to 66 MHz. Note that in
case you do not give this boot parameter, the maximum
frequency will fall back to _current_ CPU frequency which
might be lower. If you build this as a module, use the
max_freq module parameter instead.
.TH "powernow_k6_get_cpu_multiplier" 9 "powernow_k6_get_cpu_multiplier" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
powernow_k6_get_cpu_multiplier \-  returns the current FSB multiplier
.SH SYNOPSIS
.B "int" powernow_k6_get_cpu_multiplier
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns the current setting of the frequency multiplier. Core clock
speed is frequency of the Front-Side Bus multiplied with this value.
.TH "powernow_k6_set_state" 9 "powernow_k6_set_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
powernow_k6_set_state \-  set the PowerNow! multiplier
.SH SYNOPSIS
.B "void" powernow_k6_set_state
.BI "(unsigned int " best_i ");"
.SH ARGUMENTS
.IP "best_i" 12
 clock_ratio[best_i] is the target multiplier
.SH "DESCRIPTION"
Tries to change the PowerNow! multiplier
.TH "powernow_k6_verify" 9 "powernow_k6_verify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
powernow_k6_verify \-  verifies a new CPUfreq policy
.SH SYNOPSIS
.B "int" powernow_k6_verify
.BI "(struct cpufreq_policy *" policy ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.SH "DESCRIPTION"
Policy must be within lowest and highest possible CPU Frequency,
and at least one possible state must be within min and max.
.TH "powernow_k6_target" 9 "powernow_k6_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
powernow_k6_target \-  sets a new CPUFreq policy
.SH SYNOPSIS
.B "int" powernow_k6_target
.BI "(struct cpufreq_policy *" policy ","
.BI "unsigned int " target_freq ","
.BI "unsigned int " relation ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.IP "target_freq" 12
 the target frequency
.IP "relation" 12
 how that frequency relates to achieved frequency (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
.SH "DESCRIPTION"
sets a new CPUFreq policy
.TH "powernow_k6_init" 9 "powernow_k6_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
powernow_k6_init \-  initializes the k6 PowerNow! CPUFreq driver
.SH SYNOPSIS
.B "int __init" powernow_k6_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initializes the K6 PowerNow! support. Returns -ENODEV on unsupported
devices, -EINVAL or -ENOMEM on problems during initiatization, and zero
on success.
.TH "powernow_k6_exit" 9 "powernow_k6_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
powernow_k6_exit \-  unregisters AMD K6-2+/3+ PowerNow! support
.SH SYNOPSIS
.B "void __exit" powernow_k6_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters AMD K6-2+ / K6-3+ PowerNow! support.
.TH "nforce2_get" 9 "nforce2_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nforce2_get \-  get the CPU frequency
.SH SYNOPSIS
.B "unsigned int" nforce2_get
.BI "(unsigned int " cpu ");"
.SH ARGUMENTS
.IP "cpu" 12
 CPU number
.SH "DESCRIPTION"
Returns the CPU frequency
.TH "nforce2_target" 9 "nforce2_target" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nforce2_target \-  set a new CPUFreq policy
.SH SYNOPSIS
.B "int" nforce2_target
.BI "(struct cpufreq_policy *" policy ","
.BI "unsigned int " target_freq ","
.BI "unsigned int " relation ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.IP "target_freq" 12
 the target frequency
.IP "relation" 12
 how that frequency relates to achieved frequency (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
.SH "DESCRIPTION"
Sets a new CPUFreq policy.
.TH "nforce2_verify" 9 "nforce2_verify" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nforce2_verify \-  verifies a new CPUFreq policy
.SH SYNOPSIS
.B "int" nforce2_verify
.BI "(struct cpufreq_policy *" policy ");"
.SH ARGUMENTS
.IP "policy" 12
 new policy
.TH "nforce2_detect_chipset" 9 "nforce2_detect_chipset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nforce2_detect_chipset \-  detect the Southbridge which contains FSB PLL logic
.SH SYNOPSIS
.B "unsigned int" nforce2_detect_chipset
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Detects nForce2 A2 and C1 stepping
.TH "nforce2_init" 9 "nforce2_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nforce2_init \-  initializes the nForce2 CPUFreq driver
.SH SYNOPSIS
.B "int __init" nforce2_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Initializes the nForce2 FSB support. Returns -ENODEV on unsupported
devices, -EINVAL on problems during initiatization, and zero on
success.
.TH "nforce2_exit" 9 "nforce2_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
nforce2_exit \-  unregisters cpufreq module
.SH SYNOPSIS
.B "void __exit" nforce2_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Unregisters nForce2 FSB change support.
.TH "set_mtrr" 9 "set_mtrr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_mtrr \-  update mtrrs on all processors
.SH SYNOPSIS
.B "void" set_mtrr
.BI "(unsigned int " reg ","
.BI "unsigned long " base ","
.BI "unsigned long " size ","
.BI "mtrr_type " type ");"
.SH ARGUMENTS
.IP "reg" 12
	mtrr in question
.IP "base" 12
	mtrr base
.IP "size" 12
	mtrr size
.IP "type" 12
	mtrr type
.SH "DESCRIPTION"
This is kinda tricky, but fortunately, Intel spelled it out for us cleanly:

1. Send IPI to do the following:
2. Disable Interrupts
3. Wait for all procs to do so 
4. Enter no-fill cache mode
5. Flush caches
6. Clear PGE bit
7. Flush all TLBs
8. Disable all range registers
9. Update the MTRRs
10. Enable all range registers
11. Flush all TLBs and caches again
12. Enter normal cache mode and reenable caching
13. Set PGE 
14. Wait for buddies to catch up
15. Enable interrupts.

What does that mean for us? Well, first we set data.count to the number
of CPUs. As each CPU disables interrupts, it'll decrement it once. We wait
until it hits 0 and proceed. We set the data.gate flag and reset data.count.
Meanwhile, they are waiting for that flag to be set. Once it's set, each 
CPU goes through the transition of updating MTRRs. The CPU vendors may each do it 
differently, so we call mtrr_if-&gt;\fBset\fP callback and let them take care of it.
When they're done, they again decrement data-&gt;count and wait for data.gate to 
be reset. 
When we finish, we wait for data.count to hit 0 and toggle the data.gate flag.
Everyone then enables interrupts and we all continue on.

Note that the mechanism is the same for UP systems, too; all the SMP stuff
becomes nops.
.TH "mtrr_add_page" 9 "mtrr_add_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mtrr_add_page \-  Add a memory type region
.SH SYNOPSIS
.B "int" mtrr_add_page
.BI "(unsigned long " base ","
.BI "unsigned long " size ","
.BI "unsigned int " type ","
.BI "char " increment ");"
.SH ARGUMENTS
.IP "base" 12
 Physical base address of region in pages (4 KB)
.IP "size" 12
 Physical size of region in pages (4 KB)
.IP "type" 12
 Type of MTRR desired
.IP "increment" 12
 If this is true do usage counting on the region
.SH "DESCRIPTION"
Memory type region registers control the caching on newer Intel and
non Intel processors. This function allows drivers to request an
MTRR is added. The details and hardware specifics of each processor's
implementation are hidden from the caller, but nevertheless the 
caller should expect to need to provide a power of two size on an
equivalent power of two boundary.

If the region cannot be added either because all regions are in use
or the CPU cannot support it a negative value is returned. On success
the register number for this entry is returned, but should be treated
as a cookie only.

On a multiprocessor machine the changes are made to all processors.
This is required on x86 by the Intel processors.

The available types are

MTRR_TYPE_UNCACHABLE	-	No caching

MTRR_TYPE_WRBACK	-	Write data back in bursts whenever

MTRR_TYPE_WRCOMB	-	Write data back soon but allow bursts

MTRR_TYPE_WRTHROUGH	-	Cache reads but not writes
.SH "BUGS"
 Needs a quiet flag for the cases where drivers do not mind
failures and do not wish system log messages to be sent.
.TH "mtrr_add" 9 "mtrr_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mtrr_add \-  Add a memory type region
.SH SYNOPSIS
.B "int" mtrr_add
.BI "(unsigned long " base ","
.BI "unsigned long " size ","
.BI "unsigned int " type ","
.BI "char " increment ");"
.SH ARGUMENTS
.IP "base" 12
 Physical base address of region
.IP "size" 12
 Physical size of region
.IP "type" 12
 Type of MTRR desired
.IP "increment" 12
 If this is true do usage counting on the region
.SH "DESCRIPTION"
Memory type region registers control the caching on newer Intel and
non Intel processors. This function allows drivers to request an
MTRR is added. The details and hardware specifics of each processor's
implementation are hidden from the caller, but nevertheless the 
caller should expect to need to provide a power of two size on an
equivalent power of two boundary.

If the region cannot be added either because all regions are in use
or the CPU cannot support it a negative value is returned. On success
the register number for this entry is returned, but should be treated
as a cookie only.

On a multiprocessor machine the changes are made to all processors.
This is required on x86 by the Intel processors.

The available types are

MTRR_TYPE_UNCACHABLE	-	No caching

MTRR_TYPE_WRBACK	-	Write data back in bursts whenever

MTRR_TYPE_WRCOMB	-	Write data back soon but allow bursts

MTRR_TYPE_WRTHROUGH	-	Cache reads but not writes
.SH "BUGS"
 Needs a quiet flag for the cases where drivers do not mind
failures and do not wish system log messages to be sent.
.TH "mtrr_del_page" 9 "mtrr_del_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mtrr_del_page \-  delete a memory type region
.SH SYNOPSIS
.B "int" mtrr_del_page
.BI "(int " reg ","
.BI "unsigned long " base ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "reg" 12
 Register returned by mtrr_add
.IP "base" 12
 Physical base address
.IP "size" 12
 Size of region
.SH "DESCRIPTION"
If register is supplied then base and size are ignored. This is
how drivers should call it.

Releases an MTRR region. If the usage count drops to zero the 
register is freed and the region returns to default state.
On success the register is returned, on failure a negative error
code.
.TH "mtrr_del" 9 "mtrr_del" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mtrr_del \-  delete a memory type region
.SH SYNOPSIS
.B "int" mtrr_del
.BI "(int " reg ","
.BI "unsigned long " base ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "reg" 12
 Register returned by mtrr_add
.IP "base" 12
 Physical base address
.IP "size" 12
 Size of region
.SH "DESCRIPTION"
If register is supplied then base and size are ignored. This is
how drivers should call it.

Releases an MTRR region. If the usage count drops to zero the 
register is freed and the region returns to default state.
On success the register is returned, on failure a negative error
code.
.TH "mtrr_bp_init" 9 "mtrr_bp_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mtrr_bp_init \-  initialize mtrrs on the boot CPU
.SH SYNOPSIS
.B "void __init" mtrr_bp_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This needs to be called early; before any of the other CPUs are 
initialized (i.e. before \fBsmp_init\fP).
.TH "acpi_save_state_mem" 9 "acpi_save_state_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_save_state_mem \-  save kernel state
.SH SYNOPSIS
.B "int" acpi_save_state_mem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Create an identity mapped page table and copy the wakeup routine to
low memory.
.TH "acpi_reserve_bootmem" 9 "acpi_reserve_bootmem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_reserve_bootmem \-  do _very_ early ACPI initialisation
.SH SYNOPSIS
.B "void __init" acpi_reserve_bootmem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

We allocate a page from the first 1MB of memory for the wakeup
routine for when we come back from a sleep state. The
runtime allocator allows specification of &lt;16MB pages, but not
&lt;1MB pages.
.TH "copy_edd" 9 "copy_edd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_edd \-  Copy the BIOS EDD information
.SH SYNOPSIS
.B "void" copy_edd
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
from boot_params into a safe place.
.TH "apm_error" 9 "apm_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_error \- 	display an APM error
.SH SYNOPSIS
.B "void" apm_error
.BI "(char *" str ","
.BI "int " err ");"
.SH ARGUMENTS
.IP "str" 12
 information string
.IP "err" 12
 APM BIOS return code
.SH "DESCRIPTION"
Write a meaningful log entry to the kernel log in the event of
an APM error.
.TH "apm_bios_call" 9 "apm_bios_call" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_bios_call \- 	Make an APM BIOS 32bit call
.SH SYNOPSIS
.B "u8" apm_bios_call
.BI "(u32 " func ","
.BI "u32 " ebx_in ","
.BI "u32 " ecx_in ","
.BI "u32 *" eax ","
.BI "u32 *" ebx ","
.BI "u32 *" ecx ","
.BI "u32 *" edx ","
.BI "u32 *" esi ");"
.SH ARGUMENTS
.IP "func" 12
 APM function to execute
.IP "ebx_in" 12
 EBX register for call entry
.IP "ecx_in" 12
 ECX register for call entry
.IP "eax" 12
 EAX register return
.IP "ebx" 12
 EBX register return
.IP "ecx" 12
 ECX register return
.IP "edx" 12
 EDX register return
.IP "esi" 12
 ESI register return
.SH "DESCRIPTION"
Make an APM call using the 32bit protected mode interface. The
caller is responsible for knowing if APM BIOS is configured and
enabled. This call can disable interrupts for a long period of
time on some laptops.  The return value is in AH and the carry
flag is loaded into AL.  If there is an error, then the error
code is returned in AH (bits 8-15 of eax) and this function
returns non-zero.
.TH "apm_bios_call_simple" 9 "apm_bios_call_simple" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_bios_call_simple \- 	make a simple APM BIOS 32bit call
.SH SYNOPSIS
.B "u8" apm_bios_call_simple
.BI "(u32 " func ","
.BI "u32 " ebx_in ","
.BI "u32 " ecx_in ","
.BI "u32 *" eax ");"
.SH ARGUMENTS
.IP "func" 12
 APM function to invoke
.IP "ebx_in" 12
 EBX register value for BIOS call
.IP "ecx_in" 12
 ECX register value for BIOS call
.IP "eax" 12
 EAX register on return from the BIOS call
.SH "DESCRIPTION"
Make a BIOS call that does only returns one value, or just status.
If there is an error, then the error code is returned in AH
(bits 8-15 of eax) and this function returns non-zero. This is
used for simpler BIOS operations. This call may hold interrupts
off for a long time on some laptops.
.TH "apm_driver_version" 9 "apm_driver_version" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_driver_version \- 	APM driver version
.SH SYNOPSIS
.B "int" apm_driver_version
.BI "(u_short *" val ");"
.SH ARGUMENTS
.IP "val" 12
	loaded with the APM version on return
.SH "DESCRIPTION"
Retrieve the APM version supported by the BIOS. This is only
supported for APM 1.1 or higher. An error indicates APM 1.0 is
probably present.

On entry val should point to a value indicating the APM driver
version with the high byte being the major and the low byte the
minor number both in BCD

On return it will hold the BIOS revision supported in the
same format.
.TH "apm_get_event" 9 "apm_get_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_get_event \- 	get an APM event from the BIOS
.SH SYNOPSIS
.B "int" apm_get_event
.BI "(apm_event_t *" event ","
.BI "apm_eventinfo_t *" info ");"
.SH ARGUMENTS
.IP "event" 12
 pointer to the event
.IP "info" 12
 point to the event information
.SH "DESCRIPTION"
The APM BIOS provides a polled information for event
reporting. The BIOS expects to be polled at least every second
when events are pending. When a message is found the caller should
poll until no more messages are present.  However, this causes
problems on some laptops where a suspend event notification is
not cleared until it is acknowledged.

Additional information is returned in the info pointer, providing
that APM 1.2 is in use. If no messges are pending the value 0x80
is returned (No power management events pending).
.TH "set_power_state" 9 "set_power_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_power_state \- 	set the power management state
.SH SYNOPSIS
.B "int" set_power_state
.BI "(u_short " what ","
.BI "u_short " state ");"
.SH ARGUMENTS
.IP "what" 12
 which items to transition
.IP "state" 12
 state to transition to
.SH "DESCRIPTION"
Request an APM change of state for one or more system devices. The
processor state must be transitioned last of all. what holds the
class of device in the upper byte and the device number (0xFF for
all) for the object to be transitioned.

The state holds the state to transition to, which may in fact
be an acceptance of a BIOS requested state change.
.TH "set_system_power_state" 9 "set_system_power_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_system_power_state \-  set system wide power state
.SH SYNOPSIS
.B "int" set_system_power_state
.BI "(u_short " state ");"
.SH ARGUMENTS
.IP "state" 12
 which state to enter
.SH "DESCRIPTION"
Transition the entire system into a new APM power state.
.TH "apm_do_idle" 9 "apm_do_idle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_do_idle \- 	perform power saving
.SH SYNOPSIS
.B "int" apm_do_idle
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function notifies the BIOS that the processor is (in the view
of the OS) idle. It returns -1 in the event that the BIOS refuses
to handle the idle request. On a success the function returns 1
if the BIOS did clock slowing or 0 otherwise.
.TH "apm_do_busy" 9 "apm_do_busy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_do_busy \- 	inform the BIOS the CPU is busy
.SH SYNOPSIS
.B "void" apm_do_busy
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Request that the BIOS brings the CPU back to full performance. 
.TH "apm_cpu_idle" 9 "apm_cpu_idle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_cpu_idle \- 	cpu idling for APM capable Linux
.SH SYNOPSIS
.B "void" apm_cpu_idle
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This is the idling function the kernel executes when APM is available. It 
tries to do BIOS powermanagement based on the average system idle time.
Furthermore it calls the system default idle routine.
.TH "apm_power_off" 9 "apm_power_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_power_off \- 	ask the BIOS to power off
.SH SYNOPSIS
.B "void" apm_power_off
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Handle the power off sequence. This is the one piece of code we
will execute even on SMP machines. In order to deal with BIOS
bugs we support real mode APM BIOS power off calls. We also make
the SMP call on CPU0 as some systems will only honour this call
on their first cpu.
.TH "apm_enable_power_management" 9 "apm_enable_power_management" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_enable_power_management \-  enable BIOS APM power management
.SH SYNOPSIS
.B "int" apm_enable_power_management
.BI "(int " enable ");"
.SH ARGUMENTS
.IP "enable" 12
 enable yes/no
.SH "DESCRIPTION"
Enable or disable the APM BIOS power services. 
.TH "apm_get_power_status" 9 "apm_get_power_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_get_power_status \- 	get current power state
.SH SYNOPSIS
.B "int" apm_get_power_status
.BI "(u_short *" status ","
.BI "u_short *" bat ","
.BI "u_short *" life ");"
.SH ARGUMENTS
.IP "status" 12
 returned status
.IP "bat" 12
 battery info
.IP "life" 12
 estimated life
.SH "DESCRIPTION"
Obtain the current power status from the APM BIOS. We return a
status which gives the rough battery status, and current power
source. The bat value returned give an estimate as a percentage
of life and a status value for the battery. The estimated life
if reported is a lifetime in secodnds/minutes at current powwer
consumption.
.TH "apm_engage_power_management" 9 "apm_engage_power_management" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_engage_power_management \- 	enable PM on a device
.SH SYNOPSIS
.B "int" apm_engage_power_management
.BI "(u_short " device ","
.BI "int " enable ");"
.SH ARGUMENTS
.IP "device" 12
 identity of device
.IP "enable" 12
 on/off
.SH "DESCRIPTION"
Activate or deactive power management on either a specific device
or the entire system (APM_DEVICE_ALL).
.TH "apm_console_blank" 9 "apm_console_blank" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_console_blank \- 	blank the display
.SH SYNOPSIS
.B "int" apm_console_blank
.BI "(int " blank ");"
.SH ARGUMENTS
.IP "blank" 12
 on/off
.SH "DESCRIPTION"
Attempt to blank the console, firstly by blanking just video device
zero, and if that fails (some BIOSes don't support it) then it blanks
all video devices. Typically the BIOS will do laptop backlight and
monitor powerdown for us.
.TH "dmi_check_system" 9 "dmi_check_system" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dmi_check_system \-  check system DMI data
.SH SYNOPSIS
.B "int" dmi_check_system
.BI "(struct dmi_system_id *" list ");"
.SH ARGUMENTS
.IP "list" 12
 array of dmi_system_id structures to match against
.SH "DESCRIPTION"
Walk the blacklist table running matching functions until someone
returns non zero or we hit the end. Callback function is called for
each successfull match. Returns the number of matches.
.TH "dmi_get_system_info" 9 "dmi_get_system_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dmi_get_system_info \-  return DMI data value
.SH SYNOPSIS
.B "char *" dmi_get_system_info
.BI "(int " field ");"
.SH ARGUMENTS
.IP "field" 12
 data index (see enum dmi_filed)
.SH "DESCRIPTION"
Returns one DMI data value, can be used to perform
complex DMI data checks.
.TH "dmi_find_device" 9 "dmi_find_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
dmi_find_device \-  find onboard device by type/name
.SH SYNOPSIS
.B "struct dmi_device *" dmi_find_device
.BI "(int " type ","
.BI "const char *" name ","
.BI "struct dmi_device *" from ");"
.SH ARGUMENTS
.IP "type" 12
 device type or DMI_DEV_TYPE_ANY to match all device types
.IP "name" 12
-- undescribed --
.IP "from" 12
 previous device found in search, or NULL for new search.
.SH "DESCRIPTION"
Iterates through the list of known onboard devices. If a device is
found with a matching \fIvendor\fP and \fIdevice\fP, a pointer to its device
structure is returned.  Otherwise, NULL is returned.
A new search is initiated by passing NULL to the \fIfrom\fP argument.
If \fIfrom\fP is not NULL, searches continue from next device.
.TH "restore_ELCR" 9 "restore_ELCR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
restore_ELCR \- 
.SH SYNOPSIS
.B "void" restore_ELCR
.BI "(char *" trigger ");"
.SH ARGUMENTS
.IP "trigger" 12
-- undescribed --
.TH "mca_read_and_store_pos" 9 "mca_read_and_store_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_read_and_store_pos \-  read the POS registers into a memory buffer
.SH SYNOPSIS
.B "int" mca_read_and_store_pos
.BI "(unsigned char *" pos ");"
.SH ARGUMENTS
.IP "pos" 12
 a char pointer to 8 bytes, contains the POS register value on
successful return
.SH "DESCRIPTION"
Returns 1 if a card actually exists (i.e. the pos isn't
all 0xff) or 0 otherwise
.TH "ioremap_nocache" 9 "ioremap_nocache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioremap_nocache \-    map bus memory into CPU space
.SH SYNOPSIS
.B "void __iomem *" ioremap_nocache
.BI "(unsigned long " phys_addr ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "phys_addr" 12
-- undescribed --
.IP "size" 12
      size of the resource to map
.SH "DESCRIPTION"
ioremap_nocache performs a platform specific sequence of operations to
make bus memory CPU accessible via the readb/readw/readl/writeb/
writew/writel functions and the other mmio helpers. The returned
address is not guaranteed to be usable directly as a virtual
address. 

This version of ioremap ensures that the memory is marked uncachable
on the CPU as well as honouring existing caching rules from things like
the PCI bus. Note that there are other caches and buffers on many 
busses. In particular driver authors should read up on PCI writes

It's useful if some control registers are in such an area and
.SH "WRITE COMBINING OR READ CACHING IS NOT DESIRABLE"

Must be freed with iounmap.
.TH "fs_initcall" 9 "fs_initcall" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fs_initcall \- 
.SH SYNOPSIS
.B "" fs_initcall
.BI "(" pcibios_assign_resources ");"
.SH ARGUMENTS
.IP "pcibios_assign_resources" 12
.SH "DESCRIPTION"
give a chance for motherboard reserve resources
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "int" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_next_zero_bit" 9 "find_next_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "int" find_next_zero_bit
.BI "(const unsigned long *" addr ","
.BI "int " size ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "__strncpy_from_user" 9 "__strncpy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__strncpy_from_user \-  Copy a NUL terminated string from userspace, with less checking.
.SH SYNOPSIS
.B "long" __strncpy_from_user
.BI "(char *" dst ","
.BI "const char __user *" src ","
.BI "long " count ");"
.SH ARGUMENTS
.IP "dst" 12
   Destination address, in kernel space.  This buffer must be at
least \fIcount\fP bytes long.
.IP "src" 12
   Source address, in user space.
.IP "count" 12
 Maximum number of bytes to copy, including the trailing NUL.
.SH "DESCRIPTION"
Copies a NUL-terminated string from userspace to kernel space.
Caller must check the specified block with \fBaccess_ok\fP before calling
this function.

On success, returns the length of the string (not including the trailing
NUL).

If access to userspace fails, returns -EFAULT (some data may have been
copied).

If \fIcount\fP is smaller than the length of the string, copies \fIcount\fP bytes
and returns \fIcount\fP.
.TH "strncpy_from_user" 9 "strncpy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strncpy_from_user \-  Copy a NUL terminated string from userspace.
.SH SYNOPSIS
.B "long" strncpy_from_user
.BI "(char *" dst ","
.BI "const char __user *" src ","
.BI "long " count ");"
.SH ARGUMENTS
.IP "dst" 12
   Destination address, in kernel space.  This buffer must be at
least \fIcount\fP bytes long.
.IP "src" 12
   Source address, in user space.
.IP "count" 12
 Maximum number of bytes to copy, including the trailing NUL.
.SH "DESCRIPTION"
Copies a NUL-terminated string from userspace to kernel space.

On success, returns the length of the string (not including the trailing
NUL).

If access to userspace fails, returns -EFAULT (some data may have been
copied).

If \fIcount\fP is smaller than the length of the string, copies \fIcount\fP bytes
and returns \fIcount\fP.
.TH "clear_user" 9 "clear_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
clear_user \-  Zero a block of memory in user space.
.SH SYNOPSIS
.B "unsigned long" clear_user
.BI "(void __user *" to ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "n" 12
    Number of bytes to zero.
.SH "DESCRIPTION"
Zero a block of memory in user space.

Returns number of bytes that could not be cleared.
On success, this will be zero.
.TH "__clear_user" 9 "__clear_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__clear_user \-  Zero a block of memory in user space, with less checking.
.SH SYNOPSIS
.B "unsigned long" __clear_user
.BI "(void __user *" to ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "n" 12
    Number of bytes to zero.
.SH "DESCRIPTION"
Zero a block of memory in user space.  Caller must check
the specified block with \fBaccess_ok\fP before calling this function.

Returns number of bytes that could not be cleared.
On success, this will be zero.
.TH "strnlen_user" 9 "strnlen_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strnlen_user \-  Get the size of a string in user space.
.SH SYNOPSIS
.B "long" strnlen_user
.BI "(const char __user *" s ","
.BI "long " n ");"
.SH ARGUMENTS
.IP "s" 12
 The string to measure.
.IP "n" 12
 The maximum valid length
.SH "DESCRIPTION"
Get the size of a NUL-terminated string in user space.

Returns the size of the string INCLUDING the terminating NUL.
On exception, returns 0.
If the string is too long, returns a value greater than \fIn\fP.
.TH "copy_to_user" 9 "copy_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_to_user \-  Copy a block of data into user space.
.SH SYNOPSIS
.B "unsigned long" copy_to_user
.BI "(void __user *" to ","
.BI "const void *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in user space.
.IP "from" 12
 Source address, in kernel space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from kernel space to user space.

Returns number of bytes that could not be copied.
On success, this will be zero.
.TH "copy_from_user" 9 "copy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_from_user \-  Copy a block of data from user space.
.SH SYNOPSIS
.B "unsigned long" copy_from_user
.BI "(void *" to ","
.BI "const void __user *" from ","
.BI "unsigned long " n ");"
.SH ARGUMENTS
.IP "to" 12
   Destination address, in kernel space.
.IP "from" 12
 Source address, in user space.
.IP "n" 12
    Number of bytes to copy.
.SH "CONTEXT"
 User context only.  This function may sleep.
.SH "DESCRIPTION"
Copy data from user space to kernel space.

Returns number of bytes that could not be copied.
On success, this will be zero.

If some data could not be copied, this function will pad the copied
data to the requested size using zero bytes.
.TH "disable_irq_nosync" 9 "disable_irq_nosync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq_nosync \-  disable an irq without waiting
.SH SYNOPSIS
.B "void" disable_irq_nosync
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line.  Disables and Enables are
nested.
Unlike \fBdisable_irq\fP, this function does not ensure existing
instances of the IRQ handler have completed before returning.

This function may be called from IRQ context.
.TH "disable_irq" 9 "disable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq \-  disable an irq and wait for completion
.SH SYNOPSIS
.B "void" disable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.

This function may be called - with care - from IRQ context.
.TH "enable_irq" 9 "enable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_irq \-  enable handling of an irq
.SH SYNOPSIS
.B "void" enable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to enable
.SH "DESCRIPTION"
Undoes the effect of one call to \fBdisable_irq\fP.  If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.

This function may be called from IRQ context.
.TH "request_irq" 9 "request_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
request_irq \-  allocate an interrupt line
.SH SYNOPSIS
.B "int" request_irq
.BI "(unsigned int " irq ","
.BI "irqreturn_t (*" handler ") (int, void *, struct pt_regs *),"
.BI "unsigned long " irqflags ","
.BI "const char *" devname ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to allocate
.IP "handler" 12
 Function to be called when the IRQ occurs
.IP "irqflags" 12
 Interrupt type flags
.IP "devname" 12
 An ascii name for the claiming device
.IP "dev_id" 12
 A cookie passed back to the handler function
.SH "DESCRIPTION"
This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.

Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.

If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.
.SH "FLAGS"

SA_SHIRQ		Interrupt is shared

SA_INTERRUPT		Disable local interrupts while processing

SA_SAMPLE_RANDOM	The interrupt can be used for entropy
.TH "free_irq" 9 "free_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_irq \-  free an interrupt
.SH SYNOPSIS
.B "void" free_irq
.BI "(unsigned int " irq ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to free
.IP "dev_id" 12
 Device identity to free
.SH "DESCRIPTION"
Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.

This function may be called from interrupt context.
.SH "BUGS"
 Attempting to free an irq in a handler for the same irq hangs
the machine.
.TH "probe_irq_on" 9 "probe_irq_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_on \-  begin an interrupt autodetect
.SH SYNOPSIS
.B "unsigned long" probe_irq_on
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Commence probing for an interrupt. The interrupts are scanned
and a mask of potential interrupt lines is returned.
.TH "probe_irq_mask" 9 "probe_irq_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_mask \-  scan a bitmap of interrupt lines
.SH SYNOPSIS
.B "unsigned int" probe_irq_mask
.BI "(unsigned long " xmask ");"
.SH ARGUMENTS
.IP "xmask" 12
-- undescribed --
.SH "DESCRIPTION"
Scan the ISA bus interrupt lines and return a bitmap of
active interrupts. The interrupt probe logic state is then
returned to its previous value.
.SH "NOTE"
 we need to scan all the irq's even though we will
only return ISA irq numbers - just so that we reset them
all to a known state.
.TH "probe_irq_off" 9 "probe_irq_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_off \-  end an interrupt autodetect
.SH SYNOPSIS
.B "int" probe_irq_off
.BI "(unsigned long " xmask ");"
.SH ARGUMENTS
.IP "xmask" 12
 mask of potential interrupts (unused)
.SH "DESCRIPTION"
Scans the unused interrupt lines and returns the line which
appears to have triggered the interrupt. If no interrupt was
found then zero is returned. If more than one interrupt is
found then minus the first candidate is returned to indicate
their is doubt.

The interrupt probe logic state is returned to its previous
value.
.SH "BUGS"
 When used in a module (which arguably shouldnt happen)
nothing prevents two IRQ probe callers from overlapping. The
results of this are non-optimal.
.TH "tioca_gart_init" 9 "tioca_gart_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_gart_init \-  Initialize SGI TIOCA GART
.SH SYNOPSIS
.B "int" tioca_gart_init
.BI "(struct tioca_kernel *" tioca_kern ");"
.SH ARGUMENTS
.IP "tioca_kern" 12
-- undescribed --
.SH "DESCRIPTION"
If the indicated tioca has devices present, initialize its associated
GART MMR's and kernel memory.
.TH "tioca_fastwrite_enable" 9 "tioca_fastwrite_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_fastwrite_enable \-  enable AGP FW for a tioca and its functions
.SH SYNOPSIS
.B "void" tioca_fastwrite_enable
.BI "(struct tioca_kernel *" tioca_kern ");"
.SH ARGUMENTS
.IP "tioca_kern" 12
-- undescribed --
.SH "DESCRIPTION"
Given a CA, scan all attached functions making sure they all support
FastWrite.  If so, enable FastWrite for all functions and the CA itself.
.TH "tioca_dma_d64" 9 "tioca_dma_d64" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_dma_d64 \-  create a DMA mapping using 64-bit direct mode
.SH SYNOPSIS
.B "uint64_t" tioca_dma_d64
.BI "(unsigned long " paddr ");"
.SH ARGUMENTS
.IP "paddr" 12
 system physical address
.SH "DESCRIPTION"
Map \fIpaddr\fP into 64-bit CA bus space.  No device context is necessary.
.SH "BITS 53"
0 come from the coretalk address.  We just need to mask in the
following optional bits of the 64-bit pci address:
.SH "63"
60 - Coretalk Packet Type -  0x1 for Mem Get/Put (coherent)
0x2 for PIO (non-coherent)
We will always use 0x1
.SH "55"
55 - Swap bytes		   Currently unused
.TH "tioca_dma_d48" 9 "tioca_dma_d48" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_dma_d48 \-  create a DMA mapping using 48-bit direct mode
.SH SYNOPSIS
.B "uint64_t" tioca_dma_d48
.BI "(struct pci_dev *" pdev ","
.BI "uint64_t " paddr ");"
.SH ARGUMENTS
.IP "pdev" 12
 linux pci_dev representing the function
.IP "paddr" 12
 system physical address
.SH "DESCRIPTION"
Map \fIpaddr\fP into 64-bit bus space of the CA associated with \fIpcidev_info\fP.
.SH "THE CA AGP 48 BIT DIRECT ADDRESS FALLS OUT AS FOLLOWS"

When direct mapping AGP addresses, the 48 bit AGP address is
.SH "CONSTRUCTED AS FOLLOWS"

[47:40] - Low 8 bits of the page Node ID extracted from coretalk
address [47:40].  The upper 8 node bits are fixed
and come from the xxx register bits [5:0]
[39:38] - Chiplet ID extracted from coretalk address [39:38]
[37:00] - node offset extracted from coretalk address [37:00]

Since the node id in general will be non-zero, and the chiplet id
will always be non-zero, it follows that the device must support
a dma mask of at least 0xffffffffff (40 bits) to target node 0
and in general should be 0xffffffffffff (48 bits) to target nodes
up to 255.  Nodes above 255 need the support of the xxx register,
and so a given CA can only directly target nodes in the range
xxx - xxx+255.
.TH "tioca_dma_mapped" 9 "tioca_dma_mapped" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_dma_mapped \-  create a DMA mapping using a CA GART 
.SH SYNOPSIS
.B "dma_addr_t" tioca_dma_mapped
.BI "(struct pci_dev *" pdev ","
.BI "uint64_t " paddr ","
.BI "size_t " req_size ");"
.SH ARGUMENTS
.IP "pdev" 12
 linux pci_dev representing the function
.IP "paddr" 12
 host physical address to map
.IP "req_size" 12
 len (bytes) to map
.SH "DESCRIPTION"
Map \fIpaddr\fP into CA address space using the GART mechanism.  The mapped
dma_addr_t is guarenteed to be contiguous in CA bus space.
.TH "tioca_dma_unmap" 9 "tioca_dma_unmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_dma_unmap \-  release CA mapping resources
.SH SYNOPSIS
.B "void" tioca_dma_unmap
.BI "(struct pci_dev *" pdev ","
.BI "dma_addr_t " bus_addr ","
.BI "int " dir ");"
.SH ARGUMENTS
.IP "pdev" 12
 linux pci_dev representing the function
.IP "bus_addr" 12
 bus address returned by an earlier tioca_dma_map
.IP "dir" 12
 mapping direction (unused)
.SH "DESCRIPTION"
Locate mapping resources associated with \fIbus_addr\fP and release them.
For mappings created using the direct modes (64 or 48) there are no
resources to release.
.TH "tioca_dma_map" 9 "tioca_dma_map" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_dma_map \-  map pages for PCI DMA
.SH SYNOPSIS
.B "uint64_t" tioca_dma_map
.BI "(struct pci_dev *" pdev ","
.BI "uint64_t " paddr ","
.BI "size_t " byte_count ");"
.SH ARGUMENTS
.IP "pdev" 12
 linux pci_dev representing the function
.IP "paddr" 12
 host physical address to map
.IP "byte_count" 12
 bytes to map
.SH "DESCRIPTION"
This is the main wrapper for mapping host physical pages to CA PCI space.
The mapping mode used is based on the devices dma_mask.  As a last resort
use the GART mapped mode.
.TH "tioca_error_intr_handler" 9 "tioca_error_intr_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_error_intr_handler \-  SGI TIO CA error interrupt handler
.SH SYNOPSIS
.B "irqreturn_t" tioca_error_intr_handler
.BI "(int " irq ","
.BI "void *" arg ","
.BI "struct pt_regs *" pt ");"
.SH ARGUMENTS
.IP "irq" 12
 unused
.IP "arg" 12
 pointer to tioca_common struct for the given CA
.IP "pt" 12
 unused
.SH "DESCRIPTION"
Handle a CA error interrupt.  Simply a wrapper around a SAL call which
defers processing to the SGI prom.
.TH "tioca_bus_fixup" 9 "tioca_bus_fixup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_bus_fixup \-  perform final PCI fixup for a TIO CA bus
.SH SYNOPSIS
.B "void *" tioca_bus_fixup
.BI "(struct pcibus_bussoft *" prom_bussoft ","
.BI "struct pci_controller *" controller ");"
.SH ARGUMENTS
.IP "prom_bussoft" 12
 Common prom/kernel struct representing the bus
.IP "controller" 12
-- undescribed --
.SH "DESCRIPTION"
Replicates the tioca_common pointed to by \fIprom_bussoft\fP in kernel
space.  Allocates and initializes a kernel-only area for a given CA,
and sets up an irq for handling CA error interrupts.

On successful setup, returns the kernel version of tioca_common back to
the caller.
.TH "tioca_init_provider" 9 "tioca_init_provider" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tioca_init_provider \-  init SN PCI provider ops for TIO CA
.SH SYNOPSIS
.B "int" tioca_init_provider
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "sn_dma_supported" 9 "sn_dma_supported" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_supported \-  test a DMA mask
.SH SYNOPSIS
.B "int" sn_dma_supported
.BI "(struct device *" dev ","
.BI "u64 " mask ");"
.SH ARGUMENTS
.IP "dev" 12
 device to test
.IP "mask" 12
 DMA mask to test
.SH "DESCRIPTION"
Return whether the given PCI device DMA address mask can be supported
properly.  For example, if your device can only drive the low 24-bits
during PCI bus mastering, then you would pass 0x00ffffff as the mask to
this function.  Of course, SN only supports devices that have 32 or more
address bits when using the PMU.
.TH "sn_dma_set_mask" 9 "sn_dma_set_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_set_mask \-  set the DMA mask
.SH SYNOPSIS
.B "int" sn_dma_set_mask
.BI "(struct device *" dev ","
.BI "u64 " dma_mask ");"
.SH ARGUMENTS
.IP "dev" 12
 device to set
.IP "dma_mask" 12
 new mask
.SH "DESCRIPTION"
Set \fIdev\fP's DMA mask if the hw supports it.
.TH "sn_dma_alloc_coherent" 9 "sn_dma_alloc_coherent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_alloc_coherent \-  allocate memory for coherent DMA
.SH SYNOPSIS
.B "void *" sn_dma_alloc_coherent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "dma_addr_t *" dma_handle ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "dev" 12
 device to allocate for
.IP "size" 12
 size of the region
.IP "dma_handle" 12
 DMA (bus) address
.IP "flags" 12
 memory allocation flags
.SH "DESCRIPTION"
\fBdma_alloc_coherent\fP returns a pointer to a memory region suitable for
coherent DMA traffic to/from a PCI device.  On SN platforms, this means
that \fIdma_handle\fP will have the PCIIO_DMA_CMD flag set.

This interface is usually used for "command" streams (e.g. the command
queue for a SCSI controller).  See Documentation/DMA-API.txt for
more information.
.TH "sn_dma_free_coherent" 9 "sn_dma_free_coherent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_free_coherent \-  free memory associated with coherent DMAable region
.SH SYNOPSIS
.B "void" sn_dma_free_coherent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "void *" cpu_addr ","
.BI "dma_addr_t " dma_handle ");"
.SH ARGUMENTS
.IP "dev" 12
 device to free for
.IP "size" 12
 size to free
.IP "cpu_addr" 12
 kernel virtual address to free
.IP "dma_handle" 12
 DMA address associated with this region
.SH "DESCRIPTION"
Frees the memory allocated by \fBdma_alloc_coherent\fP, potentially unmapping
any associated IOMMU mappings.
.TH "sn_dma_map_single" 9 "sn_dma_map_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_map_single \-  map a single page for DMA
.SH SYNOPSIS
.B "dma_addr_t" sn_dma_map_single
.BI "(struct device *" dev ","
.BI "void *" cpu_addr ","
.BI "size_t " size ","
.BI "int " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 device to map for
.IP "cpu_addr" 12
 kernel virtual address of the region to map
.IP "size" 12
 size of the region
.IP "direction" 12
 DMA direction
.SH "DESCRIPTION"
Map the region pointed to by \fIcpu_addr\fP for DMA and return the
DMA address.

We map this to the one step pcibr_dmamap_trans interface rather than
the two step pcibr_dmamap_alloc/pcibr_dmamap_addr because we have
no way of saving the dmamap handle from the alloc to later free
(which is pretty much unacceptable).
.SH "TODO"
 simplify our interface;
figure out how to save dmamap handle so can use two step.
.TH "sn_dma_unmap_single" 9 "sn_dma_unmap_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_unmap_single \-  unamp a DMA mapped page
.SH SYNOPSIS
.B "void" sn_dma_unmap_single
.BI "(struct device *" dev ","
.BI "dma_addr_t " dma_addr ","
.BI "size_t " size ","
.BI "int " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 device to sync
.IP "dma_addr" 12
 DMA address to sync
.IP "size" 12
 size of region
.IP "direction" 12
 DMA direction
.SH "DESCRIPTION"
This routine is supposed to sync the DMA region specified
by \fIdma_handle\fP into the coherence domain.  On SN, we're always cache
coherent, so we just need to free any ATEs associated with this mapping.
.TH "sn_dma_unmap_sg" 9 "sn_dma_unmap_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_unmap_sg \-  unmap a DMA scatterlist
.SH SYNOPSIS
.B "void" sn_dma_unmap_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sg ","
.BI "int " nhwentries ","
.BI "int " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 device to unmap
.IP "sg" 12
 scatterlist to unmap
.IP "nhwentries" 12
 number of scatterlist entries
.IP "direction" 12
 DMA direction
.SH "DESCRIPTION"
Unmap a set of streaming mode DMA translations.
.TH "sn_dma_map_sg" 9 "sn_dma_map_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_dma_map_sg \-  map a scatterlist for DMA
.SH SYNOPSIS
.B "int" sn_dma_map_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sg ","
.BI "int " nhwentries ","
.BI "int " direction ");"
.SH ARGUMENTS
.IP "dev" 12
 device to map for
.IP "sg" 12
 scatterlist to map
.IP "nhwentries" 12
 number of entries
.IP "direction" 12
 direction of the DMA transaction
.SH "DESCRIPTION"
Maps each entry of \fIsg\fP for DMA.
.TH "tiocx_match" 9 "tiocx_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
tiocx_match \-  Try to match driver id list with device.
.SH SYNOPSIS
.B "int" tiocx_match
.BI "(struct device *" dev ","
.BI "struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "dev" 12
 device pointer
.IP "drv" 12
 driver pointer
.SH "DESCRIPTION"
Returns 1 if match, 0 otherwise.
.TH "cx_device_match" 9 "cx_device_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_device_match \-  Find cx_device in the id table.
.SH SYNOPSIS
.B "const struct cx_device_id *" cx_device_match
.BI "(const struct cx_device_id *" ids ","
.BI "struct cx_dev *" cx_device ");"
.SH ARGUMENTS
.IP "ids" 12
 id table from driver
.IP "cx_device" 12
 part/mfg id for the device
.TH "cx_device_probe" 9 "cx_device_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_device_probe \-  Look for matching device.
.SH SYNOPSIS
.B "int" cx_device_probe
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"
Call driver probe routine if found.
.TH "cx_driver_remove" 9 "cx_driver_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_driver_remove \-  Remove driver from device struct.
.SH SYNOPSIS
.B "int" cx_driver_remove
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device
.TH "cx_driver_register" 9 "cx_driver_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_driver_register \-  Register the driver.
.SH SYNOPSIS
.B "int" cx_driver_register
.BI "(struct cx_drv *" cx_driver ");"
.SH ARGUMENTS
.IP "cx_driver" 12
 driver table (cx_drv struct) from driver
.SH "DESCRIPTION"
Called from the driver init routine to register a driver.
The cx_drv struct contains the driver name, a pointer to
a table of part/mfg numbers and a pointer to the driver's
probe/attach routine.
.TH "cx_driver_unregister" 9 "cx_driver_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_driver_unregister \-  Unregister the driver.
.SH SYNOPSIS
.B "int" cx_driver_unregister
.BI "(struct cx_drv *" cx_driver ");"
.SH ARGUMENTS
.IP "cx_driver" 12
 driver table (cx_drv struct) from driver
.TH "cx_device_register" 9 "cx_device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_device_register \-  Register a device.
.SH SYNOPSIS
.B "int" cx_device_register
.BI "(nasid_t " nasid ","
.BI "int " part_num ","
.BI "int " mfg_num ","
.BI "struct hubdev_info *" hubdev ");"
.SH ARGUMENTS
.IP "nasid" 12
 device's nasid
.IP "part_num" 12
 device's part number
.IP "mfg_num" 12
 device's manufacturer number
.IP "hubdev" 12
 hub info associated with this device
.TH "cx_device_unregister" 9 "cx_device_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_device_unregister \-  Unregister a device.
.SH SYNOPSIS
.B "int" cx_device_unregister
.BI "(struct cx_dev *" cx_dev ");"
.SH ARGUMENTS
.IP "cx_dev" 12
 part/mfg id for the device
.TH "cx_device_reload" 9 "cx_device_reload" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cx_device_reload \-  Reload the device.
.SH SYNOPSIS
.B "int" cx_device_reload
.BI "(struct cx_dev *" cx_dev ");"
.SH ARGUMENTS
.IP "cx_dev" 12
-- undescribed --
.SH "DESCRIPTION"
Remove the device associated with 'nasid' from device list and then
call device-register with the given part/mfg numbers.
.TH "sn2_global_tlb_purge" 9 "sn2_global_tlb_purge" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn2_global_tlb_purge \-  globally purge translation cache of virtual address range
.SH SYNOPSIS
.B "void" sn2_global_tlb_purge
.BI "(unsigned long " start ","
.BI "unsigned long " end ","
.BI "unsigned long " nbits ");"
.SH ARGUMENTS
.IP "start" 12
 start of virtual address range
.IP "end" 12
 end of virtual address range
.IP "nbits" 12
 specifies number of bytes to purge per instruction (num = 1&lt;&lt;(nbits &amp; 0xfc))
.SH "DESCRIPTION"
Purges the translation caches of all processors of the given virtual address
range.
.SH "NOTE"
- cpu_vm_mask is a bit mask that indicates which cpus have loaded the context.
- cpu_vm_mask is converted into a nodemask of the nodes containing the
cpus in cpu_vm_mask.
- if only one bit is set in cpu_vm_mask &amp; it is the current cpu,
then only the local TLB needs to be flushed. This flushing can be done
using ptc.l. This is the common case &amp; avoids the global spinlock.
- if multiple cpus have loaded the context, then flushing has to be
done with ptc.g/MMRs under protection of the global ptc_lock.
.TH "sn_send_IPI_phys" 9 "sn_send_IPI_phys" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_send_IPI_phys \-  send an IPI to a Nasid and slice
.SH SYNOPSIS
.B "void" sn_send_IPI_phys
.BI "(int " nasid ","
.BI "long " physid ","
.BI "int " vector ","
.BI "int " delivery_mode ");"
.SH ARGUMENTS
.IP "nasid" 12
 nasid to receive the interrupt (may be outside partition)
.IP "physid" 12
 physical cpuid to receive the interrupt.
.IP "vector" 12
 command to send
.IP "delivery_mode" 12
 delivery mechanism
.SH "DESCRIPTION"
Sends an IPI (interprocessor interrupt) to the processor specified by
\fIphysid\fP

\fIdelivery_mode\fP can be one of the following

IA64_IPI_DM_INT - pend an interrupt
IA64_IPI_DM_PMI - pend a PMI
IA64_IPI_DM_NMI - pend an NMI
IA64_IPI_DM_INIT - pend an INIT interrupt
.TH "sn2_send_IPI" 9 "sn2_send_IPI" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn2_send_IPI \-  send an IPI to a processor
.SH SYNOPSIS
.B "void" sn2_send_IPI
.BI "(int " cpuid ","
.BI "int " vector ","
.BI "int " delivery_mode ","
.BI "int " redirect ");"
.SH ARGUMENTS
.IP "cpuid" 12
 target of the IPI
.IP "vector" 12
 command to send
.IP "delivery_mode" 12
 delivery mechanism
.IP "redirect" 12
 redirect the IPI?
.SH "DESCRIPTION"
Sends an IPI (InterProcessor Interrupt) to the processor specified by
\fIcpuid\fP.  \fIvector\fP specifies the command to send, while \fIdelivery_mode\fP can 
be one of the following

IA64_IPI_DM_INT - pend an interrupt
IA64_IPI_DM_PMI - pend a PMI
IA64_IPI_DM_NMI - pend an NMI
IA64_IPI_DM_INIT - pend an INIT interrupt
.TH "sn_flush_all_caches" 9 "sn_flush_all_caches" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_flush_all_caches \-  flush a range of address from all caches (incl. L4)
.SH SYNOPSIS
.B "void" sn_flush_all_caches
.BI "(long " flush_addr ","
.BI "long " bytes ");"
.SH ARGUMENTS
.IP "flush_addr" 12
 identity mapped region 7 address to start flushing
.IP "bytes" 12
 number of bytes to flush
.SH "DESCRIPTION"
Flush a range of addresses from all caches including L4. 
All addresses fully or partially contained within 
\fIflush_addr\fP to \fIflush_addr\fP + \fIbytes\fP are flushed
from the all caches.
.TH "sn_io_addr" 9 "sn_io_addr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_io_addr \-  convert an in/out port to an i/o address
.SH SYNOPSIS
.B "void *" sn_io_addr
.BI "(unsigned long " port ");"
.SH ARGUMENTS
.IP "port" 12
 port to convert
.SH "DESCRIPTION"
Legacy in/out instructions are converted to ld/st instructions
on IA64.  This routine will convert a port number into a valid 
SN i/o address.  Used by sn_in*() and sn_out*().
.TH "__sn_mmiowb" 9 "__sn_mmiowb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__sn_mmiowb \-  I/O space memory barrier
.SH SYNOPSIS
.B "void" __sn_mmiowb
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

See include/asm-ia64/io.h and Documentation/DocBook/deviceiobook.tmpl
for details.

On SN2, we wait for the PIO_WRITE_STATUS SHub register to clear.
See PV 871084 for details about the WAR about zero value.
.TH "early_sn_setup" 9 "early_sn_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
early_sn_setup \-  early setup routine for SN platforms
.SH SYNOPSIS
.B "void __init" early_sn_setup
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Sets up an initial console to aid debugging.  Intended primarily
for bringup.  See \fBstart_kernel\fP in init/main.c.
.TH "sn_setup" 9 "sn_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_setup \-  SN platform setup routine
.SH SYNOPSIS
.B "void __init" sn_setup
.BI "(char **" cmdline_p ");"
.SH ARGUMENTS
.IP "cmdline_p" 12
 kernel command line
.SH "DESCRIPTION"
Handles platform setup for SN machines.  This includes determining
the RTC frequency (via a SAL call), initializing secondary CPUs, and
setting up per-node data areas.  The console is also initialized here.
.TH "sn_init_pdas" 9 "sn_init_pdas" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_init_pdas \-  setup node data areas
.SH SYNOPSIS
.B "void __init" sn_init_pdas
.BI "(char **" cmdline_p ");"
.SH ARGUMENTS
.IP "cmdline_p" 12
-- undescribed --
.SH "DESCRIPTION"

One time setup for Node Data Area.  Called by \fBsn_setup\fP.
.TH "sn_cpu_init" 9 "sn_cpu_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sn_cpu_init \-  initialize per-cpu data areas
.SH SYNOPSIS
.B "void __init" sn_cpu_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
Called during cpu initialization on each cpu as it starts.
Currently, initializes the per-cpu data area for SNIA.
Also sets up a few fields in the nodepda.  Also known as
\fBplatform_cpu_init\fP by the ia64 machvec code.
.TH "show_mem" 9 "show_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
show_mem \-  display a memory statistics summary
.SH SYNOPSIS
.B "void" show_mem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Just walks the pages in the system and describes where they're allocated.
.TH "find_max_pfn" 9 "find_max_pfn" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_max_pfn \-  adjust the maximum page number callback
.SH SYNOPSIS
.B "int" find_max_pfn
.BI "(unsigned long " start ","
.BI "unsigned long " end ","
.BI "void *" arg ");"
.SH ARGUMENTS
.IP "start" 12
 start of range
.IP "end" 12
 end of range
.IP "arg" 12
 address of pointer to global max_pfn variable
.SH "DESCRIPTION"
Passed as a callback function to \fBefi_memmap_walk\fP to determine the highest
available page frame number in the system.
.TH "find_bootmap_location" 9 "find_bootmap_location" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_bootmap_location \-  callback to find a memory area for the bootmap
.SH SYNOPSIS
.B "int" find_bootmap_location
.BI "(unsigned long " start ","
.BI "unsigned long " end ","
.BI "void *" arg ");"
.SH ARGUMENTS
.IP "start" 12
 start of region
.IP "end" 12
 end of region
.IP "arg" 12
 unused callback data
.SH "DESCRIPTION"
Find a place to put the bootmap and return its starting address in
bootmap_start.  This address must be page-aligned.
.TH "find_memory" 9 "find_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_memory \-  setup memory map
.SH SYNOPSIS
.B "void" find_memory
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Walk the EFI memory map and find usable memory for the system, taking
into account reserved areas.
.TH "per_cpu_init" 9 "per_cpu_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
per_cpu_init \-  setup per-cpu variables
.SH SYNOPSIS
.B "void *" per_cpu_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate and setup per-cpu data areas.
.TH "build_node_maps" 9 "build_node_maps" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
build_node_maps \-  callback to setup bootmem structs for each node
.SH SYNOPSIS
.B "int __init" build_node_maps
.BI "(unsigned long " start ","
.BI "unsigned long " len ","
.BI "int " node ");"
.SH ARGUMENTS
.IP "start" 12
 physical start of range
.IP "len" 12
 length of range
.IP "node" 12
 node where this range resides
.SH "DESCRIPTION"
We allocate a struct bootmem_data for each piece of memory that we wish to
treat as a virtually contiguous block (i.e. each node). Each such block
must start on an IA64_GRANULE_SIZE boundary, so we round the address down
if necessary.  Any non-existent pages will simply be part of the virtual
memmap.  We also update min_low_pfn and max_low_pfn here as we receive
memory ranges from the caller.
.TH "early_nr_cpus_node" 9 "early_nr_cpus_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
early_nr_cpus_node \-  return number of cpus on a given node
.SH SYNOPSIS
.B "int __init" early_nr_cpus_node
.BI "(int " node ");"
.SH ARGUMENTS
.IP "node" 12
 node to check
.SH "DESCRIPTION"
Count the number of cpus on \fInode\fP.  We can't use \fBnr_cpus_node\fP yet because
\fBacpi_boot_init\fP (which builds the node_to_cpu_mask array) hasn't been
called yet.  Note that node 0 will also count all non-existent cpus.
.TH "compute_pernodesize" 9 "compute_pernodesize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
compute_pernodesize \-  compute size of pernode data
.SH SYNOPSIS
.B "unsigned long __init" compute_pernodesize
.BI "(int " node ");"
.SH ARGUMENTS
.IP "node" 12
 the node id.
.TH "per_cpu_node_setup" 9 "per_cpu_node_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
per_cpu_node_setup \-  setup per-cpu areas on each node
.SH SYNOPSIS
.B "void *" per_cpu_node_setup
.BI "(void *" cpu_data ","
.BI "int " node ");"
.SH ARGUMENTS
.IP "cpu_data" 12
 per-cpu area on this node
.IP "node" 12
 node to setup
.SH "DESCRIPTION"
Copy the static per-cpu data into the region we just set aside and then
setup __per_cpu_offset for each CPU on this node.  Return a pointer to
the end of the area.
.TH "fill_pernode" 9 "fill_pernode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fill_pernode \-  initialize pernode data.
.SH SYNOPSIS
.B "void __init" fill_pernode
.BI "(int " node ","
.BI "unsigned long " pernode ","
.BI "unsigned long " pernodesize ");"
.SH ARGUMENTS
.IP "node" 12
 the node id.
.IP "pernode" 12
 physical address of pernode data
.IP "pernodesize" 12
 size of the pernode data
.TH "find_pernode_space" 9 "find_pernode_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_pernode_space \-  allocate memory for memory map and per-node structures
.SH SYNOPSIS
.B "int __init" find_pernode_space
.BI "(unsigned long " start ","
.BI "unsigned long " len ","
.BI "int " node ");"
.SH ARGUMENTS
.IP "start" 12
 physical start of range
.IP "len" 12
 length of range
.IP "node" 12
 node where this range resides
.SH "DESCRIPTION"
This routine reserves space for the per-cpu data struct, the list of
pg_data_ts and the per-node data struct.  Each node will have something like
the following in the first chunk of addr. space large enough to hold it.

________________________
|                        |
|~~~~~~~~~~~~~~~~~~~~~~~~| &lt;-- NODEDATA_ALIGN(start, node) for the first
|    PERCPU_PAGE_SIZE *  |     start and length big enough
|    cpus_on_this_node   | Node 0 will also have entries for all non-existent cpus.
|------------------------|
|   local pg_data_t *    |
|------------------------|
|  local ia64_node_data  |
|------------------------|
|          ???           |
|________________________|

Once this space has been set aside, the bootmem maps are initialized.  We
could probably move the allocation of the per-cpu and ia64_node_data space
outside of this function and use \fBalloc_bootmem_node\fP, but doing it here
is straightforward and we get the alignments we want so...
.TH "free_node_bootmem" 9 "free_node_bootmem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_node_bootmem \-  free bootmem allocator memory for use
.SH SYNOPSIS
.B "int __init" free_node_bootmem
.BI "(unsigned long " start ","
.BI "unsigned long " len ","
.BI "int " node ");"
.SH ARGUMENTS
.IP "start" 12
 physical start of range
.IP "len" 12
 length of range
.IP "node" 12
 node where this range resides
.SH "DESCRIPTION"
Simply calls the bootmem allocator to free the specified ranged from
the given pg_data_t's bdata struct.  After this function has been called
for all the entries in the EFI memory map, the bootmem allocator will
be ready to service allocation requests.
.TH "reserve_pernode_space" 9 "reserve_pernode_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
reserve_pernode_space \-  reserve memory for per-node space
.SH SYNOPSIS
.B "void __init" reserve_pernode_space
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Reserve the space used by the bootmem maps &amp; per-node space in the boot
allocator so that when we actually create the real mem maps we don't
use their memory.
.TH "initialize_pernode_data" 9 "initialize_pernode_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
initialize_pernode_data \-  fixup per-cpu \\\amp; per-node pointers
.SH SYNOPSIS
.B "void __init" initialize_pernode_data
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Each node's per-node area has a copy of the global pg_data_t list, so
we copy that to each node here, as well as setting the per-cpu pointer
to the local node data structure.  The active_cpus field of the per-node
structure gets setup by the \fBplatform_cpu_init\fP function later.
.TH "memory_less_node_alloc" 9 "memory_less_node_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memory_less_node_alloc \-  * attempt to allocate memory on the best NUMA slit
.SH SYNOPSIS
.B "void __init *" memory_less_node_alloc
.BI "(int " nid ","
.BI "unsigned long " pernodesize ","
.BI "unsigned long " align ");"
.SH ARGUMENTS
.IP "nid" 12
 node id
.IP "pernodesize" 12
 size of this node's pernode data
.IP "align" 12
 alignment to use for this node's pernode data
.SH "DESCRIPTION"
node but fall back to any other node when __alloc_bootmem_node fails
for best.
.TH "pgdat_insert" 9 "pgdat_insert" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pgdat_insert \-  insert the pgdat into global pgdat_list
.SH SYNOPSIS
.B "void __init" pgdat_insert
.BI "(pg_data_t *" pgdat ");"
.SH ARGUMENTS
.IP "pgdat" 12
 the pgdat for a node.
.TH "memory_less_nodes" 9 "memory_less_nodes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memory_less_nodes \-  allocate and initialize CPU only nodes pernode
.SH SYNOPSIS
.B "void __init" memory_less_nodes
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
information.
.TH "find_memory" 9 "find_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_memory \-  walk the EFI memory map and setup the bootmem allocator
.SH SYNOPSIS
.B "void __init" find_memory
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Called early in boot to setup the bootmem allocator, and to
allocate the per-cpu and per-node structures.
.TH "per_cpu_init" 9 "per_cpu_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
per_cpu_init \-  setup per-cpu variables
.SH SYNOPSIS
.B "void *" per_cpu_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

\fBfind_pernode_space\fP does most of this already, we just need to set
local_per_cpu_offset
.TH "show_mem" 9 "show_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
show_mem \-  give short summary of memory stats
.SH SYNOPSIS
.B "void" show_mem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Shows a simple page count of reserved and used pages in the system.
For discontig machines, it does this on a per-pgdat basis.
.TH "call_pernode_memory" 9 "call_pernode_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
call_pernode_memory \-  use SRAT to call callback functions with node info
.SH SYNOPSIS
.B "void" call_pernode_memory
.BI "(unsigned long " start ","
.BI "unsigned long " len ","
.BI "void *" arg ");"
.SH ARGUMENTS
.IP "start" 12
 physical start of range
.IP "len" 12
 length of range
.IP "arg" 12
 function to call for each range
.SH "DESCRIPTION"
\fBefi_memmap_walk\fP knows nothing about layout of memory across nodes. Find
out to which node a block of memory belongs.  Ignore memory that we cannot
identify, and split blocks that run across multiple nodes.

Take this opportunity to round the start address up and the end address
down to page boundaries.
.TH "count_node_pages" 9 "count_node_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
count_node_pages \-  callback to build per-node memory info structures
.SH SYNOPSIS
.B "__init int" count_node_pages
.BI "(unsigned long " start ","
.BI "unsigned long " len ","
.BI "int " node ");"
.SH ARGUMENTS
.IP "start" 12
 physical start of range
.IP "len" 12
 length of range
.IP "node" 12
 node where this range resides
.SH "DESCRIPTION"
Each node has it's own number of physical pages, DMAable pages, start, and
end page frame number.  This routine will be called by \fBcall_pernode_memory\fP
for each piece of usable memory and will setup these values for each node.
Very similar to \fBbuild_maps\fP.
.TH "paging_init" 9 "paging_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
paging_init \-  setup page tables
.SH SYNOPSIS
.B "void __init" paging_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

\fBpaging_init\fP sets up the page tables for each node of the system and frees
the bootmem allocator memory for general use.
.TH "ia64_pci_get_legacy_mem" 9 "ia64_pci_get_legacy_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ia64_pci_get_legacy_mem \-  generic legacy mem routine
.SH SYNOPSIS
.B "char *" ia64_pci_get_legacy_mem
.BI "(struct pci_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 bus to get legacy memory base address for
.SH "DESCRIPTION"
Find the base of legacy memory for \fIbus\fP.  This is typically the first
megabyte of bus address space for \fIbus\fP or is simply 0 on platforms whose
chipsets support legacy I/O and memory routing.  Returns the base address
or an error pointer if an error occurred.

This is the ia64 generic version of this routine.  Other platforms
are free to override it with a machine vector.
.TH "pci_mmap_legacy_page_range" 9 "pci_mmap_legacy_page_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_mmap_legacy_page_range \-  map legacy memory space to userland
.SH SYNOPSIS
.B "int" pci_mmap_legacy_page_range
.BI "(struct pci_bus *" bus ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "bus" 12
 bus whose legacy space we're mapping
.IP "vma" 12
 vma passed in by mmap
.SH "DESCRIPTION"
Map legacy memory space for this device back to userspace using a machine
vector to get the base address.
.TH "ia64_pci_legacy_read" 9 "ia64_pci_legacy_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ia64_pci_legacy_read \-  read from legacy I/O space
.SH SYNOPSIS
.B "int" ia64_pci_legacy_read
.BI "(struct pci_bus *" bus ","
.BI "u16 " port ","
.BI "u32 *" val ","
.BI "u8 " size ");"
.SH ARGUMENTS
.IP "bus" 12
 bus to read
.IP "port" 12
 legacy port value
.IP "val" 12
 caller allocated storage for returned value
.IP "size" 12
 number of bytes to read
.SH "DESCRIPTION"
Simply reads \fIsize\fP bytes from \fIport\fP and puts the result in \fIval\fP.

Again, this (and the write routine) are generic versions that can be
overridden by the platform.  This is necessary on platforms that don't
support legacy I/O routing or that hard fail on legacy I/O timeouts.
.TH "ia64_pci_legacy_write" 9 "ia64_pci_legacy_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ia64_pci_legacy_write \-  perform a legacy I/O write
.SH SYNOPSIS
.B "int" ia64_pci_legacy_write
.BI "(struct pci_dev *" bus ","
.BI "u16 " port ","
.BI "u32 " val ","
.BI "u8 " size ");"
.SH ARGUMENTS
.IP "bus" 12
 bus pointer
.IP "port" 12
 port to write
.IP "val" 12
 value to write
.IP "size" 12
 number of bytes to write from \fIval\fP
.SH "DESCRIPTION"
Simply writes \fIsize\fP bytes of \fIval\fP to \fIport\fP.
.TH "pci_cacheline_size" 9 "pci_cacheline_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pci_cacheline_size \-  determine cacheline size for PCI devices
.SH SYNOPSIS
.B "unsigned long" pci_cacheline_size
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
We want to use the line-size of the outer-most cache.  We assume
that this line-size is the same for all CPUs.

Code mostly taken from arch/ia64/kernel/palinfo.c:\fBcache_info\fP.
.SH "RETURNS"
 An appropriate -ERRNO error value on eror, or zero for success.
.TH "pcibios_prep_mwi" 9 "pcibios_prep_mwi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcibios_prep_mwi \-  helper function for drivers/pci/pci.c:pci_set_mwi()
.SH SYNOPSIS
.B "int" pcibios_prep_mwi
.BI "(struct pci_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the PCI device for which MWI is enabled
.SH "DESCRIPTION"
For ia64, we can get the cacheline sizes from PAL.
.SH "RETURNS"
 An appropriate -ERRNO error value on eror, or zero for success.
.TH "mca_page_isolate" 9 "mca_page_isolate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_page_isolate \-  isolate a poisoned page in order not to use it later
.SH SYNOPSIS
.B "isolate_status_t" mca_page_isolate
.BI "(unsigned long " paddr ");"
.SH ARGUMENTS
.IP "paddr" 12
	poisoned memory location
.SH "RETURN VALUE"
one of isolate_status_t, ISOLATE_OK/NG/NONE.
.TH "mca_handler_bh" 9 "mca_handler_bh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_handler_bh \-  Kill the process which occurred memory read error
.SH SYNOPSIS
.B "void" mca_handler_bh
.BI "(unsigned long " paddr ");"
.SH ARGUMENTS
.IP "paddr" 12
	poisoned address received from MCA Handler
.TH "mca_make_peidx" 9 "mca_make_peidx" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_make_peidx \-  Make index of processor error section
.SH SYNOPSIS
.B "void" mca_make_peidx
.BI "(sal_log_processor_info_t *" slpi ","
.BI "peidx_table_t *" peidx ");"
.SH ARGUMENTS
.IP "slpi" 12
	pointer to record of processor error section
.IP "peidx" 12
	pointer to index of processor error section
.TH "LOG_INDEX_ADD_SECT_PTR" 9 "LOG_INDEX_ADD_SECT_PTR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
LOG_INDEX_ADD_SECT_PTR \-   Make index of SAL error record
.SH SYNOPSIS
.B "" LOG_INDEX_ADD_SECT_PTR
.BI "(" sect ","
.BI "" ptr ");"
.SH ARGUMENTS
.IP "sect" 12
.IP "ptr" 12
.SH "RETURN VALUE"
1 if record has platform error / 0 if not
.TH "init_record_index_pools" 9 "init_record_index_pools" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_record_index_pools \-  Initialize pool of lists for SAL record index
.SH SYNOPSIS
.B "int" init_record_index_pools
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.SH "RETURN VALUE"
0 on Success / -ENOMEM on Failure
.TH "is_mca_global" 9 "is_mca_global" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
is_mca_global \-  Check whether this MCA is global or not
.SH SYNOPSIS
.B "mca_type_t" is_mca_global
.BI "(peidx_table_t *" peidx ","
.BI "pal_bus_check_info_t *" pbci ","
.BI "struct ia64_sal_os_state *" sos ");"
.SH ARGUMENTS
.IP "peidx" 12
	pointer of index of processor error section
.IP "pbci" 12
	pointer to pal_bus_check_info_t
.IP "sos" 12
	pointer to hand off struct between SAL and OS
.SH "RETURN VALUE"
MCA_IS_LOCAL / MCA_IS_GLOBAL
.TH "recover_from_read_error" 9 "recover_from_read_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
recover_from_read_error \-  Try to recover the errors which type are "read"s.
.SH SYNOPSIS
.B "int" recover_from_read_error
.BI "(slidx_table_t *" slidx ","
.BI "peidx_table_t *" peidx ","
.BI "pal_bus_check_info_t *" pbci ","
.BI "struct ia64_sal_os_state *" sos ");"
.SH ARGUMENTS
.IP "slidx" 12
	pointer of index of SAL error record
.IP "peidx" 12
	pointer of index of processor error section
.IP "pbci" 12
	pointer of pal_bus_check_info
.IP "sos" 12
	pointer to hand off struct between SAL and OS
.SH "RETURN VALUE"
1 on Success / 0 on Failure
.TH "recover_from_platform_error" 9 "recover_from_platform_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
recover_from_platform_error \-  Recover from platform error.
.SH SYNOPSIS
.B "int" recover_from_platform_error
.BI "(slidx_table_t *" slidx ","
.BI "peidx_table_t *" peidx ","
.BI "pal_bus_check_info_t *" pbci ","
.BI "struct ia64_sal_os_state *" sos ");"
.SH ARGUMENTS
.IP "slidx" 12
	pointer of index of SAL error record
.IP "peidx" 12
	pointer of index of processor error section
.IP "pbci" 12
	pointer of pal_bus_check_info
.IP "sos" 12
	pointer to hand off struct between SAL and OS
.SH "RETURN VALUE"
1 on Success / 0 on Failure
.TH "recover_from_processor_error" 9 "recover_from_processor_error" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
recover_from_processor_error \- 
.SH SYNOPSIS
.B "int" recover_from_processor_error
.BI "(int " platform ","
.BI "slidx_table_t *" slidx ","
.BI "peidx_table_t *" peidx ","
.BI "pal_bus_check_info_t *" pbci ","
.BI "struct ia64_sal_os_state *" sos ");"
.SH ARGUMENTS
.IP "platform" 12
	whether there are some platform error section or not
.IP "slidx" 12
	pointer of index of SAL error record
.IP "peidx" 12
	pointer of index of processor error section
.IP "pbci" 12
	pointer of pal_bus_check_info
.IP "sos" 12
	pointer to hand off struct between SAL and OS
.SH "RETURN VALUE"
1 on Success / 0 on Failure
.TH "mca_try_to_recover" 9 "mca_try_to_recover" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mca_try_to_recover \-  Try to recover from MCA
.SH SYNOPSIS
.B "int" mca_try_to_recover
.BI "(void *" rec ","
.BI "struct ia64_sal_os_state *" sos ");"
.SH ARGUMENTS
.IP "rec" 12
	pointer to a SAL error record
.IP "sos" 12
	pointer to hand off struct between SAL and OS
.SH "RETURN VALUE"
1 on Success / 0 on Failure
.TH "reserve_memory" 9 "reserve_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
reserve_memory \-  setup reserved memory areas
.SH SYNOPSIS
.B "void" reserve_memory
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Setup the reserved memory areas set aside for the boot parameters,
initrd, etc.  There are currently IA64_MAX_RSVD_REGIONS defined,
see include/asm-ia64/meminit.h if you need to define more.
.TH "find_initrd" 9 "find_initrd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_initrd \-  get initrd parameters from the boot parameter structure
.SH SYNOPSIS
.B "void" find_initrd
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Grab the initrd start and end from the boot parameter struct given us by
the boot loader.
.TH "early_console_setup" 9 "early_console_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
early_console_setup \-  setup debugging console
.SH SYNOPSIS
.B "int __init" early_console_setup
.BI "(char *" cmdline ");"
.SH ARGUMENTS
.IP "cmdline" 12
-- undescribed --
.SH "DESCRIPTION"

Consoles started here require little enough setup that we can start using
them very early in the boot process, either right after the machine
vector initialization, or even before if the drivers can detect their hw.

Returns non-zero if a console couldn't be setup.
.TH "build_cpu_to_node_map" 9 "build_cpu_to_node_map" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
build_cpu_to_node_map \-  setup cpu to node and node to cpumask arrays
.SH SYNOPSIS
.B "void __init" build_cpu_to_node_map
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Build cpu to node mapping and initialize the per node cpu masks using
info from the node_cpuid array handed to us by ACPI.
.TH "sba_dump_tlb" 9 "sba_dump_tlb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dump_tlb \-  debugging only - print IOMMU operating parameters
.SH SYNOPSIS
.B "void" sba_dump_tlb
.BI "(char *" hpa ");"
.SH ARGUMENTS
.IP "hpa" 12
 base address of the IOMMU
.SH "DESCRIPTION"
Print the size/location of the IO MMU PDIR.
.TH "sba_dump_pdir_entry" 9 "sba_dump_pdir_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dump_pdir_entry \-  debugging only - print one IOMMU PDIR entry
.SH SYNOPSIS
.B "void" sba_dump_pdir_entry
.BI "(struct ioc *" ioc ","
.BI "char *" msg ","
.BI "uint " pide ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "msg" 12
 text to print ont the output line.
.IP "pide" 12
 pdir index.
.SH "DESCRIPTION"
Print one entry of the IO MMU PDIR in human readable form.
.TH "sba_check_pdir" 9 "sba_check_pdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_check_pdir \-  debugging only - consistency checker
.SH SYNOPSIS
.B "int" sba_check_pdir
.BI "(struct ioc *" ioc ","
.BI "char *" msg ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "msg" 12
 text to print ont the output line.
.SH "DESCRIPTION"
Verify the resource map and pdir state is consistent
.TH "sba_dump_sg" 9 "sba_dump_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_dump_sg \-  debugging only - print Scatter-Gather list
.SH SYNOPSIS
.B "void" sba_dump_sg
.BI "(struct ioc *" ioc ","
.BI "struct scatterlist *" startsg ","
.BI "int " nents ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "startsg" 12
 head of the SG list
.IP "nents" 12
 number of entries in SG list
.SH "DESCRIPTION"
print the SG list so we can verify it's correct by hand.
.TH "get_iovp_order" 9 "get_iovp_order" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_iovp_order \- 
.SH SYNOPSIS
.B "SBA_INLINE int" get_iovp_order
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
to PAGE_SIZE being the minimum mapping alignment and TC flush granularity.
It only incurs about 1 clock cycle to use this one with the static variable
and makes the code more intuitive.
.TH "sba_search_bitmap" 9 "sba_search_bitmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_search_bitmap \-  find free space in IO PDIR resource bitmap
.SH SYNOPSIS
.B "SBA_INLINE unsigned long" sba_search_bitmap
.BI "(struct ioc *" ioc ","
.BI "unsigned long " bits_wanted ","
.BI "int " use_hint ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "bits_wanted" 12
 number of entries we need.
.IP "use_hint" 12
 use res_hint to indicate where to start looking
.SH "DESCRIPTION"
Find consecutive free bits in resource bitmap.
Each bit represents one entry in the IO Pdir.
.SH "COOL PERF OPTIMIZATION"
 search for log2(size) bits at a time.
.TH "sba_alloc_range" 9 "sba_alloc_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_alloc_range \-  find free bits and mark them in IO PDIR resource bitmap
.SH SYNOPSIS
.B "int" sba_alloc_range
.BI "(struct ioc *" ioc ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "size" 12
 number of bytes to create a mapping for
.SH "DESCRIPTION"
Given a size, find consecutive unmarked and then mark those bits in the
resource bit map.
.TH "sba_free_range" 9 "sba_free_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_free_range \-  unmark bits in IO PDIR resource bitmap
.SH SYNOPSIS
.B "SBA_INLINE void" sba_free_range
.BI "(struct ioc *" ioc ","
.BI "dma_addr_t " iova ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "iova" 12
 IO virtual address which was previously allocated.
.IP "size" 12
 number of bytes to create a mapping for
.SH "DESCRIPTION"
clear bits in the ioc's resource map
.TH "sba_io_pdir_entry" 9 "sba_io_pdir_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_io_pdir_entry \-  fill in one IO PDIR entry
.SH SYNOPSIS
.B "" sba_io_pdir_entry
.BI "(" pdir_ptr ","
.BI "" vba ");"
.SH ARGUMENTS
.IP "pdir_ptr" 12
  pointer to IO PDIR entry
.IP "vba" 12
 Virtual CPU address of buffer to map
.SH "DESCRIPTION"
SBA Mapping Routine

Given a virtual address (vba, arg1) \fBsba_io_pdir_entry\fP
loads the I/O PDIR entry pointed to by pdir_ptr (arg0).
Each IO Pdir entry consists of 8 bytes as shown below
(LSB == bit 0):

63                    40                                 11    7        0
+-+---------------------+----------------------------------+----+--------+
|V|        U            |            PPN[39:12]            | U  |   FF   |
+-+---------------------+----------------------------------+----+--------+

V  == Valid Bit
U  == Unused
PPN == Physical Page Number

The physical address fields are filled with the results of \fBvirt_to_phys\fP
on the vba.
.TH "mark_clean" 9 "mark_clean" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mark_clean \- cache coherent, any (complete) pages that were written via
.SH SYNOPSIS
.B "void" mark_clean
.BI "(void *" addr ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "addr" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"
DMA can be marked as "clean" so that \fBlazy_mmu_prot_update\fP doesn't have to
flush them when they get mapped into an executable vm-area.
.TH "sba_mark_invalid" 9 "sba_mark_invalid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_mark_invalid \-  invalidate one or more IO PDIR entries
.SH SYNOPSIS
.B "SBA_INLINE void" sba_mark_invalid
.BI "(struct ioc *" ioc ","
.BI "dma_addr_t " iova ","
.BI "size_t " byte_cnt ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "iova" 12
  IO Virtual Address mapped earlier
.IP "byte_cnt" 12
  number of bytes this mapping covers.
.SH "DESCRIPTION"
Marking the IO PDIR entry(ies) as Invalid and invalidate
corresponding IO TLB entry. The PCOM (Purge Command Register)
is to purge stale entries in the IO TLB when unmapping entries.

The PCOM register supports purging of multiple pages, with a minium
of 1 page and a maximum of 2GB. Hardware requires the address be
aligned to the size of the range being purged. The size of the range
must be a power of 2. The "Cool perf optimization" in the
allocation routine helps keep that true.
.TH "sba_map_single" 9 "sba_map_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_map_single \-  map one buffer and return IOVA for DMA
.SH SYNOPSIS
.B "dma_addr_t" sba_map_single
.BI "(struct device *" dev ","
.BI "void *" addr ","
.BI "size_t " size ","
.BI "int " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "addr" 12
  driver buffer to map.
.IP "size" 12
  number of bytes to map in driver buffer.
.IP "dir" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_unmap_single" 9 "sba_unmap_single" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_unmap_single \-  unmap one IOVA and free resources
.SH SYNOPSIS
.B "void" sba_unmap_single
.BI "(struct device *" dev ","
.BI "dma_addr_t " iova ","
.BI "size_t " size ","
.BI "int " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "iova" 12
  IOVA of driver buffer previously mapped.
.IP "size" 12
  number of bytes mapped in driver buffer.
.IP "dir" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_alloc_coherent" 9 "sba_alloc_coherent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_alloc_coherent \-  allocate/map shared mem for DMA
.SH SYNOPSIS
.B "void *" sba_alloc_coherent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "dma_addr_t *" dma_handle ","
.BI "int " flags ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "size" 12
  number of bytes mapped in driver buffer.
.IP "dma_handle" 12
  IOVA of new buffer.
.IP "flags" 12
-- undescribed --
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_free_coherent" 9 "sba_free_coherent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_free_coherent \-  free/unmap shared mem for DMA
.SH SYNOPSIS
.B "void" sba_free_coherent
.BI "(struct device *" dev ","
.BI "size_t " size ","
.BI "void *" vaddr ","
.BI "dma_addr_t " dma_handle ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "size" 12
  number of bytes mapped in driver buffer.
.IP "vaddr" 12
  virtual address IOVA of "consistent" buffer.
.IP "dma_handle" 12
-- undescribed --
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_fill_pdir" 9 "sba_fill_pdir" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_fill_pdir \-  write allocated SG entries into IO PDIR
.SH SYNOPSIS
.B "SBA_INLINE int" sba_fill_pdir
.BI "(struct ioc *" ioc ","
.BI "struct scatterlist *" startsg ","
.BI "int " nents ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "startsg" 12
  list of IOVA/size pairs
.IP "nents" 12
 number of entries in startsg list
.SH "DESCRIPTION"
Take preprocessed SG list and write corresponding entries
in the IO PDIR.
.TH "sba_coalesce_chunks" 9 "sba_coalesce_chunks" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_coalesce_chunks \-  preprocess the SG list
.SH SYNOPSIS
.B "SBA_INLINE int" sba_coalesce_chunks
.BI "(struct ioc *" ioc ","
.BI "struct scatterlist *" startsg ","
.BI "int " nents ");"
.SH ARGUMENTS
.IP "ioc" 12
 IO MMU structure which owns the pdir we are interested in.
.IP "startsg" 12
  list of IOVA/size pairs
.IP "nents" 12
 number of entries in startsg list
.SH "DESCRIPTION"
First pass is to walk the SG list and determine where the breaks are
in the DMA stream. Allocates PDIR entries but does not fill them.
Returns the number of DMA chunks.

Doing the fill separate from the coalescing/allocation keeps the
code simpler. Future enhancement could make one pass through
the sglist do both.
.TH "sba_map_sg" 9 "sba_map_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_map_sg \-  map Scatter/Gather list
.SH SYNOPSIS
.B "int" sba_map_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sglist ","
.BI "int " nents ","
.BI "int " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "sglist" 12
  array of buffer/length pairs
.IP "nents" 12
  number of entries in list
.IP "dir" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "sba_unmap_sg" 9 "sba_unmap_sg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sba_unmap_sg \-  unmap Scatter/Gather list
.SH SYNOPSIS
.B "void" sba_unmap_sg
.BI "(struct device *" dev ","
.BI "struct scatterlist *" sglist ","
.BI "int " nents ","
.BI "int " dir ");"
.SH ARGUMENTS
.IP "dev" 12
 instance of PCI owned by the driver that's asking.
.IP "sglist" 12
  array of buffer/length pairs
.IP "nents" 12
  number of entries in list
.IP "dir" 12
  R/W or both.
.SH "DESCRIPTION"
See Documentation/DMA-mapping.txt
.TH "ssp_write_word" 9 "ssp_write_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_write_word \-  write a word to the SSP port
.SH SYNOPSIS
.B "int" ssp_write_word
.BI "(struct ssp_dev *" dev ","
.BI "u32 " data ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "data" 12
 32-bit, MSB justified data to write.
.SH "DESCRIPTION"
Wait for a free entry in the SSP transmit FIFO, and write a data
word to the SSP port.

The caller is expected to perform the necessary locking.
.SH "RETURNS"
-ETIMEDOUT	timeout occurred (for future)
0			success
.TH "ssp_read_word" 9 "ssp_read_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_read_word \-  read a word from the SSP port
.SH SYNOPSIS
.B "int" ssp_read_word
.BI "(struct ssp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Wait for a data word in the SSP receive FIFO, and return the
received data.  Data is LSB justified.
.SH "NOTE"
 Currently, if data is not expected to be received, this
function will wait for ever.

The caller is expected to perform the necessary locking.
.SH "RETURNS"
-ETIMEDOUT	timeout occurred (for future)
32-bit data	success
.TH "ssp_flush" 9 "ssp_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_flush \-  flush the transmit and receive FIFOs
.SH SYNOPSIS
.B "void" ssp_flush
.BI "(struct ssp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Wait for the SSP to idle, and ensure that the receive FIFO
is empty.

The caller is expected to perform the necessary locking.
.TH "ssp_enable" 9 "ssp_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_enable \-  enable the SSP port
.SH SYNOPSIS
.B "void" ssp_enable
.BI "(struct ssp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Turn on the SSP port.
.TH "ssp_disable" 9 "ssp_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_disable \-  shut down the SSP port
.SH SYNOPSIS
.B "void" ssp_disable
.BI "(struct ssp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

Turn off the SSP port, optionally powering it down.
.TH "ssp_save_state" 9 "ssp_save_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_save_state \-  save the SSP configuration
.SH SYNOPSIS
.B "void" ssp_save_state
.BI "(struct ssp_dev *" dev ","
.BI "struct ssp_state *" ssp ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "ssp" 12
 pointer to structure to save SSP configuration
.SH "DESCRIPTION"
Save the configured SSP state for suspend.
.TH "ssp_restore_state" 9 "ssp_restore_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_restore_state \-  restore a previously saved SSP configuration
.SH SYNOPSIS
.B "void" ssp_restore_state
.BI "(struct ssp_dev *" dev ","
.BI "struct ssp_state *" ssp ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "ssp" 12
 pointer to configuration saved by ssp_save_state
.SH "DESCRIPTION"
Restore the SSP configuration saved previously by ssp_save_state.
.TH "ssp_config" 9 "ssp_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_config \-  configure SSP port settings
.SH SYNOPSIS
.B "int" ssp_config
.BI "(struct ssp_dev *" dev ","
.BI "u32 " mode ","
.BI "u32 " flags ","
.BI "u32 " psp_flags ","
.BI "u32 " speed ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "mode" 12
 port operating mode
.IP "flags" 12
 port config flags
.IP "psp_flags" 12
 port PSP config flags
.IP "speed" 12
 port speed
.SH "DESCRIPTION"
Port MUST be disabled by ssp_disable before making any config changes.
.TH "ssp_init" 9 "ssp_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_init \-  setup the SSP port
.SH SYNOPSIS
.B "int" ssp_init
.BI "(struct ssp_dev *" dev ","
.BI "u32 " port ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "port" 12
-- undescribed --
.SH "DESCRIPTION"

initialise and claim resources for the SSP port.
.SH "RETURNS"
-ENODEV	if the SSP port is unavailable
-EBUSY	if the resources are already in use
0		on success
.TH "ssp_exit" 9 "ssp_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_exit \-  undo the effects of ssp_init
.SH SYNOPSIS
.B "void" ssp_exit
.BI "(struct ssp_dev *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.SH "DESCRIPTION"

release and free resources for the SSP port.
.TH "save_time_delta" 9 "save_time_delta" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
save_time_delta \-  Save the offset between system time and RTC time
.SH SYNOPSIS
.B "void" save_time_delta
.BI "(struct timespec *" delta ","
.BI "struct timespec *" rtc ");"
.SH ARGUMENTS
.IP "delta" 12
 pointer to timespec to store delta
.IP "rtc" 12
 pointer to timespec for current RTC time
.SH "DESCRIPTION"
Return a delta between the system time and the RTC time, such
that system time can be restored later with \fBrestore_time_delta\fP
.TH "restore_time_delta" 9 "restore_time_delta" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
restore_time_delta \-  Restore the current system time
.SH SYNOPSIS
.B "void" restore_time_delta
.BI "(struct timespec *" delta ","
.BI "struct timespec *" rtc ");"
.SH ARGUMENTS
.IP "delta" 12
 delta returned by \fBsave_time_delta\fP
.IP "rtc" 12
 pointer to timespec for current RTC time
.TH "pcibios_enable_device" 9 "pcibios_enable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pcibios_enable_device \-  Enable I/O and memory.
.SH SYNOPSIS
.B "int" pcibios_enable_device
.BI "(struct pci_dev *" dev ","
.BI "int " mask ");"
.SH ARGUMENTS
.IP "dev" 12
 PCI device to be enabled
.IP "mask" 12
-- undescribed --
.TH "apm_queue_event" 9 "apm_queue_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
apm_queue_event \-  queue an APM event for kapmd
.SH SYNOPSIS
.B "void" apm_queue_event
.BI "(apm_event_t " event ");"
.SH ARGUMENTS
.IP "event" 12
 APM event
.SH "DESCRIPTION"
Queue an APM event for kapmd to process and ultimately take the
appropriate action.  Only a subset of events are handled:
APM_LOW_BATTERY
APM_POWER_STATUS_CHANGE
APM_USER_SUSPEND
APM_SYS_SUSPEND
APM_CRITICAL_SUSPEND
.TH "disable_irq_nosync" 9 "disable_irq_nosync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq_nosync \-  disable an irq without waiting
.SH SYNOPSIS
.B "void" disable_irq_nosync
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line.  Enables and disables
are nested.  We do this lazily.

This function may be called from IRQ context.
.TH "disable_irq" 9 "disable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq \-  disable an irq and wait for completion
.SH SYNOPSIS
.B "void" disable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line.  Enables and disables
are nested.  This functions waits for any pending IRQ
handlers for this interrupt to complete before returning.
If you use this function while holding a resource the IRQ
handler may need you will deadlock.

This function may be called - with care - from IRQ context.
.TH "enable_irq" 9 "enable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_irq \-  enable interrupt handling on an irq
.SH SYNOPSIS
.B "void" enable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to enable
.SH "DESCRIPTION"
Re-enables the processing of interrupts on this IRQ line.
Note that this may call the interrupt handler, so you may
get unexpected results if you hold IRQs disabled.

This function may be called from IRQ context.
.TH "request_irq" 9 "request_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
request_irq \-  allocate an interrupt line
.SH SYNOPSIS
.B "int" request_irq
.BI "(unsigned int " irq ","
.BI "irqreturn_t (*" handler ") (int, void *, struct pt_regs *),"
.BI "unsigned long " irq_flags ","
.BI "const char *" devname ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to allocate
.IP "handler" 12
 Function to be called when the IRQ occurs
.IP "irq_flags" 12
-- undescribed --
.IP "devname" 12
 An ascii name for the claiming device
.IP "dev_id" 12
 A cookie passed back to the handler function
.SH "DESCRIPTION"
This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.

Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.

If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.
.SH "FLAGS"

SA_SHIRQ		Interrupt is shared

SA_INTERRUPT		Disable local interrupts while processing

SA_SAMPLE_RANDOM	The interrupt can be used for entropy
.TH "free_irq" 9 "free_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_irq \-  free an interrupt
.SH SYNOPSIS
.B "void" free_irq
.BI "(unsigned int " irq ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to free
.IP "dev_id" 12
 Device identity to free
.SH "DESCRIPTION"
Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function.

This function must not be called from interrupt context.
.TH "otg_get_transceiver" 9 "otg_get_transceiver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
otg_get_transceiver \-  find the (single) OTG transceiver driver
.SH SYNOPSIS
.B "struct otg_transceiver *" otg_get_transceiver
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns the transceiver driver, after getting a refcount to it; or
null if there is no such transceiver.  The caller is responsible for
releasing that count.
.TH "omap_pm_finish" 9 "omap_pm_finish" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
omap_pm_finish \-  Finish up suspend sequence.
.SH SYNOPSIS
.B "int" omap_pm_finish
.BI "(suspend_state_t " state ");"
.SH ARGUMENTS
.IP "state" 12
		State we're coming out of.
.SH "DESCRIPTION"
This is called after we wake back up (or if entering the sleep state
failed).
.TH "sa1100_request_dma" 9 "sa1100_request_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_request_dma \-  allocate one of the SA11x0's DMA chanels
.SH SYNOPSIS
.B "int" sa1100_request_dma
.BI "(dma_device_t " device ","
.BI "const char *" device_id ","
.BI "dma_callback_t " callback ","
.BI "void *" data ","
.BI "dma_regs_t **" dma_regs ");"
.SH ARGUMENTS
.IP "device" 12
 The SA11x0 peripheral targeted by this request
.IP "device_id" 12
 An ascii name for the claiming device
.IP "callback" 12
 Function to be called when the DMA completes
.IP "data" 12
 A cookie passed back to the callback function
.IP "dma_regs" 12
 Pointer to the location of the allocated channel's identifier
.SH "DESCRIPTION"
This function will search for a free DMA channel and returns the
address of the hardware registers for that channel as the channel
identifier. This identifier is written to the location pointed by
\fIdma_regs\fP. The list of possible values for \fIdevice\fP are listed into
linux/include/asm-arm/arch-sa1100/dma.h as a dma_device_t enum.

Note that reading from a port and writing to the same port are
actually considered as two different streams requiring separate
DMA registrations.

The \fIcallback\fP function is called from interrupt context when one
of the two possible DMA buffers in flight has terminated. That
function has to be small and efficient while posponing more complex
processing to a lower priority execution context.

If no channels are available, or if the desired \fIdevice\fP is already in
use by another DMA channel, then an error code is returned.  This
function must be called before any other DMA calls.
.TH "sa1100_free_dma" 9 "sa1100_free_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_free_dma \-  free a SA11x0 DMA channel
.SH SYNOPSIS
.B "void" sa1100_free_dma
.BI "(dma_regs_t *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 identifier for the channel to free
.SH "DESCRIPTION"
This clears all activities on a given DMA channel and releases it
for future requests.  The \fIregs\fP identifier is provided by a
successful call to \fBsa1100_request_dma\fP.
.TH "sa1100_start_dma" 9 "sa1100_start_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_start_dma \-  submit a data buffer for DMA
.SH SYNOPSIS
.B "int" sa1100_start_dma
.BI "(dma_regs_t *" regs ","
.BI "dma_addr_t " dma_ptr ","
.BI "u_int " size ");"
.SH ARGUMENTS
.IP "regs" 12
 identifier for the channel to use
.IP "dma_ptr" 12
 buffer physical (or bus) start address
.IP "size" 12
 buffer size
.SH "DESCRIPTION"
This function hands the given data buffer to the hardware for DMA
access. If another buffer is already in flight then this buffer
will be queued so the DMA engine will switch to it automatically
when the previous one is done.  The DMA engine is actually toggling
between two buffers so at most 2 successful calls can be made before
one of them terminates and the callback function is called.

The \fIregs\fP identifier is provided by a successful call to
\fBsa1100_request_dma\fP.

The \fIsize\fP must not be larger than MAX_DMA_SIZE.  If a given buffer
is larger than that then it's the caller's responsibility to split
it into smaller chunks and submit them separately. If this is the
case then a \fIsize\fP of CUT_DMA_SIZE is recommended to avoid ending
up with too small chunks. The callback function can be used to chain
submissions of buffer chunks.
.SH "ERROR RETURN VALUES"
-EOVERFLOW:	Given buffer size is too big.
-EBUSY:	Both DMA buffers are already in use.
-EAGAIN:	Both buffers were busy but one of them just completed
but the interrupt handler has to execute first.

This function returs 0 on success.
.TH "sa1100_get_dma_pos" 9 "sa1100_get_dma_pos" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_get_dma_pos \-  return current DMA position
.SH SYNOPSIS
.B "dma_addr_t" sa1100_get_dma_pos
.BI "(dma_regs_t *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 identifier for the channel to use
.SH "DESCRIPTION"
This function returns the current physical (or bus) address for the
given DMA channel.  If the channel is running i.e. not in a stopped
state then the caller must disable interrupts prior calling this
function and process the returned value before re-enabling them to
prevent races with the completion interrupt handler and the callback
function. The validation of the returned value is the caller's
responsibility as well -- the hardware seems to return out of range
values when the DMA engine completes a buffer.

The \fIregs\fP identifier is provided by a successful call to
\fBsa1100_request_dma\fP.
.TH "sa1100_reset_dma" 9 "sa1100_reset_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1100_reset_dma \-  reset a DMA channel
.SH SYNOPSIS
.B "void" sa1100_reset_dma
.BI "(dma_regs_t *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 identifier for the channel to use
.SH "DESCRIPTION"
This function resets and reconfigure the given DMA channel. This is
particularly useful after a sleep/wakeup event.

The \fIregs\fP identifier is provided by a successful call to
\fBsa1100_request_dma\fP.
.TH "hackkit_uart_pm" 9 "hackkit_uart_pm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hackkit_uart_pm \-  powermgmt callback function for system 3 UART
.SH SYNOPSIS
.B "void" hackkit_uart_pm
.BI "(struct uart_port *" port ","
.BI "u_int " state ","
.BI "u_int " oldstate ");"
.SH ARGUMENTS
.IP "port" 12
 uart port structure
.IP "state" 12
 pm state
.IP "oldstate" 12
 old pm state
.TH "ssp_write_word" 9 "ssp_write_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_write_word \-  write a word to the SSP port
.SH SYNOPSIS
.B "int" ssp_write_word
.BI "(u16 " data ");"
.SH ARGUMENTS
.IP "data" 12
 16-bit, MSB justified data to write.
.SH "DESCRIPTION"
Wait for a free entry in the SSP transmit FIFO, and write a data
word to the SSP port.  Wait for the SSP port to start sending
the data.

The caller is expected to perform the necessary locking.
.SH "RETURNS"
-ETIMEDOUT	timeout occurred (for future)
0			success
.TH "ssp_read_word" 9 "ssp_read_word" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_read_word \-  read a word from the SSP port
.SH SYNOPSIS
.B "int" ssp_read_word
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Wait for a data word in the SSP receive FIFO, and return the
received data.  Data is LSB justified.
.SH "NOTE"
 Currently, if data is not expected to be received, this
function will wait for ever.

The caller is expected to perform the necessary locking.
.SH "RETURNS"
-ETIMEDOUT	timeout occurred (for future)
16-bit data	success
.TH "ssp_flush" 9 "ssp_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_flush \-  flush the transmit and receive FIFOs
.SH SYNOPSIS
.B "void" ssp_flush
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Wait for the SSP to idle, and ensure that the receive FIFO
is empty.

The caller is expected to perform the necessary locking.
.TH "ssp_enable" 9 "ssp_enable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_enable \-  enable the SSP port
.SH SYNOPSIS
.B "void" ssp_enable
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Turn on the SSP port.
.TH "ssp_disable" 9 "ssp_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_disable \-  shut down the SSP port
.SH SYNOPSIS
.B "void" ssp_disable
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Turn off the SSP port, optionally powering it down.
.TH "ssp_save_state" 9 "ssp_save_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_save_state \-  save the SSP configuration
.SH SYNOPSIS
.B "void" ssp_save_state
.BI "(struct ssp_state *" ssp ");"
.SH ARGUMENTS
.IP "ssp" 12
 pointer to structure to save SSP configuration
.SH "DESCRIPTION"
Save the configured SSP state for suspend.
.TH "ssp_restore_state" 9 "ssp_restore_state" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_restore_state \-  restore a previously saved SSP configuration
.SH SYNOPSIS
.B "void" ssp_restore_state
.BI "(struct ssp_state *" ssp ");"
.SH ARGUMENTS
.IP "ssp" 12
 pointer to configuration saved by ssp_save_state
.SH "DESCRIPTION"
Restore the SSP configuration saved previously by ssp_save_state.
.TH "ssp_init" 9 "ssp_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_init \-  setup the SSP port
.SH SYNOPSIS
.B "int" ssp_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

initialise and claim resources for the SSP port.
.SH "RETURNS"
-ENODEV	if the SSP port is unavailable
-EBUSY	if the resources are already in use
0		on success
.TH "ssp_exit" 9 "ssp_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ssp_exit \-  undo the effects of ssp_init
.SH SYNOPSIS
.B "void" ssp_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

release and free resources for the SSP port.
.TH "__locomo_probe" 9 "__locomo_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__locomo_probe \-  probe for a single LoCoMo chip.
.SH SYNOPSIS
.B "int" __locomo_probe
.BI "(struct device *" me ","
.BI "struct resource *" mem ","
.BI "int " irq ");"
.SH ARGUMENTS
.IP "me" 12
-- undescribed --
.IP "mem" 12
-- undescribed --
.IP "irq" 12
-- undescribed --
.SH "DESCRIPTION"
Probe for a LoCoMo chip.  This must be called
before any other locomo-specific code.
.SH "RETURNS"
-ENODEV	device not found.
-EBUSY		physical address already marked in-use.
0		successful.
.TH "__sa1111_probe" 9 "__sa1111_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__sa1111_probe \-  probe for a single SA1111 chip.
.SH SYNOPSIS
.B "int" __sa1111_probe
.BI "(struct device *" me ","
.BI "struct resource *" mem ","
.BI "int " irq ");"
.SH ARGUMENTS
.IP "me" 12
-- undescribed --
.IP "mem" 12
-- undescribed --
.IP "irq" 12
-- undescribed --
.SH "DESCRIPTION"
Probe for a SA1111 chip.  This must be called
before any other SA1111-specific code.
.SH "RETURNS"
-ENODEV	device not found.
-EBUSY		physical address already marked in-use.
0		successful.
.TH "sa1111_pll_clock" 9 "sa1111_pll_clock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1111_pll_clock \-  return the current PLL clock frequency.
.SH SYNOPSIS
.B "unsigned int" sa1111_pll_clock
.BI "(struct sa1111_dev *" sadev ");"
.SH ARGUMENTS
.IP "sadev" 12
 SA1111 function block
.SH "BUG"
 we should look at SKCR.  We also blindly believe that
the chip is being fed with the 3.6864MHz clock.

Returns the PLL clock in Hz.
.TH "sa1111_select_audio_mode" 9 "sa1111_select_audio_mode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1111_select_audio_mode \-  select I2S or AC link mode
.SH SYNOPSIS
.B "void" sa1111_select_audio_mode
.BI "(struct sa1111_dev *" sadev ","
.BI "int " mode ");"
.SH ARGUMENTS
.IP "sadev" 12
 SA1111 function block
.IP "mode" 12
 One of SA1111_AUDIO_ACLINK or SA1111_AUDIO_I2S
.SH "DESCRIPTION"
Frob the SKCR to select AC Link mode or I2S mode for
the audio block.
.TH "sa1111_set_audio_rate" 9 "sa1111_set_audio_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1111_set_audio_rate \-  set the audio sample rate
.SH SYNOPSIS
.B "int" sa1111_set_audio_rate
.BI "(struct sa1111_dev *" sadev ","
.BI "int " rate ");"
.SH ARGUMENTS
.IP "sadev" 12
 SA1111 SAC function block
.IP "rate" 12
 sample rate to select
.TH "sa1111_get_audio_rate" 9 "sa1111_get_audio_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1111_get_audio_rate \-  get the audio sample rate
.SH SYNOPSIS
.B "int" sa1111_get_audio_rate
.BI "(struct sa1111_dev *" sadev ");"
.SH ARGUMENTS
.IP "sadev" 12
 SA1111 SAC function block device
.TH "sa1111_enable_device" 9 "sa1111_enable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1111_enable_device \-  enable an on-chip SA1111 function block
.SH SYNOPSIS
.B "void" sa1111_enable_device
.BI "(struct sa1111_dev *" sadev ");"
.SH ARGUMENTS
.IP "sadev" 12
 SA1111 function block device to enable
.TH "sa1111_disable_device" 9 "sa1111_disable_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sa1111_disable_device \-  disable an on-chip SA1111 function block
.SH SYNOPSIS
.B "void" sa1111_disable_device
.BI "(struct sa1111_dev *" sadev ");"
.SH ARGUMENTS
.IP "sadev" 12
 SA1111 function block device to disable
.TH "amba_driver_register" 9 "amba_driver_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
amba_driver_register \-  register an AMBA device driver
.SH SYNOPSIS
.B "int" amba_driver_register
.BI "(struct amba_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 amba device driver structure
.SH "DESCRIPTION"
Register an AMBA device driver with the Linux device model
core.  If devices pre-exist, the drivers probe function will
be called.
.TH "amba_driver_unregister" 9 "amba_driver_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
amba_driver_unregister \-  remove an AMBA device driver
.SH SYNOPSIS
.B "void" amba_driver_unregister
.BI "(struct amba_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 AMBA device driver structure to remove
.SH "DESCRIPTION"
Unregister an AMBA device driver from the Linux device
model.  The device model will call the drivers remove function
for each device the device driver is currently handling.
.TH "amba_device_register" 9 "amba_device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
amba_device_register \-  register an AMBA device
.SH SYNOPSIS
.B "int" amba_device_register
.BI "(struct amba_device *" dev ","
.BI "struct resource *" parent ");"
.SH ARGUMENTS
.IP "dev" 12
 AMBA device to register
.IP "parent" 12
 parent memory resource
.SH "DESCRIPTION"
Setup the AMBA device, reading the cell ID if present.
Claim the resource, and register the AMBA device with
the Linux device manager.
.TH "amba_device_unregister" 9 "amba_device_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
amba_device_unregister \-  unregister an AMBA device
.SH SYNOPSIS
.B "void" amba_device_unregister
.BI "(struct amba_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 AMBA device to remove
.SH "DESCRIPTION"
Remove the specified AMBA device from the Linux device
manager.  All files associated with this object will be
destroyed, and device drivers notified that the device has
been removed.  The AMBA device's resources including
the amba_device structure will be freed once all
references to it have been dropped.
.TH "amba_find_device" 9 "amba_find_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
amba_find_device \-  locate an AMBA device given a bus id
.SH SYNOPSIS
.B "struct amba_device *" amba_find_device
.BI "(const char *" busid ","
.BI "struct device *" parent ","
.BI "unsigned int " id ","
.BI "unsigned int " mask ");"
.SH ARGUMENTS
.IP "busid" 12
 bus id for device (or NULL)
.IP "parent" 12
 parent device (or NULL)
.IP "id" 12
 peripheral ID (or 0)
.IP "mask" 12
 peripheral ID mask (or 0)
.SH "DESCRIPTION"
Return the AMBA device corresponding to the supplied parameters.
If no device matches, returns NULL.
.SH "NOTE"
 When a valid device is found, its refcount is
incremented, and must be decremented before the returned
reference.
.TH "amba_request_regions" 9 "amba_request_regions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
amba_request_regions \-  request all mem regions associated with device
.SH SYNOPSIS
.B "int" amba_request_regions
.BI "(struct amba_device *" dev ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "dev" 12
 amba_device structure for device
.IP "name" 12
 name, or NULL to use driver name
.TH "amba_release_regions" 9 "amba_release_regions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
amba_release_regions \-  release mem regions assoicated with device
.SH SYNOPSIS
.B "void" amba_release_regions
.BI "(struct amba_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 amba_device structure for device
.SH "DESCRIPTION"
Release regions claimed by a successful call to amba_request_regions.
.TH "cm_control" 9 "cm_control" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cm_control \-  update the CM_CTRL register.
.SH SYNOPSIS
.B "void" cm_control
.BI "(u32 " mask ","
.BI "u32 " set ");"
.SH ARGUMENTS
.IP "mask" 12
 bits to change
.IP "set" 12
 bits to set
.TH "spin_retry_setup" 9 "spin_retry_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
spin_retry_setup \- 
.SH SYNOPSIS
.B "int __init" spin_retry_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
-- undescribed --
.TH "strlen" 9 "strlen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlen \-  Find the length of a string
.SH SYNOPSIS
.B "size_t" strlen
.BI "(const char *" s ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be sized
.SH "DESCRIPTION"
returns the length of \fIs\fP
.TH "strnlen" 9 "strnlen" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strnlen \-  Find the length of a length-limited string
.SH SYNOPSIS
.B "size_t" strnlen
.BI "(const char *" s ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be sized
.IP "n" 12
 The maximum number of bytes to search
.SH "DESCRIPTION"
returns the minimum of the length of \fIs\fP and \fIn\fP
.TH "strcpy" 9 "strcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strcpy \-  Copy a %NUL terminated string
.SH SYNOPSIS
.B "char *" strcpy
.BI "(char *" dest ","
.BI "const char *" src ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy the string to
.IP "src" 12
 Where to copy the string from
.SH "DESCRIPTION"
returns a pointer to \fIdest\fP
.TH "strlcpy" 9 "strlcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlcpy \-  Copy a %NUL terminated string into a sized buffer
.SH SYNOPSIS
.B "size_t" strlcpy
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy the string to
.IP "src" 12
 Where to copy the string from
.IP "size" 12
 size of destination buffer
.SH "BSD"
 the result is always a valid
NUL-terminated string that fits in the buffer (unless,
of course, the buffer size is zero). It does not pad
out the result like \fBstrncpy\fP does.
.TH "strncpy" 9 "strncpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strncpy \-  Copy a length-limited, %NUL-terminated string
.SH SYNOPSIS
.B "char *" strncpy
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy the string to
.IP "src" 12
 Where to copy the string from
.IP "n" 12
 The maximum number of bytes to copy
.SH "DESCRIPTION"
The result is not NUL-terminated if the source exceeds
\fIn\fP bytes.
.TH "strcat" 9 "strcat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strcat \-  Append one %NUL-terminated string to another
.SH SYNOPSIS
.B "char *" strcat
.BI "(char *" dest ","
.BI "const char *" src ");"
.SH ARGUMENTS
.IP "dest" 12
 The string to be appended to
.IP "src" 12
 The string to append to it
.SH "DESCRIPTION"
returns a pointer to \fIdest\fP
.TH "strlcat" 9 "strlcat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strlcat \-  Append a length-limited, %NUL-terminated string to another
.SH SYNOPSIS
.B "size_t" strlcat
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "dest" 12
 The string to be appended to
.IP "src" 12
 The string to append to it
.IP "n" 12
 The size of the destination buffer.
.TH "strncat" 9 "strncat" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strncat \-  Append a length-limited, %NUL-terminated string to another
.SH SYNOPSIS
.B "char *" strncat
.BI "(char *" dest ","
.BI "const char *" src ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "dest" 12
 The string to be appended to
.IP "src" 12
 The string to append to it
.IP "n" 12
 The maximum numbers of bytes to copy
.SH "DESCRIPTION"
returns a pointer to \fIdest\fP

Note that in contrast to strncpy, strncat ensures the result is
terminated.
.TH "strcmp" 9 "strcmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strcmp \-  Compare two strings
.SH SYNOPSIS
.B "int" strcmp
.BI "(const char *" cs ","
.BI "const char *" ct ");"
.SH ARGUMENTS
.IP "cs" 12
 One string
.IP "ct" 12
 Another string
.SH "DESCRIPTION"
returns   0 if \fIcs\fP and \fIct\fP are equal,
&lt; 0 if \fIcs\fP is less than \fIct\fP
&gt; 0 if \fIcs\fP is greater than \fIct\fP
.TH "strrchr" 9 "strrchr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strrchr \-  Find the last occurrence of a character in a string
.SH SYNOPSIS
.B "char *" strrchr
.BI "(const char *" s ","
.BI "int " c ");"
.SH ARGUMENTS
.IP "s" 12
 The string to be searched
.IP "c" 12
 The character to search for
.TH "strstr" 9 "strstr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
strstr \-  Find the first substring in a %NUL terminated string
.SH SYNOPSIS
.B "char *" strstr
.BI "(const char *" s1 ","
.BI "const char *" s2 ");"
.SH ARGUMENTS
.IP "s1" 12
 The string to be searched
.IP "s2" 12
 The string to search for
.TH "memchr" 9 "memchr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memchr \-  Find a character in an area of memory.
.SH SYNOPSIS
.B "void *" memchr
.BI "(const void *" s ","
.BI "int " c ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "s" 12
 The memory area
.IP "c" 12
 The byte to search for
.IP "n" 12
 The size of the area.
.SH "DESCRIPTION"
returns the address of the first occurrence of \fIc\fP, or NULL
if \fIc\fP is not found
.TH "memcmp" 9 "memcmp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memcmp \-  Compare two areas of memory
.SH SYNOPSIS
.B "int" memcmp
.BI "(const void *" cs ","
.BI "const void *" ct ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "cs" 12
 One area of memory
.IP "ct" 12
 Another area of memory
.IP "n" 12
-- undescribed --
.TH "memscan" 9 "memscan" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memscan \-  Find a character in an area of memory.
.SH SYNOPSIS
.B "void *" memscan
.BI "(void *" s ","
.BI "int " c ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "s" 12
 The memory area
.IP "c" 12
 The byte to search for
.IP "n" 12
 The size of the area.
.SH "DESCRIPTION"
returns the address of the first occurrence of \fIc\fP, or 1 byte past
the area if \fIc\fP is not found
.TH "memcpy" 9 "memcpy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memcpy \-  Copy one area of memory to another
.SH SYNOPSIS
.B "void *" memcpy
.BI "(void *" dest ","
.BI "const void *" src ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "dest" 12
 Where to copy to
.IP "src" 12
 Where to copy from
.IP "n" 12
 The size of the area.
.SH "DESCRIPTION"
returns a pointer to \fIdest\fP
.TH "memset" 9 "memset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
memset \-  Fill a region of memory with the given value
.SH SYNOPSIS
.B "void *" memset
.BI "(void *" s ","
.BI "int " c ","
.BI "size_t " n ");"
.SH ARGUMENTS
.IP "s" 12
 Pointer to the start of the area.
.IP "c" 12
 The byte to fill the area with
.IP "n" 12
 The size of the area.
.SH "DESCRIPTION"
returns a pointer to \fIs\fP
.TH "oprofile_arch_init" 9 "oprofile_arch_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
oprofile_arch_init \- 
.SH SYNOPSIS
.B "int __init" oprofile_arch_init
.BI "(struct oprofile_operations *" ops ");"
.SH ARGUMENTS
.IP "ops" 12
-- undescribed --
.SH "DESCRIPTION"

S390 Version
Copyright (C) 2003 IBM Deutschland Entwicklung GmbH, IBM Corporation
Author(s): Thomas Spatzier (tspat\fIde\fP.ibm.com)

\fIremark\fP Copyright 2002 OProfile authors
.TH "crypt_z990_func_available" 9 "crypt_z990_func_available" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
crypt_z990_func_available \- 
.SH SYNOPSIS
.B "int" crypt_z990_func_available
.BI "(int " func ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.TH "of_find_node_by_name" 9 "of_find_node_by_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_find_node_by_name \-  Find a node by it's "name" property
.SH SYNOPSIS
.B "struct device_node *" of_find_node_by_name
.BI "(struct device_node *" from ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "from" 12
	The node to start searching from or NULL, the node
you pass will not be searched, only the next one
will; typically, you pass what the previous call
returned. \fBof_node_put\fP will be called on it
.IP "name" 12
	The name string to match against
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.TH "of_find_node_by_type" 9 "of_find_node_by_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_find_node_by_type \-  Find a node by it's "device_type" property
.SH SYNOPSIS
.B "struct device_node *" of_find_node_by_type
.BI "(struct device_node *" from ","
.BI "const char *" type ");"
.SH ARGUMENTS
.IP "from" 12
	The node to start searching from or NULL, the node
you pass will not be searched, only the next one
will; typically, you pass what the previous call
returned. \fBof_node_put\fP will be called on it
.IP "type" 12
-- undescribed --
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.TH "of_find_compatible_node" 9 "of_find_compatible_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_find_compatible_node \-  Find a node based on type and one of the
.SH SYNOPSIS
.B "struct device_node *" of_find_compatible_node
.BI "(struct device_node *" from ","
.BI "const char *" type ","
.BI "const char *" compatible ");"
.SH ARGUMENTS
.IP "from" 12
		The node to start searching from or NULL, the node
you pass will not be searched, only the next one
will; typically, you pass what the previous call
returned. \fBof_node_put\fP will be called on it
.IP "type" 12
		The type string to match "device_type" or NULL to ignore
.IP "compatible" 12
	The string to match to one of the tokens in the device
"compatible" list.
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.TH "of_find_node_by_path" 9 "of_find_node_by_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_find_node_by_path \-  Find a node matching a full OF path
.SH SYNOPSIS
.B "struct device_node *" of_find_node_by_path
.BI "(const char *" path ");"
.SH ARGUMENTS
.IP "path" 12
	The full path to match
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.TH "of_find_all_nodes" 9 "of_find_all_nodes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_find_all_nodes \-  Get next node in global list
.SH SYNOPSIS
.B "struct device_node *" of_find_all_nodes
.BI "(struct device_node *" prev ");"
.SH ARGUMENTS
.IP "prev" 12
	Previous node or NULL to start iteration
\fBof_node_put\fP will be called on it
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.TH "of_get_parent" 9 "of_get_parent" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_get_parent \-  Get a node's parent if any
.SH SYNOPSIS
.B "struct device_node *" of_get_parent
.BI "(const struct device_node *" node ");"
.SH ARGUMENTS
.IP "node" 12
	Node to get parent
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.TH "of_get_next_child" 9 "of_get_next_child" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_get_next_child \-  Iterate a node childs
.SH SYNOPSIS
.B "struct device_node *" of_get_next_child
.BI "(const struct device_node *" node ","
.BI "struct device_node *" prev ");"
.SH ARGUMENTS
.IP "node" 12
	parent node
.IP "prev" 12
	previous child of the parent node, or NULL to get first
.SH "DESCRIPTION"
Returns a node pointer with refcount incremented, use
\fBof_node_put\fP on it when done.
.TH "of_node_get" 9 "of_node_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_node_get \-  Increment refcount of a node
.SH SYNOPSIS
.B "struct device_node *" of_node_get
.BI "(struct device_node *" node ");"
.SH ARGUMENTS
.IP "node" 12
	Node to inc refcount, NULL is supported to
simplify writing of callers
.SH "DESCRIPTION"
Returns the node itself or NULL if gone. Current implementation
does nothing as we don't yet do dynamic node allocation on ppc32
.TH "of_node_put" 9 "of_node_put" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_node_put \-  Decrement refcount of a node
.SH SYNOPSIS
.B "void" of_node_put
.BI "(struct device_node *" node ");"
.SH ARGUMENTS
.IP "node" 12
	Node to dec refcount, NULL is supported to
simplify writing of callers
.SH "DESCRIPTION"
Current implementation does nothing as we don't yet do dynamic node
allocation on ppc32
.TH "ocp_device_match" 9 "ocp_device_match" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_device_match \- 	Match one driver to one device
.SH SYNOPSIS
.B "int" ocp_device_match
.BI "(struct device *" dev ","
.BI "struct device_driver *" drv ");"
.SH ARGUMENTS
.IP "dev" 12
 device to match
.IP "drv" 12
 driver to match
.SH "DESCRIPTION"
This function returns 0 if the driver and device don't match
.TH "ocp_register_driver" 9 "ocp_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_register_driver \- 	Register an OCP driver
.SH SYNOPSIS
.B "int" ocp_register_driver
.BI "(struct ocp_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to statically defined ocp_driver structure
.SH "DESCRIPTION"
The driver's \fBprobe\fP callback is called either recursively
by this function or upon later call of ocp_driver_init
.SH "NOTE"
 Detection of devices is a 2 pass step on this implementation,
hotswap isn't supported. First, all OCP devices are put in the device
list, _then_ all drivers are probed on each match.
.TH "ocp_unregister_driver" 9 "ocp_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_unregister_driver \- 	Unregister an OCP driver
.SH SYNOPSIS
.B "void" ocp_unregister_driver
.BI "(struct ocp_driver *" drv ");"
.SH ARGUMENTS
.IP "drv" 12
 pointer to statically defined ocp_driver structure
.SH "DESCRIPTION"
The driver's \fBremove\fP callback is called recursively
by this function for any device already registered
.TH "ocp_find_device" 9 "ocp_find_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_find_device \- 	Find a device by function \\\amp; index
.SH SYNOPSIS
.B "struct ocp_device *" ocp_find_device
.BI "(unsigned int " vendor ","
.BI "unsigned int " function ","
.BI "int " index ");"
.SH ARGUMENTS
.IP "vendor" 12
 vendor ID of the device (or OCP_ANY_ID)
.IP "function" 12
 function code of the device (or OCP_ANY_ID)
.IP "index" 12
-- undescribed --
.SH "DESCRIPTION"
This function allows a lookup of a given function by it's
index, it's typically used to find the MAL or ZMII associated
with an EMAC or similar horrors.
You can pass vendor, though you usually want OCP_ANY_ID there...
.TH "ocp_get_one_device" 9 "ocp_get_one_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_get_one_device \- 	Find a def by function \\\amp; index
.SH SYNOPSIS
.B "struct ocp_def *" ocp_get_one_device
.BI "(unsigned int " vendor ","
.BI "unsigned int " function ","
.BI "int " index ");"
.SH ARGUMENTS
.IP "vendor" 12
 vendor ID of the device (or OCP_ANY_ID)
.IP "function" 12
 function code of the device (or OCP_ANY_ID)
.IP "index" 12
-- undescribed --
.SH "DESCRIPTION"
This function allows a lookup of a given ocp_def by it's
vendor, function, and index.  The main purpose for is to
allow modification of the def before binding to the driver
.TH "ocp_add_one_device" 9 "ocp_add_one_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_add_one_device \- 	Add a device
.SH SYNOPSIS
.B "int" ocp_add_one_device
.BI "(struct ocp_def *" def ");"
.SH ARGUMENTS
.IP "def" 12
 static device definition structure
.SH "DESCRIPTION"
This function adds a device definition to the
device list. It may only be called before
\fBocp_driver_init\fP and will return an error
otherwise.
.TH "ocp_remove_one_device" 9 "ocp_remove_one_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_remove_one_device \- 	Remove a device by function \\\amp; index
.SH SYNOPSIS
.B "int" ocp_remove_one_device
.BI "(unsigned int " vendor ","
.BI "unsigned int " function ","
.BI "int " index ");"
.SH ARGUMENTS
.IP "vendor" 12
 vendor ID of the device (or OCP_ANY_ID)
.IP "function" 12
 function code of the device (or OCP_ANY_ID)
.IP "index" 12
-- undescribed --
.SH "DESCRIPTION"
This function allows removal of a given function by its
index. It may only be called before \fBocp_driver_init\fP
and will return an error otherwise.
.TH "ocp_for_each_device" 9 "ocp_for_each_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_for_each_device \- 	Iterate over OCP devices
.SH SYNOPSIS
.B "void" ocp_for_each_device
.BI "(void(*" callback ") (struct ocp_device *, void *arg),"
.BI "void *" arg ");"
.SH ARGUMENTS
.IP "callback" 12
 routine to execute for each ocp device.
.IP "arg" 12
 user data to be passed to callback routine.
.SH "DESCRIPTION"
This routine holds the ocp_device semaphore, so the
callback routine cannot modify the ocp_device list.
.TH "ocp_early_init" 9 "ocp_early_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_early_init \- 	Init OCP device management
.SH SYNOPSIS
.B "int __init" ocp_early_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function builds the list of devices before setup_arch.
This allows platform code to modify the device lists before
they are bound to drivers (changes to paddr, removing devices
etc)
.TH "ocp_driver_init" 9 "ocp_driver_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ocp_driver_init \- 	Init OCP device management
.SH SYNOPSIS
.B "int __init" ocp_driver_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function is meant to be called via OCP bus registration.
.TH "of_match_device" 9 "of_match_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_match_device \-  Tell if an of_device structure has a matching
.SH SYNOPSIS
.B "const struct of_device_id *" of_match_device
.BI "(const struct of_device_id *" matches ","
.BI "const struct of_device *" dev ");"
.SH ARGUMENTS
.IP "matches" 12
-- undescribed --
.IP "dev" 12
 the of device structure to match against
.SH "DESCRIPTION"
Used by a driver to check whether an of_device present in the
system is in its list of supported devices.
.SH "DESCRIPTION"
Used by a driver to check whether an of_device present in the
system is in its list of supported devices.
.TH "of_release_dev" 9 "of_release_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
of_release_dev \-  free an of device structure when all users of it are finished.
.SH SYNOPSIS
.B "void" of_release_dev
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 device that's been disconnected
.SH "DESCRIPTION"
Will be called only by the device core when all users of this of device are
done.
.TH "simple_strtoull" 9 "simple_strtoull" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
simple_strtoull \-  convert a string to an unsigned long long
.SH SYNOPSIS
.B "unsigned long long" simple_strtoull
.BI "(const char *" cp ","
.BI "char **" endp ","
.BI "unsigned int " base ");"
.SH ARGUMENTS
.IP "cp" 12
 The start of the string
.IP "endp" 12
 A pointer to the end of the parsed string will be placed here
.IP "base" 12
 The number base to use
.TH "csum_fold" 9 "csum_fold" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
csum_fold \-  Fold and invert a 32bit checksum.
.SH SYNOPSIS
.B "unsigned int" csum_fold
.BI "(unsigned int " sum ");"
.SH ARGUMENTS
.IP "sum" 12
-- undescribed --
.SH "SUM"
 32bit unfolded sum

Fold a 32bit running checksum to 16bit and invert it. This is usually
the last step before putting a checksum into a packet.
Make sure not to mix with 64bit checksums.
.TH "csum_tcpudp_nofold" 9 "csum_tcpudp_nofold" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
csum_tcpudp_nofold \-  Compute an IPv4 pseudo header checksum.
.SH SYNOPSIS
.B "unsigned long" csum_tcpudp_nofold
.BI "(unsigned " saddr ","
.BI "unsigned " daddr ","
.BI "unsigned short " len ","
.BI "unsigned short " proto ","
.BI "unsigned int " sum ");"
.SH ARGUMENTS
.IP "saddr" 12
 source address
.IP "daddr" 12
 destination address
.IP "len" 12
 length of packet
.IP "proto" 12
 ip protocol of packet
.IP "sum" 12
 initial sum to be added in (32bit unfolded)
.SH "DESCRIPTION"
Returns the pseudo header checksum the input data. Result is
32bit unfolded.
.TH "ip_fast_csum" 9 "ip_fast_csum" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ip_fast_csum \-  Compute the IPv4 header checksum efficiently.
.SH SYNOPSIS
.B "unsigned short" ip_fast_csum
.BI "(unsigned char *" iph ","
.BI "unsigned int " ihl ");"
.SH ARGUMENTS
.IP "iph" 12
-- undescribed --
.IP "ihl" 12
-- undescribed --
.SH "IPH"
 ipv4 header
.SH "IHL"
 length of header / 4
.TH "smp_call_function" 9 "smp_call_function" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
smp_call_function \- 
.SH SYNOPSIS
.B "int" smp_call_function
.BI "(void (*" func ") (void *info),"
.BI "void *" info ","
.BI "int " retry ","
.BI "int " wait ");"
.SH ARGUMENTS
.IP "func" 12
-- undescribed --
.IP "info" 12
-- undescribed --
.IP "retry" 12
-- undescribed --
.IP "wait" 12
-- undescribed --
.SH "DESCRIPTION"
&lt;func&gt;	The function to run. This must be fast and non-blocking.
&lt;info&gt;	An arbitrary pointer to pass to the function.
&lt;retry&gt;	If true, keep retrying until ready.
&lt;wait&gt;	If true, wait until function has completed on other CPUs.
[RETURNS]   0 on success, else a negative status code.

Does not return until remote CPUs are nearly ready to execute &lt;func&gt;
or have executed.
.TH "next_dev" 9 "next_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
next_dev \-  enumerates registered devices
.SH SYNOPSIS
.B "struct parisc_device *" next_dev
.BI "(struct device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 the previous device returned from next_dev
.SH "DESCRIPTION"
next_dev does a depth-first search of the tree, returning parents
before children.  Returns NULL when there are no more devices.
.TH "match_device" 9 "match_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_device \-  Report whether this driver can handle this device
.SH SYNOPSIS
.B "int" match_device
.BI "(struct parisc_driver *" driver ","
.BI "struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "driver" 12
 the PA-RISC driver to try
.IP "dev" 12
 the PA-RISC device to try
.TH "register_parisc_driver" 9 "register_parisc_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_parisc_driver \-  Register this driver if it can handle a device
.SH SYNOPSIS
.B "int" register_parisc_driver
.BI "(struct parisc_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
 the PA-RISC driver to try
.TH "count_parisc_driver" 9 "count_parisc_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
count_parisc_driver \-  count # of devices this driver would match
.SH SYNOPSIS
.B "int" count_parisc_driver
.BI "(struct parisc_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
 the PA-RISC driver to try
.SH "DESCRIPTION"
Use by IOMMU support to "guess" the right size IOPdir.
Formula is something like memsize/(num_iommu * entry_size).
.TH "unregister_parisc_driver" 9 "unregister_parisc_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_parisc_driver \-  Unregister this driver from the list of drivers
.SH SYNOPSIS
.B "int" unregister_parisc_driver
.BI "(struct parisc_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
 the PA-RISC driver to unregister
.TH "find_pa_parent_type" 9 "find_pa_parent_type" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_pa_parent_type \-  Find a parent of a specific type
.SH SYNOPSIS
.B "const struct parisc_device *" find_pa_parent_type
.BI "(const struct parisc_device *" padev ","
.BI "int " type ");"
.SH ARGUMENTS
.IP "padev" 12
-- undescribed --
.IP "type" 12
 The device type to search for.
.SH "DESCRIPTION"
Walks up the device tree looking for a device of the specified type.
If it finds it, it returns it.  If not, it returns NULL.
.TH "print_pa_hwpath" 9 "print_pa_hwpath" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
print_pa_hwpath \-  Returns hardware path for PA devices
.SH SYNOPSIS
.B "char *" print_pa_hwpath
.BI "(struct parisc_device *" dev ","
.BI "char *" output ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "output" 12
-- undescribed --
.SH "DEV"
 The device to return the path for
.SH "OUTPUT"
 Pointer to a previously-allocated array to place the path in.

This function fills in the output array with a human-readable path
to a PA device.  This string is compatible with that used by PDC, and
may be printed on the outside of the box.
.TH "get_pci_node_path" 9 "get_pci_node_path" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_pci_node_path \-  Determines the hardware path for a PCI device
.SH SYNOPSIS
.B "void" get_pci_node_path
.BI "(struct pci_dev *" pdev ","
.BI "struct hardware_path *" path ");"
.SH ARGUMENTS
.IP "pdev" 12
 The device to return the path for
.IP "path" 12
 Pointer to a previously-allocated array to place the path in.
.SH "DESCRIPTION"
This function fills in the hardware_path structure with the route to
the specified PCI device.  This structure is suitable for passing to
PDC calls.
.TH "print_pci_hwpath" 9 "print_pci_hwpath" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
print_pci_hwpath \-  Returns hardware path for PCI devices
.SH SYNOPSIS
.B "char *" print_pci_hwpath
.BI "(struct pci_dev *" dev ","
.BI "char *" output ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "output" 12
-- undescribed --
.SH "DEV"
 The device to return the path for
.SH "OUTPUT"
 Pointer to a previously-allocated array to place the path in.

This function fills in the output array with a human-readable path
to a PCI device.  This string is compatible with that used by PDC, and
may be printed on the outside of the box.
.TH "alloc_tree_node" 9 "alloc_tree_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_tree_node \-  returns a device entry in the iotree
.SH SYNOPSIS
.B "struct parisc_device *" alloc_tree_node
.BI "(struct device *" parent ","
.BI "char " id ");"
.SH ARGUMENTS
.IP "parent" 12
 the parent node in the tree
.IP "id" 12
 the element of the module path for this entry
.SH "DESCRIPTION"
Checks all the children of \fIparent\fP for a matching \fIid\fP.  If none
found, it allocates a new device and returns it.
.TH "register_parisc_device" 9 "register_parisc_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_parisc_device \-  Locate a driver to manage this device.
.SH SYNOPSIS
.B "int" register_parisc_device
.BI "(struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The parisc device.
.SH "DESCRIPTION"
Search the driver list for a driver that is willing to manage
this device.
.TH "match_pci_device" 9 "match_pci_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_pci_device \-  Matches a pci device against a given hardware path
.SH SYNOPSIS
.B "int" match_pci_device
.BI "(struct device *" dev ","
.BI "int " index ","
.BI "struct hardware_path *" modpath ");"
.SH ARGUMENTS
.IP "dev" 12
 the generic device (known to be contained by a pci_dev).
.IP "index" 12
 the current BC index
.IP "modpath" 12
 the hardware path.
.SH "DESCRIPTION"
entry.
.TH "match_parisc_device" 9 "match_parisc_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
match_parisc_device \-  Matches a parisc device against a given hardware
.SH SYNOPSIS
.B "int" match_parisc_device
.BI "(struct device *" dev ","
.BI "int " index ","
.BI "struct hardware_path *" modpath ");"
.SH ARGUMENTS
.IP "dev" 12
 the generic device (known to be contained by a parisc_device).
.IP "index" 12
 the current BC index
.IP "modpath" 12
 the hardware path.
.SH "DESCRIPTION"
path entry.
.TH "parse_tree_node" 9 "parse_tree_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parse_tree_node \-  returns a device entry in the iotree
.SH SYNOPSIS
.B "struct device *" parse_tree_node
.BI "(struct device *" parent ","
.BI "int " index ","
.BI "struct hardware_path *" modpath ");"
.SH ARGUMENTS
.IP "parent" 12
 the parent node in the tree
.IP "index" 12
 the current BC index
.IP "modpath" 12
 the hardware_path struct to match a device against
.SH "DESCRIPTION"
Checks all the children of \fIparent\fP for a matching \fIid\fP.  If none
found, it returns NULL.
.TH "hwpath_to_device" 9 "hwpath_to_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hwpath_to_device \-  Finds the generic device corresponding to a given hardware path.
.SH SYNOPSIS
.B "struct device *" hwpath_to_device
.BI "(struct hardware_path *" modpath ");"
.SH ARGUMENTS
.IP "modpath" 12
 the hardware path.
.TH "device_to_hwpath" 9 "device_to_hwpath" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
device_to_hwpath \-  Populates the hwpath corresponding to the given device.
.SH SYNOPSIS
.B "void" device_to_hwpath
.BI "(struct device *" dev ","
.BI "struct hardware_path *" path ");"
.SH ARGUMENTS
.IP "dev" 12
-- undescribed --
.IP "path" 12
-- undescribed --
.SH "DESCRIPTION"
\fIparam\fP dev the target device
\fIparam\fP path pointer to a previously allocated hwpath struct to be filled in
.TH "walk_native_bus" 9 "walk_native_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
walk_native_bus \- - Probe a bus for devices
.SH SYNOPSIS
.B "void" walk_native_bus
.BI "(unsigned long " io_io_low ","
.BI "unsigned long " io_io_high ","
.BI "struct device *" parent ");"
.SH ARGUMENTS
.IP "io_io_low" 12
 Base address of this bus.
.IP "io_io_high" 12
 Last address of this bus.
.IP "parent" 12
 The parent bus device.
.SH "DESCRIPTION"
A native bus (eg Runway or GSC) may have up to 64 devices on it,
spaced at intervals of 0x1000 bytes.  PDC may not inform us of these
devices, so we have to probe for them.  Unfortunately, we may find
devices which are not physically connected (such as extra serial &amp;
keyboard ports).  This problem is not yet solved.
.TH "walk_central_bus" 9 "walk_central_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
walk_central_bus \-  Find devices attached to the central bus
.SH SYNOPSIS
.B "void" walk_central_bus
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

PDC doesn't tell us about all devices in the system.  This routine
finds devices connected to the central bus.
.TH "init_parisc_bus" 9 "init_parisc_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_parisc_bus \-  Some preparation to be done before inventory
.SH SYNOPSIS
.B "void" init_parisc_bus
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "print_parisc_devices" 9 "print_parisc_devices" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
print_parisc_devices \-  Print out a list of devices found in this system
.SH SYNOPSIS
.B "void" print_parisc_devices
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "f_extend" 9 "f_extend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
f_extend \-  Convert PDC addresses to kernel addresses.
.SH SYNOPSIS
.B "unsigned long" f_extend
.BI "(unsigned long " address ");"
.SH ARGUMENTS
.IP "address" 12
 Address returned from PDC.
.SH "DESCRIPTION"
This function is used to convert PDC addresses into kernel addresses
when the PDC address size and kernel address size are different.
.TH "convert_to_wide" 9 "convert_to_wide" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
convert_to_wide \-  Convert the return buffer addresses into kernel addresses.
.SH SYNOPSIS
.B "void" convert_to_wide
.BI "(unsigned long *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
-- undescribed --
.SH "DESCRIPTION"
This function is used to convert the return buffer addresses retrieved from PDC
into kernel addresses when the PDC address size and kernel address size are
different.
.TH "set_firmware_width" 9 "set_firmware_width" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
set_firmware_width \-  Determine if the firmware is wide or narrow.
.SH SYNOPSIS
.B "void __init" set_firmware_width
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function must be called before any pdc_* function that uses the convert_to_wide
function.
.TH "pdc_emergency_unlock" 9 "pdc_emergency_unlock" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_emergency_unlock \-  Unlock the linux pdc lock
.SH SYNOPSIS
.B "void" pdc_emergency_unlock
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This call unlocks the linux pdc lock in case we need some PDC functions
(like pdc_add_valid) during kernel stack dump.
.TH "pdc_add_valid" 9 "pdc_add_valid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_add_valid \-  Verify address can be accessed without causing a HPMC.
.SH SYNOPSIS
.B "int" pdc_add_valid
.BI "(unsigned long " address ");"
.SH ARGUMENTS
.IP "address" 12
 Address to be verified.
.SH "DESCRIPTION"
This PDC call attempts to read from the specified address and verifies
if the address is valid.

The return value is PDC_OK (0) in case accessing this address is valid.
.TH "pdc_chassis_info" 9 "pdc_chassis_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_chassis_info \-  Return chassis information.
.SH SYNOPSIS
.B "int __init" pdc_chassis_info
.BI "(struct pdc_chassis_info *" chassis_info ","
.BI "void *" led_info ","
.BI "unsigned long " len ");"
.SH ARGUMENTS
.IP "chassis_info" 12
 The memory buffer address.
.IP "led_info" 12
-- undescribed --
.IP "len" 12
 The size of the memory buffer address.
.SH "DESCRIPTION"
An HVERSION dependent call for returning the chassis information.
.TH "pdc_pat_chassis_send_log" 9 "pdc_pat_chassis_send_log" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_chassis_send_log \-  Sends a PDC PAT CHASSIS log message.
.SH SYNOPSIS
.B "int" pdc_pat_chassis_send_log
.BI "(unsigned long " state ","
.BI "unsigned long " data ");"
.SH ARGUMENTS
.IP "state" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.SH "DESCRIPTION"
Must be correctly formatted or expect system crash
.TH "pdc_chassis_disp" 9 "pdc_chassis_disp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_chassis_disp \-  Updates display
.SH SYNOPSIS
.B "int" pdc_chassis_disp
.BI "(unsigned long " disp ");"
.SH ARGUMENTS
.IP "disp" 12
-- undescribed --
.SH "DESCRIPTION"
Works on old PDC only (E class, others?)
.TH "pdc_coproc_cfg" 9 "pdc_coproc_cfg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_coproc_cfg \-  To identify coprocessors attached to the processor.
.SH SYNOPSIS
.B "int __init" pdc_coproc_cfg
.BI "(struct pdc_coproc_cfg *" pdc_coproc_info ");"
.SH ARGUMENTS
.IP "pdc_coproc_info" 12
 Return buffer address.
.SH "DESCRIPTION"
This PDC call returns the presence and status of all the coprocessors
attached to the processor.
.TH "pdc_iodc_read" 9 "pdc_iodc_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_iodc_read \-  Read data from the modules IODC.
.SH SYNOPSIS
.B "int" pdc_iodc_read
.BI "(unsigned long *" actcnt ","
.BI "unsigned long " hpa ","
.BI "unsigned int " index ","
.BI "void *" iodc_data ","
.BI "unsigned int " iodc_data_size ");"
.SH ARGUMENTS
.IP "actcnt" 12
 The actual number of bytes.
.IP "hpa" 12
 The HPA of the module for the iodc read.
.IP "index" 12
 The iodc entry point.
.IP "iodc_data" 12
 A buffer memory for the iodc options.
.IP "iodc_data_size" 12
 Size of the memory buffer.
.SH "DESCRIPTION"
This PDC call reads from the IODC of the module specified by the hpa
argument.
.TH "pdc_system_map_find_mods" 9 "pdc_system_map_find_mods" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_system_map_find_mods \-  Locate unarchitected modules.
.SH SYNOPSIS
.B "int" pdc_system_map_find_mods
.BI "(struct pdc_system_map_mod_info *" pdc_mod_info ","
.BI "struct pdc_module_path *" mod_path ","
.BI "long " mod_index ");"
.SH ARGUMENTS
.IP "pdc_mod_info" 12
 Return buffer address.
.IP "mod_path" 12
 pointer to dev path structure.
.IP "mod_index" 12
 fixed address module index.
.SH "DESCRIPTION"
To locate and identify modules which reside at fixed I/O addresses, which
do not self-identify via architected bus walks.
.TH "pdc_system_map_find_addrs" 9 "pdc_system_map_find_addrs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_system_map_find_addrs \-  Retrieve additional address ranges.
.SH SYNOPSIS
.B "int" pdc_system_map_find_addrs
.BI "(struct pdc_system_map_addr_info *" pdc_addr_info ","
.BI "long " mod_index ","
.BI "long " addr_index ");"
.SH ARGUMENTS
.IP "pdc_addr_info" 12
 Return buffer address.
.IP "mod_index" 12
 Fixed address module index.
.IP "addr_index" 12
 Address range index.
.SH "DESCRIPTION"
Retrieve additional information about subsequent address ranges for modules
with multiple address ranges.  
.TH "pdc_model_info" 9 "pdc_model_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_model_info \-  Return model information about the processor.
.SH SYNOPSIS
.B "int" pdc_model_info
.BI "(struct pdc_model *" model ");"
.SH ARGUMENTS
.IP "model" 12
 The return buffer.
.SH "DESCRIPTION"
Returns the version numbers, identifiers, and capabilities from the processor module.
.TH "pdc_model_sysmodel" 9 "pdc_model_sysmodel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_model_sysmodel \-  Get the system model name.
.SH SYNOPSIS
.B "int" pdc_model_sysmodel
.BI "(char *" name ");"
.SH ARGUMENTS
.IP "name" 12
 A char array of at least 81 characters.
.SH "DESCRIPTION"
Get system model name from PDC ROM (e.g. 9000/715 or 9000/778/B160L)
.TH "pdc_model_versions" 9 "pdc_model_versions" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_model_versions \-  Identify the version number of each processor.
.SH SYNOPSIS
.B "int" pdc_model_versions
.BI "(unsigned long *" versions ","
.BI "int " id ");"
.SH ARGUMENTS
.IP "versions" 12
-- undescribed --
.IP "id" 12
 The id of the processor to check.
.SH "DESCRIPTION"
Returns the version number for each processor component.

This comment was here before, but I do not know what it means :( -RB
.SH "ID"
 0 = cpu revision, 1 = boot-rom-version
.TH "pdc_model_cpuid" 9 "pdc_model_cpuid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_model_cpuid \-  Returns the CPU_ID.
.SH SYNOPSIS
.B "int" pdc_model_cpuid
.BI "(unsigned long *" cpu_id ");"
.SH ARGUMENTS
.IP "cpu_id" 12
 The return buffer.
.SH "DESCRIPTION"
Returns the CPU_ID value which uniquely identifies the cpu portion of
the processor module.
.TH "pdc_model_capabilities" 9 "pdc_model_capabilities" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_model_capabilities \-  Returns the platform capabilities.
.SH SYNOPSIS
.B "int" pdc_model_capabilities
.BI "(unsigned long *" capabilities ");"
.SH ARGUMENTS
.IP "capabilities" 12
 The return buffer.
.SH "DESCRIPTION"
Returns information about platform support for 32- and/or 64-bit
OSes, IO-PDIR coherency, and virtual aliasing.
.TH "pdc_cache_info" 9 "pdc_cache_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_cache_info \-  Return cache and TLB information.
.SH SYNOPSIS
.B "int" pdc_cache_info
.BI "(struct pdc_cache_info *" cache_info ");"
.SH ARGUMENTS
.IP "cache_info" 12
 The return buffer.
.SH "DESCRIPTION"
Returns information about the processor's cache and TLB.
.TH "pdc_btlb_info" 9 "pdc_btlb_info" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_btlb_info \-  Return block TLB information.
.SH SYNOPSIS
.B "int" pdc_btlb_info
.BI "(struct pdc_btlb_info *" btlb ");"
.SH ARGUMENTS
.IP "btlb" 12
 The return buffer.
.SH "DESCRIPTION"
Returns information about the hardware Block TLB.
.TH "pdc_mem_map_hpa" 9 "pdc_mem_map_hpa" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_mem_map_hpa \-  Find fixed module information.  
.SH SYNOPSIS
.B "int" pdc_mem_map_hpa
.BI "(struct pdc_memory_map *" address ","
.BI "struct pdc_module_path *" mod_path ");"
.SH ARGUMENTS
.IP "address" 12
 The return buffer
.IP "mod_path" 12
 pointer to dev path structure.
.SH "DESCRIPTION"
This call was developed for S700 workstations to allow the kernel to find
the I/O devices (Core I/O). In the future (Kittyhawk and beyond) this
call will be replaced (on workstations) by the architected PDC_SYSTEM_MAP
call.

This call is supported by all existing S700 workstations (up to  Gecko).
.TH "pdc_lan_station_id" 9 "pdc_lan_station_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_lan_station_id \-  Get the LAN address.
.SH SYNOPSIS
.B "int" pdc_lan_station_id
.BI "(char *" lan_addr ","
.BI "unsigned long " hpa ");"
.SH ARGUMENTS
.IP "lan_addr" 12
 The return buffer.
.IP "hpa" 12
 The network device HPA.
.SH "DESCRIPTION"
Get the LAN station address when it is not directly available from the LAN hardware.
.TH "pdc_stable_read" 9 "pdc_stable_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_stable_read \-  Read data from Stable Storage.
.SH SYNOPSIS
.B "int" pdc_stable_read
.BI "(unsigned long " staddr ","
.BI "void *" memaddr ","
.BI "unsigned long " count ");"
.SH ARGUMENTS
.IP "staddr" 12
 Stable Storage address to access.
.IP "memaddr" 12
 The memory address where Stable Storage data shall be copied.
.IP "count" 12
 number of bytes to transfert. count is multiple of 4.
.SH "DESCRIPTION"
This PDC call reads from the Stable Storage address supplied in staddr
and copies count bytes to the memory address memaddr.
The call will fail if staddr+count &gt; PDC_STABLE size.
.TH "pdc_stable_write" 9 "pdc_stable_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_stable_write \-  Write data to Stable Storage.
.SH SYNOPSIS
.B "int" pdc_stable_write
.BI "(unsigned long " staddr ","
.BI "void *" memaddr ","
.BI "unsigned long " count ");"
.SH ARGUMENTS
.IP "staddr" 12
 Stable Storage address to access.
.IP "memaddr" 12
 The memory address where Stable Storage data shall be read from.
.IP "count" 12
 number of bytes to transfert. count is multiple of 4.
.SH "DESCRIPTION"
This PDC call reads count bytes from the supplied memaddr address,
and copies count bytes to the Stable Storage address staddr.
The call will fail if staddr+count &gt; PDC_STABLE size.
.TH "pdc_stable_get_size" 9 "pdc_stable_get_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_stable_get_size \-  Get Stable Storage size in bytes.
.SH SYNOPSIS
.B "int" pdc_stable_get_size
.BI "(unsigned long *" size ");"
.SH ARGUMENTS
.IP "size" 12
 pointer where the size will be stored.
.SH "DESCRIPTION"
This PDC call returns the number of bytes in the processor's Stable
Storage, which is the number of contiguous bytes implemented in Stable
Storage starting from staddr=0. size in an unsigned 64-bit integer
which is a multiple of four.
.TH "pdc_stable_verify_contents" 9 "pdc_stable_verify_contents" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_stable_verify_contents \-  Checks that Stable Storage contents are valid.
.SH SYNOPSIS
.B "int" pdc_stable_verify_contents
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This PDC call is meant to be used to check the integrity of the current
contents of Stable Storage.
.TH "pdc_stable_initialize" 9 "pdc_stable_initialize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_stable_initialize \-  Sets Stable Storage contents to zero and initialize
.SH SYNOPSIS
.B "int" pdc_stable_initialize
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
the validity indicator.

This PDC call will erase all contents of Stable Storage. Use with care!
.TH "pdc_get_initiator" 9 "pdc_get_initiator" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_get_initiator \-  Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD)
.SH SYNOPSIS
.B "int" pdc_get_initiator
.BI "(struct hardware_path *" hwpath ","
.BI "struct pdc_initiator *" initiator ");"
.SH ARGUMENTS
.IP "hwpath" 12
 fully bc.mod style path to the device.
.IP "initiator" 12
 the array to return the result into
.SH "DESCRIPTION"
Get the SCSI operational parameters from PDC.
Needed since HPUX never used BIOS or symbios card NVRAM.
Most ncr/sym cards won't have an entry and just use whatever
capabilities of the card are (eg Ultra, LVD). But there are
several cases where it's useful:
o set SCSI id for Multi-initiator clusters,
o cable too long (ie SE scsi 10Mhz won't support 6m length),
o bus width exported is less than what the interface chip supports.
.TH "pdc_pci_irt_size" 9 "pdc_pci_irt_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pci_irt_size \-  Get the number of entries in the interrupt routing table.
.SH SYNOPSIS
.B "int" pdc_pci_irt_size
.BI "(unsigned long *" num_entries ","
.BI "unsigned long " hpa ");"
.SH ARGUMENTS
.IP "num_entries" 12
 The return value.
.IP "hpa" 12
 The HPA for the device.
.SH "DESCRIPTION"
This PDC function returns the number of entries in the specified cell's
interrupt table.
Similar to PDC_PAT stuff - but added for Forte/Allegro boxes
.TH "pdc_pci_irt" 9 "pdc_pci_irt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pci_irt \-  Get the PCI interrupt routing table.
.SH SYNOPSIS
.B "int" pdc_pci_irt
.BI "(unsigned long " num_entries ","
.BI "unsigned long " hpa ","
.BI "void *" tbl ");"
.SH ARGUMENTS
.IP "num_entries" 12
 The number of entries in the table.
.IP "hpa" 12
 The Hard Physical Address of the device.
.IP "tbl" 12
 
.SH "DESCRIPTION"
Get the PCI interrupt routing table for the device at the given HPA.
Similar to PDC_PAT stuff - but added for Forte/Allegro boxes
.TH "pdc_pci_config_read" 9 "pdc_pci_config_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pci_config_read \-  read PCI config space.
.SH SYNOPSIS
.B "unsigned int" pdc_pci_config_read
.BI "(void *" hpa ","
.BI "unsigned long " cfg_addr ");"
.SH ARGUMENTS
.IP "hpa" 12
-- undescribed --
.IP "cfg_addr" 12
-- undescribed --
.SH "DESCRIPTION"
\fIhpa\fP		token from PDC to indicate which PCI device
\fIpci_addr\fP	configuration space address to read from

Read PCI Configuration space *before* linux PCI subsystem is running.
.TH "pdc_pci_config_write" 9 "pdc_pci_config_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pci_config_write \-  read PCI config space.
.SH SYNOPSIS
.B "void" pdc_pci_config_write
.BI "(void *" hpa ","
.BI "unsigned long " cfg_addr ","
.BI "unsigned int " val ");"
.SH ARGUMENTS
.IP "hpa" 12
-- undescribed --
.IP "cfg_addr" 12
-- undescribed --
.IP "val" 12
-- undescribed --
.SH "DESCRIPTION"
\fIhpa\fP		token from PDC to indicate which PCI device
\fIpci_addr\fP	configuration space address to write
\fIval\fP		value we want in the 32-bit register

Write PCI Configuration space *before* linux PCI subsystem is running.
.TH "pdc_tod_read" 9 "pdc_tod_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_tod_read \-  Read the Time-Of-Day clock.
.SH SYNOPSIS
.B "int" pdc_tod_read
.BI "(struct pdc_tod *" tod ");"
.SH ARGUMENTS
.IP "tod" 12
 The return buffer:
.SH "DESCRIPTION"
Read the Time-Of-Day clock
.TH "pdc_tod_set" 9 "pdc_tod_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_tod_set \-  Set the Time-Of-Day clock.
.SH SYNOPSIS
.B "int" pdc_tod_set
.BI "(unsigned long " sec ","
.BI "unsigned long " usec ");"
.SH ARGUMENTS
.IP "sec" 12
 The number of seconds since epoch.
.IP "usec" 12
 The number of micro seconds.
.SH "DESCRIPTION"
Set the Time-Of-Day clock.
.TH "pdc_iodc_putc" 9 "pdc_iodc_putc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_iodc_putc \-  Console character print using IODC.
.SH SYNOPSIS
.B "void" pdc_iodc_putc
.BI "(unsigned char " c ");"
.SH ARGUMENTS
.IP "c" 12
 the character to output.
.SH "NOTE THAT ONLY THESE SPECIAL CHARS ARE ARCHITECTED FOR CONSOLE IODC IO"
BEL, BS, CR, and LF. Others are passed through.
Since the HP console requires CR+LF to perform a 'newline', we translate
"\n" to "\r\n".
.TH "pdc_iodc_outc" 9 "pdc_iodc_outc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_iodc_outc \-  Console character print using IODC (without conversions).
.SH SYNOPSIS
.B "void" pdc_iodc_outc
.BI "(unsigned char " c ");"
.SH ARGUMENTS
.IP "c" 12
 the character to output.
.SH "DESCRIPTION"
Write the character directly to the IODC console.
.TH "pdc_iodc_getc" 9 "pdc_iodc_getc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_iodc_getc \-  Read a character (non-blocking) from the PDC console.
.SH SYNOPSIS
.B "int" pdc_iodc_getc
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Read a character (non-blocking) from the PDC console, returns -1 if
key is not present.
.TH "pdc_pat_cell_get_number" 9 "pdc_pat_cell_get_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_cell_get_number \-  Returns the cell number.
.SH SYNOPSIS
.B "int" pdc_pat_cell_get_number
.BI "(struct pdc_pat_cell_num *" cell_info ");"
.SH ARGUMENTS
.IP "cell_info" 12
 The return buffer.
.SH "DESCRIPTION"
This PDC call returns the cell number of the cell from which the call
is made.
.TH "pdc_pat_cell_module" 9 "pdc_pat_cell_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_cell_module \-  Retrieve the cell's module information.
.SH SYNOPSIS
.B "int" pdc_pat_cell_module
.BI "(unsigned long *" actcnt ","
.BI "unsigned long " ploc ","
.BI "unsigned long " mod ","
.BI "unsigned long " view_type ","
.BI "void *" mem_addr ");"
.SH ARGUMENTS
.IP "actcnt" 12
 The number of bytes written to mem_addr.
.IP "ploc" 12
 The physical location.
.IP "mod" 12
 The module index.
.IP "view_type" 12
 The view of the address type.
.IP "mem_addr" 12
 The return buffer.
.SH "DESCRIPTION"
This PDC call returns information about each module attached to the cell
at the specified location.
.TH "pdc_pat_cpu_get_number" 9 "pdc_pat_cpu_get_number" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_cpu_get_number \-  Retrieve the cpu number.
.SH SYNOPSIS
.B "int" pdc_pat_cpu_get_number
.BI "(struct pdc_pat_cpu_num *" cpu_info ","
.BI "void *" hpa ");"
.SH ARGUMENTS
.IP "cpu_info" 12
 The return buffer.
.IP "hpa" 12
 The Hard Physical Address of the CPU.
.SH "DESCRIPTION"
Retrieve the cpu number for the cpu at the specified HPA.
.TH "pdc_pat_get_irt_size" 9 "pdc_pat_get_irt_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_get_irt_size \-  Retrieve the number of entries in the cell's interrupt table.
.SH SYNOPSIS
.B "int" pdc_pat_get_irt_size
.BI "(unsigned long *" num_entries ","
.BI "unsigned long " cell_num ");"
.SH ARGUMENTS
.IP "num_entries" 12
 The return value.
.IP "cell_num" 12
 The target cell.
.SH "DESCRIPTION"
This PDC function returns the number of entries in the specified cell's
interrupt table.
.TH "pdc_pat_get_irt" 9 "pdc_pat_get_irt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_get_irt \-  Retrieve the cell's interrupt table.
.SH SYNOPSIS
.B "int" pdc_pat_get_irt
.BI "(void *" r_addr ","
.BI "unsigned long " cell_num ");"
.SH ARGUMENTS
.IP "r_addr" 12
 The return buffer.
.IP "cell_num" 12
 The target cell.
.SH "DESCRIPTION"
This PDC function returns the actual interrupt table for the specified cell.
.TH "pdc_pat_pd_get_addr_map" 9 "pdc_pat_pd_get_addr_map" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_pd_get_addr_map \-  Retrieve information about memory address ranges.
.SH SYNOPSIS
.B "int" pdc_pat_pd_get_addr_map
.BI "(unsigned long *" actual_len ","
.BI "void *" mem_addr ","
.BI "unsigned long " count ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "actual_len" 12
-- undescribed --
.IP "mem_addr" 12
 Pointer to the memory buffer.
.IP "count" 12
 The number of bytes to read from the buffer.
.IP "offset" 12
 The offset with respect to the beginning of the buffer.
.TH "pdc_pat_io_pci_cfg_read" 9 "pdc_pat_io_pci_cfg_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_io_pci_cfg_read \-  Read PCI configuration space.
.SH SYNOPSIS
.B "int" pdc_pat_io_pci_cfg_read
.BI "(unsigned long " pci_addr ","
.BI "int " pci_size ","
.BI "u32 *" mem_addr ");"
.SH ARGUMENTS
.IP "pci_addr" 12
 PCI configuration space address for which the read request is being made.
.IP "pci_size" 12
 Size of read in bytes. Valid values are 1, 2, and 4. 
.IP "mem_addr" 12
 Pointer to return memory buffer.
.TH "pdc_pat_io_pci_cfg_write" 9 "pdc_pat_io_pci_cfg_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_pat_io_pci_cfg_write \-  Retrieve information about memory address ranges.
.SH SYNOPSIS
.B "int" pdc_pat_io_pci_cfg_write
.BI "(unsigned long " pci_addr ","
.BI "int " pci_size ","
.BI "u32 " val ");"
.SH ARGUMENTS
.IP "pci_addr" 12
 PCI configuration space address for which the write  request is being made.
.IP "pci_size" 12
 Size of write in bytes. Valid values are 1, 2, and 4. 
.IP "val" 12
-- undescribed --
.TH "snake_inventory" 9 "snake_inventory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snake_inventory \- 
.SH SYNOPSIS
.B "void __init" snake_inventory
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Before PDC_SYSTEM_MAP was invented, the PDC_MEM_MAP call was used.
To use it, we initialise the mod_path.bc to 0xff and try all values of
mod to get the HPA for the top-level devices.  Bus adapters may have
sub-devices which are discovered by setting bc[5] to 0 and bc[4] to the
module, then trying all possible functions.
.TH "add_system_map_addresses" 9 "add_system_map_addresses" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
add_system_map_addresses \-  Add additional addresses to the parisc device.
.SH SYNOPSIS
.B "void __init" add_system_map_addresses
.BI "(struct parisc_device *" dev ","
.BI "int " num_addrs ","
.BI "int " module_instance ");"
.SH ARGUMENTS
.IP "dev" 12
 The parisc device.
.IP "num_addrs" 12
 Then number of addresses to add;
.IP "module_instance" 12
 The system_map module instance.
.SH "DESCRIPTION"
This function adds any additional addresses reported by the system_map
firmware to the parisc device.
.TH "system_map_inventory" 9 "system_map_inventory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
system_map_inventory \-  Retrieve firmware devices via SYSTEM_MAP.
.SH SYNOPSIS
.B "void __init" system_map_inventory
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function attempts to retrieve and register all the devices firmware
knows about via the SYSTEM_MAP PDC call.
.TH "pdc_chassis_setup" 9 "pdc_chassis_setup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_chassis_setup \-  Enable/disable pdc_chassis code at boot time.
.SH SYNOPSIS
.B "int __init" pdc_chassis_setup
.BI "(char *" str ");"
.SH ARGUMENTS
.IP "str" 12
 0 to disable chassis log
\fIreturn\fP 1
.TH "pdc_chassis_checkold" 9 "pdc_chassis_checkold" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_chassis_checkold \-  Checks for old PDC_CHASSIS compatibility
.SH SYNOPSIS
.B "void __init" pdc_chassis_checkold
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
Currently, only E class and A180 are known to work with this.
Inspired by Christoph Plattner
.TH "pdc_chassis_panic_event" 9 "pdc_chassis_panic_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_chassis_panic_event \-  Called by the panic handler.
.SH SYNOPSIS
.B "int" pdc_chassis_panic_event
.BI "(struct notifier_block *" this ","
.BI "unsigned long " event ","
.BI "void *" ptr ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.IP "event" 12
-- undescribed --
.IP "ptr" 12
-- undescribed --
.SH "DESCRIPTION"

As soon as a panic occurs, we should inform the PDC.
.TH "pdc_chassis_reboot_event" 9 "pdc_chassis_reboot_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_chassis_reboot_event \-  Called by the reboot handler.
.SH SYNOPSIS
.B "int" pdc_chassis_reboot_event
.BI "(struct notifier_block *" this ","
.BI "unsigned long " event ","
.BI "void *" ptr ");"
.SH ARGUMENTS
.IP "this" 12
-- undescribed --
.IP "event" 12
-- undescribed --
.IP "ptr" 12
-- undescribed --
.SH "DESCRIPTION"

As soon as a reboot occurs, we should inform the PDC.
.TH "parisc_pdc_chassis_init" 9 "parisc_pdc_chassis_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
parisc_pdc_chassis_init \-  Called at boot time.
.SH SYNOPSIS
.B "void __init" parisc_pdc_chassis_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.TH "pdc_chassis_send_status" 9 "pdc_chassis_send_status" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pdc_chassis_send_status \-  Sends a predefined message to the chassis,
.SH SYNOPSIS
.B "int" pdc_chassis_send_status
.BI "(int " message ");"
.SH ARGUMENTS
.IP "message" 12
-- undescribed --
.SH "DESCRIPTION"
Only machines with 64 bits PDC PAT and those reported in
\fBpdc_chassis_checkold\fP are supported atm.

returns 0 if no error, -1 if no supported PDC is present or invalid message,
else returns the appropriate PDC error code.

For a list of predefined messages, see asm-parisc/pdc_chassis.h
.SH "DESCRIPTION"
Only machines with 64 bits PDC PAT and those reported in
\fBpdc_chassis_checkold\fP are supported atm.

returns 0 if no error, -1 if no supported PDC is present or invalid message,
else returns the appropriate PDC error code.

For a list of predefined messages, see asm-parisc/pdc_chassis.h
.TH "processor_probe" 9 "processor_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
processor_probe \-  Determine if processor driver should claim this device.
.SH SYNOPSIS
.B "int __init" processor_probe
.BI "(struct parisc_device *" dev ");"
.SH ARGUMENTS
.IP "dev" 12
 The device which has been found.
.SH "DESCRIPTION"
Determine if processor driver should claim this chip (return 0) or not 
(return 1).  If so, initialize the chip and tell other partners in crime 
they have work to do.
.TH "collect_boot_cpu_data" 9 "collect_boot_cpu_data" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
collect_boot_cpu_data \-  Fill the boot_cpu_data structure.
.SH SYNOPSIS
.B "void __init" collect_boot_cpu_data
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This function collects and stores the generic processor information
in the boot_cpu_data structure.
.TH "init_percpu_prof" 9 "init_percpu_prof" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_percpu_prof \-  enable/setup per cpu profiling hooks.
.SH SYNOPSIS
.B "void __init" init_percpu_prof
.BI "(int " cpunum ");"
.SH ARGUMENTS
.IP "cpunum" 12
 The processor instance.
.SH "FIXME"
 doesn't do much yet...
.TH "init_per_cpu" 9 "init_per_cpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
init_per_cpu \-  Handle individual processor initializations.
.SH SYNOPSIS
.B "int __init" init_per_cpu
.BI "(int " cpunum ");"
.SH ARGUMENTS
.IP "cpunum" 12
 logical processor number.
.SH "DESCRIPTION"
This function handles initialization for *every* CPU
.SH "IN THE SYSTEM"

o Set "default" CPU width for trap handlers

o Enable FP coprocessor
.SH "REVISIT"
 this could be done in the "code 22" trap handler.
(frowands idea - that way we know which processes need FP
registers saved on the interrupt stack.)
.SH "NEWS FLASH"
 wide kernels need FP coprocessor enabled to handle
formatted printing of lx for example (double divides I think)

o Enable CPU profiling hooks.
.TH "processor_init" 9 "processor_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
processor_init \-  Processor initalization procedure.
.SH SYNOPSIS
.B "void __init" processor_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Register this driver.
.TH "restore_ELCR" 9 "restore_ELCR" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
restore_ELCR \- 
.SH SYNOPSIS
.B "void" restore_ELCR
.BI "(char *" trigger ");"
.SH ARGUMENTS
.IP "trigger" 12
-- undescribed --
.TH "copy_edd" 9 "copy_edd" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_edd \-  Copy the BIOS EDD information
.SH SYNOPSIS
.B "void" copy_edd
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
from boot_params into a safe place.
.TH "acpi_save_state_mem" 9 "acpi_save_state_mem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_save_state_mem \-  save kernel state
.SH SYNOPSIS
.B "int" acpi_save_state_mem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Create an identity mapped page table and copy the wakeup routine to
low memory.
.TH "acpi_reserve_bootmem" 9 "acpi_reserve_bootmem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
acpi_reserve_bootmem \-  do _very_ early ACPI initialisation
.SH SYNOPSIS
.B "void __init" acpi_reserve_bootmem
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

We allocate a page in low memory for the wakeup
routine for when we come back from a sleep state. The
runtime allocator allows specification of &lt;16M pages, but not
&lt;1M pages.
.TH "fill_mp_bus_to_cpumask" 9 "fill_mp_bus_to_cpumask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fill_mp_bus_to_cpumask \- 
.SH SYNOPSIS
.B "__init static int" fill_mp_bus_to_cpumask
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
fills the mp_bus_to_cpumask array based according to the LDT Bus Number
Registers found in the K8 northbridge
.TH "ioremap_nocache" 9 "ioremap_nocache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioremap_nocache \-    map bus memory into CPU space
.SH SYNOPSIS
.B "void __iomem *" ioremap_nocache
.BI "(unsigned long " phys_addr ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "phys_addr" 12
-- undescribed --
.IP "size" 12
      size of the resource to map
.SH "DESCRIPTION"
ioremap_nocache performs a platform specific sequence of operations to
make bus memory CPU accessible via the readb/readw/readl/writeb/
writew/writel functions and the other mmio helpers. The returned
address is not guaranteed to be usable directly as a virtual
address. 

This version of ioremap ensures that the memory is marked uncachable
on the CPU as well as honouring existing caching rules from things like
the PCI bus. Note that there are other caches and buffers on many 
busses. In particular driver authors should read up on PCI writes

It's useful if some control registers are in such an area and
.SH "WRITE COMBINING OR READ CACHING IS NOT DESIRABLE"

Must be freed with iounmap.
.TH "find_first_zero_bit" 9 "find_first_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "long" find_first_zero_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first zero bit, not the number of the byte
containing a bit.
.TH "find_next_zero_bit" 9 "find_next_zero_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_zero_bit \-  find the first zero bit in a memory region
.SH SYNOPSIS
.B "long" find_next_zero_bit
.BI "(const unsigned long *" addr ","
.BI "long " size ","
.BI "long " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "find_first_bit" 9 "find_first_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_first_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "long" find_first_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to start the search at
.IP "size" 12
 The maximum size to search
.SH "DESCRIPTION"
Returns the bit-number of the first set bit, not the number of the byte
containing a bit.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the first set bit in a memory region
.SH SYNOPSIS
.B "long" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "long " size ","
.BI "long " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "csum_partial_copy_from_user" 9 "csum_partial_copy_from_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
csum_partial_copy_from_user \-  Copy and checksum from user space. 
.SH SYNOPSIS
.B "unsigned int" csum_partial_copy_from_user
.BI "(const unsigned char __user *" src ","
.BI "unsigned char *" dst ","
.BI "int " len ","
.BI "unsigned int " isum ","
.BI "int *" errp ");"
.SH ARGUMENTS
.IP "src" 12
 source address (user space) 
.IP "dst" 12
 destination address
.IP "len" 12
 number of bytes to be copied.
.IP "isum" 12
 initial sum that is added into the result (32bit unfolded)
.IP "errp" 12
 set to -EFAULT for an bad source address.
.SH "DESCRIPTION"
Returns an 32bit unfolded checksum of the buffer.
src and dst are best aligned to 64bits. 
.TH "csum_partial_copy_to_user" 9 "csum_partial_copy_to_user" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
csum_partial_copy_to_user \-  Copy and checksum to user space. 
.SH SYNOPSIS
.B "unsigned int" csum_partial_copy_to_user
.BI "(unsigned const char *" src ","
.BI "unsigned char __user *" dst ","
.BI "int " len ","
.BI "unsigned int " isum ","
.BI "int *" errp ");"
.SH ARGUMENTS
.IP "src" 12
 source address
.IP "dst" 12
 destination address (user space)
.IP "len" 12
 number of bytes to be copied.
.IP "isum" 12
 initial sum that is added into the result (32bit unfolded)
.IP "errp" 12
 set to -EFAULT for an bad destination address.
.SH "DESCRIPTION"
Returns an 32bit unfolded checksum of the buffer.
src and dst are best aligned to 64bits.
.TH "csum_partial_copy_nocheck" 9 "csum_partial_copy_nocheck" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
csum_partial_copy_nocheck \-  Copy and checksum.
.SH SYNOPSIS
.B "unsigned int" csum_partial_copy_nocheck
.BI "(const unsigned char *" src ","
.BI "unsigned char *" dst ","
.BI "int " len ","
.BI "unsigned int " sum ");"
.SH ARGUMENTS
.IP "src" 12
 source address
.IP "dst" 12
 destination address
.IP "len" 12
 number of bytes to be copied.
.IP "sum" 12
-- undescribed --
.SH "DESCRIPTION"
Returns an 32bit unfolded checksum of the buffer.
.TH "sh64_cache_init" 9 "sh64_cache_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh64_cache_init \- 
.SH SYNOPSIS
.B "int __init" sh64_cache_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This is pretty much just a straightforward clone of the SH
\fBdetect_cpu_and_cache_system\fP.

This function is responsible for setting up all of the cache
info dynamically as well as taking care of CPU probing and
setting up the relevant subtype data.
.SH "FIXME"
 For the time being, we only really support the SH5-101
out of the box, and don't support dynamic probing for things
like the SH5-103 or even cut2 of the SH5-101. Implement this
later!
.TH "sh64_tlb_init" 9 "sh64_tlb_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh64_tlb_init \- 
.SH SYNOPSIS
.B "int __init" sh64_tlb_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Perform initial setup for the DTLB and ITLB.
.TH "sh64_next_free_dtlb_entry" 9 "sh64_next_free_dtlb_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh64_next_free_dtlb_entry \- 
.SH SYNOPSIS
.B "unsigned long long" sh64_next_free_dtlb_entry
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Find the next available DTLB entry
.TH "sh64_get_wired_dtlb_entry" 9 "sh64_get_wired_dtlb_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh64_get_wired_dtlb_entry \- 
.SH SYNOPSIS
.B "unsigned long long" sh64_get_wired_dtlb_entry
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Allocate a wired (locked-in) entry in the DTLB
.TH "sh64_put_wired_dtlb_entry" 9 "sh64_put_wired_dtlb_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh64_put_wired_dtlb_entry \- 
.SH SYNOPSIS
.B "int" sh64_put_wired_dtlb_entry
.BI "(unsigned long long " entry ");"
.SH ARGUMENTS
.IP "entry" 12
	Address of TLB slot.
.SH "DESCRIPTION"
Free a wired (locked-in) entry in the DTLB.

Works like a stack, last one to allocate must be first one to free.
.SH "DESCRIPTION"
Free a wired (locked-in) entry in the DTLB.

Works like a stack, last one to allocate must be first one to free.
.TH "sh64_setup_tlb_slot" 9 "sh64_setup_tlb_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh64_setup_tlb_slot \- 
.SH SYNOPSIS
.B "void" sh64_setup_tlb_slot
.BI "(unsigned long long " config_addr ","
.BI "unsigned long " eaddr ","
.BI "unsigned long " asid ","
.BI "unsigned long " paddr ");"
.SH ARGUMENTS
.IP "config_addr" 12
	Address of TLB slot.
.IP "eaddr" 12
		Virtual address.
.IP "asid" 12
		Address Space Identifier.
.IP "paddr" 12
		Physical address.
.SH "DESCRIPTION"
Load up a virtual&lt;-&gt;physical translation for \fIeaddr\fP&lt;-&gt;\fIpaddr\fP in the
pre-allocated TLB slot \fIconfig_addr\fP (see sh64_get_wired_dtlb_entry).
.SH "DESCRIPTION"
Load up a virtual&lt;-&gt;physical translation for \fIeaddr\fP&lt;-&gt;\fIpaddr\fP in the
pre-allocated TLB slot \fIconfig_addr\fP (see sh64_get_wired_dtlb_entry).
.TH "sh64_teardown_tlb_slot" 9 "sh64_teardown_tlb_slot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh64_teardown_tlb_slot \- 
.SH SYNOPSIS
.B "void" sh64_teardown_tlb_slot
.BI "(unsigned long long " config_addr ");"
.SH ARGUMENTS
.IP "config_addr" 12
	Address of TLB slot.
.SH "DESCRIPTION"
Teardown any existing mapping in the TLB slot \fIconfig_addr\fP.
.SH "DESCRIPTION"
Teardown any existing mapping in the TLB slot \fIconfig_addr\fP.
.TH "find_next_bit" 9 "find_next_bit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_bit \-  find the next set bit in a memory region
.SH SYNOPSIS
.B "unsigned long" find_next_bit
.BI "(const unsigned long *" addr ","
.BI "unsigned long " size ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "addr" 12
 The address to base the search on
.IP "size" 12
 The maximum size to search
.IP "offset" 12
 The bitnumber to start searching at
.TH "disable_irq_nosync" 9 "disable_irq_nosync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq_nosync \-  disable an irq without waiting
.SH SYNOPSIS
.B "void inline" disable_irq_nosync
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line. Disables of an interrupt
stack. Unlike \fBdisable_irq\fP, this function does not ensure existing
instances of the IRQ handler have completed before returning.

This function may be called from IRQ context.
.TH "disable_irq" 9 "disable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
disable_irq \-  disable an irq and wait for completion
.SH SYNOPSIS
.B "void" disable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to disable
.SH "DESCRIPTION"
Disable the selected interrupt line. Disables of an interrupt
stack. That is for two disables you need two enables. This
function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.

This function may be called - with care - from IRQ context.
.TH "enable_irq" 9 "enable_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
enable_irq \-  enable interrupt handling on an irq
.SH SYNOPSIS
.B "void" enable_irq
.BI "(unsigned int " irq ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt to enable
.SH "DESCRIPTION"
Re-enables the processing of interrupts on this IRQ line
providing no disable_irq calls are now in effect.

This function may be called from IRQ context.
.TH "request_irq" 9 "request_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
request_irq \-  allocate an interrupt line
.SH SYNOPSIS
.B "int" request_irq
.BI "(unsigned int " irq ","
.BI "irqreturn_t (*" handler ") (int, void *, struct pt_regs *),"
.BI "unsigned long " irqflags ","
.BI "const char *" devname ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to allocate
.IP "handler" 12
 Function to be called when the IRQ occurs
.IP "irqflags" 12
 Interrupt type flags
.IP "devname" 12
 An ascii name for the claiming device
.IP "dev_id" 12
 A cookie passed back to the handler function
.SH "DESCRIPTION"
This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board 
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.

Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.

If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.
.SH "FLAGS"

SA_SHIRQ		Interrupt is shared

SA_INTERRUPT		Disable local interrupts while processing

SA_SAMPLE_RANDOM	The interrupt can be used for entropy
.TH "free_irq" 9 "free_irq" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_irq \-  free an interrupt
.SH SYNOPSIS
.B "void" free_irq
.BI "(unsigned int " irq ","
.BI "void *" dev_id ");"
.SH ARGUMENTS
.IP "irq" 12
 Interrupt line to free
.IP "dev_id" 12
 Device identity to free
.SH "DESCRIPTION"
Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.

This function may be called from interrupt context. 
.SH "BUGS"
 Attempting to free an irq in a handler for the same irq hangs
the machine.
.TH "probe_irq_on" 9 "probe_irq_on" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_on \-  begin an interrupt autodetect
.SH SYNOPSIS
.B "unsigned long" probe_irq_on
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Commence probing for an interrupt. The interrupts are scanned
and a mask of potential interrupt lines is returned.
.TH "probe_irq_mask" 9 "probe_irq_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_mask \-  scan a bitmap of interrupt lines
.SH SYNOPSIS
.B "unsigned int" probe_irq_mask
.BI "(unsigned long " val ");"
.SH ARGUMENTS
.IP "val" 12
	mask of interrupts to consider
.SH "DESCRIPTION"
Scan the ISA bus interrupt lines and return a bitmap of
active interrupts. The interrupt probe logic state is then
returned to its previous value.
.SH "NOTE"
 we need to scan all the irq's even though we will
only return ISA irq numbers - just so that we reset them
all to a known state.
.TH "probe_irq_off" 9 "probe_irq_off" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
probe_irq_off \-  end an interrupt autodetect
.SH SYNOPSIS
.B "int" probe_irq_off
.BI "(unsigned long " val ");"
.SH ARGUMENTS
.IP "val" 12
 mask of potential interrupts (unused)
.SH "DESCRIPTION"
Scans the unused interrupt lines and returns the line which
appears to have triggered the interrupt. If no interrupt was
found then zero is returned. If more than one interrupt is
found then minus the first candidate is returned to indicate
their is doubt.

The interrupt probe logic state is returned to its previous
value.
.SH "BUGS"
 When used in a module (which arguably shouldnt happen)
nothing prevents two IRQ probe callers from overlapping. The
results of this are non-optimal.
.TH "aica_rtc_gettimeofday" 9 "aica_rtc_gettimeofday" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aica_rtc_gettimeofday \-  Get the time from the AICA RTC
.SH SYNOPSIS
.B "void" aica_rtc_gettimeofday
.BI "(struct timespec *" ts ");"
.SH ARGUMENTS
.IP "ts" 12
 pointer to resulting timespec
.SH "DESCRIPTION"
Grabs the current RTC seconds counter and adjusts it to the Unix Epoch.
.TH "aica_rtc_settimeofday" 9 "aica_rtc_settimeofday" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
aica_rtc_settimeofday \-  Set the AICA RTC to the current time
.SH SYNOPSIS
.B "int" aica_rtc_settimeofday
.BI "(const time_t " secs ");"
.SH ARGUMENTS
.IP "secs" 12
 contains the time_t to set
.SH "DESCRIPTION"
Adjusts the given \fItv\fP to the AICA Epoch and sets the RTC seconds counter.
.TH "sh_cpu_init" 9 "sh_cpu_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sh_cpu_init \- 
.SH SYNOPSIS
.B "void __init" sh_cpu_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

This is our initial entry point for each CPU, and is invoked on the boot
CPU prior to calling \fBstart_kernel\fP. For SMP, a combination of this and
\fBstart_secondary\fP will bring up each processor to a ready state prior
to hand forking the idle loop.

We do all of the basic processor init here, including setting up the
caches, FPU, DSP, kicking the UBC, etc. By the time \fBstart_kernel\fP is
hit (and subsequently \fBplatform_setup\fP) things like determining the
CPU subtype and initial configuration will all be done.

Each processor family is still responsible for doing its own probing
and cache configuration in \fBdetect_cpu_and_cache_system\fP.
.TH "denormal_to_double" 9 "denormal_to_double" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
denormal_to_double \-  Given denormalized float number,
.SH SYNOPSIS
.B "void" denormal_to_double
.BI "(struct sh_fpu_hard_struct *" fpu ","
.BI "int " n ");"
.SH ARGUMENTS
.IP "fpu" 12
 Pointer to sh_fpu_hard structure
.IP "n" 12
 Index to FP register
.SH "DESCRIPTION"
store double float
.TH "ieee_fpe_handler" 9 "ieee_fpe_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ieee_fpe_handler \-  Handle denormalized number exception
.SH SYNOPSIS
.B "int" ieee_fpe_handler
.BI "(struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "regs" 12
 Pointer to register structure
.SH "DESCRIPTION"
Returns 1 when it's handled (should not cause exception).
.SH "DESCRIPTION"
Returns 1 when it's handled (should not cause exception).
.TH "sq_flush" 9 "sq_flush" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_flush \-  Flush (prefetch) the store queue cache
.SH SYNOPSIS
.B "void" sq_flush
.BI "(void *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
 the store queue address to flush
.SH "DESCRIPTION"
Executes a prefetch instruction on the specified store queue cache,
so that the cached data is written to physical memory.
.TH "sq_flush_range" 9 "sq_flush_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_flush_range \-  Flush (prefetch) a specific SQ range
.SH SYNOPSIS
.B "void" sq_flush_range
.BI "(unsigned long " start ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "start" 12
 the store queue address to start flushing from
.IP "len" 12
 the length to flush
.SH "DESCRIPTION"
Flushes the store queue cache from \fIstart\fP to \fIstart\fP + \fIlen\fP in a
linear fashion.
.TH "__sq_remap" 9 "__sq_remap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__sq_remap \-  Perform a translation from the SQ to a phys addr
.SH SYNOPSIS
.B "struct sq_mapping *" __sq_remap
.BI "(struct sq_mapping *" map ");"
.SH ARGUMENTS
.IP "map" 12
 sq mapping containing phys and store queue addresses.
.SH "DESCRIPTION"
Maps the store queue address specified in the mapping to the physical
address specified in the mapping.
.TH "sq_remap" 9 "sq_remap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_remap \-  Map a physical address through the Store Queues
.SH SYNOPSIS
.B "struct sq_mapping *" sq_remap
.BI "(unsigned long " phys ","
.BI "unsigned int " size ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "phys" 12
 Physical address of mapping.
.IP "size" 12
 Length of mapping.
.IP "name" 12
 User invoking mapping.
.SH "DESCRIPTION"
Remaps the physical address \fIphys\fP through the next available store queue
address of \fIsize\fP length. \fIname\fP is logged at boot time as well as through
the procfs interface.

A pre-allocated and filled sq_mapping pointer is returned, and must be
cleaned up with a call to \fBsq_unmap\fP when the user is done with the
mapping.
.TH "sq_unmap" 9 "sq_unmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_unmap \-  Unmap a Store Queue allocation
.SH SYNOPSIS
.B "void" sq_unmap
.BI "(struct sq_mapping *" map ");"
.SH ARGUMENTS
.IP "map" 12
 Pre-allocated Store Queue mapping.
.SH "DESCRIPTION"
Unmaps the store queue allocation \fImap\fP that was previously created by
\fBsq_remap\fP. Also frees up the pte that was previously inserted into
the kernel page table and discards the UTLB translation.
.TH "sq_clear" 9 "sq_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_clear \-  Clear a store queue range
.SH SYNOPSIS
.B "void" sq_clear
.BI "(unsigned long " addr ","
.BI "unsigned int " len ");"
.SH ARGUMENTS
.IP "addr" 12
 Address to start clearing from.
.IP "len" 12
 Length to clear.
.SH "DESCRIPTION"
A quick zero-fill implementation for clearing out memory that has been
remapped through the store queues.
.TH "sq_vma_unmap" 9 "sq_vma_unmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_vma_unmap \-  Unmap a VMA range
.SH SYNOPSIS
.B "void" sq_vma_unmap
.BI "(struct vm_area_struct *" area ","
.BI "unsigned long " addr ","
.BI "size_t " len ");"
.SH ARGUMENTS
.IP "area" 12
 VMA containing range.
.IP "addr" 12
 Start of range.
.IP "len" 12
 Length of range.
.SH "DESCRIPTION"
Searches the sq_mapping_list for a mapping matching the sq addr \fIaddr\fP,
and subsequently frees up the entry. Further cleanup is done by generic
code.
.TH "sq_vma_sync" 9 "sq_vma_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_vma_sync \-  Sync a VMA range
.SH SYNOPSIS
.B "int" sq_vma_sync
.BI "(struct vm_area_struct *" area ","
.BI "unsigned long " start ","
.BI "size_t " len ","
.BI "unsigned int " flags ");"
.SH ARGUMENTS
.IP "area" 12
 VMA containing range.
.IP "start" 12
 Start of range.
.IP "len" 12
 Length of range.
.IP "flags" 12
 Additional flags.
.SH "DESCRIPTION"
Synchronizes an sq mapped range by flushing the store queue cache for
the duration of the mapping.

Used internally for user mappings, which must use \fBmsync\fP to prefetch
the store queue cache.
.TH "sq_mmap" 9 "sq_mmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sq_mmap \-  mmap() for /dev/cpu/sq
.SH SYNOPSIS
.B "int" sq_mmap
.BI "(struct file *" file ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "file" 12
 unused.
.IP "vma" 12
 VMA to remap.
.SH "DESCRIPTION"
Remap the specified vma \fIvma\fP through the store queues, and setup associated
information for the new mapping. Also build up the page tables for the new
area.
.TH "ioremap_nocache" 9 "ioremap_nocache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ioremap_nocache \-    map bus memory into CPU space
.SH SYNOPSIS
.B "void __iomem *" ioremap_nocache
.BI "(unsigned long " phys_addr ","
.BI "unsigned long " size ");"
.SH ARGUMENTS
.IP "phys_addr" 12
-- undescribed --
.IP "size" 12
      size of the resource to map
.SH "DESCRIPTION"
Must be freed with iounmap.
.TH "hub_pio_map" 9 "hub_pio_map" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hub_pio_map \-   establish a HUB PIO mapping
.SH SYNOPSIS
.B "unsigned long" hub_pio_map
.BI "(cnodeid_t " cnode ","
.BI "xwidgetnum_t " widget ","
.BI "unsigned long " xtalk_addr ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "cnode" 12
-- undescribed --
.IP "widget" 12
	widget ID to perform PIO mapping for
.IP "xtalk_addr" 12
	xtalk_address that needs to be mapped
.IP "size" 12
	size of the PIO mapping
.SH "DESCRIPTION"
.TH "hub_set_piomode" 9 "hub_set_piomode" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
hub_set_piomode \-   set pio mode for a given hub
.SH SYNOPSIS
.B "void" hub_set_piomode
.BI "(nasid_t " nasid ");"
.SH ARGUMENTS
.IP "nasid" 12
	physical node ID for the hub in question
.SH "DESCRIPTION"
Put the hub into either "PIO conveyor belt" mode or "fire-and-forget" mode.
To do this, we have to make absolutely sure that no PIOs are in progress
so we turn off access to all widgets for the duration of the function.

XXX - This code should really check what kind of widget we're talking
to.  Bridges can only handle three requests, but XG will do more.
How many can crossbow handle to widget 0?  We're assuming 1.

XXX - There is a bug in the crossbow that link reset PIOs do not
return write responses.  The easiest solution to this problem is to
leave widget 0 (xbow) in fire-and-forget mode at all times.  This
only affects pio's to xbow registers, which should be rare.
.SH "DESCRIPTION"
Put the hub into either "PIO conveyor belt" mode or "fire-and-forget" mode.
To do this, we have to make absolutely sure that no PIOs are in progress
so we turn off access to all widgets for the duration of the function.

XXX - This code should really check what kind of widget we're talking
to.  Bridges can only handle three requests, but XG will do more.
How many can crossbow handle to widget 0?  We're assuming 1.

XXX - There is a bug in the crossbow that link reset PIOs do not
return write responses.  The easiest solution to this problem is to
leave widget 0 (xbow) in fire-and-forget mode at all times.  This
only affects pio's to xbow registers, which should be rare.
.TH "bit_map_string_get" 9 "bit_map_string_get" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bit_map_string_get \-  find and set a bit string in bit map.
.SH SYNOPSIS
.B "int" bit_map_string_get
.BI "(struct bit_map *" t ","
.BI "int " len ","
.BI "int " align ");"
.SH ARGUMENTS
.IP "t" 12
 the bit map.
.IP "len" 12
 requested string length
.IP "align" 12
 requested alignment
.SH "DESCRIPTION"
Returns offset in the map or -1 if out of space.

Not safe to call from an interrupt (uses spin_lock).
.TH "balance_dirty_pages_ratelimited" 9 "balance_dirty_pages_ratelimited" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
balance_dirty_pages_ratelimited \-  balance dirty memory state
.SH SYNOPSIS
.B "void" balance_dirty_pages_ratelimited
.BI "(struct address_space *" mapping ");"
.SH ARGUMENTS
.IP "mapping" 12
 address_space which was dirtied
.SH "DESCRIPTION"
Processes which are dirtying memory should call in here once for each page
which was newly dirtied.  The function will periodically check the system's
dirty state and will initiate writeback if needed.

On really big machines, get_writeback_state is expensive, so try to avoid
calling it too often (ratelimiting).  But once we're over the dirty memory
limit we decrease the ratelimiting by a lot, to prevent individual processes
from overshooting the limit by (ratelimit_pages) each.
.TH "write_one_page" 9 "write_one_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
write_one_page \-  write out a single page and optionally wait on I/O
.SH SYNOPSIS
.B "int" write_one_page
.BI "(struct page *" page ","
.BI "int " wait ");"
.SH ARGUMENTS
.IP "page" 12
 the page to write
.IP "wait" 12
 if true, wait on writeout
.SH "DESCRIPTION"
The page must be locked by the caller and will be unlocked upon return.

\fBwrite_one_page\fP returns a negative error code if I/O failed.
.SH "DESCRIPTION"
The page must be locked by the caller and will be unlocked upon return.

\fBwrite_one_page\fP returns a negative error code if I/O failed.
.TH "kmem_cache_create" 9 "kmem_cache_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kmem_cache_create \-  Create a cache.
.SH SYNOPSIS
.B "kmem_cache_t *" kmem_cache_create
.BI "(const char *" name ","
.BI "size_t " size ","
.BI "size_t " align ","
.BI "unsigned long " flags ","
.BI "void (*" ctor ") (void*, kmem_cache_t *, unsigned long),"
.BI "void (*" dtor ") (void*, kmem_cache_t *, unsigned long));"
.SH ARGUMENTS
.IP "name" 12
 A string which is used in /proc/slabinfo to identify this cache.
.IP "size" 12
 The size of objects to be created in this cache.
.IP "align" 12
 The required alignment for the objects.
.IP "flags" 12
 SLAB flags
.IP "ctor" 12
 A constructor for the objects.
.IP "dtor" 12
 A destructor for the objects.
.SH "DESCRIPTION"
Returns a ptr to the cache on success, NULL on failure.
Cannot be called within a int, but can be interrupted.
The \fIctor\fP is run when new pages are allocated by the cache
and the \fIdtor\fP is run before the pages are handed back.

\fIname\fP must be valid until the cache is destroyed. This implies that
the module calling this has to destroy the cache before getting 
unloaded.

The flags are

SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)
to catch references to uninitialised memory.

SLAB_RED_ZONE - Insert `Red' zones around the allocated memory to check
for buffer overruns.

SLAB_NO_REAP - Don't automatically reap this cache when we're under
memory pressure.

SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware
cacheline.  This can be beneficial if you're counting cycles as closely
as davem.
.TH "kmem_cache_shrink" 9 "kmem_cache_shrink" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kmem_cache_shrink \-  Shrink a cache.
.SH SYNOPSIS
.B "int" kmem_cache_shrink
.BI "(kmem_cache_t *" cachep ");"
.SH ARGUMENTS
.IP "cachep" 12
 The cache to shrink.
.SH "DESCRIPTION"
Releases as many slabs as possible for a cache.
To help debugging, a zero exit status indicates all slabs were released.
.TH "kmem_cache_destroy" 9 "kmem_cache_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kmem_cache_destroy \-  delete a cache
.SH SYNOPSIS
.B "int" kmem_cache_destroy
.BI "(kmem_cache_t *" cachep ");"
.SH ARGUMENTS
.IP "cachep" 12
 the cache to destroy
.SH "DESCRIPTION"
Remove a kmem_cache_t object from the slab cache.
Returns 0 on success.

It is expected this function will be called by a module when it is
unloaded.  This will remove the cache completely, and avoid a duplicate
cache being allocated each time a module is loaded and unloaded, if the
module doesn't have persistent in-kernel storage across loads and unloads.

The cache must be empty before calling this function.

The caller must guarantee that noone will allocate memory from the cache
during the \fBkmem_cache_destroy\fP.
.TH "kmem_cache_alloc" 9 "kmem_cache_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kmem_cache_alloc \-  Allocate an object
.SH SYNOPSIS
.B "void *" kmem_cache_alloc
.BI "(kmem_cache_t *" cachep ","
.BI "gfp_t " flags ");"
.SH ARGUMENTS
.IP "cachep" 12
 The cache to allocate from.
.IP "flags" 12
 See \fBkmalloc\fP.
.SH "DESCRIPTION"
Allocate an object from this cache.  The flags are only relevant
if the cache has no available objects.
.TH "kmem_ptr_validate" 9 "kmem_ptr_validate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kmem_ptr_validate \-  check if an untrusted pointer might
.SH SYNOPSIS
.B "int fastcall" kmem_ptr_validate
.BI "(kmem_cache_t *" cachep ","
.BI "void *" ptr ");"
.SH ARGUMENTS
.IP "cachep" 12
 the cache we're checking against
.IP "ptr" 12
 pointer to validate
.SH "DESCRIPTION"
be a slab entry.
.SH "THIS VERIFIES THAT THE UNTRUSTED POINTER LOOKS SANE"
it is _not_ a guarantee that the pointer is actually
part of the slab cache in question, but it at least
validates that the pointer can be dereferenced and
looks half-way sane.

Currently only used for dentry validation.
.TH "kmem_cache_alloc_node" 9 "kmem_cache_alloc_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kmem_cache_alloc_node \-  Allocate an object on the specified node
.SH SYNOPSIS
.B "void *" kmem_cache_alloc_node
.BI "(kmem_cache_t *" cachep ","
.BI "gfp_t " flags ","
.BI "int " nodeid ");"
.SH ARGUMENTS
.IP "cachep" 12
 The cache to allocate from.
.IP "flags" 12
 See \fBkmalloc\fP.
.IP "nodeid" 12
 node number of the target node.
.SH "DESCRIPTION"
Identical to kmem_cache_alloc, except that this function is slow
and can sleep. And it will allocate memory on the given node, which
can improve the performance for cpu bound structures.
.SH "NEW AND IMPROVED"
 it will now make sure that the object gets
put on the correct node list so that there is no false sharing.
.TH "__kmalloc" 9 "__kmalloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__kmalloc \-  allocate memory
.SH SYNOPSIS
.B "void *" __kmalloc
.BI "(size_t " size ","
.BI "gfp_t " flags ");"
.SH ARGUMENTS
.IP "size" 12
 how many bytes of memory are required.
.IP "flags" 12
 the type of memory to allocate.
.SH "DESCRIPTION"
kmalloc is the normal method of allocating memory
in the kernel.

The \fIflags\fP argument may be one of:

GFP_USER - Allocate memory on behalf of user.  May sleep.

GFP_KERNEL - Allocate normal kernel ram.  May sleep.

GFP_ATOMIC - Allocation will not sleep.  Use inside interrupt handlers.

Additionally, the GFP_DMA flag may be set to indicate the memory
must be suitable for DMA.  This can mean different things on different
platforms.  For example, on i386, it means that the memory must come
from the first 16MB.
.TH "__alloc_percpu" 9 "__alloc_percpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__alloc_percpu \-  allocate one copy of the object for every present
.SH SYNOPSIS
.B "void *" __alloc_percpu
.BI "(size_t " size ","
.BI "size_t " align ");"
.SH ARGUMENTS
.IP "size" 12
 how many bytes of memory are required.
.IP "align" 12
 the alignment, which can't be greater than SMP_CACHE_BYTES.
.SH "DESCRIPTION"
cpu in the system, zeroing them.
Objects should be dereferenced using the per_cpu_ptr macro only.
.TH "kmem_cache_free" 9 "kmem_cache_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kmem_cache_free \-  Deallocate an object
.SH SYNOPSIS
.B "void" kmem_cache_free
.BI "(kmem_cache_t *" cachep ","
.BI "void *" objp ");"
.SH ARGUMENTS
.IP "cachep" 12
 The cache the allocation was from.
.IP "objp" 12
 The previously allocated object.
.SH "DESCRIPTION"
Free an object which was previously allocated from this
cache.
.TH "kzalloc" 9 "kzalloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kzalloc \-  allocate memory. The memory is set to zero.
.SH SYNOPSIS
.B "void *" kzalloc
.BI "(size_t " size ","
.BI "gfp_t " flags ");"
.SH ARGUMENTS
.IP "size" 12
 how many bytes of memory are required.
.IP "flags" 12
 the type of memory to allocate.
.TH "kfree" 9 "kfree" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
kfree \-  free previously allocated memory
.SH SYNOPSIS
.B "void" kfree
.BI "(const void *" objp ");"
.SH ARGUMENTS
.IP "objp" 12
 pointer returned by kmalloc.
.SH "DESCRIPTION"
If \fIobjp\fP is NULL, no operation is performed.

Don't free memory not originally allocated by \fBkmalloc\fP
or you will run into trouble.
.TH "free_percpu" 9 "free_percpu" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
free_percpu \-  free previously allocated percpu memory
.SH SYNOPSIS
.B "void" free_percpu
.BI "(const void *" objp ");"
.SH ARGUMENTS
.IP "objp" 12
 pointer returned by alloc_percpu.
.SH "DESCRIPTION"
Don't free memory not originally allocated by \fBalloc_percpu\fP
The complemented objp is to check for that.
.TH "cache_reap" 9 "cache_reap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
cache_reap \-  Reclaim memory from caches.
.SH SYNOPSIS
.B "void" cache_reap
.BI "(void *" unused ");"
.SH ARGUMENTS
.IP "unused" 12
-- undescribed --
.SH "DESCRIPTION"

Called from workqueue/eventd every few seconds.
.SH "PURPOSE"
- clear the per-cpu caches for this CPU.
- return freeable pages to the main free memory pool.

If we cannot acquire the cache chain semaphore then just give up - we'll
try again on the next iteration.
.TH "slabinfo_write" 9 "slabinfo_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
slabinfo_write \-  Tuning for the slab allocator
.SH SYNOPSIS
.B "ssize_t" slabinfo_write
.BI "(struct file *" file ","
.BI "const char __user *" buffer ","
.BI "size_t " count ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
 unused
.IP "buffer" 12
 user buffer
.IP "count" 12
 data length
.IP "ppos" 12
 unused
.TH "ksize" 9 "ksize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ksize \-  get the actual amount of memory allocated for a given object
.SH SYNOPSIS
.B "unsigned int" ksize
.BI "(const void *" objp ");"
.SH ARGUMENTS
.IP "objp" 12
 Pointer to the object
.SH "DESCRIPTION"
kmalloc may internally round up allocations and return more memory
than requested. \fBksize\fP can be used to determine the actual amount of
memory allocated. The caller may use this additional memory, even though
a smaller amount of memory was initially specified with the kmalloc call.
The caller must guarantee that objp points to a valid object previously
allocated with either \fBkmalloc\fP or \fBkmem_cache_alloc\fP. The object
must not be freed during the duration of the call.
.TH "alloc_page_vma" 9 "alloc_page_vma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_page_vma \-  Allocate a page for a VMA.
.SH SYNOPSIS
.B "struct page *" alloc_page_vma
.BI "(gfp_t " gfp ","
.BI "struct vm_area_struct *" vma ","
.BI "unsigned long " addr ");"
.SH ARGUMENTS
.IP "gfp" 12
GFP_USER    user allocation.
GFP_KERNEL  kernel allocations,
GFP_HIGHMEM highmem/user allocations,
GFP_FS      allocation should not call back into a file system.
GFP_ATOMIC  don't sleep.
.IP "vma" 12
  Pointer to VMA or NULL if not available.
.IP "addr" 12
 Virtual Address of the allocation. Must be inside the VMA.
.SH "DESCRIPTION"
This function allocates a page from the kernel page pool and applies
a NUMA policy associated with the VMA or the current process.
When VMA is not NULL caller must hold down_read on the mmap_sem of the
mm_struct of the VMA to prevent it from going away. Should be used for
all allocations for pages that will be mapped into
user space. Returns NULL when no page can be allocated.

Should be called with the mm_sem of the vma hold.
.SH "DESCRIPTION"
This function allocates a page from the kernel page pool and applies
a NUMA policy associated with the VMA or the current process.
When VMA is not NULL caller must hold down_read on the mmap_sem of the
mm_struct of the VMA to prevent it from going away. Should be used for
all allocations for pages that will be mapped into
user space. Returns NULL when no page can be allocated.

Should be called with the mm_sem of the vma hold.
.TH "alloc_pages_current" 9 "alloc_pages_current" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
alloc_pages_current \-  Allocate pages.
.SH SYNOPSIS
.B "struct page *" alloc_pages_current
.BI "(gfp_t " gfp ","
.BI "unsigned " order ");"
.SH ARGUMENTS
.IP "gfp" 12
GFP_USER   user allocation,
GFP_KERNEL kernel allocation,
GFP_HIGHMEM highmem allocation,
GFP_FS     don't call back into a file system.
GFP_ATOMIC don't sleep.
.IP "order" 12
 Power of two of allocation size in pages. 0 is a single page.
.SH "DESCRIPTION"
Allocate a page from the kernel page pool.  When not in
interrupt context and apply the current process NUMA policy.
Returns NULL when no page can be allocated.

Don't call \fBcpuset_update_current_mems_allowed\fP unless
1) it's ok to take cpuset_sem (can WAIT), and
2) allocating for current task (not interrupt).
.SH "DESCRIPTION"
Allocate a page from the kernel page pool.  When not in
interrupt context and apply the current process NUMA policy.
Returns NULL when no page can be allocated.

Don't call \fBcpuset_update_current_mems_allowed\fP unless
1) it's ok to take cpuset_sem (can WAIT), and
2) allocating for current task (not interrupt).
.TH "unmap_vmas" 9 "unmap_vmas" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unmap_vmas \-  unmap a range of memory covered by a list of vma's
.SH SYNOPSIS
.B "unsigned long" unmap_vmas
.BI "(struct mmu_gather **" tlbp ","
.BI "struct mm_struct *" mm ","
.BI "struct vm_area_struct *" vma ","
.BI "unsigned long " start_addr ","
.BI "unsigned long " end_addr ","
.BI "unsigned long *" nr_accounted ","
.BI "struct zap_details *" details ");"
.SH ARGUMENTS
.IP "tlbp" 12
 address of the caller's struct mmu_gather
.IP "mm" 12
 the controlling mm_struct
.IP "vma" 12
 the starting vma
.IP "start_addr" 12
 virtual address at which to start unmapping
.IP "end_addr" 12
 virtual address at which to end unmapping
.IP "nr_accounted" 12
 Place number of unmapped pages in vm-accountable vma's here
.IP "details" 12
 details of nonlinear truncation or shared cache invalidation
.SH "DESCRIPTION"
Returns the end address of the unmapping (restart addr if interrupted).

Unmap all pages in the vma list.  Called under page_table_lock.

We aim to not hold page_table_lock for too long (for scheduling latency
reasons).  So zap pages in ZAP_BLOCK_SIZE bytecounts.  This means we need to
return the ending mmu_gather to the caller.

Only addresses between `start' and `end' will be unmapped.

The VMA list must be sorted in ascending virtual address order.

\fBunmap_vmas\fP assumes that the caller will flush the whole unmapped address
range after \fBunmap_vmas\fP returns.  So the only responsibility here is to
ensure that any thus-far unmapped pages are flushed before \fBunmap_vmas\fP
drops the lock and schedules.
.TH "zap_page_range" 9 "zap_page_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
zap_page_range \-  remove user pages in a given range
.SH SYNOPSIS
.B "unsigned long" zap_page_range
.BI "(struct vm_area_struct *" vma ","
.BI "unsigned long " address ","
.BI "unsigned long " size ","
.BI "struct zap_details *" details ");"
.SH ARGUMENTS
.IP "vma" 12
 vm_area_struct holding the applicable pages
.IP "address" 12
 starting address of pages to zap
.IP "size" 12
 number of bytes to zap
.IP "details" 12
 details of nonlinear truncation or shared cache invalidation
.TH "unmap_mapping_range" 9 "unmap_mapping_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unmap_mapping_range \-  unmap the portion of all mmaps
.SH SYNOPSIS
.B "void" unmap_mapping_range
.BI "(struct address_space *" mapping ","
.BI "loff_t const " holebegin ","
.BI "loff_t const " holelen ","
.BI "int " even_cows ");"
.SH ARGUMENTS
.IP "mapping" 12
 the address space containing mmaps to be unmapped.
.IP "holebegin" 12
 byte in first page to unmap, relative to the start of
the underlying file.  This will be rounded down to a PAGE_SIZE
boundary.  Note that this is different from \fBvmtruncate\fP, which
must keep the partial page.  In contrast, we must get rid of
partial pages.
.IP "holelen" 12
 size of prospective hole in bytes.  This will be rounded
up to a PAGE_SIZE boundary.  A holelen of zero truncates to the
end of the file.
.IP "even_cows" 12
 1 when truncating a file, unmap even private COWed pages;
but 0 when invalidating pagecache, don't throw away private data.
.SH "DESCRIPTION"
in the specified address_space corresponding to the specified
page range in the underlying file.
.TH "get_vm_area" 9 "get_vm_area" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
get_vm_area \-   reserve a contingous kernel virtual area
.SH SYNOPSIS
.B "struct vm_struct *" get_vm_area
.BI "(unsigned long " size ","
.BI "unsigned long " flags ");"
.SH ARGUMENTS
.IP "size" 12
		size of the area
.IP "flags" 12
		VM_IOREMAP for I/O mappings or VM_ALLOC
.SH "DESCRIPTION"
Search an area of \fIsize\fP in the kernel virtual mapping area,
and reserved it for out purposes.  Returns the area descriptor
on success or NULL on failure.
.SH "DESCRIPTION"
Search an area of \fIsize\fP in the kernel virtual mapping area,
and reserved it for out purposes.  Returns the area descriptor
on success or NULL on failure.
.TH "remove_vm_area" 9 "remove_vm_area" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
remove_vm_area \-   find and remove a contingous kernel virtual area
.SH SYNOPSIS
.B "struct vm_struct *" remove_vm_area
.BI "(void *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
		base address
.SH "DESCRIPTION"
Search for the kernel VM area starting at \fIaddr\fP, and remove it.
This function returns the found VM area, but using it is NOT safe
on SMP machines, except for its size or flags.
.SH "DESCRIPTION"
Search for the kernel VM area starting at \fIaddr\fP, and remove it.
This function returns the found VM area, but using it is NOT safe
on SMP machines, except for its size or flags.
.TH "vfree" 9 "vfree" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vfree \-   release memory allocated by vmalloc()
.SH SYNOPSIS
.B "void" vfree
.BI "(void *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
		memory base address
.SH "DESCRIPTION"
Free the virtually contiguous memory area starting at \fIaddr\fP, as
obtained from \fBvmalloc\fP, \fBvmalloc_32\fP or \fB__vmalloc\fP. If \fIaddr\fP is
NULL, no operation is performed.

Must not be called in interrupt context.
.SH "DESCRIPTION"
Free the virtually contiguous memory area starting at \fIaddr\fP, as
obtained from \fBvmalloc\fP, \fBvmalloc_32\fP or \fB__vmalloc\fP. If \fIaddr\fP is
NULL, no operation is performed.

Must not be called in interrupt context.
.TH "vunmap" 9 "vunmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vunmap \-   release virtual mapping obtained by vmap()
.SH SYNOPSIS
.B "void" vunmap
.BI "(void *" addr ");"
.SH ARGUMENTS
.IP "addr" 12
		memory base address
.SH "DESCRIPTION"
Free the virtually contiguous memory area starting at \fIaddr\fP,
which was created from the page array passed to \fBvmap\fP.

Must not be called in interrupt context.
.SH "DESCRIPTION"
Free the virtually contiguous memory area starting at \fIaddr\fP,
which was created from the page array passed to \fBvmap\fP.

Must not be called in interrupt context.
.TH "vmap" 9 "vmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vmap \-   map an array of pages into virtually contiguous space
.SH SYNOPSIS
.B "void *" vmap
.BI "(struct page **" pages ","
.BI "unsigned int " count ","
.BI "unsigned long " flags ","
.BI "pgprot_t " prot ");"
.SH ARGUMENTS
.IP "pages" 12
		array of page pointers
.IP "count" 12
		number of pages to map
.IP "flags" 12
		vm_area-&gt;flags
.IP "prot" 12
		page protection for the mapping
.SH "DESCRIPTION"
Maps \fIcount\fP pages from \fIpages\fP into contiguous kernel virtual
space.
.SH "DESCRIPTION"
Maps \fIcount\fP pages from \fIpages\fP into contiguous kernel virtual
space.
.TH "__vmalloc" 9 "__vmalloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__vmalloc \-   allocate virtually contiguous memory
.SH SYNOPSIS
.B "void *" __vmalloc
.BI "(unsigned long " size ","
.BI "gfp_t " gfp_mask ","
.BI "pgprot_t " prot ");"
.SH ARGUMENTS
.IP "size" 12
		allocation size
.IP "gfp_mask" 12
	flags for the page level allocator
.IP "prot" 12
		protection mask for the allocated pages
.SH "DESCRIPTION"
Allocate enough pages to cover \fIsize\fP from the page level
allocator with \fIgfp_mask\fP flags.  Map them into contiguous
kernel virtual space, using a pagetable protection of \fIprot\fP.
.SH "DESCRIPTION"
Allocate enough pages to cover \fIsize\fP from the page level
allocator with \fIgfp_mask\fP flags.  Map them into contiguous
kernel virtual space, using a pagetable protection of \fIprot\fP.
.TH "vmalloc" 9 "vmalloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vmalloc \-   allocate virtually contiguous memory
.SH SYNOPSIS
.B "void *" vmalloc
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
		allocation size
.SH "DESCRIPTION"
Allocate enough pages to cover \fIsize\fP from the page level
allocator and map them into contiguous kernel virtual space.

For tight cotrol over page level allocator and protection flags
use \fB__vmalloc\fP instead.
.SH "DESCRIPTION"
Allocate enough pages to cover \fIsize\fP from the page level
allocator and map them into contiguous kernel virtual space.

For tight cotrol over page level allocator and protection flags
use \fB__vmalloc\fP instead.
.TH "vmalloc_exec" 9 "vmalloc_exec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vmalloc_exec \-   allocate virtually contiguous, executable memory
.SH SYNOPSIS
.B "void *" vmalloc_exec
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
		allocation size
.SH "DESCRIPTION"
Kernel-internal function to allocate enough pages to cover \fIsize\fP
the page level allocator and map them into contiguous and
executable kernel virtual space.

For tight cotrol over page level allocator and protection flags
use \fB__vmalloc\fP instead.
.SH "DESCRIPTION"
Kernel-internal function to allocate enough pages to cover \fIsize\fP
the page level allocator and map them into contiguous and
executable kernel virtual space.

For tight cotrol over page level allocator and protection flags
use \fB__vmalloc\fP instead.
.TH "vmalloc_32" 9 "vmalloc_32" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vmalloc_32 \-   allocate virtually contiguous memory (32bit addressable)
.SH SYNOPSIS
.B "void *" vmalloc_32
.BI "(unsigned long " size ");"
.SH ARGUMENTS
.IP "size" 12
		allocation size
.SH "DESCRIPTION"
Allocate enough 32bit PA addressable pages to cover \fIsize\fP from the
page level allocator and map them into contiguous kernel virtual space.
.SH "DESCRIPTION"
Allocate enough 32bit PA addressable pages to cover \fIsize\fP from the
page level allocator and map them into contiguous kernel virtual space.
.TH "find_next_best_node" 9 "find_next_best_node" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_next_best_node \-  find the next node that should appear in a given node's fallback list
.SH SYNOPSIS
.B "int __init" find_next_best_node
.BI "(int " node ","
.BI "nodemask_t *" used_node_mask ");"
.SH ARGUMENTS
.IP "node" 12
 node whose fallback list we're appending
.IP "used_node_mask" 12
 nodemask_t of already used nodes
.SH "DESCRIPTION"
We use a number of factors to determine which is the next node that should
appear on a given node's fallback list.  The node should not have appeared
already in \fInode\fP's fallback list, and it should be the next closest node
according to the distance array (which contains arbitrary distance values
from each node to each node in the system), and should also prefer nodes
with no CPUs, since presumably they'll have very little allocation pressure
on them otherwise.
It returns -1 if no node is found.
.TH "badness" 9 "badness" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
badness \-  calculate a numeric value for how bad this task has been
.SH SYNOPSIS
.B "unsigned long" badness
.BI "(struct task_struct *" p ","
.BI "unsigned long " uptime ");"
.SH ARGUMENTS
.IP "p" 12
 task struct of which task we should calculate
.IP "uptime" 12
 current uptime in seconds
.SH "DESCRIPTION"
The formula used is relatively simple and documented inline in the
function. The main rationale is that we want to select a good task
to kill when we run out of memory.
.SH "GOOD IN THIS CONTEXT MEANS THAT"
1) we lose the minimum amount of work done
2) we recover a large amount of memory
3) we don't kill anything innocent of eating tons of memory
4) we want to kill the minimum amount of processes (one)
5) we try to kill the process the user expects us to kill, this
algorithm has been meticulously tuned to meet the principle
of least surprise ... (be careful when you change it)
.TH "__oom_kill_task" 9 "__oom_kill_task" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__oom_kill_task \- 
.SH SYNOPSIS
.B "void" __oom_kill_task
.BI "(task_t *" p ");"
.SH ARGUMENTS
.IP "p" 12
-- undescribed --
.SH "DESCRIPTION"
CAP_SYS_RAW_IO set, send SIGTERM instead (but it's unlikely that
we select a process with CAP_SYS_RAW_IO set).
.TH "out_of_memory" 9 "out_of_memory" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
out_of_memory \-  kill the "best" process when we run out of memory
.SH SYNOPSIS
.B "void" out_of_memory
.BI "(gfp_t " gfp_mask ","
.BI "int " order ");"
.SH ARGUMENTS
.IP "gfp_mask" 12
-- undescribed --
.IP "order" 12
-- undescribed --
.SH "DESCRIPTION"

If we run out of memory, we have the choice between either
killing a random task (bad), letting the system crash (worse)
OR try to be smart about which process to kill. Note that we
don't have to be perfect here, we just have to be good.
.TH "read_cache_pages" 9 "read_cache_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
read_cache_pages \-  populate an address space with some pages, and
.SH SYNOPSIS
.B "int" read_cache_pages
.BI "(struct address_space *" mapping ","
.BI "struct list_head *" pages ","
.BI "int (*" filler ") (void *, struct page *),"
.BI "void *" data ");"
.SH ARGUMENTS
.IP "mapping" 12
 the address_space
.IP "pages" 12
 The address of a list_head which contains the target pages.  These
pages have their -&gt;index populated and are otherwise uninitialised.
.IP "filler" 12
 callback routine for filling a single page.
.IP "data" 12
 private data for the callback routine.
.SH "DESCRIPTION"
Hides the details of the LRU cache etc from the filesystems.
.SH "DESCRIPTION"
Hides the details of the LRU cache etc from the filesystems.
.TH "DEFINE_PER_CPU" 9 "DEFINE_PER_CPU" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
DEFINE_PER_CPU \- 
.SH SYNOPSIS
.B "" DEFINE_PER_CPU
.BI "(struct " pagevec ","
.BI "" lru_add_pvecs ");"
.SH ARGUMENTS
.IP "pagevec" 12
-- undescribed --
.IP "lru_add_pvecs" 12
.TH "pagevec_lookup" 9 "pagevec_lookup" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
pagevec_lookup \-  gang pagecache lookup
.SH SYNOPSIS
.B "unsigned" pagevec_lookup
.BI "(struct pagevec *" pvec ","
.BI "struct address_space *" mapping ","
.BI "pgoff_t " start ","
.BI "unsigned " nr_pages ");"
.SH ARGUMENTS
.IP "pvec" 12
	Where the resulting pages are placed
.IP "mapping" 12
	The address_space to search
.IP "start" 12
	The starting page index
.IP "nr_pages" 12
	The maximum number of pages
.SH "DESCRIPTION"
\fBpagevec_lookup\fP will search for and return a group of up to \fInr_pages\fP pages
in the mapping.  The pages are placed in \fIpvec\fP.  \fBpagevec_lookup\fP takes a
reference against the pages in \fIpvec\fP.

The search returns a group of mapping-contiguous pages with ascending
indexes.  There may be holes in the indices due to not-present pages.

\fBpagevec_lookup\fP returns the number of pages which were found.
.TH "__filemap_fdatawrite_range" 9 "__filemap_fdatawrite_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
__filemap_fdatawrite_range \-  start writeback against all of a mapping's
.SH SYNOPSIS
.B "int" __filemap_fdatawrite_range
.BI "(struct address_space *" mapping ","
.BI "loff_t " start ","
.BI "loff_t " end ","
.BI "int " sync_mode ");"
.SH ARGUMENTS
.IP "mapping" 12
	address space structure to write
.IP "start" 12
	offset in bytes where the range starts
.IP "end" 12
	offset in bytes where the range ends
.IP "sync_mode" 12
	enable synchronous operation
.SH "DESCRIPTION"
If sync_mode is WB_SYNC_ALL then this is a "data integrity" operation, as
opposed to a regular memory * cleansing writeback.  The difference between
these two operations is that if a dirty page/buffer is encountered, it must
be waited upon, and not just skipped over.
.SH "DESCRIPTION"
If sync_mode is WB_SYNC_ALL then this is a "data integrity" operation, as
opposed to a regular memory * cleansing writeback.  The difference between
these two operations is that if a dirty page/buffer is encountered, it must
be waited upon, and not just skipped over.
.TH "filemap_fdatawait" 9 "filemap_fdatawait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
filemap_fdatawait \-  walk the list of under-writeback pages of the given
.SH SYNOPSIS
.B "int" filemap_fdatawait
.BI "(struct address_space *" mapping ");"
.SH ARGUMENTS
.IP "mapping" 12
 address space structure to wait for
.SH "DESCRIPTION"
address space and wait for all of them.
.TH "unlock_page" 9 "unlock_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unlock_page \-  unlock a locked page
.SH SYNOPSIS
.B "void fastcall" unlock_page
.BI "(struct page *" page ");"
.SH ARGUMENTS
.IP "page" 12
 the page
.SH "DESCRIPTION"
Unlocks the page and wakes up sleepers in \fB___wait_on_page_locked\fP.
Also wakes sleepers in \fBwait_on_page_writeback\fP because the wakeup
mechananism between PageLocked pages and PageWriteback pages is shared.
But that's OK - sleepers in \fBwait_on_page_writeback\fP just go back to sleep.

The first mb is necessary to safely close the critical section opened by the
\fBTestSetPageLocked\fP, the second mb is necessary to enforce ordering between
the clear_bit and the read of the waitqueue (to avoid SMP races with a
parallel \fBwait_on_page_locked\fP).
.SH "DESCRIPTION"
Unlocks the page and wakes up sleepers in \fB___wait_on_page_locked\fP.
Also wakes sleepers in \fBwait_on_page_writeback\fP because the wakeup
mechananism between PageLocked pages and PageWriteback pages is shared.
But that's OK - sleepers in \fBwait_on_page_writeback\fP just go back to sleep.

The first mb is necessary to safely close the critical section opened by the
\fBTestSetPageLocked\fP, the second mb is necessary to enforce ordering between
the clear_bit and the read of the waitqueue (to avoid SMP races with a
parallel \fBwait_on_page_locked\fP).
.TH "find_lock_page" 9 "find_lock_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_lock_page \-  locate, pin and lock a pagecache page
.SH SYNOPSIS
.B "struct page *" find_lock_page
.BI "(struct address_space *" mapping ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "mapping" 12
 the address_space to search
.IP "offset" 12
 the page index
.SH "DESCRIPTION"
Locates the desired pagecache page, locks it, increments its reference
count and returns its address.

Returns zero if the page was not present. \fBfind_lock_page\fP may sleep.
.SH "DESCRIPTION"
Locates the desired pagecache page, locks it, increments its reference
count and returns its address.

Returns zero if the page was not present. \fBfind_lock_page\fP may sleep.
.TH "find_or_create_page" 9 "find_or_create_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_or_create_page \-  locate or add a pagecache page
.SH SYNOPSIS
.B "struct page *" find_or_create_page
.BI "(struct address_space *" mapping ","
.BI "unsigned long " index ","
.BI "unsigned int " gfp_mask ");"
.SH ARGUMENTS
.IP "mapping" 12
 the page's address_space
.IP "index" 12
 the page's index into the mapping
.IP "gfp_mask" 12
 page allocation mode
.SH "DESCRIPTION"
Locates a page in the pagecache.  If the page is not present, a new page
is allocated using \fIgfp_mask\fP and is added to the pagecache and to the VM's
LRU list.  The returned page is locked and has its reference count
incremented.

\fBfind_or_create_page\fP may sleep, even if \fIgfp_flags\fP specifies an atomic
allocation!

\fBfind_or_create_page\fP returns the desired page's address, or zero on
memory exhaustion.
.SH "DESCRIPTION"
Locates a page in the pagecache.  If the page is not present, a new page
is allocated using \fIgfp_mask\fP and is added to the pagecache and to the VM's
LRU list.  The returned page is locked and has its reference count
incremented.

\fBfind_or_create_page\fP may sleep, even if \fIgfp_flags\fP specifies an atomic
allocation!

\fBfind_or_create_page\fP returns the desired page's address, or zero on
memory exhaustion.
.TH "find_get_pages" 9 "find_get_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
find_get_pages \-  gang pagecache lookup
.SH SYNOPSIS
.B "unsigned" find_get_pages
.BI "(struct address_space *" mapping ","
.BI "pgoff_t " start ","
.BI "unsigned int " nr_pages ","
.BI "struct page **" pages ");"
.SH ARGUMENTS
.IP "mapping" 12
	The address_space to search
.IP "start" 12
	The starting page index
.IP "nr_pages" 12
	The maximum number of pages
.IP "pages" 12
	Where the resulting pages are placed
.SH "DESCRIPTION"
\fBfind_get_pages\fP will search for and return a group of up to
\fInr_pages\fP pages in the mapping.  The pages are placed at \fIpages\fP.
\fBfind_get_pages\fP takes a reference against the returned pages.

The search returns a group of mapping-contiguous pages with ascending
indexes.  There may be holes in the indices due to not-present pages.

\fBfind_get_pages\fP returns the number of pages which were found.
.TH "add_to_swap" 9 "add_to_swap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
add_to_swap \-  allocate swap space for a page
.SH SYNOPSIS
.B "int" add_to_swap
.BI "(struct page *" page ");"
.SH ARGUMENTS
.IP "page" 12
 page we want to move to swap
.SH "DESCRIPTION"
Allocate swap space for the page and add the page to the
swap cache.  Caller needs to hold the page lock. 
.TH "page_referenced_file" 9 "page_referenced_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
page_referenced_file \-  referenced check for object-based rmap
.SH SYNOPSIS
.B "int" page_referenced_file
.BI "(struct page *" page ","
.BI "int " ignore_token ");"
.SH ARGUMENTS
.IP "page" 12
 the page we're checking references on.
.IP "ignore_token" 12
-- undescribed --
.SH "DESCRIPTION"
For an object-based mapped page, find all the places it is mapped and
check/clear the referenced flag.  This is done by following the page-&gt;mapping
pointer, then walking the chain of vmas it holds.  It returns the number
of references it found.

This function is only called from page_referenced for object-based pages.
.TH "page_referenced" 9 "page_referenced" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
page_referenced \-  test if the page was referenced
.SH SYNOPSIS
.B "int" page_referenced
.BI "(struct page *" page ","
.BI "int " is_locked ","
.BI "int " ignore_token ");"
.SH ARGUMENTS
.IP "page" 12
 the page to test
.IP "is_locked" 12
 caller holds lock on the page
.IP "ignore_token" 12
-- undescribed --
.SH "DESCRIPTION"
Quick test_and_clear_referenced for all mappings to a page,
returns the number of ptes which referenced the page.
.TH "page_add_anon_rmap" 9 "page_add_anon_rmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
page_add_anon_rmap \-  add pte mapping to an anonymous page
.SH SYNOPSIS
.B "void" page_add_anon_rmap
.BI "(struct page *" page ","
.BI "struct vm_area_struct *" vma ","
.BI "unsigned long " address ");"
.SH ARGUMENTS
.IP "page" 12
	the page to add the mapping to
.IP "vma" 12
	the vm area in which the mapping is added
.IP "address" 12
	the user virtual address mapped
.SH "DESCRIPTION"
The caller needs to hold the mm-&gt;page_table_lock.
.TH "page_add_file_rmap" 9 "page_add_file_rmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
page_add_file_rmap \-  add pte mapping to a file page
.SH SYNOPSIS
.B "void" page_add_file_rmap
.BI "(struct page *" page ");"
.SH ARGUMENTS
.IP "page" 12
 the page to add the mapping to
.SH "DESCRIPTION"
The caller needs to hold the mm-&gt;page_table_lock.
.TH "page_remove_rmap" 9 "page_remove_rmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
page_remove_rmap \-  take down pte mapping from a page
.SH SYNOPSIS
.B "void" page_remove_rmap
.BI "(struct page *" page ");"
.SH ARGUMENTS
.IP "page" 12
 page to remove mapping from
.SH "DESCRIPTION"
Caller needs to hold the mm-&gt;page_table_lock.
.TH "try_to_unmap_file" 9 "try_to_unmap_file" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
try_to_unmap_file \-  unmap file page using the object-based rmap method
.SH SYNOPSIS
.B "int" try_to_unmap_file
.BI "(struct page *" page ");"
.SH ARGUMENTS
.IP "page" 12
 the page to unmap
.SH "DESCRIPTION"
Find all the mappings of a page using the mapping pointer and the vma chains
contained in the address_space struct it points to.

This function is only called from try_to_unmap for object-based pages.
.TH "try_to_unmap" 9 "try_to_unmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
try_to_unmap \-  try to remove all page table mappings to a page
.SH SYNOPSIS
.B "int" try_to_unmap
.BI "(struct page *" page ");"
.SH ARGUMENTS
.IP "page" 12
 the page to get unmapped
.SH "DESCRIPTION"
Tries to remove all the page table entries which are mapping this
page, used in the pageout path.  Caller must hold the page lock.
.SH "RETURN VALUES ARE"

SWAP_SUCCESS	- we succeeded in removing all mappings
SWAP_AGAIN	- we missed a mapping, try again later
SWAP_FAIL	- the page is unswappable
.TH "mempool_create" 9 "mempool_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mempool_create \-  create a memory pool
.SH SYNOPSIS
.B "mempool_t *" mempool_create
.BI "(int " min_nr ","
.BI "mempool_alloc_t *" alloc_fn ","
.BI "mempool_free_t *" free_fn ","
.BI "void *" pool_data ");"
.SH ARGUMENTS
.IP "min_nr" 12
    the minimum number of elements guaranteed to be
allocated for this pool.
.IP "alloc_fn" 12
  user-defined element-allocation function.
.IP "free_fn" 12
   user-defined element-freeing function.
.IP "pool_data" 12
 optional private data available to the user-defined functions.
.SH "DESCRIPTION"
this function creates and allocates a guaranteed size, preallocated
memory pool. The pool can be used from the mempool_alloc and mempool_free
functions. This function might sleep. Both the \fBalloc_fn\fP and the \fBfree_fn\fP
functions might sleep - as long as the mempool_alloc function is not called
from IRQ contexts.
.TH "mempool_resize" 9 "mempool_resize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mempool_resize \-  resize an existing memory pool
.SH SYNOPSIS
.B "int" mempool_resize
.BI "(mempool_t *" pool ","
.BI "int " new_min_nr ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "pool" 12
       pointer to the memory pool which was allocated via
\fBmempool_create\fP.
.IP "new_min_nr" 12
 the new minimum number of elements guaranteed to be
allocated for this pool.
.IP "gfp_mask" 12
   the usual allocation bitmask.
.SH "DESCRIPTION"
This function shrinks/grows the pool. In the case of growing,
it cannot be guaranteed that the pool will be grown to the new
size immediately, but new \fBmempool_free\fP calls will refill it.

Note, the caller must guarantee that no mempool_destroy is called
while this function is running. \fBmempool_alloc\fP &amp; \fBmempool_free\fP
might be called (eg. from IRQ contexts) while this function executes.
.TH "mempool_destroy" 9 "mempool_destroy" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mempool_destroy \-  deallocate a memory pool
.SH SYNOPSIS
.B "void" mempool_destroy
.BI "(mempool_t *" pool ");"
.SH ARGUMENTS
.IP "pool" 12
      pointer to the memory pool which was allocated via
\fBmempool_create\fP.
.SH "DESCRIPTION"
this function only sleeps if the \fBfree_fn\fP function sleeps. The caller
has to guarantee that all elements have been returned to the pool (ie:
freed) prior to calling \fBmempool_destroy\fP.
.TH "mempool_alloc" 9 "mempool_alloc" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mempool_alloc \-  allocate an element from a specific memory pool
.SH SYNOPSIS
.B "void *" mempool_alloc
.BI "(mempool_t *" pool ","
.BI "gfp_t " gfp_mask ");"
.SH ARGUMENTS
.IP "pool" 12
      pointer to the memory pool which was allocated via
\fBmempool_create\fP.
.IP "gfp_mask" 12
  the usual allocation bitmask.
.SH "DESCRIPTION"
this function only sleeps if the alloc_fn function sleeps or
returns NULL. Note that due to preallocation, this function
*never* fails when called from process contexts. (it might
fail if called from an IRQ context.)
.TH "mempool_free" 9 "mempool_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mempool_free \-  return an element to the pool.
.SH SYNOPSIS
.B "void" mempool_free
.BI "(void *" element ","
.BI "mempool_t *" pool ");"
.SH ARGUMENTS
.IP "element" 12
   pool element pointer.
.IP "pool" 12
      pointer to the memory pool which was allocated via
\fBmempool_create\fP.
.SH "DESCRIPTION"
this function only sleeps if the \fBfree_fn\fP function sleeps.
.TH "truncate_inode_pages" 9 "truncate_inode_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
truncate_inode_pages \-  truncate *all* the pages from an offset
.SH SYNOPSIS
.B "void" truncate_inode_pages
.BI "(struct address_space *" mapping ","
.BI "loff_t " lstart ");"
.SH ARGUMENTS
.IP "mapping" 12
 mapping to truncate
.IP "lstart" 12
 offset from which to truncate
.SH "DESCRIPTION"
Truncate the page cache at a set offset, removing the pages that are beyond
that offset (and zeroing out partial pages).

Truncate takes two passes - the first pass is nonblocking.  It will not
block on page locks and it will not block on writeback.  The second pass
will wait.  This is to prevent as much IO as possible in the affected region.
The first pass will remove most pages, so the search cost of the second pass
is low.

When looking at page-&gt;index outside the page lock we need to be careful to
copy it into a local to avoid races (it could change at any time).

We pass down the cache-hot hint to the page freeing code.  Even if the
mapping is large, it is probably the case that the final pages are the most
recently touched, and freeing happens in ascending file offset order.

Called under (and serialised by) inode-&gt;i_sem.
.TH "invalidate_mapping_pages" 9 "invalidate_mapping_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
invalidate_mapping_pages \-  Invalidate all the unlocked pages of one inode
.SH SYNOPSIS
.B "unsigned long" invalidate_mapping_pages
.BI "(struct address_space *" mapping ","
.BI "pgoff_t " start ","
.BI "pgoff_t " end ");"
.SH ARGUMENTS
.IP "mapping" 12
 the address_space which holds the pages to invalidate
.IP "start" 12
 the offset 'from' which to invalidate
.IP "end" 12
 the offset 'to' which to invalidate (inclusive)
.SH "DESCRIPTION"
This function only removes the unlocked pages, if you want to
remove all the pages of one inode, you must call truncate_inode_pages.

\fBinvalidate_mapping_pages\fP will not block on IO activity. It will not
invalidate pages which are dirty, locked, under writeback or mapped into
pagetables.
.TH "invalidate_inode_pages2_range" 9 "invalidate_inode_pages2_range" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
invalidate_inode_pages2_range \-  remove range of pages from an address_space
.SH SYNOPSIS
.B "int" invalidate_inode_pages2_range
.BI "(struct address_space *" mapping ","
.BI "pgoff_t " start ","
.BI "pgoff_t " end ");"
.SH ARGUMENTS
.IP "mapping" 12
 the address_space
.IP "start" 12
 the page offset 'from' which to invalidate
.IP "end" 12
 the page offset 'to' which to invalidate (inclusive)
.SH "DESCRIPTION"
Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.

Returns -EIO if any pages could not be invalidated.
.TH "invalidate_inode_pages2" 9 "invalidate_inode_pages2" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
invalidate_inode_pages2 \-  remove all pages from an address_space
.SH SYNOPSIS
.B "int" invalidate_inode_pages2
.BI "(struct address_space *" mapping ");"
.SH ARGUMENTS
.IP "mapping" 12
 the address_space
.SH "DESCRIPTION"
Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.

Returns -EIO if any pages could not be invalidated.
.TH "register_sound_special_device" 9 "register_sound_special_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_sound_special_device \-  register a special sound node
.SH SYNOPSIS
.B "int" register_sound_special_device
.BI "(struct file_operations *" fops ","
.BI "int " unit ","
.BI "struct device *" dev ");"
.SH ARGUMENTS
.IP "fops" 12
 File operations for the driver
.IP "unit" 12
 Unit number to allocate
.IP "dev" 12
 device pointer
.SH "DESCRIPTION"
Allocate a special sound device by minor number from the sound
subsystem. The allocated number is returned on succes. On failure
a negative error code is returned.
.TH "register_sound_mixer" 9 "register_sound_mixer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_sound_mixer \-  register a mixer device
.SH SYNOPSIS
.B "int" register_sound_mixer
.BI "(struct file_operations *" fops ","
.BI "int " dev ");"
.SH ARGUMENTS
.IP "fops" 12
 File operations for the driver
.IP "dev" 12
 Unit number to allocate
.SH "DESCRIPTION"
Allocate a mixer device. Unit is the number of the mixer requested.
Pass -1 to request the next free mixer unit. On success the allocated
number is returned, on failure a negative error code is returned.
.TH "register_sound_midi" 9 "register_sound_midi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_sound_midi \-  register a midi device
.SH SYNOPSIS
.B "int" register_sound_midi
.BI "(struct file_operations *" fops ","
.BI "int " dev ");"
.SH ARGUMENTS
.IP "fops" 12
 File operations for the driver
.IP "dev" 12
 Unit number to allocate
.SH "DESCRIPTION"
Allocate a midi device. Unit is the number of the midi device requested.
Pass -1 to request the next free midi unit. On success the allocated
number is returned, on failure a negative error code is returned.
.TH "register_sound_dsp" 9 "register_sound_dsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_sound_dsp \-  register a DSP device
.SH SYNOPSIS
.B "int" register_sound_dsp
.BI "(struct file_operations *" fops ","
.BI "int " dev ");"
.SH ARGUMENTS
.IP "fops" 12
 File operations for the driver
.IP "dev" 12
 Unit number to allocate
.SH "DESCRIPTION"
Allocate a DSP device. Unit is the number of the DSP requested.
Pass -1 to request the next free DSP unit. On success the allocated
number is returned, on failure a negative error code is returned.

This function allocates both the audio and dsp device entries together
and will always allocate them as a matching pair - eg dsp3/audio3
.TH "register_sound_synth" 9 "register_sound_synth" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
register_sound_synth \-  register a synth device
.SH SYNOPSIS
.B "int" register_sound_synth
.BI "(struct file_operations *" fops ","
.BI "int " dev ");"
.SH ARGUMENTS
.IP "fops" 12
 File operations for the driver
.IP "dev" 12
 Unit number to allocate
.SH "DESCRIPTION"
Allocate a synth device. Unit is the number of the synth device requested.
Pass -1 to request the next free synth unit. On success the allocated
number is returned, on failure a negative error code is returned.
.TH "unregister_sound_special" 9 "unregister_sound_special" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_sound_special \-  unregister a special sound device
.SH SYNOPSIS
.B "void" unregister_sound_special
.BI "(int " unit ");"
.SH ARGUMENTS
.IP "unit" 12
 unit number to allocate
.SH "DESCRIPTION"
Release a sound device that was allocated with
\fBregister_sound_special\fP. The unit passed is the return value from
the register function.
.TH "unregister_sound_mixer" 9 "unregister_sound_mixer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_sound_mixer \-  unregister a mixer
.SH SYNOPSIS
.B "void" unregister_sound_mixer
.BI "(int " unit ");"
.SH ARGUMENTS
.IP "unit" 12
 unit number to allocate
.SH "DESCRIPTION"
Release a sound device that was allocated with \fBregister_sound_mixer\fP.
The unit passed is the return value from the register function.
.TH "unregister_sound_midi" 9 "unregister_sound_midi" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_sound_midi \-  unregister a midi device
.SH SYNOPSIS
.B "void" unregister_sound_midi
.BI "(int " unit ");"
.SH ARGUMENTS
.IP "unit" 12
 unit number to allocate
.SH "DESCRIPTION"
Release a sound device that was allocated with \fBregister_sound_midi\fP.
The unit passed is the return value from the register function.
.TH "unregister_sound_dsp" 9 "unregister_sound_dsp" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_sound_dsp \-  unregister a DSP device
.SH SYNOPSIS
.B "void" unregister_sound_dsp
.BI "(int " unit ");"
.SH ARGUMENTS
.IP "unit" 12
 unit number to allocate
.SH "DESCRIPTION"
Release a sound device that was allocated with \fBregister_sound_dsp\fP.
The unit passed is the return value from the register function.

Both of the allocated units are released together automatically.
.TH "unregister_sound_synth" 9 "unregister_sound_synth" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
unregister_sound_synth \-  unregister a synth device
.SH SYNOPSIS
.B "void" unregister_sound_synth
.BI "(int " unit ");"
.SH ARGUMENTS
.IP "unit" 12
 unit number to allocate
.SH "DESCRIPTION"
Release a sound device that was allocated with \fBregister_sound_synth\fP.
The unit passed is the return value from the register function.
.TH "snd_vx_load_boot_image" 9 "snd_vx_load_boot_image" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_vx_load_boot_image \-  boot up the xilinx interface
.SH SYNOPSIS
.B "int" snd_vx_load_boot_image
.BI "(vx_core_t *" chip ","
.BI "const struct firmware *" boot ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "boot" 12
 the boot record to load
.TH "snd_vx_irq_handler" 9 "snd_vx_irq_handler" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_vx_irq_handler \-  interrupt handler
.SH SYNOPSIS
.B "irqreturn_t" snd_vx_irq_handler
.BI "(int " irq ","
.BI "void *" dev ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "dev" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.TH "snd_vx_dsp_boot" 9 "snd_vx_dsp_boot" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_vx_dsp_boot \-  load the DSP boot
.SH SYNOPSIS
.B "int" snd_vx_dsp_boot
.BI "(vx_core_t *" chip ","
.BI "const struct firmware *" boot ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "boot" 12
-- undescribed --
.TH "snd_vx_dsp_load" 9 "snd_vx_dsp_load" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_vx_dsp_load \-  load the DSP image
.SH SYNOPSIS
.B "int" snd_vx_dsp_load
.BI "(vx_core_t *" chip ","
.BI "const struct firmware *" dsp ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "dsp" 12
-- undescribed --
.TH "snd_vx_create" 9 "snd_vx_create" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_vx_create \-  constructor for vx_core_t
.SH SYNOPSIS
.B "vx_core_t *" snd_vx_create
.BI "(snd_card_t *" card ","
.BI "struct snd_vx_hardware *" hw ","
.BI "struct snd_vx_ops *" ops ","
.BI "int " extra_size ");"
.SH ARGUMENTS
.IP "card" 12
-- undescribed --
.IP "hw" 12
 hardware specific record
.IP "ops" 12
-- undescribed --
.IP "extra_size" 12
-- undescribed --
.SH "DESCRIPTION"
this function allocates the instance and prepare for the hardware
initialization.

return the instance pointer if successful, NULL in error.
.TH "vx_set_pipe_cmd_params" 9 "vx_set_pipe_cmd_params" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx_set_pipe_cmd_params \-  fill first command word for pipe commands
.SH SYNOPSIS
.B "void" vx_set_pipe_cmd_params
.BI "(struct vx_rmh *" rmh ","
.BI "int " is_capture ","
.BI "int " param1 ","
.BI "int " param2 ");"
.SH ARGUMENTS
.IP "rmh" 12
 the rmh to be modified
.IP "is_capture" 12
 0 = playback, 1 = capture operation
.IP "param1" 12
 first pipe-parameter
.IP "param2" 12
 second pipe-parameter
.TH "vx_set_stream_cmd_params" 9 "vx_set_stream_cmd_params" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx_set_stream_cmd_params \-  fill first command word for stream commands
.SH SYNOPSIS
.B "void" vx_set_stream_cmd_params
.BI "(struct vx_rmh *" rmh ","
.BI "int " is_capture ","
.BI "int " pipe ");"
.SH ARGUMENTS
.IP "rmh" 12
 the rmh to be modified
.IP "is_capture" 12
 0 = playback, 1 = capture operation
.IP "pipe" 12
 the pipe index (zero-based)
.TH "vx_init_rmh" 9 "vx_init_rmh" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx_init_rmh \-  initialize the RMH instance
.SH SYNOPSIS
.B "void" vx_init_rmh
.BI "(struct vx_rmh *" rmh ","
.BI "unsigned int " cmd ");"
.SH ARGUMENTS
.IP "rmh" 12
 the rmh pointer to be initialized
.IP "cmd" 12
 the rmh command to be set
.TH "snd_mpu401_uart_interrupt" 9 "snd_mpu401_uart_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_mpu401_uart_interrupt \-  generic MPU401-UART interrupt handler
.SH SYNOPSIS
.B "irqreturn_t" snd_mpu401_uart_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
 the irq number
.IP "dev_id" 12
 mpu401 instance
.IP "regs" 12
 the reigster
.SH "DESCRIPTION"
Processes the interrupt for MPU401-UART i/o.
.TH "snd_mpu401_uart_new" 9 "snd_mpu401_uart_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_mpu401_uart_new \-  create an MPU401-UART instance
.SH SYNOPSIS
.B "int" snd_mpu401_uart_new
.BI "(snd_card_t *" card ","
.BI "int " device ","
.BI "unsigned short " hardware ","
.BI "unsigned long " port ","
.BI "int " integrated ","
.BI "int " irq ","
.BI "int " irq_flags ","
.BI "snd_rawmidi_t **" rrawmidi ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "device" 12
 the device index, zero-based
.IP "hardware" 12
 the hardware type, MPU401_HW_XXXX
.IP "port" 12
 the base address of MPU401 port
.IP "integrated" 12
 non-zero if the port was already reserved by the chip
.IP "irq" 12
 the irq number, -1 if no interrupt for mpu
.IP "irq_flags" 12
 the irq request flags (SA_XXX), 0 if irq was already reserved.
.IP "rrawmidi" 12
 the pointer to store the new rawmidi instance
.SH "DESCRIPTION"
Creates a new MPU-401 instance.

Note that the rawmidi instance is returned on the rrawmidi argument,
not the mpu401 instance itself.  To access to the mpu401 instance,
cast from rawmidi-&gt;private_data (with mpu401_t magic-cast).

Returns zero if successful, or a negative error code.
.TH "mod_firmware_load" 9 "mod_firmware_load" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mod_firmware_load \-  load sound driver firmware
.SH SYNOPSIS
.B "int" mod_firmware_load
.BI "(const char *" fn ","
.BI "char **" fp ");"
.SH ARGUMENTS
.IP "fn" 12
 filename
.IP "fp" 12
 return for the buffer.
.SH "DESCRIPTION"
Load the firmware for a sound module (up to 128K) into a buffer.
The buffer is returned in *fp. It is allocated with vmalloc so is
virtually linear and not DMAable. The caller should free it with
vfree when finished.

The length of the buffer is returned on a successful load, the
value zero on a failure.
.SH "CAUTION"
 This API is not recommended. Firmware should be loaded via
an ioctl call and a setup application. This function may disappear
in future.
.TH "vx2_inb" 9 "vx2_inb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx2_inb \-  read a byte from the register
.SH SYNOPSIS
.B "unsigned char" vx2_inb
.BI "(vx_core_t *" chip ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "offset" 12
 register enum
.TH "vx2_outb" 9 "vx2_outb" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx2_outb \-  write a byte on the register
.SH SYNOPSIS
.B "void" vx2_outb
.BI "(vx_core_t *" chip ","
.BI "int " offset ","
.BI "unsigned char " val ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "offset" 12
 the register offset
.IP "val" 12
 the value to write
.TH "vx2_inl" 9 "vx2_inl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx2_inl \-  read a 32bit word from the register
.SH SYNOPSIS
.B "unsigned int" vx2_inl
.BI "(vx_core_t *" chip ","
.BI "int " offset ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "offset" 12
 register enum
.TH "vx2_outl" 9 "vx2_outl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx2_outl \-  write a 32bit word on the register
.SH SYNOPSIS
.B "void" vx2_outl
.BI "(vx_core_t *" chip ","
.BI "int " offset ","
.BI "unsigned int " val ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "offset" 12
 the register enum
.IP "val" 12
 the value to write
.TH "vx2_setup_pseudo_dma" 9 "vx2_setup_pseudo_dma" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
vx2_setup_pseudo_dma \-  set up the pseudo dma read/write mode.
.SH SYNOPSIS
.B "void" vx2_setup_pseudo_dma
.BI "(vx_core_t *" chip ","
.BI "int " do_write ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "do_write" 12
 0 = read, 1 = set up for DMA write
.TH "snd_ac97_write" 9 "snd_ac97_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_write \-  write a value on the given register
.SH SYNOPSIS
.B "void" snd_ac97_write
.BI "(ac97_t *" ac97 ","
.BI "unsigned short " reg ","
.BI "unsigned short " value ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.IP "reg" 12
 the register to change
.IP "value" 12
 the value to set
.SH "DESCRIPTION"
Writes a value on the given register.  This will invoke the write
callback directly after the register check.
This function doesn't change the register cache unlike
#\fBsnd_ca97_write_cache\fP, so use this only when you don't want to
reflect the change to the suspend/resume state.
.TH "snd_ac97_read" 9 "snd_ac97_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_read \-  read a value from the given register
.SH SYNOPSIS
.B "unsigned short" snd_ac97_read
.BI "(ac97_t *" ac97 ","
.BI "unsigned short " reg ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.IP "reg" 12
 the register to read
.SH "DESCRIPTION"
Reads a value from the given register.  This will invoke the read
callback directly after the register check.

Returns the read value.
.SH "DESCRIPTION"
Reads a value from the given register.  This will invoke the read
callback directly after the register check.

Returns the read value.
.TH "snd_ac97_write_cache" 9 "snd_ac97_write_cache" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_write_cache \-  write a value on the given register and update the cache
.SH SYNOPSIS
.B "void" snd_ac97_write_cache
.BI "(ac97_t *" ac97 ","
.BI "unsigned short " reg ","
.BI "unsigned short " value ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.IP "reg" 12
 the register to change
.IP "value" 12
 the value to set
.SH "DESCRIPTION"
Writes a value on the given register and updates the register
cache.  The cached values are used for the cached-read and the
suspend/resume.
.TH "snd_ac97_update" 9 "snd_ac97_update" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_update \-  update the value on the given register
.SH SYNOPSIS
.B "int" snd_ac97_update
.BI "(ac97_t *" ac97 ","
.BI "unsigned short " reg ","
.BI "unsigned short " value ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.IP "reg" 12
 the register to change
.IP "value" 12
 the value to set
.SH "DESCRIPTION"
Compares the value with the register cache and updates the value
only when the value is changed.

Returns 1 if the value is changed, 0 if no change, or a negative
code on failure.
.TH "snd_ac97_update_bits" 9 "snd_ac97_update_bits" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_update_bits \-  update the bits on the given register
.SH SYNOPSIS
.B "int" snd_ac97_update_bits
.BI "(ac97_t *" ac97 ","
.BI "unsigned short " reg ","
.BI "unsigned short " mask ","
.BI "unsigned short " value ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.IP "reg" 12
 the register to change
.IP "mask" 12
 the bit-mask to change
.IP "value" 12
 the value to set
.SH "DESCRIPTION"
Updates the masked-bits on the given register only when the value
is changed.

Returns 1 if the bits are changed, 0 if no change, or a negative
code on failure.
.TH "snd_ac97_get_short_name" 9 "snd_ac97_get_short_name" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_get_short_name \-  retrieve codec name
.SH SYNOPSIS
.B "const char *" snd_ac97_get_short_name
.BI "(ac97_t *" ac97 ");"
.SH ARGUMENTS
.IP "ac97" 12
 the codec instance
.SH "DESCRIPTION"
Returns the short identifying name of the codec.
.TH "snd_ac97_bus" 9 "snd_ac97_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_bus \-  create an AC97 bus component
.SH SYNOPSIS
.B "int" snd_ac97_bus
.BI "(snd_card_t *" card ","
.BI "int " num ","
.BI "ac97_bus_ops_t *" ops ","
.BI "void *" private_data ","
.BI "ac97_bus_t **" rbus ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "num" 12
 the bus number
.IP "ops" 12
 the bus callbacks table
.IP "private_data" 12
 private data pointer for the new instance
.IP "rbus" 12
 the pointer to store the new AC97 bus instance.
.SH "DESCRIPTION"
Creates an AC97 bus component.  An ac97_bus_t instance is newly
allocated and initialized.

The ops table must include valid callbacks (at least read and
write).  The other callbacks, wait and reset, are not mandatory.

The clock is set to 48000.  If another clock is needed, set
(*rbus)-&gt;clock manually.

The AC97 bus instance is registered as a low-level device, so you don't
have to release it manually.

Returns zero if successful, or a negative error code on failure.
.TH "snd_ac97_mixer" 9 "snd_ac97_mixer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_mixer \-  create an Codec97 component
.SH SYNOPSIS
.B "int" snd_ac97_mixer
.BI "(ac97_bus_t *" bus ","
.BI "ac97_template_t *" template ","
.BI "ac97_t **" rac97 ");"
.SH ARGUMENTS
.IP "bus" 12
 the AC97 bus which codec is attached to
.IP "template" 12
 the template of ac97, including index, callbacks and
the private data.
.IP "rac97" 12
 the pointer to store the new ac97 instance.
.SH "DESCRIPTION"
Creates an Codec97 component.  An ac97_t instance is newly
allocated and initialized from the template.  The codec
is then initialized by the standard procedure.

The template must include the codec number (num) and address (addr),
and the private data (private_data).

The ac97 instance is registered as a low-level device, so you don't
have to release it manually.

Returns zero if successful, or a negative error code on failure.
.TH "snd_ac97_suspend" 9 "snd_ac97_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_suspend \-  General suspend function for AC97 codec
.SH SYNOPSIS
.B "void" snd_ac97_suspend
.BI "(ac97_t *" ac97 ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.SH "DESCRIPTION"
Suspends the codec, power down the chip.
.TH "snd_ac97_resume" 9 "snd_ac97_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_resume \-  General resume function for AC97 codec
.SH SYNOPSIS
.B "void" snd_ac97_resume
.BI "(ac97_t *" ac97 ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.SH "DESCRIPTION"
Do the standard resume procedure, power up and restoring the
old register values.
.TH "snd_ac97_tune_hardware" 9 "snd_ac97_tune_hardware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_tune_hardware \-  tune up the hardware
.SH SYNOPSIS
.B "int" snd_ac97_tune_hardware
.BI "(ac97_t *" ac97 ","
.BI "struct ac97_quirk *" quirk ","
.BI "const char *" override ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.IP "quirk" 12
 quirk list
.IP "override" 12
 explicit quirk value (overrides the list if non-NULL)
.SH "DESCRIPTION"
Do some workaround for each pci device, such as renaming of the
headphone (true line-out) control as "Master".
The quirk-list must be terminated with a zero-filled entry.

Returns zero if successful, or a negative error code on failure.
.TH "snd_ac97_set_rate" 9 "snd_ac97_set_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_set_rate \-  change the rate of the given input/output.
.SH SYNOPSIS
.B "int" snd_ac97_set_rate
.BI "(ac97_t *" ac97 ","
.BI "int " reg ","
.BI "unsigned int " rate ");"
.SH ARGUMENTS
.IP "ac97" 12
 the ac97 instance
.IP "reg" 12
 the register to change
.IP "rate" 12
 the sample rate to set
.SH "DESCRIPTION"
Changes the rate of the given input/output on the codec.
If the codec doesn't support VAR, the rate must be 48000 (except
for SPDIF).

The valid registers are AC97_PMC_MIC_ADC_RATE,
AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE.
AC97_PCM_SURR_DAC_RATE and AC97_PCM_LFE_DAC_RATE are accepted
if the codec supports them.
AC97_SPDIF is accepted as a pseudo register to modify the SPDIF
status bits.

Returns zero if successful, or a negative error code on failure.
.TH "snd_ac97_pcm_assign" 9 "snd_ac97_pcm_assign" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_pcm_assign \-  assign AC97 slots to given PCM streams
.SH SYNOPSIS
.B "int" snd_ac97_pcm_assign
.BI "(ac97_bus_t *" bus ","
.BI "unsigned short " pcms_count ","
.BI "const struct ac97_pcm *" pcms ");"
.SH ARGUMENTS
.IP "bus" 12
 the ac97 bus instance
.IP "pcms_count" 12
 count of PCMs to be assigned
.IP "pcms" 12
 PCMs to be assigned
.SH "DESCRIPTION"
It assigns available AC97 slots for given PCMs. If none or only
some slots are available, pcm-&gt;xxx.slots and pcm-&gt;xxx.rslots[] members
are reduced and might be zero.
.TH "snd_ac97_pcm_open" 9 "snd_ac97_pcm_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_pcm_open \-  opens the given AC97 pcm
.SH SYNOPSIS
.B "int" snd_ac97_pcm_open
.BI "(struct ac97_pcm *" pcm ","
.BI "unsigned int " rate ","
.BI "enum ac97_pcm_cfg " cfg ","
.BI "unsigned short " slots ");"
.SH ARGUMENTS
.IP "pcm" 12
 the ac97 pcm instance
.IP "rate" 12
 rate in Hz, if codec does not support VRA, this value must be 48000Hz
.IP "cfg" 12
 output stream characteristics
.IP "slots" 12
 a subset of allocated slots (snd_ac97_pcm_assign) for this pcm
.SH "DESCRIPTION"
It locks the specified slots and sets the given rate to AC97 registers.
.TH "snd_ac97_pcm_close" 9 "snd_ac97_pcm_close" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_pcm_close \-  closes the given AC97 pcm
.SH SYNOPSIS
.B "int" snd_ac97_pcm_close
.BI "(struct ac97_pcm *" pcm ");"
.SH ARGUMENTS
.IP "pcm" 12
 the ac97 pcm instance
.SH "DESCRIPTION"
It frees the locked AC97 slots.
.TH "snd_ac97_pcm_double_rate_rules" 9 "snd_ac97_pcm_double_rate_rules" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ac97_pcm_double_rate_rules \-  set double rate constraints
.SH SYNOPSIS
.B "int" snd_ac97_pcm_double_rate_rules
.BI "(snd_pcm_runtime_t *" runtime ");"
.SH ARGUMENTS
.IP "runtime" 12
 the runtime of the ac97 front playback pcm
.SH "DESCRIPTION"
Installs the hardware constraint rules to prevent using double rates and
more than two channels at the same time.
.TH "mixart_wait_nice_for_register_value" 9 "mixart_wait_nice_for_register_value" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
mixart_wait_nice_for_register_value \- 
.SH SYNOPSIS
.B "int" mixart_wait_nice_for_register_value
.BI "(mixart_mgr_t *" mgr ","
.BI "u32 " offset ","
.BI "int " is_egal ","
.BI "u32 " value ","
.BI "unsigned long " timeout ");"
.SH ARGUMENTS
.IP "mgr" 12
-- undescribed --
.IP "offset" 12
-- undescribed --
.IP "is_egal" 12
-- undescribed --
.IP "value" 12
-- undescribed --
.IP "timeout" 12
-- undescribed --
.SH "DESCRIPTION"

\fIparam\fP mgr pointer to miXart manager structure
\fIparam\fP offset unsigned pseudo_register base + offset of value
\fIparam\fP value value
\fIparam\fP timeout timeout in centisenconds
.TH "snd_hda_codec_read" 9 "snd_hda_codec_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_codec_read \-  send a command and get the response
.SH SYNOPSIS
.B "unsigned int" snd_hda_codec_read
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ","
.BI "int " direct ","
.BI "unsigned int " verb ","
.BI "unsigned int " parm ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "nid" 12
 NID to send the command
.IP "direct" 12
 direct flag
.IP "verb" 12
 the verb to send
.IP "parm" 12
 the parameter for the verb
.SH "DESCRIPTION"
Send a single command and read the corresponding response.

Returns the obtained response value, or -1 for an error.
.TH "snd_hda_codec_write" 9 "snd_hda_codec_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_codec_write \-  send a single command without waiting for response
.SH SYNOPSIS
.B "int" snd_hda_codec_write
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ","
.BI "int " direct ","
.BI "unsigned int " verb ","
.BI "unsigned int " parm ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "nid" 12
 NID to send the command
.IP "direct" 12
 direct flag
.IP "verb" 12
 the verb to send
.IP "parm" 12
 the parameter for the verb
.SH "DESCRIPTION"
Send a single command without waiting for response.

Returns 0 if successful, or a negative error code.
.TH "snd_hda_sequence_write" 9 "snd_hda_sequence_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_sequence_write \-  sequence writes
.SH SYNOPSIS
.B "void" snd_hda_sequence_write
.BI "(struct hda_codec *" codec ","
.BI "const struct hda_verb *" seq ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "seq" 12
 VERB array to send
.SH "DESCRIPTION"
Send the commands sequentially from the given array.
The array must be terminated with NID=0.
.TH "snd_hda_get_sub_nodes" 9 "snd_hda_get_sub_nodes" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_get_sub_nodes \-  get the range of sub nodes
.SH SYNOPSIS
.B "int" snd_hda_get_sub_nodes
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ","
.BI "hda_nid_t *" start_id ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "nid" 12
 NID to parse
.IP "start_id" 12
 the pointer to store the start NID
.SH "DESCRIPTION"
Parse the NID and store the start NID of its sub-nodes.
Returns the number of sub-nodes.
.TH "snd_hda_get_connections" 9 "snd_hda_get_connections" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_get_connections \-  get connection list
.SH SYNOPSIS
.B "int" snd_hda_get_connections
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ","
.BI "hda_nid_t *" conn_list ","
.BI "int " max_conns ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "nid" 12
 NID to parse
.IP "conn_list" 12
 connection list array
.IP "max_conns" 12
 max. number of connections to store
.SH "DESCRIPTION"
Parses the connection list of the given widget and stores the list
of NIDs.

Returns the number of connections, or a negative error code.
.TH "snd_hda_queue_unsol_event" 9 "snd_hda_queue_unsol_event" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_queue_unsol_event \-  add an unsolicited event to queue
.SH SYNOPSIS
.B "int" snd_hda_queue_unsol_event
.BI "(struct hda_bus *" bus ","
.BI "u32 " res ","
.BI "u32 " res_ex ");"
.SH ARGUMENTS
.IP "bus" 12
 the BUS
.IP "res" 12
 unsolicited event (lower 32bit of RIRB entry)
.IP "res_ex" 12
 codec addr and flags (upper 32bit or RIRB entry)
.SH "DESCRIPTION"
Adds the given event to the queue.  The events are processed in
the workqueue asynchronously.  Call this function in the interrupt
hanlder when RIRB receives an unsolicited event.

Returns 0 if successful, or a negative error code.
.TH "snd_hda_bus_new" 9 "snd_hda_bus_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_bus_new \-  create a HDA bus
.SH SYNOPSIS
.B "int" snd_hda_bus_new
.BI "(snd_card_t *" card ","
.BI "const struct hda_bus_template *" temp ","
.BI "struct hda_bus **" busp ");"
.SH ARGUMENTS
.IP "card" 12
 the card entry
.IP "temp" 12
 the template for hda_bus information
.IP "busp" 12
 the pointer to store the created bus instance
.SH "DESCRIPTION"
Returns 0 if successful, or a negative error code.
.TH "snd_hda_codec_new" 9 "snd_hda_codec_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_codec_new \-  create a HDA codec
.SH SYNOPSIS
.B "int" snd_hda_codec_new
.BI "(struct hda_bus *" bus ","
.BI "unsigned int " codec_addr ","
.BI "struct hda_codec **" codecp ");"
.SH ARGUMENTS
.IP "bus" 12
 the bus to assign
.IP "codec_addr" 12
 the codec address
.IP "codecp" 12
 the pointer to store the generated codec
.SH "DESCRIPTION"
Returns 0 if successful, or a negative error code.
.TH "snd_hda_codec_setup_stream" 9 "snd_hda_codec_setup_stream" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_codec_setup_stream \-  set up the codec for streaming
.SH SYNOPSIS
.B "void" snd_hda_codec_setup_stream
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ","
.BI "u32 " stream_tag ","
.BI "int " channel_id ","
.BI "int " format ");"
.SH ARGUMENTS
.IP "codec" 12
 the CODEC to set up
.IP "nid" 12
 the NID to set up
.IP "stream_tag" 12
 stream tag to pass, it's between 0x1 and 0xf.
.IP "channel_id" 12
 channel id to pass, zero based.
.IP "format" 12
 stream format.
.TH "snd_hda_create_spdif_out_ctls" 9 "snd_hda_create_spdif_out_ctls" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_create_spdif_out_ctls \-  create Output SPDIF-related controls
.SH SYNOPSIS
.B "int" snd_hda_create_spdif_out_ctls
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "nid" 12
 audio out widget NID
.SH "DESCRIPTION"
Creates controls related with the SPDIF output.
Called from each patch supporting the SPDIF out.

Returns 0 if successful, or a negative error code.
.TH "snd_hda_create_spdif_in_ctls" 9 "snd_hda_create_spdif_in_ctls" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_create_spdif_in_ctls \-  create Input SPDIF-related controls
.SH SYNOPSIS
.B "int" snd_hda_create_spdif_in_ctls
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "nid" 12
 audio in widget NID
.SH "DESCRIPTION"
Creates controls related with the SPDIF input.
Called from each patch supporting the SPDIF in.

Returns 0 if successful, or a negative error code.
.TH "snd_hda_build_controls" 9 "snd_hda_build_controls" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_build_controls \-  build mixer controls
.SH SYNOPSIS
.B "int" snd_hda_build_controls
.BI "(struct hda_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 the BUS
.SH "DESCRIPTION"
Creates mixer controls for each codec included in the bus.

Returns 0 if successful, otherwise a negative error code.
.TH "snd_hda_calc_stream_format" 9 "snd_hda_calc_stream_format" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_calc_stream_format \-  calculate format bitset
.SH SYNOPSIS
.B "unsigned int" snd_hda_calc_stream_format
.BI "(unsigned int " rate ","
.BI "unsigned int " channels ","
.BI "unsigned int " format ","
.BI "unsigned int " maxbps ");"
.SH ARGUMENTS
.IP "rate" 12
 the sample rate
.IP "channels" 12
 the number of channels
.IP "format" 12
 the PCM format (SNDRV_PCM_FORMAT_XXX)
.IP "maxbps" 12
 the max. bps
.SH "DESCRIPTION"
Calculate the format bitset from the given rate, channels and th PCM format.

Return zero if invalid.
.TH "snd_hda_query_supported_pcm" 9 "snd_hda_query_supported_pcm" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_query_supported_pcm \-  query the supported PCM rates and formats
.SH SYNOPSIS
.B "int" snd_hda_query_supported_pcm
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ","
.BI "u32 *" ratesp ","
.BI "u64 *" formatsp ","
.BI "unsigned int *" bpsp ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "nid" 12
 NID to query
.IP "ratesp" 12
 the pointer to store the detected rate bitflags
.IP "formatsp" 12
 the pointer to store the detected formats
.IP "bpsp" 12
 the pointer to store the detected format widths
.SH "DESCRIPTION"
Queries the supported PCM rates and formats.  The NULL \fIratesp\fP, \fIformatsp\fP
or \fIbsps\fP argument is ignored.

Returns 0 if successful, otherwise a negative error code.
.TH "snd_hda_is_supported_format" 9 "snd_hda_is_supported_format" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_is_supported_format \-  check whether the given node supports the format val
.SH SYNOPSIS
.B "int" snd_hda_is_supported_format
.BI "(struct hda_codec *" codec ","
.BI "hda_nid_t " nid ","
.BI "unsigned int " format ");"
.SH ARGUMENTS
.IP "codec" 12
-- undescribed --
.IP "nid" 12
-- undescribed --
.IP "format" 12
-- undescribed --
.SH "DESCRIPTION"

Returns 1 if supported, 0 if not.
.TH "snd_hda_build_pcms" 9 "snd_hda_build_pcms" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_build_pcms \-  build PCM information
.SH SYNOPSIS
.B "int" snd_hda_build_pcms
.BI "(struct hda_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 the BUS
.SH "DESCRIPTION"
Create PCM information for each codec included in the bus.

The build_pcms codec patch is requested to set up codec-&gt;num_pcms and
codec-&gt;pcm_info properly.  The array is referred by the top-level driver
to create its PCM instances.
The allocated codec-&gt;pcm_info should be released in codec-&gt;patch_ops.free
callback.

At least, substreams, channels_min and channels_max must be filled for
each stream.  substreams = 0 indicates that the stream doesn't exist.
When rates and/or formats are zero, the supported values are queried
from the given nid.  The nid is used also by the default ops.prepare
and ops.cleanup callbacks.

The driver needs to call ops.open in its open callback.  Similarly,
ops.close is supposed to be called in the close callback.
ops.prepare should be called in the prepare or hw_params callback
with the proper parameters for set up.
ops.cleanup should be called in hw_free for clean up of streams.

This function returns 0 if successfull, or a negative error code.
.TH "snd_hda_check_board_config" 9 "snd_hda_check_board_config" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_check_board_config \-  compare the current codec with the config table
.SH SYNOPSIS
.B "int" snd_hda_check_board_config
.BI "(struct hda_codec *" codec ","
.BI "const struct hda_board_config *" tbl ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "tbl" 12
 configuration table, terminated by null entries
.SH "DESCRIPTION"
Compares the modelname or PCI subsystem id of the current codec with the
given configuration table.  If a matching entry is found, returns its
config value (supposed to be 0 or positive).

If no entries are matching, the function returns a negative value.
.TH "snd_hda_add_new_ctls" 9 "snd_hda_add_new_ctls" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_add_new_ctls \-  create controls from the array
.SH SYNOPSIS
.B "int" snd_hda_add_new_ctls
.BI "(struct hda_codec *" codec ","
.BI "snd_kcontrol_new_t *" knew ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "knew" 12
 the array of snd_kcontrol_new_t
.SH "DESCRIPTION"
This helper function creates and add new controls in the given array.
The array must be terminated with an empty entry as terminator.

Returns 0 if successful, or a negative error code.
.TH "snd_hda_suspend" 9 "snd_hda_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_suspend \-  suspend the codecs
.SH SYNOPSIS
.B "int" snd_hda_suspend
.BI "(struct hda_bus *" bus ","
.BI "pm_message_t " state ");"
.SH ARGUMENTS
.IP "bus" 12
 the HDA bus
.IP "state" 12
 suspsend state
.SH "DESCRIPTION"
Returns 0 if successful.
.TH "snd_hda_resume" 9 "snd_hda_resume" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_resume \-  resume the codecs
.SH SYNOPSIS
.B "int" snd_hda_resume
.BI "(struct hda_bus *" bus ");"
.SH ARGUMENTS
.IP "bus" 12
 the HDA bus
.SH "DESCRIPTION"
Returns 0 if successful.
.TH "snd_hda_resume_ctls" 9 "snd_hda_resume_ctls" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_resume_ctls \-  resume controls in the new control list
.SH SYNOPSIS
.B "int" snd_hda_resume_ctls
.BI "(struct hda_codec *" codec ","
.BI "snd_kcontrol_new_t *" knew ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.IP "knew" 12
 the array of snd_kcontrol_new_t
.SH "DESCRIPTION"
This function resumes the mixer controls in the snd_kcontrol_new_t array,
originally for \fBsnd_hda_add_new_ctls\fP.
The array must be terminated with an empty entry as terminator.
.TH "snd_hda_resume_spdif_out" 9 "snd_hda_resume_spdif_out" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_resume_spdif_out \-  resume the digital out
.SH SYNOPSIS
.B "int" snd_hda_resume_spdif_out
.BI "(struct hda_codec *" codec ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.TH "snd_hda_resume_spdif_in" 9 "snd_hda_resume_spdif_in" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hda_resume_spdif_in \-  resume the digital in
.SH SYNOPSIS
.B "int" snd_hda_resume_spdif_in
.BI "(struct hda_codec *" codec ");"
.SH ARGUMENTS
.IP "codec" 12
 the HDA codec
.TH "snd_pcm_format_signed" 9 "snd_pcm_format_signed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_signed \-  Check the PCM format is signed linear
.SH SYNOPSIS
.B "int" snd_pcm_format_signed
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns 1 if the given PCM format is signed linear, 0 if unsigned
linear, and a negative error code for non-linear formats.
.TH "snd_pcm_format_unsigned" 9 "snd_pcm_format_unsigned" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_unsigned \-  Check the PCM format is unsigned linear
.SH SYNOPSIS
.B "int" snd_pcm_format_unsigned
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns 1 if the given PCM format is unsigned linear, 0 if signed
linear, and a negative error code for non-linear formats.
.TH "snd_pcm_format_linear" 9 "snd_pcm_format_linear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_linear \-  Check the PCM format is linear
.SH SYNOPSIS
.B "int" snd_pcm_format_linear
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns 1 if the given PCM format is linear, 0 if not.
.TH "snd_pcm_format_little_endian" 9 "snd_pcm_format_little_endian" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_little_endian \-  Check the PCM format is little-endian
.SH SYNOPSIS
.B "int" snd_pcm_format_little_endian
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns 1 if the given PCM format is little-endian, 0 if
big-endian, or a negative error code if endian not specified.
.TH "snd_pcm_format_big_endian" 9 "snd_pcm_format_big_endian" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_big_endian \-  Check the PCM format is big-endian
.SH SYNOPSIS
.B "int" snd_pcm_format_big_endian
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns 1 if the given PCM format is big-endian, 0 if
little-endian, or a negative error code if endian not specified.
.TH "snd_pcm_format_width" 9 "snd_pcm_format_width" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_width \-  return the bit-width of the format
.SH SYNOPSIS
.B "int" snd_pcm_format_width
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns the bit-width of the format, or a negative error code
if unknown format.
.TH "snd_pcm_format_physical_width" 9 "snd_pcm_format_physical_width" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_physical_width \-  return the physical bit-width of the format
.SH SYNOPSIS
.B "int" snd_pcm_format_physical_width
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns the physical bit-width of the format, or a negative error code
if unknown format.
.TH "snd_pcm_format_size" 9 "snd_pcm_format_size" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_size \-  return the byte size of samples on the given format
.SH SYNOPSIS
.B "ssize_t" snd_pcm_format_size
.BI "(snd_pcm_format_t " format ","
.BI "size_t " samples ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.IP "samples" 12
-- undescribed --
.SH "DESCRIPTION"
Returns the byte size of the given samples for the format, or a
negative error code if unknown format.
.TH "snd_pcm_format_silence_64" 9 "snd_pcm_format_silence_64" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_silence_64 \-  return the silent data in 8 bytes array
.SH SYNOPSIS
.B "const unsigned char *" snd_pcm_format_silence_64
.BI "(snd_pcm_format_t " format ");"
.SH ARGUMENTS
.IP "format" 12
 the format to check
.SH "DESCRIPTION"
Returns the format pattern to fill or NULL if error.
.TH "snd_pcm_format_set_silence" 9 "snd_pcm_format_set_silence" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_format_set_silence \-  set the silence data on the buffer
.SH SYNOPSIS
.B "int" snd_pcm_format_set_silence
.BI "(snd_pcm_format_t " format ","
.BI "void *" data ","
.BI "unsigned int " samples ");"
.SH ARGUMENTS
.IP "format" 12
 the PCM format
.IP "data" 12
 the buffer pointer
.IP "samples" 12
 the number of samples to set silence
.SH "DESCRIPTION"
Sets the silence data on the buffer for the given samples.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_build_linear_format" 9 "snd_pcm_build_linear_format" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_build_linear_format \-  return the suitable linear format for the given condition
.SH SYNOPSIS
.B "snd_pcm_format_t" snd_pcm_build_linear_format
.BI "(int " width ","
.BI "int " unsignd ","
.BI "int " big_endian ");"
.SH ARGUMENTS
.IP "width" 12
 the bit-width
.IP "unsignd" 12
 1 if unsigned, 0 if signed.
.IP "big_endian" 12
 1 if big-endian, 0 if little-endian
.SH "DESCRIPTION"
Returns the suitable linear format for the given condition.
.TH "snd_pcm_limit_hw_rates" 9 "snd_pcm_limit_hw_rates" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_limit_hw_rates \-  determine rate_min/rate_max fields
.SH SYNOPSIS
.B "int" snd_pcm_limit_hw_rates
.BI "(snd_pcm_runtime_t *" runtime ");"
.SH ARGUMENTS
.IP "runtime" 12
 the runtime instance
.SH "DESCRIPTION"
Determines the rate_min and rate_max fields from the rates bits of
the given runtime-&gt;hw.

Returns zero if successful.
.TH "snd_pcm_new_stream" 9 "snd_pcm_new_stream" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_new_stream \-  create a new PCM stream
.SH SYNOPSIS
.B "int" snd_pcm_new_stream
.BI "(snd_pcm_t *" pcm ","
.BI "int " stream ","
.BI "int " substream_count ");"
.SH ARGUMENTS
.IP "pcm" 12
 the pcm instance
.IP "stream" 12
 the stream direction, SNDRV_PCM_STREAM_XXX
.IP "substream_count" 12
 the number of substreams
.SH "DESCRIPTION"
Creates a new stream for the pcm.
The corresponding stream on the pcm must have been empty before
calling this, i.e. zero must be given to the argument of
\fBsnd_pcm_new\fP.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_new" 9 "snd_pcm_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_new \-  create a new PCM instance
.SH SYNOPSIS
.B "int" snd_pcm_new
.BI "(snd_card_t *" card ","
.BI "char *" id ","
.BI "int " device ","
.BI "int " playback_count ","
.BI "int " capture_count ","
.BI "snd_pcm_t **" rpcm ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "id" 12
 the id string
.IP "device" 12
 the device index (zero based)
.IP "playback_count" 12
 the number of substreams for playback
.IP "capture_count" 12
 the number of substreams for capture
.IP "rpcm" 12
 the pointer to store the new pcm instance
.SH "DESCRIPTION"
Creates a new PCM instance.

The pcm operators have to be set afterwards to the new instance
via \fBsnd_pcm_set_ops\fP.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_set_ops" 9 "snd_pcm_set_ops" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_set_ops \-  set the PCM operators
.SH SYNOPSIS
.B "void" snd_pcm_set_ops
.BI "(snd_pcm_t *" pcm ","
.BI "int " direction ","
.BI "snd_pcm_ops_t *" ops ");"
.SH ARGUMENTS
.IP "pcm" 12
 the pcm instance
.IP "direction" 12
 stream direction, SNDRV_PCM_STREAM_XXX
.IP "ops" 12
 the operator table
.SH "DESCRIPTION"
Sets the given PCM operators to the pcm instance.
.TH "snd_pcm_set_sync" 9 "snd_pcm_set_sync" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_set_sync \-  set the PCM sync id
.SH SYNOPSIS
.B "void" snd_pcm_set_sync
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream
.SH "DESCRIPTION"
Sets the PCM sync identifier for the card.
.TH "snd_interval_refine" 9 "snd_interval_refine" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_interval_refine \-  refine the interval value of configurator
.SH SYNOPSIS
.B "int" snd_interval_refine
.BI "(snd_interval_t *" i ","
.BI "const snd_interval_t *" v ");"
.SH ARGUMENTS
.IP "i" 12
 the interval value to refine
.IP "v" 12
 the interval value to refer to
.SH "DESCRIPTION"
Refines the interval value with the reference value.
The interval is changed to the range satisfying both intervals.
The interval status (min, max, integer, etc.) are evaluated.

Returns non-zero if the value is changed, zero if not changed.
.TH "snd_interval_div" 9 "snd_interval_div" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_interval_div \-  refine the interval value with division
.SH SYNOPSIS
.B "void" snd_interval_div
.BI "(const snd_interval_t *" a ","
.BI "const snd_interval_t *" b ","
.BI "snd_interval_t *" c ");"
.SH ARGUMENTS
.IP "a" 12
 dividend
.IP "b" 12
 divisor
.IP "c" 12
 quotient
.SH "DESCRIPTION"
c = a / b

Returns non-zero if the value is changed, zero if not changed.
.TH "snd_interval_muldivk" 9 "snd_interval_muldivk" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_interval_muldivk \-  refine the interval value
.SH SYNOPSIS
.B "void" snd_interval_muldivk
.BI "(const snd_interval_t *" a ","
.BI "const snd_interval_t *" b ","
.BI "unsigned int " k ","
.BI "snd_interval_t *" c ");"
.SH ARGUMENTS
.IP "a" 12
 dividend 1
.IP "b" 12
 dividend 2
.IP "k" 12
 divisor (as integer)
.IP "c" 12
 result
.SH "DESCRIPTION"
c = a * b / k

Returns non-zero if the value is changed, zero if not changed.
.TH "snd_interval_mulkdiv" 9 "snd_interval_mulkdiv" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_interval_mulkdiv \-  refine the interval value
.SH SYNOPSIS
.B "void" snd_interval_mulkdiv
.BI "(const snd_interval_t *" a ","
.BI "unsigned int " k ","
.BI "const snd_interval_t *" b ","
.BI "snd_interval_t *" c ");"
.SH ARGUMENTS
.IP "a" 12
 dividend 1
.IP "k" 12
 dividend 2 (as integer)
.IP "b" 12
 divisor
.IP "c" 12
 result
.SH "DESCRIPTION"
c = a * k / b

Returns non-zero if the value is changed, zero if not changed.
.TH "snd_interval_ratnum" 9 "snd_interval_ratnum" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_interval_ratnum \-  refine the interval value
.SH SYNOPSIS
.B "int" snd_interval_ratnum
.BI "(snd_interval_t *" i ","
.BI "unsigned int " rats_count ","
.BI "ratnum_t *" rats ","
.BI "unsigned int *" nump ","
.BI "unsigned int *" denp ");"
.SH ARGUMENTS
.IP "i" 12
 interval to refine
.IP "rats_count" 12
 number of ratnum_t 
.IP "rats" 12
 ratnum_t array
.IP "nump" 12
 pointer to store the resultant numerator
.IP "denp" 12
 pointer to store the resultant denominator
.SH "DESCRIPTION"
Returns non-zero if the value is changed, zero if not changed.
.TH "snd_interval_ratden" 9 "snd_interval_ratden" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_interval_ratden \-  refine the interval value
.SH SYNOPSIS
.B "int" snd_interval_ratden
.BI "(snd_interval_t *" i ","
.BI "unsigned int " rats_count ","
.BI "ratden_t *" rats ","
.BI "unsigned int *" nump ","
.BI "unsigned int *" denp ");"
.SH ARGUMENTS
.IP "i" 12
 interval to refine
.IP "rats_count" 12
 number of ratden_t
.IP "rats" 12
 ratden_t array
.IP "nump" 12
 pointer to store the resultant numerator
.IP "denp" 12
 pointer to store the resultant denominator
.SH "DESCRIPTION"
Returns non-zero if the value is changed, zero if not changed.
.TH "snd_interval_list" 9 "snd_interval_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_interval_list \-  refine the interval value from the list
.SH SYNOPSIS
.B "int" snd_interval_list
.BI "(snd_interval_t *" i ","
.BI "unsigned int " count ","
.BI "unsigned int *" list ","
.BI "unsigned int " mask ");"
.SH ARGUMENTS
.IP "i" 12
 the interval value to refine
.IP "count" 12
 the number of elements in the list
.IP "list" 12
 the value list
.IP "mask" 12
 the bit-mask to evaluate
.SH "DESCRIPTION"
Refines the interval value from the list.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.

Returns non-zero if the value is changed, zero if not changed.
.TH "snd_pcm_hw_rule_add" 9 "snd_pcm_hw_rule_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_rule_add \-  add the hw-constraint rule
.SH SYNOPSIS
.B "int" snd_pcm_hw_rule_add
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "unsigned int " cond ","
.BI "int " var ","
.BI "snd_pcm_hw_rule_func_t " func ","
.BI "void *" private ","
.BI "int " dep ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "runtime" 12
 the pcm runtime instance
.IP "cond" 12
 condition bits
.IP "var" 12
 the variable to evaluate
.IP "func" 12
 the evaluation function
.IP "private" 12
 the private data pointer passed to function
.IP "dep" 12
 the dependent variables
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_hw_constraint_mask" 9 "snd_pcm_hw_constraint_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_mask \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_mask
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "snd_pcm_hw_param_t " var ","
.BI "u_int32_t " mask ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "var" 12
 hw_params variable to apply the mask
.IP "mask" 12
 the bitmap mask
.SH "DESCRIPTION"
Apply the constraint of the given bitmap mask to a mask parameter.
.TH "snd_pcm_hw_constraint_mask64" 9 "snd_pcm_hw_constraint_mask64" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_mask64 \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_mask64
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "snd_pcm_hw_param_t " var ","
.BI "u_int64_t " mask ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "var" 12
 hw_params variable to apply the mask
.IP "mask" 12
 the 64bit bitmap mask
.SH "DESCRIPTION"
Apply the constraint of the given bitmap mask to a mask parameter.
.TH "snd_pcm_hw_constraint_integer" 9 "snd_pcm_hw_constraint_integer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_integer \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_integer
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "snd_pcm_hw_param_t " var ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "var" 12
 hw_params variable to apply the integer constraint
.SH "DESCRIPTION"
Apply the constraint of integer to an interval parameter.
.TH "snd_pcm_hw_constraint_minmax" 9 "snd_pcm_hw_constraint_minmax" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_minmax \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_minmax
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "snd_pcm_hw_param_t " var ","
.BI "unsigned int " min ","
.BI "unsigned int " max ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "var" 12
 hw_params variable to apply the range
.IP "min" 12
 the minimal value
.IP "max" 12
 the maximal value
.SH "DESCRIPTION"
Apply the min/max range constraint to an interval parameter.
.TH "snd_pcm_hw_constraint_list" 9 "snd_pcm_hw_constraint_list" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_list \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_list
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "unsigned int " cond ","
.BI "snd_pcm_hw_param_t " var ","
.BI "snd_pcm_hw_constraint_list_t *" l ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "cond" 12
 condition bits
.IP "var" 12
 hw_params variable to apply the list constraint
.IP "l" 12
 list
.SH "DESCRIPTION"
Apply the list of constraints to an interval parameter.
.TH "snd_pcm_hw_constraint_ratnums" 9 "snd_pcm_hw_constraint_ratnums" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_ratnums \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_ratnums
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "unsigned int " cond ","
.BI "snd_pcm_hw_param_t " var ","
.BI "snd_pcm_hw_constraint_ratnums_t *" r ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "cond" 12
 condition bits
.IP "var" 12
 hw_params variable to apply the ratnums constraint
.IP "r" 12
 ratnums_t constriants
.TH "snd_pcm_hw_constraint_ratdens" 9 "snd_pcm_hw_constraint_ratdens" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_ratdens \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_ratdens
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "unsigned int " cond ","
.BI "snd_pcm_hw_param_t " var ","
.BI "snd_pcm_hw_constraint_ratdens_t *" r ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "cond" 12
 condition bits
.IP "var" 12
 hw_params variable to apply the ratdens constraint
.IP "r" 12
 ratdens_t constriants
.TH "snd_pcm_hw_constraint_msbits" 9 "snd_pcm_hw_constraint_msbits" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_msbits \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_msbits
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "unsigned int " cond ","
.BI "unsigned int " width ","
.BI "unsigned int " msbits ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "cond" 12
 condition bits
.IP "width" 12
 sample bits width
.IP "msbits" 12
 msbits width
.TH "snd_pcm_hw_constraint_step" 9 "snd_pcm_hw_constraint_step" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_step \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_step
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "unsigned int " cond ","
.BI "snd_pcm_hw_param_t " var ","
.BI "unsigned long " step ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "cond" 12
 condition bits
.IP "var" 12
 hw_params variable to apply the step constraint
.IP "step" 12
 step size
.TH "snd_pcm_hw_constraint_pow2" 9 "snd_pcm_hw_constraint_pow2" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_constraint_pow2 \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_constraint_pow2
.BI "(snd_pcm_runtime_t *" runtime ","
.BI "unsigned int " cond ","
.BI "snd_pcm_hw_param_t " var ");"
.SH ARGUMENTS
.IP "runtime" 12
 PCM runtime instance
.IP "cond" 12
 condition bits
.IP "var" 12
 hw_params variable to apply the power-of-2 constraint
.TH "snd_pcm_hw_param_value" 9 "snd_pcm_hw_param_value" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_value \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_value
.BI "(const snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Return the value for field PAR if it's fixed in configuration space 
defined by PARAMS. Return -EINVAL otherwise
.TH "snd_pcm_hw_param_value_min" 9 "snd_pcm_hw_param_value_min" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_value_min \- 
.SH SYNOPSIS
.B "unsigned int" snd_pcm_hw_param_value_min
.BI "(const snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Return the minimum value for field PAR.
.TH "snd_pcm_hw_param_value_max" 9 "snd_pcm_hw_param_value_max" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_value_max \- 
.SH SYNOPSIS
.B "unsigned int" snd_pcm_hw_param_value_max
.BI "(const snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Return the maximum value for field PAR.
.TH "snd_pcm_hw_param_first" 9 "snd_pcm_hw_param_first" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_first \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_first
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Inside configuration space defined by PARAMS remove from PAR all 
values &gt; minimum. Reduce configuration space accordingly.
Return the minimum.
.TH "snd_pcm_hw_param_last" 9 "snd_pcm_hw_param_last" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_last \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_last
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Inside configuration space defined by PARAMS remove from PAR all 
values &lt; maximum. Reduce configuration space accordingly.
Return the maximum.
.TH "snd_pcm_hw_param_min" 9 "snd_pcm_hw_param_min" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_min \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_min
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "unsigned int " val ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "val" 12
 minimal value
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Inside configuration space defined by PARAMS remove from PAR all 
values &lt; VAL. Reduce configuration space accordingly.
Return new minimum or -EINVAL if the configuration space is empty
.TH "snd_pcm_hw_param_max" 9 "snd_pcm_hw_param_max" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_max \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_max
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "unsigned int " val ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "val" 12
 maximal value
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Inside configuration space defined by PARAMS remove from PAR all 
values &gt;= VAL + 1. Reduce configuration space accordingly.
Return new maximum or -EINVAL if the configuration space is empty
.TH "snd_pcm_hw_param_set" 9 "snd_pcm_hw_param_set" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_set \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_set
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "unsigned int " val ","
.BI "int " dir ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "val" 12
 value to set
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Inside configuration space defined by PARAMS remove from PAR all 
values != VAL. Reduce configuration space accordingly.
Return VAL or -EINVAL if the configuration space is empty
.TH "snd_pcm_hw_param_mask" 9 "snd_pcm_hw_param_mask" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_mask \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_mask
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "const snd_mask_t *" val ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "val" 12
 mask to apply
.SH "DESCRIPTION"
Inside configuration space defined by PARAMS remove from PAR all values
not contained in MASK. Reduce configuration space accordingly.
This function can be called only for SNDRV_PCM_HW_PARAM_ACCESS,
SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
Return 0 on success or -EINVAL
if the configuration space is empty
.TH "snd_pcm_hw_param_near" 9 "snd_pcm_hw_param_near" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_param_near \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_param_near
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ","
.BI "snd_pcm_hw_param_t " var ","
.BI "unsigned int " best ","
.BI "int *" dir ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.IP "var" 12
 parameter to retrieve
.IP "best" 12
 value to set
.IP "dir" 12
 pointer to the direction (-1,0,1) or NULL
.SH "DESCRIPTION"
Inside configuration space defined by PARAMS set PAR to the available value
nearest to VAL. Reduce configuration space accordingly.
This function cannot be called for SNDRV_PCM_HW_PARAM_ACCESS,
SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
Return the value found.
.TH "snd_pcm_hw_params_choose" 9 "snd_pcm_hw_params_choose" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_hw_params_choose \- 
.SH SYNOPSIS
.B "int" snd_pcm_hw_params_choose
.BI "(snd_pcm_t *" pcm ","
.BI "snd_pcm_hw_params_t *" params ");"
.SH ARGUMENTS
.IP "pcm" 12
 PCM instance
.IP "params" 12
 the hw_params instance
.SH "DESCRIPTION"
Choose one configuration from configuration space defined by PARAMS
.SH "THE CONFIGURATION CHOSEN IS THAT OBTAINED FIXING IN THIS ORDER"
first access, first format, first subformat, min channels,
min rate, min period time, max buffer size, min tick time
.TH "snd_pcm_lib_ioctl" 9 "snd_pcm_lib_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_lib_ioctl \-  a generic PCM ioctl callback
.SH SYNOPSIS
.B "int" snd_pcm_lib_ioctl
.BI "(snd_pcm_substream_t *" substream ","
.BI "unsigned int " cmd ","
.BI "void *" arg ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.IP "cmd" 12
 ioctl command
.IP "arg" 12
 ioctl argument
.SH "DESCRIPTION"
Processes the generic ioctl commands for PCM.
Can be passed as the ioctl callback for PCM ops.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_period_elapsed" 9 "snd_pcm_period_elapsed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_period_elapsed \-  update the pcm status for the next period
.SH SYNOPSIS
.B "void" snd_pcm_period_elapsed
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.SH "DESCRIPTION"
This function is called from the interrupt handler when the
PCM has processed the period size.  It will update the current
pointer, set up the tick, wake up sleepers, etc.

Even if more than one periods have elapsed since the last call, you
have to call this only once.
.TH "snd_ctl_new" 9 "snd_ctl_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_new \-  create a control instance from the template
.SH SYNOPSIS
.B "snd_kcontrol_t *" snd_ctl_new
.BI "(snd_kcontrol_t *" control ","
.BI "unsigned int " access ");"
.SH ARGUMENTS
.IP "control" 12
 the control template
.IP "access" 12
 the default control access
.SH "DESCRIPTION"
Allocates a new snd_kcontrol_t instance and copies the given template 
to the new instance. It does not copy volatile data (access).

Returns the pointer of the new instance, or NULL on failure.
.TH "snd_ctl_new1" 9 "snd_ctl_new1" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_new1 \-  create a control instance from the template
.SH SYNOPSIS
.B "snd_kcontrol_t *" snd_ctl_new1
.BI "(const snd_kcontrol_new_t *" ncontrol ","
.BI "void *" private_data ");"
.SH ARGUMENTS
.IP "ncontrol" 12
 the initialization record
.IP "private_data" 12
 the private data to set
.SH "DESCRIPTION"
Allocates a new snd_kcontrol_t instance and initialize from the given 
template.  When the access field of ncontrol is 0, it's assumed as
READWRITE access. When the count field is 0, it's assumes as one.

Returns the pointer of the newly generated instance, or NULL on failure.
.TH "snd_ctl_free_one" 9 "snd_ctl_free_one" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_free_one \-  release the control instance
.SH SYNOPSIS
.B "void" snd_ctl_free_one
.BI "(snd_kcontrol_t *" kcontrol ");"
.SH ARGUMENTS
.IP "kcontrol" 12
 the control instance
.SH "DESCRIPTION"
Releases the control instance created via \fBsnd_ctl_new\fP
or \fBsnd_ctl_new1\fP.
Don't call this after the control was added to the card.
.TH "snd_ctl_add" 9 "snd_ctl_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_add \-  add the control instance to the card
.SH SYNOPSIS
.B "int" snd_ctl_add
.BI "(snd_card_t *" card ","
.BI "snd_kcontrol_t *" kcontrol ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "kcontrol" 12
 the control instance to add
.SH "DESCRIPTION"
Adds the control instance created via \fBsnd_ctl_new\fP or
\fBsnd_ctl_new1\fP to the given card. Assigns also an unique
numid used for fast search.

Returns zero if successful, or a negative error code on failure.

It frees automatically the control which cannot be added.
.TH "snd_ctl_remove" 9 "snd_ctl_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_remove \-  remove the control from the card and release it
.SH SYNOPSIS
.B "int" snd_ctl_remove
.BI "(snd_card_t *" card ","
.BI "snd_kcontrol_t *" kcontrol ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "kcontrol" 12
 the control instance to remove
.SH "DESCRIPTION"
Removes the control from the card and then releases the instance.
You don't need to call \fBsnd_ctl_free_one\fP. You must be in
the write lock - down_write(&amp;card-&gt;controls_rwsem).

Returns 0 if successful, or a negative error code on failure.
.TH "snd_ctl_remove_id" 9 "snd_ctl_remove_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_remove_id \-  remove the control of the given id and release it
.SH SYNOPSIS
.B "int" snd_ctl_remove_id
.BI "(snd_card_t *" card ","
.BI "snd_ctl_elem_id_t *" id ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "id" 12
 the control id to remove
.SH "DESCRIPTION"
Finds the control instance with the given id, removes it from the
card list and releases it.

Returns 0 if successful, or a negative error code on failure.
.TH "snd_ctl_remove_unlocked_id" 9 "snd_ctl_remove_unlocked_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_remove_unlocked_id \-  remove the unlocked control of the given id and release it
.SH SYNOPSIS
.B "int" snd_ctl_remove_unlocked_id
.BI "(snd_ctl_file_t *" file ","
.BI "snd_ctl_elem_id_t *" id ");"
.SH ARGUMENTS
.IP "file" 12
 active control handle
.IP "id" 12
 the control id to remove
.SH "DESCRIPTION"
Finds the control instance with the given id, removes it from the
card list and releases it.

Returns 0 if successful, or a negative error code on failure.
.TH "snd_ctl_rename_id" 9 "snd_ctl_rename_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_rename_id \-  replace the id of a control on the card
.SH SYNOPSIS
.B "int" snd_ctl_rename_id
.BI "(snd_card_t *" card ","
.BI "snd_ctl_elem_id_t *" src_id ","
.BI "snd_ctl_elem_id_t *" dst_id ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "src_id" 12
 the old id
.IP "dst_id" 12
 the new id
.SH "DESCRIPTION"
Finds the control with the old id from the card, and replaces the
id with the new one.

Returns zero if successful, or a negative error code on failure.
.TH "snd_ctl_find_numid" 9 "snd_ctl_find_numid" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_find_numid \-  find the control instance with the given number-id
.SH SYNOPSIS
.B "snd_kcontrol_t *" snd_ctl_find_numid
.BI "(snd_card_t *" card ","
.BI "unsigned int " numid ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "numid" 12
 the number-id to search
.SH "DESCRIPTION"
Finds the control instance with the given number-id from the card.

Returns the pointer of the instance if found, or NULL if not.

The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).
.TH "snd_ctl_find_id" 9 "snd_ctl_find_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_ctl_find_id \-  find the control instance with the given id
.SH SYNOPSIS
.B "snd_kcontrol_t *" snd_ctl_find_id
.BI "(snd_card_t *" card ","
.BI "snd_ctl_elem_id_t *" id ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "id" 12
 the id to search
.SH "DESCRIPTION"
Finds the control instance with the given id from the card.

Returns the pointer of the instance if found, or NULL if not.

The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).
.TH "snd_malloc_pages" 9 "snd_malloc_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_malloc_pages \-  allocate pages with the given size
.SH SYNOPSIS
.B "void *" snd_malloc_pages
.BI "(size_t " size ","
.BI "unsigned int " gfp_flags ");"
.SH ARGUMENTS
.IP "size" 12
 the size to allocate in bytes
.IP "gfp_flags" 12
 the allocation conditions, GFP_XXX
.SH "DESCRIPTION"
Allocates the physically contiguous pages with the given size.

Returns the pointer of the buffer, or NULL if no enoguh memory.
.TH "snd_free_pages" 9 "snd_free_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_free_pages \-  release the pages
.SH SYNOPSIS
.B "void" snd_free_pages
.BI "(void *" ptr ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "ptr" 12
 the buffer pointer to release
.IP "size" 12
 the allocated buffer size
.SH "DESCRIPTION"
Releases the buffer allocated via \fBsnd_malloc_pages\fP.
.TH "snd_dma_alloc_pages" 9 "snd_dma_alloc_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_alloc_pages \-  allocate the buffer area according to the given type
.SH SYNOPSIS
.B "int" snd_dma_alloc_pages
.BI "(int " type ","
.BI "struct device *" device ","
.BI "size_t " size ","
.BI "struct snd_dma_buffer *" dmab ");"
.SH ARGUMENTS
.IP "type" 12
 the DMA buffer type
.IP "device" 12
 the device pointer
.IP "size" 12
 the buffer size to allocate
.IP "dmab" 12
 buffer allocation record to store the allocated data
.SH "DESCRIPTION"
Calls the memory-allocator function for the corresponding
buffer type.

Returns zero if the buffer with the given size is allocated successfuly,
other a negative value at error.
.TH "snd_dma_alloc_pages_fallback" 9 "snd_dma_alloc_pages_fallback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_alloc_pages_fallback \-  allocate the buffer area according to the given type with fallback
.SH SYNOPSIS
.B "int" snd_dma_alloc_pages_fallback
.BI "(int " type ","
.BI "struct device *" device ","
.BI "size_t " size ","
.BI "struct snd_dma_buffer *" dmab ");"
.SH ARGUMENTS
.IP "type" 12
 the DMA buffer type
.IP "device" 12
 the device pointer
.IP "size" 12
 the buffer size to allocate
.IP "dmab" 12
 buffer allocation record to store the allocated data
.SH "DESCRIPTION"
Calls the memory-allocator function for the corresponding
buffer type.  When no space is left, this function reduces the size and
tries to allocate again.  The size actually allocated is stored in
res_size argument.

Returns zero if the buffer with the given size is allocated successfuly,
other a negative value at error.
.TH "snd_dma_free_pages" 9 "snd_dma_free_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_free_pages \-  release the allocated buffer
.SH SYNOPSIS
.B "void" snd_dma_free_pages
.BI "(struct snd_dma_buffer *" dmab ");"
.SH ARGUMENTS
.IP "dmab" 12
 the buffer allocation record to release
.SH "DESCRIPTION"
Releases the allocated buffer via \fBsnd_dma_alloc_pages\fP.
.TH "snd_dma_get_reserved_buf" 9 "snd_dma_get_reserved_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_get_reserved_buf \-  get the reserved buffer for the given device
.SH SYNOPSIS
.B "size_t" snd_dma_get_reserved_buf
.BI "(struct snd_dma_buffer *" dmab ","
.BI "unsigned int " id ");"
.SH ARGUMENTS
.IP "dmab" 12
 the buffer allocation record to store
.IP "id" 12
 the buffer id
.SH "DESCRIPTION"
Looks for the reserved-buffer list and re-uses if the same buffer
is found in the list.  When the buffer is found, it's removed from the free list.

Returns the size of buffer if the buffer is found, or zero if not found.
.TH "snd_dma_reserve_buf" 9 "snd_dma_reserve_buf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_reserve_buf \-  reserve the buffer
.SH SYNOPSIS
.B "int" snd_dma_reserve_buf
.BI "(struct snd_dma_buffer *" dmab ","
.BI "unsigned int " id ");"
.SH ARGUMENTS
.IP "dmab" 12
 the buffer to reserve
.IP "id" 12
 the buffer id
.SH "DESCRIPTION"
Reserves the given buffer as a reserved buffer.

Returns zero if successful, or a negative code at error.
.TH "copy_to_user_fromio" 9 "copy_to_user_fromio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_to_user_fromio \-  copy data from mmio-space to user-space
.SH SYNOPSIS
.B "int" copy_to_user_fromio
.BI "(void __user *" dst ","
.BI "const volatile void __iomem *" src ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dst" 12
 the destination pointer on user-space
.IP "src" 12
 the source pointer on mmio
.IP "count" 12
 the data size to copy in bytes
.SH "DESCRIPTION"
Copies the data from mmio-space to user-space.

Returns zero if successful, or non-zero on failure.
.TH "copy_from_user_toio" 9 "copy_from_user_toio" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_from_user_toio \-  copy data from user-space to mmio-space
.SH SYNOPSIS
.B "int" copy_from_user_toio
.BI "(volatile void __iomem *" dst ","
.BI "const void __user *" src ","
.BI "size_t " count ");"
.SH ARGUMENTS
.IP "dst" 12
 the destination pointer on mmio-space
.IP "src" 12
 the source pointer on user-space
.IP "count" 12
 the data size to copy in bytes
.SH "DESCRIPTION"
Copies the data from user-space to mmio-space.

Returns zero if successful, or non-zero on failure.
.TH "snd_hwdep_new" 9 "snd_hwdep_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_hwdep_new \-  create a new hwdep instance
.SH SYNOPSIS
.B "int" snd_hwdep_new
.BI "(snd_card_t *" card ","
.BI "char *" id ","
.BI "int " device ","
.BI "snd_hwdep_t **" rhwdep ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "id" 12
 the id string
.IP "device" 12
 the device index (zero-based)
.IP "rhwdep" 12
 the pointer to store the new hwdep instance
.SH "DESCRIPTION"
Creates a new hwdep instance with the given index on the card.
The callbacks (hwdep-&gt;ops) must be set on the returned instance
after this call manually by the caller.

Returns zero if successful, or a negative error code on failure.
.TH "snd_iprintf" 9 "snd_iprintf" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_iprintf \-  printf on the procfs buffer
.SH SYNOPSIS
.B "int" snd_iprintf
.BI "(snd_info_buffer_t *" buffer ","
.BI "char *" fmt ","
.BI "" ... ");"
.SH ARGUMENTS
.IP "buffer" 12
 the procfs buffer
.IP "fmt" 12
 the printf format
.IP "..." 12
variable arguments
.SH "DESCRIPTION"
Outputs the string on the procfs buffer just like \fBprintf\fP.

Returns the size of output string.
.TH "snd_create_proc_entry" 9 "snd_create_proc_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_create_proc_entry \-  create a procfs entry
.SH SYNOPSIS
.B "struct proc_dir_entry *" snd_create_proc_entry
.BI "(const char *" name ","
.BI "mode_t " mode ","
.BI "struct proc_dir_entry *" parent ");"
.SH ARGUMENTS
.IP "name" 12
 the name of the proc file
.IP "mode" 12
 the file permission bits, S_Ixxx
.IP "parent" 12
 the parent proc-directory entry
.SH "DESCRIPTION"
Creates a new proc file entry with the given name and permission
on the given directory.

Returns the pointer of new instance or NULL on failure.
.TH "snd_info_get_line" 9 "snd_info_get_line" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_get_line \-  read one line from the procfs buffer
.SH SYNOPSIS
.B "int" snd_info_get_line
.BI "(snd_info_buffer_t *" buffer ","
.BI "char *" line ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "buffer" 12
 the procfs buffer
.IP "line" 12
 the buffer to store
.IP "len" 12
 the max. buffer size - 1
.SH "DESCRIPTION"
Reads one line from the buffer and stores the string.

Returns zero if successful, or 1 if error or EOF.
.TH "snd_info_get_str" 9 "snd_info_get_str" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_get_str \-  parse a string token
.SH SYNOPSIS
.B "char *" snd_info_get_str
.BI "(char *" dest ","
.BI "char *" src ","
.BI "int " len ");"
.SH ARGUMENTS
.IP "dest" 12
 the buffer to store the string token
.IP "src" 12
 the original string
.IP "len" 12
 the max. length of token - 1
.SH "DESCRIPTION"
Parses the original string and copy a token to the given
string buffer.

Returns the updated pointer of the original string so that
it can be used for the next call.
.TH "snd_info_create_entry" 9 "snd_info_create_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_create_entry \-  create an info entry
.SH SYNOPSIS
.B "snd_info_entry_t *" snd_info_create_entry
.BI "(const char *" name ");"
.SH ARGUMENTS
.IP "name" 12
 the proc file name
.SH "DESCRIPTION"
Creates an info entry with the given file name and initializes as
the default state.

Usually called from other functions such as
\fBsnd_info_create_card_entry\fP.

Returns the pointer of the new instance, or NULL on failure.
.TH "snd_info_create_module_entry" 9 "snd_info_create_module_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_create_module_entry \-  create an info entry for the given module
.SH SYNOPSIS
.B "snd_info_entry_t *" snd_info_create_module_entry
.BI "(struct module *" module ","
.BI "const char *" name ","
.BI "snd_info_entry_t *" parent ");"
.SH ARGUMENTS
.IP "module" 12
 the module pointer
.IP "name" 12
 the file name
.IP "parent" 12
 the parent directory
.SH "DESCRIPTION"
Creates a new info entry and assigns it to the given module.

Returns the pointer of the new instance, or NULL on failure.
.TH "snd_info_create_card_entry" 9 "snd_info_create_card_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_create_card_entry \-  create an info entry for the given card
.SH SYNOPSIS
.B "snd_info_entry_t *" snd_info_create_card_entry
.BI "(snd_card_t *" card ","
.BI "const char *" name ","
.BI "snd_info_entry_t *" parent ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "name" 12
 the file name
.IP "parent" 12
 the parent directory
.SH "DESCRIPTION"
Creates a new info entry and assigns it to the given card.

Returns the pointer of the new instance, or NULL on failure.
.TH "snd_card_proc_new" 9 "snd_card_proc_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_proc_new \-  create an info entry for the given card
.SH SYNOPSIS
.B "int" snd_card_proc_new
.BI "(snd_card_t *" card ","
.BI "const char *" name ","
.BI "snd_info_entry_t **" entryp ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "name" 12
 the file name
.IP "entryp" 12
 the pointer to store the new info entry
.SH "DESCRIPTION"
Creates a new info entry and assigns it to the given card.
Unlike \fBsnd_info_create_card_entry\fP, this function registers the
info entry as an ALSA device component, so that it can be
unregistered/released without explicit call.
Also, you don't have to register this entry via \fBsnd_info_register\fP,
since this will be registered by \fBsnd_card_register\fP automatically.

The parent is assumed as card-&gt;proc_root.

For releasing this entry, use \fBsnd_device_free\fP instead of
\fBsnd_info_free_entry\fP. 

Returns zero if successful, or a negative error code on failure.
.TH "snd_info_free_entry" 9 "snd_info_free_entry" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_free_entry \-  release the info entry
.SH SYNOPSIS
.B "void" snd_info_free_entry
.BI "(snd_info_entry_t *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 the info entry
.SH "DESCRIPTION"
Releases the info entry.  Don't call this after registered.
.TH "snd_info_register" 9 "snd_info_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_register \-  register the info entry
.SH SYNOPSIS
.B "int" snd_info_register
.BI "(snd_info_entry_t *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 the info entry
.SH "DESCRIPTION"
Registers the proc info entry.

Returns zero if successful, or a negative error code on failure.
.TH "snd_info_unregister" 9 "snd_info_unregister" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_info_unregister \-  de-register the info entry
.SH SYNOPSIS
.B "int" snd_info_unregister
.BI "(snd_info_entry_t *" entry ");"
.SH ARGUMENTS
.IP "entry" 12
 the info entry
.SH "DESCRIPTION"
De-registers the info entry and releases the instance.

Returns zero if successful, or a negative error code on failure.
.TH "snd_request_card" 9 "snd_request_card" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_request_card \-  try to load the card module
.SH SYNOPSIS
.B "void" snd_request_card
.BI "(int " card ");"
.SH ARGUMENTS
.IP "card" 12
 the card number
.SH "DESCRIPTION"
Tries to load the module "snd-card-X" for the given card number
via KMOD.  Returns immediately if already loaded.
.TH "snd_register_device" 9 "snd_register_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_register_device \-  Register the ALSA device file for the card
.SH SYNOPSIS
.B "int" snd_register_device
.BI "(int " type ","
.BI "snd_card_t *" card ","
.BI "int " dev ","
.BI "snd_minor_t *" reg ","
.BI "const char *" name ");"
.SH ARGUMENTS
.IP "type" 12
 the device type, SNDRV_DEVICE_TYPE_XXX
.IP "card" 12
 the card instance
.IP "dev" 12
 the device index
.IP "reg" 12
 the snd_minor_t record
.IP "name" 12
 the device file name
.SH "DESCRIPTION"
Registers an ALSA device file for the given card.
The operators have to be set in reg parameter.

Retrurns zero if successful, or a negative error code on failure.
.TH "snd_unregister_device" 9 "snd_unregister_device" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_unregister_device \-  unregister the device on the given card
.SH SYNOPSIS
.B "int" snd_unregister_device
.BI "(int " type ","
.BI "snd_card_t *" card ","
.BI "int " dev ");"
.SH ARGUMENTS
.IP "type" 12
 the device type, SNDRV_DEVICE_TYPE_XXX
.IP "card" 12
 the card instance
.IP "dev" 12
 the device index
.SH "DESCRIPTION"
Unregisters the device file already registered via
\fBsnd_register_device\fP.

Returns zero if sucecessful, or a negative error code on failure
.TH "snd_dma_program" 9 "snd_dma_program" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_program \-  program an ISA DMA transfer
.SH SYNOPSIS
.B "void" snd_dma_program
.BI "(unsigned long " dma ","
.BI "unsigned long " addr ","
.BI "unsigned int " size ","
.BI "unsigned short " mode ");"
.SH ARGUMENTS
.IP "dma" 12
 the dma number
.IP "addr" 12
 the physical address of the buffer
.IP "size" 12
 the DMA transfer size
.IP "mode" 12
 the DMA transfer mode, DMA_MODE_XXX
.SH "DESCRIPTION"
Programs an ISA DMA transfer for the given buffer.
.TH "snd_dma_disable" 9 "snd_dma_disable" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_disable \-  stop the ISA DMA transfer
.SH SYNOPSIS
.B "void" snd_dma_disable
.BI "(unsigned long " dma ");"
.SH ARGUMENTS
.IP "dma" 12
 the dma number
.SH "DESCRIPTION"
Stops the ISA DMA transfer.
.TH "snd_dma_pointer" 9 "snd_dma_pointer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_dma_pointer \-  return the current pointer to DMA transfer buffer in bytes
.SH SYNOPSIS
.B "unsigned int" snd_dma_pointer
.BI "(unsigned long " dma ","
.BI "unsigned int " size ");"
.SH ARGUMENTS
.IP "dma" 12
 the dma number
.IP "size" 12
 the dma transfer size
.SH "DESCRIPTION"
Returns the current pointer in DMA tranfer buffer in bytes
.TH "snd_device_new" 9 "snd_device_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_device_new \-  create an ALSA device component
.SH SYNOPSIS
.B "int" snd_device_new
.BI "(snd_card_t *" card ","
.BI "snd_device_type_t " type ","
.BI "void *" device_data ","
.BI "snd_device_ops_t *" ops ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "type" 12
 the device type, SNDRV_DEV_XXX
.IP "device_data" 12
 the data pointer of this device
.IP "ops" 12
 the operator table
.SH "DESCRIPTION"
Creates a new device component for the given data pointer.
The device will be assigned to the card and managed together
by the card.

The data pointer plays a role as the identifier, too, so the
pointer address must be unique and unchanged.

Returns zero if successful, or a negative error code on failure.
.TH "snd_device_free" 9 "snd_device_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_device_free \-  release the device from the card
.SH SYNOPSIS
.B "int" snd_device_free
.BI "(snd_card_t *" card ","
.BI "void *" device_data ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "device_data" 12
 the data pointer to release
.SH "DESCRIPTION"
Removes the device from the list on the card and invokes the
callback, dev_unregister or dev_free, corresponding to the state.
Then release the device.

Returns zero if successful, or a negative error code on failure or if the
device not found.
.TH "snd_device_disconnect" 9 "snd_device_disconnect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_device_disconnect \-  disconnect the device
.SH SYNOPSIS
.B "int" snd_device_disconnect
.BI "(snd_card_t *" card ","
.BI "void *" device_data ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "device_data" 12
 the data pointer to disconnect
.SH "DESCRIPTION"
Turns the device into the disconnection state, invoking
dev_disconnect callback, if the device was already registered.

Usually called from \fBsnd_card_disconnect\fP.

Returns zero if successful, or a negative error code on failure or if the
device not found.
.TH "snd_device_register" 9 "snd_device_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_device_register \-  register the device
.SH SYNOPSIS
.B "int" snd_device_register
.BI "(snd_card_t *" card ","
.BI "void *" device_data ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "device_data" 12
 the data pointer to register
.SH "DESCRIPTION"
Registers the device which was already created via
\fBsnd_device_new\fP.  Usually this is called from \fBsnd_card_register\fP,
but it can be called later if any new devices are created after
invocation of \fBsnd_card_register\fP.

Returns zero if successful, or a negative error code on failure or if the
device not found.
.TH "snd_rawmidi_receive" 9 "snd_rawmidi_receive" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_rawmidi_receive \-  receive the input data from the device
.SH SYNOPSIS
.B "int" snd_rawmidi_receive
.BI "(snd_rawmidi_substream_t *" substream ","
.BI "const unsigned char *" buffer ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "substream" 12
 the rawmidi substream
.IP "buffer" 12
 the buffer pointer
.IP "count" 12
 the data size to read
.SH "DESCRIPTION"
Reads the data from the internal buffer.

Returns the size of read data, or a negative error code on failure.
.TH "snd_rawmidi_transmit_empty" 9 "snd_rawmidi_transmit_empty" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_rawmidi_transmit_empty \-  check whether the output buffer is empty
.SH SYNOPSIS
.B "int" snd_rawmidi_transmit_empty
.BI "(snd_rawmidi_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the rawmidi substream
.SH "DESCRIPTION"
Returns 1 if the internal output buffer is empty, 0 if not.
.TH "snd_rawmidi_transmit_peek" 9 "snd_rawmidi_transmit_peek" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_rawmidi_transmit_peek \-  copy data from the internal buffer
.SH SYNOPSIS
.B "int" snd_rawmidi_transmit_peek
.BI "(snd_rawmidi_substream_t *" substream ","
.BI "unsigned char *" buffer ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "substream" 12
 the rawmidi substream
.IP "buffer" 12
 the buffer pointer
.IP "count" 12
 data size to transfer
.SH "DESCRIPTION"
Copies data from the internal output buffer to the given buffer.

Call this in the interrupt handler when the midi output is ready,
and call \fBsnd_rawmidi_transmit_ack\fP after the transmission is
finished.

Returns the size of copied data, or a negative error code on failure.
.TH "snd_rawmidi_transmit_ack" 9 "snd_rawmidi_transmit_ack" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_rawmidi_transmit_ack \-  acknowledge the transmission
.SH SYNOPSIS
.B "int" snd_rawmidi_transmit_ack
.BI "(snd_rawmidi_substream_t *" substream ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "substream" 12
 the rawmidi substream
.IP "count" 12
 the tranferred count
.SH "DESCRIPTION"
Advances the hardware pointer for the internal output buffer with
the given size and updates the condition.
Call after the transmission is finished.

Returns the advanced size if successful, or a negative error code on failure.
.TH "snd_rawmidi_transmit" 9 "snd_rawmidi_transmit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_rawmidi_transmit \-  copy from the buffer to the device
.SH SYNOPSIS
.B "int" snd_rawmidi_transmit
.BI "(snd_rawmidi_substream_t *" substream ","
.BI "unsigned char *" buffer ","
.BI "int " count ");"
.SH ARGUMENTS
.IP "substream" 12
 the rawmidi substream
.IP "buffer" 12
 the buffer pointer
.IP "count" 12
 the data size to transfer
.SH "DESCRIPTION"
Copies data from the buffer to the device and advances the pointer.

Returns the copied size if successful, or a negative error code on failure.
.TH "snd_rawmidi_new" 9 "snd_rawmidi_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_rawmidi_new \-  create a rawmidi instance
.SH SYNOPSIS
.B "int" snd_rawmidi_new
.BI "(snd_card_t *" card ","
.BI "char *" id ","
.BI "int " device ","
.BI "int " output_count ","
.BI "int " input_count ","
.BI "snd_rawmidi_t **" rrawmidi ");"
.SH ARGUMENTS
.IP "card" 12
 the card instance
.IP "id" 12
 the id string
.IP "device" 12
 the device index
.IP "output_count" 12
 the number of output streams
.IP "input_count" 12
 the number of input streams
.IP "rrawmidi" 12
 the pointer to store the new rawmidi instance
.SH "DESCRIPTION"
Creates a new rawmidi instance.
Use \fBsnd_rawmidi_set_ops\fP to set the operators to the new instance.

Returns zero if successful, or a negative error code on failure.
.TH "snd_rawmidi_set_ops" 9 "snd_rawmidi_set_ops" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_rawmidi_set_ops \-  set the rawmidi operators
.SH SYNOPSIS
.B "void" snd_rawmidi_set_ops
.BI "(snd_rawmidi_t *" rmidi ","
.BI "int " stream ","
.BI "snd_rawmidi_ops_t *" ops ");"
.SH ARGUMENTS
.IP "rmidi" 12
 the rawmidi instance
.IP "stream" 12
 the stream direction, SNDRV_RAWMIDI_STREAM_XXX
.IP "ops" 12
 the operator table
.SH "DESCRIPTION"
Sets the rawmidi operators for the given stream direction.
.TH "snd_card_new" 9 "snd_card_new" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_new \-  create and initialize a soundcard structure
.SH SYNOPSIS
.B "snd_card_t *" snd_card_new
.BI "(int " idx ","
.BI "const char *" xid ","
.BI "struct module *" module ","
.BI "int " extra_size ");"
.SH ARGUMENTS
.IP "idx" 12
 card index (address) [0 ... (SNDRV_CARDS-1)]
.IP "xid" 12
 card identification (ASCII string)
.IP "module" 12
 top level module for locking
.IP "extra_size" 12
 allocate this extra size after the main soundcard structure
.SH "DESCRIPTION"
Creates and initializes a soundcard structure.

Returns kmallocated snd_card_t structure. Creates the ALSA control interface
(which is blocked until snd_card_register function is called).
.TH "snd_card_disconnect" 9 "snd_card_disconnect" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_disconnect \-  disconnect all APIs from the file-operations (user space)
.SH SYNOPSIS
.B "int" snd_card_disconnect
.BI "(snd_card_t *" card ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.SH "DESCRIPTION"
Disconnects all APIs from the file-operations (user space).

Returns zero, otherwise a negative error code.
.SH "NOTE"
 The current implementation replaces all active file-&gt;f_op with special
dummy file operations (they do nothing except release).
.TH "snd_card_free" 9 "snd_card_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_free \-  frees given soundcard structure
.SH SYNOPSIS
.B "int" snd_card_free
.BI "(snd_card_t *" card ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.SH "DESCRIPTION"
This function releases the soundcard structure and the all assigned
devices automatically.  That is, you don't have to release the devices
by yourself.

Returns zero. Frees all associated devices and frees the control
interface associated to given soundcard.
.TH "snd_card_free_in_thread" 9 "snd_card_free_in_thread" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_free_in_thread \-  call snd_card_free() in thread
.SH SYNOPSIS
.B "int" snd_card_free_in_thread
.BI "(snd_card_t *" card ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.SH "DESCRIPTION"
This function schedules the call of \fBsnd_card_free\fP function in a
work queue.  When all devices are released (non-busy), the work
is woken up and calls \fBsnd_card_free\fP.

When a card can be disconnected at any time by hotplug service,
this function should be used in disconnect (or detach) callback
instead of calling \fBsnd_card_free\fP directly.

Returns - zero otherwise a negative error code if the start of thread failed.
.TH "snd_card_register" 9 "snd_card_register" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_register \-  register the soundcard
.SH SYNOPSIS
.B "int" snd_card_register
.BI "(snd_card_t *" card ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.SH "DESCRIPTION"
This function registers all the devices assigned to the soundcard.
Until calling this, the ALSA control interface is blocked from the
external accesses.  Thus, you should call this function at the end
of the initialization of the card.

Returns zero otherwise a negative error code if the registrain failed.
.TH "snd_component_add" 9 "snd_component_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_component_add \-  add a component string
.SH SYNOPSIS
.B "int" snd_component_add
.BI "(snd_card_t *" card ","
.BI "const char *" component ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.IP "component" 12
 the component id string
.SH "DESCRIPTION"
This function adds the component id string to the supported list.
The component can be referred from the alsa-lib.

Returns zero otherwise a negative error code.
.TH "snd_card_file_add" 9 "snd_card_file_add" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_file_add \-  add the file to the file list of the card
.SH SYNOPSIS
.B "int" snd_card_file_add
.BI "(snd_card_t *" card ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.IP "file" 12
 file pointer
.SH "DESCRIPTION"
This function adds the file to the file linked-list of the card.
This linked-list is used to keep tracking the connection state,
and to avoid the release of busy resources by hotplug.

Returns zero or a negative error code.
.TH "snd_card_file_remove" 9 "snd_card_file_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_file_remove \-  remove the file from the file list
.SH SYNOPSIS
.B "int" snd_card_file_remove
.BI "(snd_card_t *" card ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.IP "file" 12
 file pointer
.SH "DESCRIPTION"
This function removes the file formerly added to the card via
\fBsnd_card_file_add\fP function.
If all files are removed and the release of the card is
scheduled, it will wake up the the thread to call \fBsnd_card_free\fP
(see \fBsnd_card_free_in_thread\fP function).

Returns zero or a negative error code.
.TH "snd_card_set_generic_dev" 9 "snd_card_set_generic_dev" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_set_generic_dev \-  assign the generic device to the card
.SH SYNOPSIS
.B "int" snd_card_set_generic_dev
.BI "(snd_card_t *" card ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.SH "DESCRIPTION"
Assigns a generic device to the card.  This function is provided as the
last resort, for devices without any proper bus.  Thus this won't override
the device already assigned to the card.

Returns zero if successful, or a negative error code.
.TH "snd_power_wait" 9 "snd_power_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_power_wait \-  wait until the power-state is changed.
.SH SYNOPSIS
.B "int" snd_power_wait
.BI "(snd_card_t *" card ","
.BI "unsigned int " power_state ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.IP "power_state" 12
 expected power state
.IP "file" 12
 file structure for the O_NONBLOCK check (optional)
.SH "DESCRIPTION"
Waits until the power-state is changed.
.SH "NOTE"
 the power lock must be active before call.
.TH "snd_card_set_pm_callback" 9 "snd_card_set_pm_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_set_pm_callback \-  set the PCI power-management callbacks
.SH SYNOPSIS
.B "int" snd_card_set_pm_callback
.BI "(snd_card_t *" card ","
.BI "int (*" suspend ") (snd_card_t *, pm_message_t),"
.BI "int (*" resume ") (snd_card_t *),"
.BI "void *" private_data ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.IP "suspend" 12
 suspend callback function
.IP "resume" 12
 resume callback function
.IP "private_data" 12
 private data to pass to the callback functions
.SH "DESCRIPTION"
Sets the power-management callback functions of the card.
These callbacks are called from ALSA's common PCI suspend/resume
handler and from the control API.
.TH "snd_card_set_generic_pm_callback" 9 "snd_card_set_generic_pm_callback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_card_set_generic_pm_callback \-  set the generic power-management callbacks
.SH SYNOPSIS
.B "int" snd_card_set_generic_pm_callback
.BI "(snd_card_t *" card ","
.BI "int (*" suspend ") (snd_card_t *, pm_message_t),"
.BI "int (*" resume ") (snd_card_t *),"
.BI "void *" private_data ");"
.SH ARGUMENTS
.IP "card" 12
 soundcard structure
.IP "suspend" 12
 suspend callback function
.IP "resume" 12
 resume callback function
.IP "private_data" 12
 private data to pass to the callback functions
.SH "DESCRIPTION"
Registers the power-management and sets the lowlevel callbacks for
the given card.  These callbacks are called from the ALSA's common
PM handler and from the control API.
.TH "snd_pcm_lib_preallocate_free" 9 "snd_pcm_lib_preallocate_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_lib_preallocate_free \-  release the preallocated buffer of the specified substream.
.SH SYNOPSIS
.B "int" snd_pcm_lib_preallocate_free
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.SH "DESCRIPTION"
Releases the pre-allocated buffer of the given substream.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_lib_preallocate_free_for_all" 9 "snd_pcm_lib_preallocate_free_for_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_lib_preallocate_free_for_all \-  release all pre-allocated buffers on the pcm
.SH SYNOPSIS
.B "int" snd_pcm_lib_preallocate_free_for_all
.BI "(snd_pcm_t *" pcm ");"
.SH ARGUMENTS
.IP "pcm" 12
 the pcm instance
.SH "DESCRIPTION"
Releases all the pre-allocated buffers on the given pcm.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_lib_preallocate_pages" 9 "snd_pcm_lib_preallocate_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_lib_preallocate_pages \-  pre-allocation for the given DMA type
.SH SYNOPSIS
.B "int" snd_pcm_lib_preallocate_pages
.BI "(snd_pcm_substream_t *" substream ","
.BI "int " type ","
.BI "struct device *" data ","
.BI "size_t " size ","
.BI "size_t " max ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.IP "type" 12
 DMA type (SNDRV_DMA_TYPE_*)
.IP "data" 12
 DMA type dependant data
.IP "size" 12
 the requested pre-allocation size in bytes
.IP "max" 12
 the max. allowed pre-allocation size
.SH "DESCRIPTION"
Do pre-allocation for the given DMA buffer type.

When substream-&gt;dma_buf_id is set, the function tries to look for
the reserved buffer, and the buffer is not freed but reserved at
destruction time.  The dma_buf_id must be unique for all systems
(in the same DMA buffer type) e.g. using \fBsnd_dma_pci_buf_id\fP.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_lib_preallocate_pages_for_all" 9 "snd_pcm_lib_preallocate_pages_for_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_lib_preallocate_pages_for_all \-  pre-allocation for continous memory type (all substreams)
.SH SYNOPSIS
.B "int" snd_pcm_lib_preallocate_pages_for_all
.BI "(snd_pcm_t *" pcm ","
.BI "int " type ","
.BI "void *" data ","
.BI "size_t " size ","
.BI "size_t " max ");"
.SH ARGUMENTS
.IP "pcm" 12
 the pcm instance
.IP "type" 12
 DMA type (SNDRV_DMA_TYPE_*)
.IP "data" 12
 DMA type dependant data
.IP "size" 12
 the requested pre-allocation size in bytes
.IP "max" 12
 the max. allowed pre-allocation size
.SH "DESCRIPTION"
Do pre-allocation to all substreams of the given pcm for the
specified DMA type.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_sgbuf_ops_page" 9 "snd_pcm_sgbuf_ops_page" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_sgbuf_ops_page \-  get the page struct at the given offset
.SH SYNOPSIS
.B "struct page *" snd_pcm_sgbuf_ops_page
.BI "(snd_pcm_substream_t *" substream ","
.BI "unsigned long " offset ");"
.SH ARGUMENTS
.IP "substream" 12
 the pcm substream instance
.IP "offset" 12
 the buffer offset
.SH "DESCRIPTION"
Returns the page struct at the given buffer offset.
Used as the page callback of PCM ops.
.TH "snd_pcm_lib_malloc_pages" 9 "snd_pcm_lib_malloc_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_lib_malloc_pages \-  allocate the DMA buffer
.SH SYNOPSIS
.B "int" snd_pcm_lib_malloc_pages
.BI "(snd_pcm_substream_t *" substream ","
.BI "size_t " size ");"
.SH ARGUMENTS
.IP "substream" 12
 the substream to allocate the DMA buffer to
.IP "size" 12
 the requested buffer size in bytes
.SH "DESCRIPTION"
Allocates the DMA buffer on the BUS type given earlier to
\fBsnd_pcm_lib_preallocate_xxx_pages\fP.

Returns 1 if the buffer is changed, 0 if not changed, or a negative
code on failure.
.TH "snd_pcm_lib_free_pages" 9 "snd_pcm_lib_free_pages" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_lib_free_pages \-  release the allocated DMA buffer.
.SH SYNOPSIS
.B "int" snd_pcm_lib_free_pages
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the substream to release the DMA buffer
.SH "DESCRIPTION"
Releases the DMA buffer allocated via \fBsnd_pcm_lib_malloc_pages\fP.

Returns zero if successful, or a negative error code on failure.
.TH "snd_pcm_start" 9 "snd_pcm_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_start \- 
.SH SYNOPSIS
.B "int" snd_pcm_start
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the PCM substream instance
.SH "DESCRIPTION"
Start all linked streams.
.TH "snd_pcm_stop" 9 "snd_pcm_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_stop \- 
.SH SYNOPSIS
.B "int" snd_pcm_stop
.BI "(snd_pcm_substream_t *" substream ","
.BI "int " state ");"
.SH ARGUMENTS
.IP "substream" 12
 the PCM substream instance
.IP "state" 12
 PCM state after stopping the stream
.SH "DESCRIPTION"
Try to stop all running streams in the substream group.
The state of each stream is changed to the given value after that unconditionally.
.TH "snd_pcm_drain_done" 9 "snd_pcm_drain_done" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_drain_done \- 
.SH SYNOPSIS
.B "int" snd_pcm_drain_done
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the PCM substream
.SH "DESCRIPTION"
Stop the DMA only when the given stream is playback.
The state is changed to SETUP.
Unlike \fBsnd_pcm_stop\fP, this affects only the given stream.
.TH "snd_pcm_suspend" 9 "snd_pcm_suspend" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_suspend \- 
.SH SYNOPSIS
.B "int" snd_pcm_suspend
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the PCM substream
.SH "DESCRIPTION"
Trigger SUSPEND to all linked streams.
After this call, all streams are changed to SUSPENDED state.
.TH "snd_pcm_suspend_all" 9 "snd_pcm_suspend_all" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_suspend_all \- 
.SH SYNOPSIS
.B "int" snd_pcm_suspend_all
.BI "(snd_pcm_t *" pcm ");"
.SH ARGUMENTS
.IP "pcm" 12
 the PCM instance
.SH "DESCRIPTION"
Trigger SUSPEND to all substreams in the given pcm.
After this call, all streams are changed to SUSPENDED state.
.TH "snd_pcm_prepare" 9 "snd_pcm_prepare" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pcm_prepare \- 
.SH SYNOPSIS
.B "int" snd_pcm_prepare
.BI "(snd_pcm_substream_t *" substream ");"
.SH ARGUMENTS
.IP "substream" 12
 the PCM substream instance
.SH "DESCRIPTION"
Prepare the PCM substream to be triggerable.
.TH "snd_pdacf_assign_resources" 9 "snd_pdacf_assign_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_pdacf_assign_resources \-  initialize the hardware and card instance.
.SH SYNOPSIS
.B "int" snd_pdacf_assign_resources
.BI "(pdacf_t *" pdacf ","
.BI "int " port ","
.BI "int " irq ");"
.SH ARGUMENTS
.IP "pdacf" 12
-- undescribed --
.IP "port" 12
 i/o port for the card
.IP "irq" 12
 irq number for the card
.SH "DESCRIPTION"
this function assigns the specified port and irq, boot the card,
create pcm and control instances, and initialize the rest hardware.

returns 0 if successful, or a negative error code.
.TH "snd_vxpocket_assign_resources" 9 "snd_vxpocket_assign_resources" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
snd_vxpocket_assign_resources \-  initialize the hardware and card instance.
.SH SYNOPSIS
.B "int" snd_vxpocket_assign_resources
.BI "(vx_core_t *" chip ","
.BI "int " port ","
.BI "int " irq ");"
.SH ARGUMENTS
.IP "chip" 12
-- undescribed --
.IP "port" 12
 i/o port for the card
.IP "irq" 12
 irq number for the card
.SH "DESCRIPTION"
this function assigns the specified port and irq, boot the card,
create pcm and control instances, and initialize the rest hardware.

returns 0 if successful, or a negative error code.
.TH "i810_ac97_power_up_bus" 9 "i810_ac97_power_up_bus" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
i810_ac97_power_up_bus \- 	bring up AC97 link
.SH SYNOPSIS
.B "int" i810_ac97_power_up_bus
.BI "(struct i810_card *" card ");"
.SH ARGUMENTS
.IP "card" 12
 ICH audio device to power up
.SH "DESCRIPTION"
Bring up the ACLink AC97 codec bus
.TH "ad1980_remove" 9 "ad1980_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad1980_remove \- 	codec remove callback
.SH SYNOPSIS
.B "void __devexit" ad1980_remove
.BI "(struct ac97_codec *" codec ","
.BI "struct ac97_driver *" driver ");"
.SH ARGUMENTS
.IP "codec" 12
 The codec that is being removed
.IP "driver" 12
-- undescribed --
.SH "DESCRIPTION"
This callback occurs when an AC97 codec is being removed. A
codec remove call will not occur for a codec during that codec
probe callback.

Most drivers will need to lock their remove versus their 
use of the codec after the probe function.
.TH "ad1980_probe" 9 "ad1980_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad1980_probe \- 	codec found callback
.SH SYNOPSIS
.B "int" ad1980_probe
.BI "(struct ac97_codec *" codec ","
.BI "struct ac97_driver *" driver ");"
.SH ARGUMENTS
.IP "codec" 12
 ac97 codec matching the idents
.IP "driver" 12
 ac97_driver it matched
.SH "DESCRIPTION"
This entry point is called when a codec is found which matches
the driver. At the point it is called the codec is basically
operational, mixer operations have been initialised and can
be overriden. Called in process context. The field driver_private
is available for the driver to use to store stuff.

The caller can claim the device by returning zero, or return
a negative error code. 
.TH "ad1980_exit" 9 "ad1980_exit" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad1980_exit \- 	module exit path
.SH SYNOPSIS
.B "void" ad1980_exit
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Our module is being unloaded. At this point unregister_driver
will call back our remove handler for any existing codecs. You
may not unregister_driver from interrupt context or from a 
probe/remove callback.
.TH "ad1980_init" 9 "ad1980_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ad1980_init \- 	set up ad1980 handlers
.SH SYNOPSIS
.B "int" ad1980_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

After we call the register function it will call our probe
function for each existing matching device before returning to us.
Any devices appearing afterwards whose id's match the codec_id
will also cause the probe function to be called.
You may not register_driver from interrupt context or from a 
probe/remove callback.
.TH "forte_ac97_wait" 9 "forte_ac97_wait" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_ac97_wait \- 
.SH SYNOPSIS
.B "int" forte_ac97_wait
.BI "(struct forte_chip *" chip ");"
.SH ARGUMENTS
.IP "chip" 12
	fm801 instance whose AC97 codec to wait on
.SH "FIXME"
Stop busy-waiting
.TH "forte_ac97_read" 9 "forte_ac97_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_ac97_read \- 
.SH SYNOPSIS
.B "u16" forte_ac97_read
.BI "(struct ac97_codec *" codec ","
.BI "u8 " reg ");"
.SH ARGUMENTS
.IP "codec" 12
	AC97 codec to read from
.IP "reg" 12
	register to read
.TH "forte_ac97_write" 9 "forte_ac97_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_ac97_write \- 
.SH SYNOPSIS
.B "void" forte_ac97_write
.BI "(struct ac97_codec *" codec ","
.BI "u8 " reg ","
.BI "u16 " val ");"
.SH ARGUMENTS
.IP "codec" 12
	AC97 codec to send command to
.IP "reg" 12
	register to write
.IP "val" 12
	value to write
.TH "forte_mixer_open" 9 "forte_mixer_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_mixer_open \- 
.SH SYNOPSIS
.B "int" forte_mixer_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
		
.IP "file" 12
		
.TH "forte_mixer_release" 9 "forte_mixer_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_mixer_release \- 
.SH SYNOPSIS
.B "int" forte_mixer_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
		
.IP "file" 12
		
.TH "forte_mixer_ioctl" 9 "forte_mixer_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_mixer_ioctl \- 
.SH SYNOPSIS
.B "int" forte_mixer_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
		
.IP "file" 12
		
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.TH "forte_channel_reset" 9 "forte_channel_reset" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_reset \- 
.SH SYNOPSIS
.B "void" forte_channel_reset
.BI "(struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "channel" 12
	Channel to reset
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_start" 9 "forte_channel_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_start \- 
.SH SYNOPSIS
.B "void inline" forte_channel_start
.BI "(struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "channel" 12
 	Channel to start (record/playback)
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_stop" 9 "forte_channel_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_stop \- 
.SH SYNOPSIS
.B "void inline" forte_channel_stop
.BI "(struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "channel" 12
 	Channel to stop
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_pause" 9 "forte_channel_pause" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_pause \- 
.SH SYNOPSIS
.B "void inline" forte_channel_pause
.BI "(struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "channel" 12
 	Channel to pause
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_rate" 9 "forte_channel_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_rate \- 
.SH SYNOPSIS
.B "int" forte_channel_rate
.BI "(struct forte_channel *" channel ","
.BI "unsigned int " rate ");"
.SH ARGUMENTS
.IP "channel" 12
 	Channel whose rate to set.  Playback and record are
independent.
.IP "rate" 12
    	Channel rate in Hz
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_format" 9 "forte_channel_format" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_format \- 
.SH SYNOPSIS
.B "int" forte_channel_format
.BI "(struct forte_channel *" channel ","
.BI "int " format ");"
.SH ARGUMENTS
.IP "channel" 12
 	Channel whose audio format to set
.IP "format" 12
  	OSS format ID
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_stereo" 9 "forte_channel_stereo" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_stereo \- 
.SH SYNOPSIS
.B "int" forte_channel_stereo
.BI "(struct forte_channel *" channel ","
.BI "unsigned int " stereo ");"
.SH ARGUMENTS
.IP "channel" 12
 	Channel to toggle
.IP "stereo" 12
  	0 for Mono, 1 for Stereo
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_buffer" 9 "forte_channel_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_buffer \- 
.SH SYNOPSIS
.B "void" forte_channel_buffer
.BI "(struct forte_channel *" channel ","
.BI "int " sz ","
.BI "int " num ");"
.SH ARGUMENTS
.IP "channel" 12
	Channel whose buffer to set up
.IP "sz" 12
-- undescribed --
.IP "num" 12
-- undescribed --
.SH "LOCKING"
	Must be called with lock held.
.TH "forte_channel_prep" 9 "forte_channel_prep" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_prep \- 
.SH SYNOPSIS
.B "void" forte_channel_prep
.BI "(struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "channel" 12
	Channel whose buffer to prepare
.SH "LOCKING"
	Lock held.
.TH "forte_channel_drain" 9 "forte_channel_drain" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_drain \- 
.SH SYNOPSIS
.B "int" forte_channel_drain
.BI "(struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "channel" 12
	
.SH "LOCKING"
	Don't hold the lock.
.TH "forte_channel_init" 9 "forte_channel_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_init \- 
.SH SYNOPSIS
.B "int" forte_channel_init
.BI "(struct forte_chip *" chip ","
.BI "struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "chip" 12
 	Forte chip instance the channel hangs off
.IP "channel" 12
 	Channel to initialize
.SH "DESCRIPTION"
Initializes a channel, sets defaults, and allocates
buffers.
.SH "LOCKING"
	No lock held.
.TH "forte_channel_free" 9 "forte_channel_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_channel_free \- 
.SH SYNOPSIS
.B "void" forte_channel_free
.BI "(struct forte_chip *" chip ","
.BI "struct forte_channel *" channel ");"
.SH ARGUMENTS
.IP "chip" 12
	Chip this channel hangs off
.IP "channel" 12
	Channel to nuke 
.SH "DESCRIPTION"
Resets channel and frees buffers.
.SH "LOCKING"
	Hold your horses.
.TH "forte_dsp_ioctl" 9 "forte_dsp_ioctl" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_dsp_ioctl \- 
.SH SYNOPSIS
.B "int" forte_dsp_ioctl
.BI "(struct inode *" inode ","
.BI "struct file *" file ","
.BI "unsigned int " cmd ","
.BI "unsigned long " arg ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.IP "cmd" 12
-- undescribed --
.IP "arg" 12
-- undescribed --
.TH "forte_dsp_open" 9 "forte_dsp_open" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_dsp_open \- 
.SH SYNOPSIS
.B "int" forte_dsp_open
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.TH "forte_dsp_release" 9 "forte_dsp_release" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_dsp_release \- 
.SH SYNOPSIS
.B "int" forte_dsp_release
.BI "(struct inode *" inode ","
.BI "struct file *" file ");"
.SH ARGUMENTS
.IP "inode" 12
-- undescribed --
.IP "file" 12
-- undescribed --
.TH "forte_dsp_poll" 9 "forte_dsp_poll" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_dsp_poll \- 
.SH SYNOPSIS
.B "unsigned int" forte_dsp_poll
.BI "(struct file *" file ","
.BI "struct poll_table_struct *" wait ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "wait" 12
-- undescribed --
.SH "DESCRIPTION"
.TH "forte_dsp_mmap" 9 "forte_dsp_mmap" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_dsp_mmap \- 
.SH SYNOPSIS
.B "int" forte_dsp_mmap
.BI "(struct file *" file ","
.BI "struct vm_area_struct *" vma ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "vma" 12
-- undescribed --
.TH "forte_dsp_write" 9 "forte_dsp_write" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_dsp_write \- 
.SH SYNOPSIS
.B "ssize_t" forte_dsp_write
.BI "(struct file *" file ","
.BI "const char __user *" buffer ","
.BI "size_t " bytes ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "bytes" 12
-- undescribed --
.IP "ppos" 12
-- undescribed --
.TH "forte_dsp_read" 9 "forte_dsp_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_dsp_read \- 
.SH SYNOPSIS
.B "ssize_t" forte_dsp_read
.BI "(struct file *" file ","
.BI "char __user *" buffer ","
.BI "size_t " bytes ","
.BI "loff_t *" ppos ");"
.SH ARGUMENTS
.IP "file" 12
-- undescribed --
.IP "buffer" 12
-- undescribed --
.IP "bytes" 12
-- undescribed --
.IP "ppos" 12
-- undescribed --
.TH "forte_interrupt" 9 "forte_interrupt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_interrupt \- 
.SH SYNOPSIS
.B "irqreturn_t" forte_interrupt
.BI "(int " irq ","
.BI "void *" dev_id ","
.BI "struct pt_regs *" regs ");"
.SH ARGUMENTS
.IP "irq" 12
-- undescribed --
.IP "dev_id" 12
-- undescribed --
.IP "regs" 12
-- undescribed --
.TH "forte_proc_read" 9 "forte_proc_read" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_proc_read \- 
.SH SYNOPSIS
.B "int" forte_proc_read
.BI "(char *" page ","
.BI "char **" start ","
.BI "off_t " off ","
.BI "int " count ","
.BI "int *" eof ","
.BI "void *" data ");"
.SH ARGUMENTS
.IP "page" 12
-- undescribed --
.IP "start" 12
-- undescribed --
.IP "off" 12
-- undescribed --
.IP "count" 12
-- undescribed --
.IP "eof" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.TH "forte_proc_init" 9 "forte_proc_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_proc_init \- 
.SH SYNOPSIS
.B "int __init" forte_proc_init
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Creates driver info entries in /proc
.TH "forte_proc_remove" 9 "forte_proc_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_proc_remove \- 
.SH SYNOPSIS
.B "void" forte_proc_remove
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Removes driver info entries in /proc
.TH "forte_chip_init" 9 "forte_chip_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_chip_init \- 
.SH SYNOPSIS
.B "int __devinit" forte_chip_init
.BI "(struct forte_chip *" chip ");"
.SH ARGUMENTS
.IP "chip" 12
	Chip instance to initialize
.SH "DESCRIPTION"
Resets chip, configures codec and registers the driver with
the sound subsystem.

Press and hold Start for 8 secs, then switch on Run
and hold for 4 seconds.  Let go of Start.  Numbers
assume a properly oiled TWG.
.TH "forte_probe" 9 "forte_probe" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_probe \- 
.SH SYNOPSIS
.B "int __init" forte_probe
.BI "(struct pci_dev *" pci_dev ","
.BI "const struct pci_device_id *" pci_id ");"
.SH ARGUMENTS
.IP "pci_dev" 12
	PCI struct for probed device
.IP "pci_id" 12
	
.SH "DESCRIPTION"
Allocates chip instance, I/O region, and IRQ
.TH "forte_remove" 9 "forte_remove" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_remove \- 
.SH SYNOPSIS
.B "void" forte_remove
.BI "(struct pci_dev *" pci_dev ");"
.SH ARGUMENTS
.IP "pci_dev" 12
	PCI device to unclaim
.TH "forte_init_module" 9 "forte_init_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_init_module \- 
.SH SYNOPSIS
.B "int __init" forte_init_module
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "forte_cleanup_module" 9 "forte_cleanup_module" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
forte_cleanup_module \- 
.SH SYNOPSIS
.B "void __exit" forte_cleanup_module
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"
.TH "codec_id" 9 "codec_id" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
codec_id \-   Turn id1/id2 into a PnP string
.SH SYNOPSIS
.B "char *" codec_id
.BI "(u16 " id1 ","
.BI "u16 " id2 ","
.BI "char *" buf ");"
.SH ARGUMENTS
.IP "id1" 12
 Vendor ID1
.IP "id2" 12
 Vendor ID2
.IP "buf" 12
 CODEC_ID_BUFSZ byte buffer
.SH "DESCRIPTION"
Fills buf with a zero terminated PnP ident string for the id1/id2
pair. For convenience the return is the passed in buffer pointer.
.TH "ac97_check_modem" 9 "ac97_check_modem" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_check_modem \-  Check if the Codec is a modem
.SH SYNOPSIS
.B "int" ac97_check_modem
.BI "(struct ac97_codec *" codec ");"
.SH ARGUMENTS
.IP "codec" 12
 codec to check
.SH "DESCRIPTION"
Return true if the device is an AC97 1.0 or AC97 2.0 modem
.TH "ac97_alloc_codec" 9 "ac97_alloc_codec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_alloc_codec \-  Allocate an AC97 codec
.SH SYNOPSIS
.B "struct ac97_codec *" ac97_alloc_codec
.BI "(" void ");"
.SH ARGUMENTS
.IP "void" 12
no arguments
.SH "DESCRIPTION"

Returns a new AC97 codec structure. AC97 codecs may become
refcounted soon so this interface is needed. Returns with
one reference taken.
.TH "ac97_release_codec" 9 "ac97_release_codec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_release_codec \- 	Release an AC97 codec
.SH SYNOPSIS
.B "void" ac97_release_codec
.BI "(struct ac97_codec *" codec ");"
.SH ARGUMENTS
.IP "codec" 12
 codec to release
.SH "DESCRIPTION"
Release an allocated AC97 codec. This will be refcounted in
time but for the moment is trivial. Calls the unregister
handler if the codec is now defunct.
.TH "ac97_probe_codec" 9 "ac97_probe_codec" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_probe_codec \-  Initialize and setup AC97-compatible codec
.SH SYNOPSIS
.B "int" ac97_probe_codec
.BI "(struct ac97_codec *" codec ");"
.SH ARGUMENTS
.IP "codec" 12
 (in/out) Kernel info for a single AC97 codec
.SH "DESCRIPTION"
Reset the AC97 codec, then initialize the mixer and
the rest of the \fIcodec\fP structure.

The codec_read and codec_write fields of \fIcodec\fP are
required to be setup and working when this function
is called.  All other fields are set by this function.

codec_wait field of \fIcodec\fP can optionally be provided
when calling this function.  If codec_wait is not NULL,
this function will call codec_wait any time it is
necessary to wait for the audio chip to reach the
codec-ready state.  If codec_wait is NULL, then
the default behavior is to call schedule_timeout.
Currently codec_wait is used to wait for AC97 codec
reset to complete. 

Some codecs will power down when a register reset is
performed. We now check for such codecs.

Returns 1 (true) on success, or 0 (false) on failure.
.TH "ac97_set_dac_rate" 9 "ac97_set_dac_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_set_dac_rate \- 	set codec rate adaption
.SH SYNOPSIS
.B "unsigned int" ac97_set_dac_rate
.BI "(struct ac97_codec *" codec ","
.BI "unsigned int " rate ");"
.SH ARGUMENTS
.IP "codec" 12
 ac97 code
.IP "rate" 12
 rate in hertz
.SH "DESCRIPTION"
Set the DAC rate. Assumes the codec supports VRA. The caller is
expected to have checked this little detail.
.TH "ac97_set_adc_rate" 9 "ac97_set_adc_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_set_adc_rate \- 	set codec rate adaption
.SH SYNOPSIS
.B "unsigned int" ac97_set_adc_rate
.BI "(struct ac97_codec *" codec ","
.BI "unsigned int " rate ");"
.SH ARGUMENTS
.IP "codec" 12
 ac97 code
.IP "rate" 12
 rate in hertz
.SH "DESCRIPTION"
Set the ADC rate. Assumes the codec supports VRA. The caller is
expected to have checked this little detail.
.TH "ac97_register_driver" 9 "ac97_register_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_register_driver \- 	register a codec helper
.SH SYNOPSIS
.B "int" ac97_register_driver
.BI "(struct ac97_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
 Driver handler
.SH "DESCRIPTION"
Register a handler for codecs matching the codec id. The handler
attach function is called for all present codecs and will be 
called when new codecs are discovered.
.TH "ac97_unregister_driver" 9 "ac97_unregister_driver" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_unregister_driver \- 	unregister a codec helper
.SH SYNOPSIS
.B "void" ac97_unregister_driver
.BI "(struct ac97_driver *" driver ");"
.SH ARGUMENTS
.IP "driver" 12
 Driver handler
.SH "DESCRIPTION"
Unregister a handler for codecs matching the codec id. The handler
remove function is called for all matching codecs.
.TH "ac97_tune_hardware" 9 "ac97_tune_hardware" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
ac97_tune_hardware \-  tune up the hardware
.SH SYNOPSIS
.B "int" ac97_tune_hardware
.BI "(struct pci_dev *" pdev ","
.BI "struct ac97_quirk *" quirk ","
.BI "int " override ");"
.SH ARGUMENTS
.IP "pdev" 12
 pci_dev pointer
.IP "quirk" 12
 quirk list
.IP "override" 12
 explicit quirk value (overrides if not AC97_TUNE_DEFAULT)
.SH "DESCRIPTION"
Do some workaround for each pci device, such as renaming of the
headphone (true line-out) control as "Master".
The quirk-list must be terminated with a zero-filled entry.

Returns zero if successful, or a negative error code on failure.
.TH "query_format" 9 "query_format" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
query_format \-  returns a valid sound format
.SH SYNOPSIS
.B "void" query_format
.BI "(int " recsrc ","
.BI "struct wave_format *" wave_fmt ");"
.SH ARGUMENTS
.IP "recsrc" 12
-- undescribed --
.IP "wave_fmt" 12
-- undescribed --
.SH "DESCRIPTION"

This function will return a valid sound format as close
to the requested one as possible. 
.TH "emu10k1_voice_alloc_buffer" 9 "emu10k1_voice_alloc_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
emu10k1_voice_alloc_buffer \- 
.SH SYNOPSIS
.B "int" emu10k1_voice_alloc_buffer
.BI "(struct emu10k1_card *" card ","
.BI "struct voice_mem *" mem ","
.BI "u32 " pages ");"
.SH ARGUMENTS
.IP "card" 12
-- undescribed --
.IP "mem" 12
-- undescribed --
.IP "pages" 12
-- undescribed --
.SH "DESCRIPTION"

allocates the memory buffer for a voice. Two page tables are kept for each buffer.
One (dma_handle) keeps track of the host memory pages used and the other (virtualpagetable)
is passed to the device so that it can do DMA to host memory.
.TH "emu10k1_voice_free_buffer" 9 "emu10k1_voice_free_buffer" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
emu10k1_voice_free_buffer \- 
.SH SYNOPSIS
.B "void" emu10k1_voice_free_buffer
.BI "(struct emu10k1_card *" card ","
.BI "struct voice_mem *" mem ");"
.SH ARGUMENTS
.IP "card" 12
-- undescribed --
.IP "mem" 12
-- undescribed --
.SH "DESCRIPTION"

frees the memory buffer for a voice.
.TH "emu10k1_waveout_getxfersize" 9 "emu10k1_waveout_getxfersize" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
emu10k1_waveout_getxfersize \- 
.SH SYNOPSIS
.B "void" emu10k1_waveout_getxfersize
.BI "(struct woinst *" woinst ","
.BI "u32 *" total_free_bytes ");"
.SH ARGUMENTS
.IP "woinst" 12
-- undescribed --
.IP "total_free_bytes" 12
-- undescribed --
.SH "DESCRIPTION"

gives the total free bytes on the voice buffer, including silence bytes
(basically: total_free_bytes = free_bytes + silence_bytes).
.TH "copy_block" 9 "copy_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_block \- 
.SH SYNOPSIS
.B "void" copy_block
.BI "(void **" dst ","
.BI "u32 " str ","
.BI "u8 __user *" src ","
.BI "u32 " len ");"
.SH ARGUMENTS
.IP "dst" 12
-- undescribed --
.IP "str" 12
-- undescribed --
.IP "src" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"

copies a block of pcm data to a voice buffer.
Notice that the voice buffer is actually a set of disjointed memory pages.
.TH "copy_ilv_block" 9 "copy_ilv_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
copy_ilv_block \- 
.SH SYNOPSIS
.B "void" copy_ilv_block
.BI "(struct woinst *" woinst ","
.BI "u32 " str ","
.BI "u8 __user *" src ","
.BI "u32 " len ");"
.SH ARGUMENTS
.IP "woinst" 12
-- undescribed --
.IP "str" 12
-- undescribed --
.IP "src" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"

copies a block of pcm data containing n interleaved channels to n mono voice buffers.
Notice that the voice buffer is actually a set of disjointed memory pages.
.TH "fill_block" 9 "fill_block" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
fill_block \- 
.SH SYNOPSIS
.B "void" fill_block
.BI "(struct woinst *" woinst ","
.BI "u32 " str ","
.BI "u8 " data ","
.BI "u32 " len ");"
.SH ARGUMENTS
.IP "woinst" 12
-- undescribed --
.IP "str" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "len" 12
-- undescribed --
.SH "DESCRIPTION"

fills a set voice buffers with a block of a given sample.
.TH "emu10k1_waveout_xferdata" 9 "emu10k1_waveout_xferdata" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
emu10k1_waveout_xferdata \- 
.SH SYNOPSIS
.B "void" emu10k1_waveout_xferdata
.BI "(struct woinst *" woinst ","
.BI "u8 __user *" data ","
.BI "u32 *" size ");"
.SH ARGUMENTS
.IP "woinst" 12
-- undescribed --
.IP "data" 12
-- undescribed --
.IP "size" 12
-- undescribed --
.SH "DESCRIPTION"

copies pcm data to the voice buffer. Silence samples
previously added to the buffer are overwritten.
.TH "emu10k1_waveout_fillsilence" 9 "emu10k1_waveout_fillsilence" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
emu10k1_waveout_fillsilence \- 
.SH SYNOPSIS
.B "void" emu10k1_waveout_fillsilence
.BI "(struct woinst *" woinst ");"
.SH ARGUMENTS
.IP "woinst" 12
-- undescribed --
.SH "DESCRIPTION"

adds samples of silence to the voice buffer so that we
don't loop over stale pcm data.
.TH "emu10k1_waveout_update" 9 "emu10k1_waveout_update" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
emu10k1_waveout_update \- 
.SH SYNOPSIS
.B "void" emu10k1_waveout_update
.BI "(struct woinst *" woinst ");"
.SH ARGUMENTS
.IP "woinst" 12
-- undescribed --
.SH "DESCRIPTION"

updates the position of the voice buffer hardware pointer (hw_pos)
and the number of free bytes on the buffer (free_bytes).
The free bytes _don't_ include silence bytes that may have been
added to the buffer.
.TH "via_chan_stop" 9 "via_chan_stop" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_stop \-  Terminate DMA on specified PCM channel
.SH SYNOPSIS
.B "void" via_chan_stop
.BI "(long " iobase ");"
.SH ARGUMENTS
.IP "iobase" 12
 PCI base address for SGD channel registers
.SH "DESCRIPTION"
Terminate scatter-gather DMA operation for given
channel (derived from \fIiobase\fP), if DMA is active.

Note that \fIiobase\fP is not the PCI base address,
but the PCI base address plus an offset to
one of three PCM channels supported by the chip.
.TH "via_chan_status_clear" 9 "via_chan_status_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_status_clear \-  Clear status flags on specified DMA channel
.SH SYNOPSIS
.B "void" via_chan_status_clear
.BI "(long " iobase ");"
.SH ARGUMENTS
.IP "iobase" 12
 PCI base address for SGD channel registers
.SH "DESCRIPTION"
Clear any pending status flags for the given
DMA channel (derived from \fIiobase\fP), if any
flags are asserted.

Note that \fIiobase\fP is not the PCI base address,
but the PCI base address plus an offset to
one of three PCM channels supported by the chip.
.TH "sg_begin" 9 "sg_begin" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
sg_begin \-  Begin recording or playback on a PCM channel
.SH SYNOPSIS
.B "void" sg_begin
.BI "(struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Channel for which DMA operation shall begin
.SH "DESCRIPTION"
Start scatter-gather DMA for the given channel.
.TH "via_syscall_down" 9 "via_syscall_down" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_syscall_down \-  down the card-specific syscell semaphore
.SH SYNOPSIS
.B "int" via_syscall_down
.BI "(struct via_info *" card ","
.BI "int " nonblock ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.IP "nonblock" 12
 boolean, non-zero if O_NONBLOCK is set
.SH "DESCRIPTION"
Encapsulates standard method of acquiring the syscall sem.

Returns negative errno on error, or zero for success.
.TH "via_stop_everything" 9 "via_stop_everything" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_stop_everything \-  Stop all audio operations
.SH SYNOPSIS
.B "void" via_stop_everything
.BI "(struct via_info *" card ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.SH "DESCRIPTION"
Stops all DMA operations and interrupts, and clear
any pending status bits resulting from those operations.
.TH "via_set_rate" 9 "via_set_rate" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_set_rate \-  Set PCM rate for given channel
.SH SYNOPSIS
.B "int" via_set_rate
.BI "(struct ac97_codec *" ac97 ","
.BI "struct via_channel *" chan ","
.BI "unsigned " rate ");"
.SH ARGUMENTS
.IP "ac97" 12
 Pointer to generic codec info struct
.IP "chan" 12
 Private info for specified channel
.IP "rate" 12
 Desired PCM sample rate, in Khz
.SH "DESCRIPTION"
Sets the PCM sample rate for a channel.

Values for \fIrate\fP are clamped to a range of 4000 Khz through 48000 Khz,
due to hardware constraints.
.TH "via_chan_init_defaults" 9 "via_chan_init_defaults" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_init_defaults \-  Initialize a struct via_channel
.SH SYNOPSIS
.B "void" via_chan_init_defaults
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "card" 12
 Private audio chip info
.IP "chan" 12
 Channel to be initialized
.SH "DESCRIPTION"
Zero \fIchan\fP, and then set all static defaults for the structure.
.TH "via_chan_init" 9 "via_chan_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_init \-  Initialize PCM channel
.SH SYNOPSIS
.B "void" via_chan_init
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "card" 12
 Private audio chip info
.IP "chan" 12
 Channel to be initialized
.SH "DESCRIPTION"
Performs some of the preparations necessary to begin
using a PCM channel.

Currently the preparations consist of
setting the PCM channel to a known state.
.TH "via_chan_buffer_init" 9 "via_chan_buffer_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_buffer_init \-  Initialize PCM channel buffer
.SH SYNOPSIS
.B "int" via_chan_buffer_init
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "card" 12
 Private audio chip info
.IP "chan" 12
 Channel to be initialized
.SH "DESCRIPTION"
Performs some of the preparations necessary to begin
using a PCM channel.

Currently the preparations include allocating the
scatter-gather DMA table and buffers,
and passing the
address of the DMA table to the hardware.

Note that special care is taken when passing the
DMA table address to hardware, because it was found
during driver development that the hardware did not
always "take" the address.
.TH "via_chan_free" 9 "via_chan_free" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_free \-  Release a PCM channel
.SH SYNOPSIS
.B "void" via_chan_free
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "card" 12
 Private audio chip info
.IP "chan" 12
 Channel to be released
.SH "DESCRIPTION"
Performs all the functions necessary to clean up
an initialized channel.

Currently these functions include disabled any
active DMA operations, setting the PCM channel
back to a known state, and releasing any allocated
sound buffers.
.TH "via_chan_pcm_fmt" 9 "via_chan_pcm_fmt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_pcm_fmt \-  Update PCM channel settings
.SH SYNOPSIS
.B "void" via_chan_pcm_fmt
.BI "(struct via_channel *" chan ","
.BI "int " reset ");"
.SH ARGUMENTS
.IP "chan" 12
 Channel to be updated
.IP "reset" 12
 Boolean.  If non-zero, channel will be reset
to 8-bit mono mode.
.SH "DESCRIPTION"
Stores the settings of the current PCM format,
8-bit or 16-bit, and mono/stereo, into the
hardware settings for the specified channel.
If \fIreset\fP is non-zero, the channel is reset
to 8-bit mono mode.  Otherwise, the channel
is set to the values stored in the channel
information struct \fIchan\fP.
.TH "via_chan_clear" 9 "via_chan_clear" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_clear \-  Stop DMA channel operation, and reset pointers
.SH SYNOPSIS
.B "void" via_chan_clear
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "card" 12
 the chip to accessed
.IP "chan" 12
 Channel to be cleared
.SH "DESCRIPTION"
Call via_chan_stop to halt DMA operations, and then resets
all software pointers which track DMA operation.
.TH "via_chan_set_speed" 9 "via_chan_set_speed" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_set_speed \-  Set PCM sample rate for given channel
.SH SYNOPSIS
.B "int" via_chan_set_speed
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ","
.BI "int " val ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.IP "chan" 12
 Channel whose sample rate will be adjusted
.IP "val" 12
 New sample rate, in Khz
.SH "DESCRIPTION"
Helper function for the SNDCTL_DSP_SPEED ioctl.  OSS semantics
demand that all audio operations halt (if they are not already
halted) when the SNDCTL_DSP_SPEED is given.

This function halts all audio operations for the given channel
\fIchan\fP, and then calls via_set_rate to set the audio hardware
to the new rate.
.TH "via_chan_set_fmt" 9 "via_chan_set_fmt" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_set_fmt \-  Set PCM sample size for given channel
.SH SYNOPSIS
.B "int" via_chan_set_fmt
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ","
.BI "int " val ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.IP "chan" 12
 Channel whose sample size will be adjusted
.IP "val" 12
 New sample size, use the AFMT_xxx constants
.SH "DESCRIPTION"
Helper function for the SNDCTL_DSP_SETFMT ioctl.  OSS semantics
demand that all audio operations halt (if they are not already
halted) when the SNDCTL_DSP_SETFMT is given.

This function halts all audio operations for the given channel
\fIchan\fP, and then calls via_chan_pcm_fmt to set the audio hardware
to the new sample size, either 8-bit or 16-bit.
.TH "via_chan_set_stereo" 9 "via_chan_set_stereo" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_set_stereo \-  Enable or disable stereo for a DMA channel
.SH SYNOPSIS
.B "int" via_chan_set_stereo
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ","
.BI "int " val ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.IP "chan" 12
 Channel whose stereo setting will be adjusted
.IP "val" 12
 New sample size, use the AFMT_xxx constants
.SH "DESCRIPTION"
Helper function for the SNDCTL_DSP_CHANNELS and SNDCTL_DSP_STEREO ioctls.  OSS semantics
demand that all audio operations halt (if they are not already
halted) when SNDCTL_DSP_CHANNELS or SNDCTL_DSP_STEREO is given.

This function halts all audio operations for the given channel
\fIchan\fP, and then calls via_chan_pcm_fmt to set the audio hardware
to enable or disable stereo.
.TH "via_chan_dump_bufs" 9 "via_chan_dump_bufs" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_dump_bufs \-  Display DMA table contents
.SH SYNOPSIS
.B "void" via_chan_dump_bufs
.BI "(struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Channel whose DMA table will be displayed
.SH "DESCRIPTION"
Debugging function which displays the contents of the
scatter-gather DMA table for the given channel \fIchan\fP.
.TH "via_chan_flush_frag" 9 "via_chan_flush_frag" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_flush_frag \-  Flush partially-full playback buffer to hardware
.SH SYNOPSIS
.B "void" via_chan_flush_frag
.BI "(struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Channel whose DMA table will be flushed
.SH "DESCRIPTION"
Flushes partially-full playback buffer to hardware.
.TH "via_chan_maybe_start" 9 "via_chan_maybe_start" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_chan_maybe_start \-  Initiate audio hardware DMA operation
.SH SYNOPSIS
.B "void" via_chan_maybe_start
.BI "(struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "chan" 12
 Channel whose DMA is to be started
.SH "DESCRIPTION"
Initiate DMA operation, if the DMA engine for the given
channel \fIchan\fP is not already active.
.TH "via_ac97_wait_idle" 9 "via_ac97_wait_idle" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_ac97_wait_idle \-  Wait until AC97 codec is not busy
.SH SYNOPSIS
.B "u8" via_ac97_wait_idle
.BI "(struct via_info *" card ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.SH "DESCRIPTION"
Sleep until the AC97 codec is no longer busy.
Returns the final value read from the SGD
register being polled.
.TH "via_ac97_read_reg" 9 "via_ac97_read_reg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_ac97_read_reg \-  Read AC97 standard register
.SH SYNOPSIS
.B "u16" via_ac97_read_reg
.BI "(struct ac97_codec *" codec ","
.BI "u8 " reg ");"
.SH ARGUMENTS
.IP "codec" 12
 Pointer to generic AC97 codec info
.IP "reg" 12
 Index of AC97 register to be read
.SH "DESCRIPTION"
Read the value of a single AC97 codec register,
as defined by the Intel AC97 specification.

Defines the standard AC97 read-register operation
required by the kernel's ac97_codec interface.

Returns the 16-bit value stored in the specified
register.
.TH "via_ac97_write_reg" 9 "via_ac97_write_reg" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_ac97_write_reg \-  Write AC97 standard register
.SH SYNOPSIS
.B "void" via_ac97_write_reg
.BI "(struct ac97_codec *" codec ","
.BI "u8 " reg ","
.BI "u16 " value ");"
.SH ARGUMENTS
.IP "codec" 12
 Pointer to generic AC97 codec info
.IP "reg" 12
 Index of AC97 register to be written
.IP "value" 12
 Value to be written to AC97 register
.SH "DESCRIPTION"
Write the value of a single AC97 codec register,
as defined by the Intel AC97 specification.

Defines the standard AC97 write-register operation
required by the kernel's ac97_codec interface.
.TH "via_intr_channel" 9 "via_intr_channel" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_intr_channel \-  handle an interrupt for a single channel
.SH SYNOPSIS
.B "void" via_intr_channel
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ");"
.SH ARGUMENTS
.IP "card" 12
 unused
.IP "chan" 12
 handle interrupt for this channel
.SH "DESCRIPTION"
This is the "meat" of the interrupt handler,
containing the actions taken each time an interrupt
occurs.  All communication and coordination with
userspace takes place here.
.SH "LOCKING"
 inside card-&gt;lock
.TH "via_interrupt_init" 9 "via_interrupt_init" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_interrupt_init \-  Initialize interrupt handling
.SH SYNOPSIS
.B "int" via_interrupt_init
.BI "(struct via_info *" card ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.SH "DESCRIPTION"
Obtain and reserve IRQ for using in handling audio events.
Also, disable any IRQ-generating resources, to make sure
we don't get interrupts before we want them.
.TH "via_dsp_drain_playback" 9 "via_dsp_drain_playback" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_dsp_drain_playback \-  sleep until all playback samples are flushed
.SH SYNOPSIS
.B "int" via_dsp_drain_playback
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ","
.BI "int " nonblock ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.IP "chan" 12
 Channel to drain
.IP "nonblock" 12
 boolean, non-zero if O_NONBLOCK is set
.SH "DESCRIPTION"
Sleeps until all playback has been flushed to the audio
hardware.
.SH "LOCKING"
 inside card-&gt;syscall_sem
.TH "via_dsp_ioctl_space" 9 "via_dsp_ioctl_space" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_dsp_ioctl_space \-  get information about channel buffering
.SH SYNOPSIS
.B "int" via_dsp_ioctl_space
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.IP "chan" 12
 pointer to channel-specific info
.IP "arg" 12
 user buffer for returned information
.SH "DESCRIPTION"
Handles SNDCTL_DSP_GETISPACE and SNDCTL_DSP_GETOSPACE.
.SH "LOCKING"
 inside card-&gt;syscall_sem
.TH "via_dsp_ioctl_ptr" 9 "via_dsp_ioctl_ptr" "January 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
via_dsp_ioctl_ptr \-  get information about hardware buffer ptr
.SH SYNOPSIS
.B "int" via_dsp_ioctl_ptr
.BI "(struct via_info *" card ","
.BI "struct via_channel *" chan ","
.BI "void __user *" arg ");"
.SH ARGUMENTS
.IP "card" 12
 Private info for specified board
.IP "chan" 12
 pointer to channel-specific info
.IP "arg" 12
 user buffer for returned information
.SH "DESCRIPTION"
Handles SNDCTL_DSP_GETIPTR and SNDCTL_DSP_GETOPTR.
.SH "LOCKING"
 inside card-&gt;syscall_sem
